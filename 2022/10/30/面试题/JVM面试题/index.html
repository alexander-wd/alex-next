<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/alex-next/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/alex-next/images/favicon.ico?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/alex-next/images/favicon.ico?v=7.4.0">
  <link rel="mask-icon" href="/alex-next/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/alex-next/atom.xml" title="alex的博客 - github.com" type="application/atom+xml">

<link rel="stylesheet" href="/alex-next/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/alex-next/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/alex-next/',
    scheme: 'Pisces',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: true,
    pangu: true,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="类加载机制1.简述java类加载机制虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，准备，解析和初始化，最终形成可以被虚拟机直接使用的java类型  2.描述一下JVM加载Class文件的原理机制默认隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中        显式装载， 通过class.forname()等方法，显式加载需">
<meta name="keywords" content="JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM面试题">
<meta property="og:url" content="https://alexander-wd.github.io/2022/10/30/面试题/JVM面试题/index.html">
<meta property="og:site_name" content="alex的博客 - github.com">
<meta property="og:description" content="类加载机制1.简述java类加载机制虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，准备，解析和初始化，最终形成可以被虚拟机直接使用的java类型  2.描述一下JVM加载Class文件的原理机制默认隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中        显式装载， 通过class.forname()等方法，显式加载需">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2023-02-13T10:14:16.505Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JVM面试题">
<meta name="twitter:description" content="类加载机制1.简述java类加载机制虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，准备，解析和初始化，最终形成可以被虚拟机直接使用的java类型  2.描述一下JVM加载Class文件的原理机制默认隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中        显式装载， 通过class.forname()等方法，显式加载需">
  <link rel="canonical" href="https://alexander-wd.github.io/2022/10/30/面试题/JVM面试题/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>JVM面试题 | alex的博客 - github.com</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/alex-next/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">alex的博客 - github.com</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/alex-next/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/alex-next/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/alex-next/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/alex-next/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/alexander-wd" class="github-corner" title="alex GitHub" aria-label="alex GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://alexander-wd.github.io/alex-next/2022/10/30/面试题/JVM面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="alex">
      <meta itemprop="description" content="时光静好,与君语;细水流年,与君同;繁华落尽,与君老.">
      <meta itemprop="image" content="/alex-next/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="alex的博客 - github.com">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">JVM面试题

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2022-10-30 18:18:20" itemprop="dateCreated datePublished" datetime="2022-10-30T18:18:20+08:00">2022-10-30</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-13 18:14:16" itemprop="dateModified" datetime="2023-02-13T18:14:16+08:00">2023-02-13</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/alex-next/categories/面试题/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><h4 id="1-简述java类加载机制"><a href="#1-简述java类加载机制" class="headerlink" title="1.简述java类加载机制"></a>1.简述java类加载机制</h4><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，准备，解析和初始化，最终形成可以被虚拟机直接使用的java类型</p>
<p><img alt="2" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109171002.png"></p>
<h4 id="2-描述一下JVM加载Class文件的原理机制"><a href="#2-描述一下JVM加载Class文件的原理机制" class="headerlink" title="2.描述一下JVM加载Class文件的原理机制"></a>2.描述一下JVM加载Class文件的原理机制</h4><p>默认隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中<br>        显式装载， 通过class.forname()等方法，显式加载需要的类<br>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p>
<h4 id="3-什么是类加载器，类加载器有哪些"><a href="#3-什么是类加载器，类加载器有哪些" class="headerlink" title="3.什么是类加载器，类加载器有哪些"></a>3.什么是类加载器，类加载器有哪些</h4><p>类加载器负责动态加载Java类到Java虚拟机的内存空间中</p>
<p>类加载器有：</p>
<p>启动类加载器<br>    用来加载java核心类库，无法被java程序直接引用<br>扩展类加载器<br>    它用来加载 Java 的扩展库<br>系统类加载器<br>    它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类<br>用户自定义类加载器<br>    通过继承 java.lang.ClassLoader类的方式实现</p>
<h4 id="4-说一下类装载的执行过程"><a href="#4-说一下类装载的执行过程" class="headerlink" title="==4.说一下类装载的执行过程=="></a>==4.说一下类装载的执行过程==</h4><p>加载：根据查找路径找到相应的 class 文件然后导入<br>    双亲委派<br>验证：检查加载的 class 文件的正确性，如开头CAFEBABE<br>准备：给类中的静态变量分配内存空间，赋予默认值<br>解析：虚拟机将常量池中的符号引用替换成直接引用的过程(也就是得到类或者字段、方法在内存中的指针或者偏移量)<br>初始化：对静态变量和静态代码块执行初始化工作(初始化为用户自定义的值)</p>
<h4 id="5-什么是双亲委派模型"><a href="#5-什么是双亲委派模型" class="headerlink" title="==5.什么是双亲委派模型=="></a>==5.什么是双亲委派模型==</h4><p><strong>步骤</strong><br>    1.首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接 返回。<br>     2.如果此类没有加载过(在内存中)，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用parent.loadClass(name, false);）(扩展类加载器再向上委托便是bootstrap类加载器来加载)。<br>    3.如果父加载器及bootstrap类加载器都没有找到指定的类，那么向下委托看当前加载器的路径下有没有改class文件(一般都会回到当前类加载器的 findClass方法来完成类加载)。<br>        注意AppClassLoader和ExtClassLoader的findClass方法均在URLClassLoader中实现<br>细节</p>
<blockquote>
<p>双亲委派机制</p>
<p>向上委托主要是判断要加载的类有没有被加载到内存，如果已被加载到内存，就没必要继续向上委托。</p>
<p>而父类向下委托则是判断自己的类路径中有没有该类，有的话直接加载进内存。</p>
</blockquote>
<p>==为什么要设计双亲委派机制==<br>    1.沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心API库被随意篡改<br>    2.避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证被加载类的唯一性<br>模型图参考</p>
<p><img alt="2" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109175409.png"></p>
<h4 id="6-如何判断两个class对象是否相同？"><a href="#6-如何判断两个class对象是否相同？" class="headerlink" title="6.如何判断两个class对象是否相同？"></a>6.如何判断两个class对象是否相同？</h4><p>1.类的完整类名必须一致，包括包名<br>2.加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</p>
<h4 id="7-怎么实现一个自定义的类加载器"><a href="#7-怎么实现一个自定义的类加载器" class="headerlink" title="7.怎么实现一个自定义的类加载器"></a>7.怎么实现一个自定义的类加载器</h4><p>自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，<br>        一个是 loadClass(String, boolean)，实现了双亲委派机制<br>        还有一个方法是findClass，默认实现是空 方法，所以我们自定义类加载器主要是重写findClass方法<br>                重写findClass方法实际上就是为了实现defineClass方法，将类路径的类加载进来。</p>
<h4 id="8-怎么打破双亲委派模型"><a href="#8-怎么打破双亲委派模型" class="headerlink" title="8.怎么打破双亲委派模型"></a>8.怎么打破双亲委派模型</h4><p>自己写一个类加载器继承ClassLoader<br>主要重写 loadClass() 方法，把原来双亲委派的部分去掉<br>重写 findClass() 方法</p>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><h4 id="自增-操作数栈"><a href="#自增-操作数栈" class="headerlink" title="==自增/操作数栈=="></a>==自增/操作数栈==</h4><p><img alt="1" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109195634.png"></p>
<p>结果<br>    i=4,j=1,k=11<br>分析<br>    1.i=i++<br>        将i=1读入操作数栈，i自增(此时i=2)存在局部变量表，接着赋值，将操作数栈的i覆盖局部变量表的i，最后i=1<br>    2.j = i++<br>        将i=1读入操作数栈，i自增(操作之后i=2)存在局部变量表，接着赋值，将操作数栈的i覆盖局部变量表的j，最后j=1,i=2<br>    3.k=i+ ++i <em> i++<br>        将i=2读入操作数栈，++i(操作之后i=3)存在局部变量表，将i=3(乘号前的)压入栈中，紧接着将i=3(乘号后的)压入栈中，i++(操作之后i=4)存在局部变量表；计算乘法操作(3</em>3=9)后，与一开始的入栈的2相加得11，赋值给局部变量表的k。最后k=11，i=4</p>
<p>总结<br>    赋值运算，最后计算；赋值运算就是将对应操作数栈的数，移到局部变量表中<br>    i++和++i的区别就是<br>        压入操作数栈和修改局部变量表中的值(+1操作)顺序的区别(无论如何这两步操作是紧接在一起的)<br>        i++自增直接修改局部变量表中的值，不经过操作数栈；++i自增直接修改局部变量表中的值，之后再把局部变量表的i放入操作数栈<br><a href="https://www.bilibili.com/video/BV1Eb411P7bP/?vd_source=3c18550954067ac625f4410f0e243609" target="_blank" rel="noopener">来源</a></p>
<h4 id="1-介绍下-Java-内存区域（运行时数据区）"><a href="#1-介绍下-Java-内存区域（运行时数据区）" class="headerlink" title="==1.介绍下 Java 内存区域（运行时数据区）=="></a>==1.介绍下 Java 内存区域（运行时数据区）==</h4><p>运行时数据区<br>    Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域<br>==五大区域==<br>    程序计数器<br>        当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成<br>    虚拟机栈(线程栈)<br>        用于存储局部变量表、操作数栈、动态链接、方法出口等信息<br>    本地方法栈<br>        与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的<br>        局部变量表<br>            存基本数据类型和对象引用<br>        操作数栈<br>            方法调用的中转站<br>        动态链接<br>            动态链接的作用就是为了将符号引用转换为调用方法的直接引用(与类装载解析阶段是将静态方法的符号引用转换为直接引用不同)<br>        方法出口<br>            return 或异常<br>    堆<br>        Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存<br>    方法区<br>        用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据<br>线程共享<br>    堆<br>    方法区<br>线程私有<br>    程序计数器<br>    虚拟机栈<br>    本地方法栈<br>参考</p>
<p><img alt="3" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109200014.png"></p>
<h4 id="2-Java-对象的创建过程"><a href="#2-Java-对象的创建过程" class="headerlink" title="==2.Java 对象的创建过程=="></a>==2.Java 对象的创建过程==</h4><p>1.类加载检查<br>    虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个 符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程<br>2.分配内存</p>
<p>​    参考图</p>
<p>​    <img alt="4" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109200515.png"></p>
<p>​    内存分配方式<br>​        指针碰撞：类比顺序链表，依次分配内存<br>​        空闲链表：类比单链表，哪有空间就存哪<br>​        用哪种方式取决于Java 堆内存是否规整，而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”(不规整)，还是”标记-整理”(规整)或复制算法(规整)<br>​    创建对象可能频繁，产生并发问题<br>​        CAS<br>​            因为冲突失败就重试，直到成功为止<br>​        TLAB(本地线程分配缓冲)<br>​            为每一个线程预先在 Eden 区分配一块内存(这样就不会冲突)，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配<br>3.初始化<br>​    将分配到的内存空间都初始化为零值<br>​    这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用<br>4.设置对象头<br>​    mark word</p>
<p>​    <img alt="5" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109200437.png"></p>
<p>​        主要存的是自身运行时数据<br>​            对象的哈希码<br>​            对象的GC分代年龄<br>​            锁状态信息等<br>​    Klass Pointer类型指针：对象指向它的类元数据的指针<br>​        对象是哪个类的实例<br>​        如何才能找到类的元数据信息<br>​    数组长度(4字节，只有数组对象才有)<br>5.执行<init>方法<br>​    对象按照程序员的意愿对属性进行赋值</init></p>
<h4 id="3-对象的访问定位的两种方式"><a href="#3-对象的访问定位的两种方式" class="headerlink" title="3.对象的访问定位的两种方式"></a>3.对象的访问定位的两种方式</h4><p>​    对象的访问定位方式由虚拟机实现而定<br>​    句柄访问<br>​        引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。<br>​    直接指针<br>​        速度更快，节省了一次指针定位的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。</p>
<h4 id="4-说一下-JVM-的主要组成部分及其作用"><a href="#4-说一下-JVM-的主要组成部分及其作用" class="headerlink" title="4.说一下 JVM 的主要组成部分及其作用"></a>4.说一下 JVM 的主要组成部分及其作用</h4><p><img alt="6" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109204100.png"></p>
<p>类加载子系统<br>    步骤<br>        加载<br>        验证<br>        准备<br>        解析<br>        初始化<br>    类加载器（ClassLoader）再把字节码加载到内存中(JVM可以直接使用的java类)<br>运行时数据区<br>    Q.1<br>执行引擎<br>    即时编译器JIT</p>
<p>​        <img alt="7" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109204230.png"></p>
<p>​        前端编译(javac命令)为.class文件<br>​        解释执行，运行到不同平台上<br>​    垃圾回收器<br>本地库接口<br>本地方法库</p>
<h4 id="5-说一下堆栈的区别"><a href="#5-说一下堆栈的区别" class="headerlink" title="5.说一下堆栈的区别"></a>5.说一下堆栈的区别</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>==存储内容==</th>
<th>==程序可见度==</th>
<th>作用</th>
<th>存储结构</th>
<th>内存大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>堆</td>
<td>主要存放对象实例</td>
<td>线程共享</td>
<td>主要用于存储对象信息</td>
<td>物理地址分配对象不连续，速度慢</td>
<td>分配不连续，在运行期确认，大小不固定，大小远远大于栈</td>
</tr>
<tr>
<td>栈</td>
<td>存放基本数据类型和对象的引用</td>
<td>线程私有</td>
<td>运行时的单位，解决程序运行时的问题</td>
<td>使用数据结构—栈，物理地址分配连续，速度快</td>
<td>分配连续，在编译期确认，大小固定</td>
</tr>
</tbody>
</table>
</div>
<h4 id="6-深拷贝和浅拷贝"><a href="#6-深拷贝和浅拷贝" class="headerlink" title="6.深拷贝和浅拷贝"></a>6.深拷贝和浅拷贝</h4><p>浅拷贝<br>    引用数据类型在堆中是同一个<br>深拷贝<br>    引用数据类型会创建一个新的对象放到堆中<br>对于基本数据类型都一样，因为基本数据类型存在虚拟机栈中</p>
<h4 id="7-谈谈你对内存分配的理解？大对象怎么分配？"><a href="#7-谈谈你对内存分配的理解？大对象怎么分配？" class="headerlink" title="==7.谈谈你对内存分配的理解？大对象怎么分配？=="></a>==7.谈谈你对内存分配的理解？大对象怎么分配？==</h4><p>1.根据逃逸分析，判断对象不会逃逸，就在栈上分配<br>2.判断如果是大对象，直接进老年代<br>3.判断TLAB(本地线程分配缓存)是否满了<br>细节</p>
<p>​    1.大对象直接进老年代</p>
<p>​    2.Eden区满了(事实上有个阈值)，就会回收(99%的对象都会变成垃圾)，存活的放到幸存区<br>​        若幸存区存不下，直接进老年代<br>​    3.长期存活的对象进老年代<br>​        分代年龄阈值可以通过-XX:MaxTenuringThreshold 来设置<br>​    4.对象动态年龄判断<br>​        例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会 把年龄n(含)以上的对象都放入老年代。<br>​        -XX:TargetSurvivorRatio可以指定<br>​    5.老年代空间担保机制</p>
<p>​        <img alt="7" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109211752.png"></p>
<p>​        ==确保minorGC之后，老年代能够装下年轻代中的所有对象==<br>内存分配流程图</p>
<p><img alt="6" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109211655.png"></p>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h4 id="1-如何判断对象是否死亡（两种方法）"><a href="#1-如何判断对象是否死亡（两种方法）" class="headerlink" title="1.如何判断对象是否死亡（两种方法）"></a>1.如何判断对象是否死亡（两种方法）</h4><p>引用计数法<br>    有一个地方引用它，计数器+1；引用失效，计数器-1；计数器为0<br>    问题<br>        不能解决循环引用的问题，引发内存泄漏<br>==可达性分析算法==<br>    以GCRoot为起点，向下搜索标记引用链，最后未标记的就是垃圾<br>    GCRoot<br>        虚拟机栈(栈帧中的本地变量表)中引用的对象<br>        本地方法栈(Native 方法)中引用的对象<br>        方法区中类静态属性引用的对象<br>        方法区中常量引用的对象<br>        所有被同步锁持有的对象</p>
<h4 id="2-简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。-很少见"><a href="#2-简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。-很少见" class="headerlink" title="2.简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。(很少见)"></a>2.简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。(很少见)</h4><p>强引用<br>    编程中一般对象所使用的引用<br>软引用<br>    软引用可用来实现内存敏感的高速缓存<br>弱引用<br>虚引用<br>    虚引用主要用来跟踪对象被垃圾回收的活动<br>虚引用与软引用和弱引用的区别<br>    虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<h4 id="3-如何判断一个常量是废弃常量"><a href="#3-如何判断一个常量是废弃常量" class="headerlink" title="3.如何判断一个常量是废弃常量"></a>3.如何判断一个常量是废弃常量</h4><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量</p>
<h4 id="4-如何判断一个类是无用的类"><a href="#4-如何判断一个类是无用的类" class="headerlink" title="4.如何判断一个类是无用的类"></a>4.如何判断一个类是无用的类</h4><p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。<br>加载该类的 ClassLoader 已经被回收。<br>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
<h4 id="5-垃圾收集有哪些算法，各自的特点？"><a href="#5-垃圾收集有哪些算法，各自的特点？" class="headerlink" title="==5.垃圾收集有哪些算法，各自的特点？=="></a>==5.垃圾收集有哪些算法，各自的特点？==</h4><p>1.复制算法</p>
<p><img alt="2" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230111215622.png"></p>
<p>2.标记清除算法</p>
<p><img alt="3" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230111215624.png"></p>
<p>3.标记整理算法</p>
<p><img alt="4" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230111215626.png"></p>
<h4 id="6-HotSpot-为什么要分为新生代和老年代？"><a href="#6-HotSpot-为什么要分为新生代和老年代？" class="headerlink" title="==6.HotSpot 为什么要分为新生代和老年代？=="></a>==6.HotSpot 为什么要分为新生代和老年代？==</h4><p>将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>​    新生代<br>​            每次收集都会有大量对象(近99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可 以完成每次垃圾收集<br>​    老年代<br>​            对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集</p>
<h4 id="7-常见的垃圾回收器有哪些？"><a href="#7-常见的垃圾回收器有哪些？" class="headerlink" title="==7.常见的垃圾回收器有哪些？=="></a>==7.常见的垃圾回收器有哪些？==</h4><p><img alt="1" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230111211416.png"></p>
<h5 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1.Serial 收集器"></a>1.Serial 收集器</h5><p>​    单线程，串行<br>​    新生代采用标记-复制算法，老年代采用标记-整理算法</p>
<h5 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2.ParNew 收集器"></a>2.ParNew 收集器</h5><p>​    Serial 收集器的多线程版本，其他和Serial一样<br>​    只能用于新生代，采用标记-复制算法<br>​    可以和CMS收集器配合使用</p>
<h5 id="3-Parallel-收集器"><a href="#3-Parallel-收集器" class="headerlink" title="3.Parallel 收集器"></a>3.Parallel 收集器</h5><p>​    新生代采用复制算法，老年代采用标记-整理算法<br>​    关注点是吞吐量（高效率的利用CPU）</p>
<h5 id="4-CMS收集器"><a href="#4-CMS收集器" class="headerlink" title="4.CMS收集器"></a>4.CMS收集器</h5><p>​    只能用于老年代，使用标记清除算法<br>​    步骤<br>​        初始标记<br>​            STW<br>​            记录gc roots直接能引用的对象，很快<br>​        并发标记<br>​            三色标记算法<br>​        重新标记<br>​            STW<br>​            主要使用三色标记中的增量更新做重新标记<br>​        并发清理<br>​            开启用户线程，同时GC线程开始对未标记的区域做清扫<br>​        并发重置<br>​            重置本次GC过程中的标记数据<br>​    并发标记时漏标使用增量更新</p>
<h5 id="5-G1"><a href="#5-G1" class="headerlink" title="5.G1"></a>5.G1</h5><h6 id="并发标记时漏标使用原始快照-SATB"><a href="#并发标记时漏标使用原始快照-SATB" class="headerlink" title="并发标记时漏标使用原始快照(SATB)"></a>并发标记时漏标使用原始快照(SATB)</h6><h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6><p>​        可预测的停顿<br>​            这是 G1 相对于 CMS 的一个大优势<br>​        空间整合<br>​            与 CMS 的“标记-清理”算法不同<br>​            G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。<br>​        分代收集<br>​            虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念<br>​        并行与并发<br>​            G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。<br>​            部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。<br>​        有优先级的回收策略<br>​            在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字 Garbage-First的由来)<br>​                比如一个Region花200ms能回收10M垃圾，另外一个Region花50ms能回收20M垃圾，在回收时间有限情况下，G1当然会优先选择后面这个Region回收。</p>
<h6 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h6><p>​        初始标记<br>​            同CMS<br>​        并发标记<br>​            同CMS<br>​        最终标记<br>​            同CMS重新标记<br>​        筛选回收<br>​            会STW<br>​            首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划<br>​                例：老年代此时有1000个 Region都满了，但是因为根据预期停顿时间，本次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得 知，可能回收其中800个Region刚好需要200ms，那么就只会回收800个Region(Collection Set，要回收的集合)，尽量把GC导致的停顿时间控制在我们指定的范围内。<br>​                可以用JVM参数 -XX:MaxGCPauseMillis指定GC停顿时间<br>​            不管是年轻代或是老 年代，回收算法主要用的是复制算法<br>​                将一个region中的存活对象复制到另一个region中，这种不会像CMS那样 回收完因为有很多内存碎片还需要整理一次，G1采用复制算法回收几乎不会有太多内存碎片</p>
<h6 id="G1-垃圾收集分类"><a href="#G1-垃圾收集分类" class="headerlink" title="G1 垃圾收集分类"></a>G1 垃圾收集分类</h6><p>​        Young GC<br>​            YoungGC并不是说现有的Eden区放满了就会马上触发，而是接近参数 -XX:MaxGCPauseMills 设定的值<br>​        Mixed GC<br>​            老年代的堆占有率达到参数(-XX:InitiatingHeapOccupancyPercent)设定的值则触发<br>​            回收所有的 Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区<br>​        Full GC<br>​            Mixed GC使用复制算法发现没有足够的空region就会触发<br>​            STW，使用Serial单线程<br>​    回收流程图</p>
<p><img alt="9" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109220816.png"></p>
<h6 id="JDK8默认"><a href="#JDK8默认" class="headerlink" title="JDK8默认"></a>JDK8默认</h6><p>​    Parallel Scavenge收集器(新生代)和Parallel Old收集器(老年代)</p>
<h4 id="8-介绍一下-CMS-G1-收集器。"><a href="#8-介绍一下-CMS-G1-收集器。" class="headerlink" title="==8.介绍一下 CMS,G1 收集器。=="></a>==8.介绍一下 CMS,G1 收集器。==</h4><p>参考Q.7</p>
<h4 id="9-Minor-Gc-和-Full-GC-有什么不同呢？"><a href="#9-Minor-Gc-和-Full-GC-有什么不同呢？" class="headerlink" title="==9.Minor Gc 和 Full GC 有什么不同呢？=="></a>==9.Minor Gc 和 Full GC 有什么不同呢？==</h4><p>Minor GC<br>    指发生在新生代的垃圾收集<br>    采用复制算法<br>    频繁<br>Full GC<br>    指发生在老年代的垃圾收集<br>    “标记-清除”或“标记-整理”算法<br>    相比Minor GC没那么频繁</p>
<h4 id="10-Java会存在内存泄漏吗？请简单描述"><a href="#10-Java会存在内存泄漏吗？请简单描述" class="headerlink" title="10.Java会存在内存泄漏吗？请简单描述"></a>10.Java会存在内存泄漏吗？请简单描述</h4><p>简单使用一个hashmap，于是不断往里面放缓存数据，但是很少考虑这个map的容量问题，结果这个缓存map越来越大，一直占用着老年代的很多空间，时间长了就会导致full gc非常频繁，这就是一种内存泄漏<br>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收</p>
<h4 id="11-简述Java垃圾回收机制"><a href="#11-简述Java垃圾回收机制" class="headerlink" title="11.简述Java垃圾回收机制"></a>11.简述Java垃圾回收机制</h4><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。<br>在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p>
<h4 id="12-什么是浮动垃圾"><a href="#12-什么是浮动垃圾" class="headerlink" title="12.什么是浮动垃圾"></a>12.什么是浮动垃圾</h4><p>产生时机<br>    并发标记时，三色算法多标<br>    并发清理时，有对象变成垃圾<br>    这两个时机异曲同工</p>
<h4 id="13-什么是内存碎片？如何解决"><a href="#13-什么是内存碎片？如何解决" class="headerlink" title="13.什么是内存碎片？如何解决"></a>13.什么是内存碎片？如何解决</h4><p>概念<br>    由于不同 Java 对象存活时间是不一定的，因此，在程序运行一段时间以后，如果不进行内存整理，就会出现零散的内存碎片。<br>产生的问题<br>    会导致无法分配大块的内存空间<br>    程序运行效率降低<br>解决<br>    “复制”算法<br>    “标记-整理”算法</p>
<h4 id="14-为什么G1用SATB？CMS用增量更新？"><a href="#14-为什么G1用SATB？CMS用增量更新？" class="headerlink" title="14.为什么G1用SATB？CMS用增量更新？"></a>14.为什么G1用SATB？CMS用增量更新？</h4><p>SATB相对增量更新效率会高(当然SATB可能造成更多的浮动垃圾)，因为不需要在重新标记阶段再次深度扫描 被删除引用对象<br>而CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的region，CMS就一块老年代区域，重新深度扫描对象的话G1的代价会比CMS高<br>所以G1选择SATB不深度扫描对象，只是简单标记，等到下一轮GC 再深度扫描。</p>
<h4 id="15-如何选择垃圾收集器"><a href="#15-如何选择垃圾收集器" class="headerlink" title="==15.如何选择垃圾收集器=="></a>==15.如何选择垃圾收集器==</h4><ol>
<li>优先调整堆的大小让服务器自己来选择 </li>
<li>如果内存小于100M，使用串行收集器 </li>
<li>如果是单核，并且没有停顿时间的要求，串行或JVM自己选择 </li>
<li>如果允许停顿时间超过1秒，选择并行或者JVM自己选 </li>
<li>如果响应时间最重要，并且不能超过1秒，使用并发收集器 </li>
<li>4G以下可以用parallel，4-8G可以用ParNew+CMS，8G以上可以用G1，几百G以上用ZGC</li>
</ol>
<h4 id="16-尽量避免内存泄漏的方法"><a href="#16-尽量避免内存泄漏的方法" class="headerlink" title="16.尽量避免内存泄漏的方法"></a>16.尽量避免内存泄漏的方法</h4><p>1.尽量不要使用 static 成员变量，减少生命周期；<br>2.及时关闭资源；<br>3.不用的对象，可以手动设置为 null。</p>
<h4 id="17-新生代和老年代分别采用什么垃圾回收算法，为什么"><a href="#17-新生代和老年代分别采用什么垃圾回收算法，为什么" class="headerlink" title="==17.新生代和老年代分别采用什么垃圾回收算法，为什么=="></a>==17.新生代和老年代分别采用什么垃圾回收算法，为什么==</h4><p>新生代<br>    复制算法<br>    每次收集都会有大量对象(近99%)死去，只需要付出少量对象的复制成本就可 以完成每次垃圾收集。<br>老年代<br>    “标记-清除”或“标记-整理”算法<br>    老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以不能使用复制算法</p>
<h3 id="调优实战"><a href="#调优实战" class="headerlink" title="调优实战"></a>调优实战</h3><h3 id="真实面试题"><a href="#真实面试题" class="headerlink" title="真实面试题"></a>真实面试题</h3><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/414173543" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/414173543</a></p>
</blockquote>
<h4 id="头条一面-GC"><a href="#头条一面-GC" class="headerlink" title="头条一面(GC)"></a>头条一面(GC)</h4><h5 id="JVM-从-GC-角度看，堆的分区情况"><a href="#JVM-从-GC-角度看，堆的分区情况" class="headerlink" title="JVM 从 GC 角度看，堆的分区情况"></a><strong>JVM 从 GC 角度看，堆的分区情况</strong></h5><h5 id="为什么要将堆内存分为两块而不是直接一个老年代就行？"><a href="#为什么要将堆内存分为两块而不是直接一个老年代就行？" class="headerlink" title="为什么要将堆内存分为两块而不是直接一个老年代就行？"></a><strong>为什么要将堆内存分为两块而不是直接一个老年代就行？</strong></h5><h5 id="那为什么新生代还需要继续细分"><a href="#那为什么新生代还需要继续细分" class="headerlink" title="那为什么新生代还需要继续细分?"></a><strong>那为什么新生代还需要继续细分?</strong></h5><h5 id="Survivor-区会进行垃圾回收吗？"><a href="#Survivor-区会进行垃圾回收吗？" class="headerlink" title="Survivor 区会进行垃圾回收吗？"></a><strong>Survivor 区会进行垃圾回收吗？</strong></h5><h5 id="直接分成1块Eden区和1块s区不行吗？"><a href="#直接分成1块Eden区和1块s区不行吗？" class="headerlink" title="直接分成1块Eden区和1块s区不行吗？"></a><strong>直接分成1块Eden区和1块s区不行吗？</strong></h5><h4 id="美团一面-GC"><a href="#美团一面-GC" class="headerlink" title="美团一面(GC)"></a><strong>美团一面</strong>(GC)</h4><h5 id="说下JVM的垃圾回收算法"><a href="#说下JVM的垃圾回收算法" class="headerlink" title="说下JVM的垃圾回收算法"></a><strong>说下JVM的垃圾回收算法</strong></h5><h4 id="滴滴一面-GC"><a href="#滴滴一面-GC" class="headerlink" title="滴滴一面(GC)"></a><strong>滴滴一面</strong>(GC)</h4><h5 id="你知道哪几种垃圾回收器，各自的优缺点"><a href="#你知道哪几种垃圾回收器，各自的优缺点" class="headerlink" title="你知道哪几种垃圾回收器，各自的优缺点"></a><strong>你知道哪几种垃圾回收器，各自的优缺点</strong></h5><h4 id="字节一面-GC"><a href="#字节一面-GC" class="headerlink" title="字节一面(GC)"></a><strong>字节一面</strong>(GC)</h4><h5 id="CMS回收停顿了几次，为什么要停顿两次"><a href="#CMS回收停顿了几次，为什么要停顿两次" class="headerlink" title="CMS回收停顿了几次，为什么要停顿两次"></a><strong>CMS回收停顿了几次，为什么要停顿两次</strong></h5><h5 id="为什么要STW"><a href="#为什么要STW" class="headerlink" title="为什么要STW"></a><strong>为什么要STW</strong></h5><h5 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a><strong>三色标记算法</strong></h5><h5 id="cms-清理步骤"><a href="#cms-清理步骤" class="headerlink" title="cms 清理步骤"></a><strong>cms 清理步骤</strong></h5><h5 id="cms-为什么要停顿两次"><a href="#cms-为什么要停顿两次" class="headerlink" title="cms 为什么要停顿两次"></a><strong>cms 为什么要停顿两次</strong></h5><h4 id="字节二面-other"><a href="#字节二面-other" class="headerlink" title="字节二面(other)"></a><strong>字节二面</strong>(other)</h4><h5 id="JVM各区域间是如何协同工作的"><a href="#JVM各区域间是如何协同工作的" class="headerlink" title="JVM各区域间是如何协同工作的"></a><strong>JVM各区域间是如何协同工作的</strong></h5><h5 id="堆、栈、方法区之间数据存储怎么协调的"><a href="#堆、栈、方法区之间数据存储怎么协调的" class="headerlink" title="堆、栈、方法区之间数据存储怎么协调的"></a><strong>堆、栈、方法区之间数据存储怎么协调的</strong></h5><h5 id="双亲委派机制了解吗"><a href="#双亲委派机制了解吗" class="headerlink" title="双亲委派机制了解吗"></a><strong>双亲委派机制了解吗</strong></h5><h5 id="内存分配策略了解吗"><a href="#内存分配策略了解吗" class="headerlink" title="内存分配策略了解吗"></a><strong>内存分配策略了解吗</strong></h5><h5 id="为什么要引入元空间"><a href="#为什么要引入元空间" class="headerlink" title="为什么要引入元空间"></a><strong>为什么要引入元空间</strong></h5><h5 id="方法区，元空间，永久代之间关系"><a href="#方法区，元空间，永久代之间关系" class="headerlink" title="方法区，元空间，永久代之间关系"></a><strong>方法区，元空间，永久代之间关系</strong></h5><h5 id="System-gc-和-Runtime-getRuntime-gc-会做什么事情"><a href="#System-gc-和-Runtime-getRuntime-gc-会做什么事情" class="headerlink" title="System.gc() 和 Runtime. getRuntime(). gc()会做什么事情"></a><strong>System.gc() 和 Runtime. getRuntime(). gc()会做什么事情</strong></h5><h4 id="蚂蚁金服一面-GC"><a href="#蚂蚁金服一面-GC" class="headerlink" title="蚂蚁金服一面(GC)"></a><strong>蚂蚁金服一面</strong>(GC)</h4><h5 id="说下G1-收集器"><a href="#说下G1-收集器" class="headerlink" title="说下G1 收集器"></a><strong>说下G1 收集器</strong></h5><h4 id="京东二面-调优"><a href="#京东二面-调优" class="headerlink" title="京东二面(调优)"></a><strong>京东二面</strong>(调优)</h4><h5 id="讲下-jvm-调优思路"><a href="#讲下-jvm-调优思路" class="headerlink" title="讲下 jvm 调优思路"></a><strong>讲下 jvm 调优思路</strong></h5><h4 id="阿里一面-GC"><a href="#阿里一面-GC" class="headerlink" title="阿里一面(GC)"></a><strong>阿里一面</strong>(GC)</h4><h5 id="什么情况下触发垃圾回收"><a href="#什么情况下触发垃圾回收" class="headerlink" title="什么情况下触发垃圾回收"></a><strong>什么情况下触发垃圾回收</strong></h5><h4 id="美团一面-调优"><a href="#美团一面-调优" class="headerlink" title="美团一面(调优)"></a><strong>美团一面</strong>(调优)</h4><h5 id="有在⼯作时间中使⽤过-jstat-jmap-mat⼯具吗？能给⼀个实际的例⼦说明⼀下吗"><a href="#有在⼯作时间中使⽤过-jstat-jmap-mat⼯具吗？能给⼀个实际的例⼦说明⼀下吗" class="headerlink" title="有在⼯作时间中使⽤过 jstat, jmap, mat⼯具吗？能给⼀个实际的例⼦说明⼀下吗"></a><strong>有在⼯作时间中使⽤过 jstat, jmap, mat⼯具吗？能给⼀个实际的例⼦说明⼀下吗</strong></h5><h4 id="问题-GC"><a href="#问题-GC" class="headerlink" title="问题(GC)"></a>问题(GC)</h4><h5 id="增加-Eden-区，Minor-GC-的间隔变长了，会不会导致-Minor-GC-的时间增加"><a href="#增加-Eden-区，Minor-GC-的间隔变长了，会不会导致-Minor-GC-的时间增加" class="headerlink" title="增加 Eden 区，Minor GC 的间隔变长了，会不会导致 Minor GC 的时间增加"></a><strong>增加 Eden 区，Minor GC 的间隔变长了，会不会导致 Minor GC 的时间增加</strong></h5>
    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/alex-next/tags/JVM/" rel="tag"># JVM</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/alex-next/2022/10/27/javaEE/商城项目记录/" rel="next" title="商城项目记录">
                  <i class="fa fa-chevron-left"></i> 商城项目记录
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/alex-next/2022/11/16/面试题/JUC面试题/" rel="prev" title="JUC面试题">
                  JUC面试题 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="gitalk-container"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载机制"><span class="nav-number">1.</span> <span class="nav-text">类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-简述java类加载机制"><span class="nav-number">1.1.</span> <span class="nav-text">1.简述java类加载机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-描述一下JVM加载Class文件的原理机制"><span class="nav-number">1.2.</span> <span class="nav-text">2.描述一下JVM加载Class文件的原理机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-什么是类加载器，类加载器有哪些"><span class="nav-number">1.3.</span> <span class="nav-text">3.什么是类加载器，类加载器有哪些</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-说一下类装载的执行过程"><span class="nav-number">1.4.</span> <span class="nav-text">==4.说一下类装载的执行过程==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-什么是双亲委派模型"><span class="nav-number">1.5.</span> <span class="nav-text">==5.什么是双亲委派模型==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-如何判断两个class对象是否相同？"><span class="nav-number">1.6.</span> <span class="nav-text">6.如何判断两个class对象是否相同？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-怎么实现一个自定义的类加载器"><span class="nav-number">1.7.</span> <span class="nav-text">7.怎么实现一个自定义的类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-怎么打破双亲委派模型"><span class="nav-number">1.8.</span> <span class="nav-text">8.怎么打破双亲委派模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存分配"><span class="nav-number">2.</span> <span class="nav-text">内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自增-操作数栈"><span class="nav-number">2.1.</span> <span class="nav-text">==自增/操作数栈==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-介绍下-Java-内存区域（运行时数据区）"><span class="nav-number">2.2.</span> <span class="nav-text">==1.介绍下 Java 内存区域（运行时数据区）==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Java-对象的创建过程"><span class="nav-number">2.3.</span> <span class="nav-text">==2.Java 对象的创建过程==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-对象的访问定位的两种方式"><span class="nav-number">2.4.</span> <span class="nav-text">3.对象的访问定位的两种方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-说一下-JVM-的主要组成部分及其作用"><span class="nav-number">2.5.</span> <span class="nav-text">4.说一下 JVM 的主要组成部分及其作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-说一下堆栈的区别"><span class="nav-number">2.6.</span> <span class="nav-text">5.说一下堆栈的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-深拷贝和浅拷贝"><span class="nav-number">2.7.</span> <span class="nav-text">6.深拷贝和浅拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-谈谈你对内存分配的理解？大对象怎么分配？"><span class="nav-number">2.8.</span> <span class="nav-text">==7.谈谈你对内存分配的理解？大对象怎么分配？==</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收器"><span class="nav-number">3.</span> <span class="nav-text">垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-如何判断对象是否死亡（两种方法）"><span class="nav-number">3.1.</span> <span class="nav-text">1.如何判断对象是否死亡（两种方法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。-很少见"><span class="nav-number">3.2.</span> <span class="nav-text">2.简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。(很少见)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-如何判断一个常量是废弃常量"><span class="nav-number">3.3.</span> <span class="nav-text">3.如何判断一个常量是废弃常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-如何判断一个类是无用的类"><span class="nav-number">3.4.</span> <span class="nav-text">4.如何判断一个类是无用的类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-垃圾收集有哪些算法，各自的特点？"><span class="nav-number">3.5.</span> <span class="nav-text">==5.垃圾收集有哪些算法，各自的特点？==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-HotSpot-为什么要分为新生代和老年代？"><span class="nav-number">3.6.</span> <span class="nav-text">==6.HotSpot 为什么要分为新生代和老年代？==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-常见的垃圾回收器有哪些？"><span class="nav-number">3.7.</span> <span class="nav-text">==7.常见的垃圾回收器有哪些？==</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Serial-收集器"><span class="nav-number">3.7.1.</span> <span class="nav-text">1.Serial 收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-ParNew-收集器"><span class="nav-number">3.7.2.</span> <span class="nav-text">2.ParNew 收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Parallel-收集器"><span class="nav-number">3.7.3.</span> <span class="nav-text">3.Parallel 收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-CMS收集器"><span class="nav-number">3.7.4.</span> <span class="nav-text">4.CMS收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-G1"><span class="nav-number">3.7.5.</span> <span class="nav-text">5.G1</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#并发标记时漏标使用原始快照-SATB"><span class="nav-number">3.7.5.1.</span> <span class="nav-text">并发标记时漏标使用原始快照(SATB)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#特点"><span class="nav-number">3.7.5.2.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#步骤"><span class="nav-number">3.7.5.3.</span> <span class="nav-text">步骤</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#G1-垃圾收集分类"><span class="nav-number">3.7.5.4.</span> <span class="nav-text">G1 垃圾收集分类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#JDK8默认"><span class="nav-number">3.7.5.5.</span> <span class="nav-text">JDK8默认</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-介绍一下-CMS-G1-收集器。"><span class="nav-number">3.8.</span> <span class="nav-text">==8.介绍一下 CMS,G1 收集器。==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-Minor-Gc-和-Full-GC-有什么不同呢？"><span class="nav-number">3.9.</span> <span class="nav-text">==9.Minor Gc 和 Full GC 有什么不同呢？==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-Java会存在内存泄漏吗？请简单描述"><span class="nav-number">3.10.</span> <span class="nav-text">10.Java会存在内存泄漏吗？请简单描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-简述Java垃圾回收机制"><span class="nav-number">3.11.</span> <span class="nav-text">11.简述Java垃圾回收机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-什么是浮动垃圾"><span class="nav-number">3.12.</span> <span class="nav-text">12.什么是浮动垃圾</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-什么是内存碎片？如何解决"><span class="nav-number">3.13.</span> <span class="nav-text">13.什么是内存碎片？如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-为什么G1用SATB？CMS用增量更新？"><span class="nav-number">3.14.</span> <span class="nav-text">14.为什么G1用SATB？CMS用增量更新？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-如何选择垃圾收集器"><span class="nav-number">3.15.</span> <span class="nav-text">==15.如何选择垃圾收集器==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-尽量避免内存泄漏的方法"><span class="nav-number">3.16.</span> <span class="nav-text">16.尽量避免内存泄漏的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-新生代和老年代分别采用什么垃圾回收算法，为什么"><span class="nav-number">3.17.</span> <span class="nav-text">==17.新生代和老年代分别采用什么垃圾回收算法，为什么==</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调优实战"><span class="nav-number">4.</span> <span class="nav-text">调优实战</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#真实面试题"><span class="nav-number">5.</span> <span class="nav-text">真实面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#头条一面-GC"><span class="nav-number">5.1.</span> <span class="nav-text">头条一面(GC)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#JVM-从-GC-角度看，堆的分区情况"><span class="nav-number">5.1.1.</span> <span class="nav-text">JVM 从 GC 角度看，堆的分区情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么要将堆内存分为两块而不是直接一个老年代就行？"><span class="nav-number">5.1.2.</span> <span class="nav-text">为什么要将堆内存分为两块而不是直接一个老年代就行？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#那为什么新生代还需要继续细分"><span class="nav-number">5.1.3.</span> <span class="nav-text">那为什么新生代还需要继续细分?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Survivor-区会进行垃圾回收吗？"><span class="nav-number">5.1.4.</span> <span class="nav-text">Survivor 区会进行垃圾回收吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#直接分成1块Eden区和1块s区不行吗？"><span class="nav-number">5.1.5.</span> <span class="nav-text">直接分成1块Eden区和1块s区不行吗？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#美团一面-GC"><span class="nav-number">5.2.</span> <span class="nav-text">美团一面(GC)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#说下JVM的垃圾回收算法"><span class="nav-number">5.2.1.</span> <span class="nav-text">说下JVM的垃圾回收算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#滴滴一面-GC"><span class="nav-number">5.3.</span> <span class="nav-text">滴滴一面(GC)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#你知道哪几种垃圾回收器，各自的优缺点"><span class="nav-number">5.3.1.</span> <span class="nav-text">你知道哪几种垃圾回收器，各自的优缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字节一面-GC"><span class="nav-number">5.4.</span> <span class="nav-text">字节一面(GC)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CMS回收停顿了几次，为什么要停顿两次"><span class="nav-number">5.4.1.</span> <span class="nav-text">CMS回收停顿了几次，为什么要停顿两次</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么要STW"><span class="nav-number">5.4.2.</span> <span class="nav-text">为什么要STW</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#三色标记算法"><span class="nav-number">5.4.3.</span> <span class="nav-text">三色标记算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cms-清理步骤"><span class="nav-number">5.4.4.</span> <span class="nav-text">cms 清理步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cms-为什么要停顿两次"><span class="nav-number">5.4.5.</span> <span class="nav-text">cms 为什么要停顿两次</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字节二面-other"><span class="nav-number">5.5.</span> <span class="nav-text">字节二面(other)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#JVM各区域间是如何协同工作的"><span class="nav-number">5.5.1.</span> <span class="nav-text">JVM各区域间是如何协同工作的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#堆、栈、方法区之间数据存储怎么协调的"><span class="nav-number">5.5.2.</span> <span class="nav-text">堆、栈、方法区之间数据存储怎么协调的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#双亲委派机制了解吗"><span class="nav-number">5.5.3.</span> <span class="nav-text">双亲委派机制了解吗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内存分配策略了解吗"><span class="nav-number">5.5.4.</span> <span class="nav-text">内存分配策略了解吗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么要引入元空间"><span class="nav-number">5.5.5.</span> <span class="nav-text">为什么要引入元空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方法区，元空间，永久代之间关系"><span class="nav-number">5.5.6.</span> <span class="nav-text">方法区，元空间，永久代之间关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#System-gc-和-Runtime-getRuntime-gc-会做什么事情"><span class="nav-number">5.5.7.</span> <span class="nav-text">System.gc() 和 Runtime. getRuntime(). gc()会做什么事情</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#蚂蚁金服一面-GC"><span class="nav-number">5.6.</span> <span class="nav-text">蚂蚁金服一面(GC)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#说下G1-收集器"><span class="nav-number">5.6.1.</span> <span class="nav-text">说下G1 收集器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#京东二面-调优"><span class="nav-number">5.7.</span> <span class="nav-text">京东二面(调优)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#讲下-jvm-调优思路"><span class="nav-number">5.7.1.</span> <span class="nav-text">讲下 jvm 调优思路</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阿里一面-GC"><span class="nav-number">5.8.</span> <span class="nav-text">阿里一面(GC)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#什么情况下触发垃圾回收"><span class="nav-number">5.8.1.</span> <span class="nav-text">什么情况下触发垃圾回收</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#美团一面-调优"><span class="nav-number">5.9.</span> <span class="nav-text">美团一面(调优)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#有在⼯作时间中使⽤过-jstat-jmap-mat⼯具吗？能给⼀个实际的例⼦说明⼀下吗"><span class="nav-number">5.9.1.</span> <span class="nav-text">有在⼯作时间中使⽤过 jstat, jmap, mat⼯具吗？能给⼀个实际的例⼦说明⼀下吗</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-GC"><span class="nav-number">5.10.</span> <span class="nav-text">问题(GC)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#增加-Eden-区，Minor-GC-的间隔变长了，会不会导致-Minor-GC-的时间增加"><span class="nav-number">5.10.1.</span> <span class="nav-text">增加 Eden 区，Minor GC 的间隔变长了，会不会导致 Minor GC 的时间增加</span></a></li></ol></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/alex-next/images/avatar.jpg"
      alt="alex">
  <p class="site-author-name" itemprop="name">alex</p>
  <div class="site-description" itemprop="description">时光静好,与君语;细水流年,与君同;繁华落尽,与君老.</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/alex-next/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/alex-next/categories/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/alex-next/tags/">
          
        
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/alex-next/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">alex</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/alex-next/lib/anime.min.js?v=3.1.0"></script>
  <script src="/alex-next/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/alex-next/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script src="/alex-next/lib/pjax/pjax.min.js?v=0.2.8"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
<script src="/alex-next/js/utils.js?v=7.4.0"></script><script src="/alex-next/js/motion.js?v=7.4.0"></script>
<script src="/alex-next/js/schemes/pisces.js?v=7.4.0"></script>
<script src="/alex-next/js/next-boot.js?v=7.4.0"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var id = element.id || '';
    var src = element.src || '';
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (id !=='') {
      script.id = element.id;
    }
    if (src !== '') {
      script.src = src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  








  <script src="/alex-next/js/local-search.js?v=7.4.0"></script>













    <div id="pjax">

  

  
    
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    
  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: '84888b5ba3be0f56b2ed',
      clientSecret: '1306406ecbdc02b679df3c95b94985753d302d6a',
      repo: 'alex-next',
      owner: 'alexander-wd',
      admin: ['alexander-wd'],
      id: 'abe15b8a3778e4979bc195dd3b6d9cfe',
        language: 'zh-CN',
      
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script>

    </div>
</body>
</html>
