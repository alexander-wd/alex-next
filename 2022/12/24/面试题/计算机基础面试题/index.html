<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/alex-next/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/alex-next/images/favicon.ico?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/alex-next/images/favicon.ico?v=7.4.0">
  <link rel="mask-icon" href="/alex-next/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/alex-next/atom.xml" title="alex的博客 - github.com" type="application/atom+xml">

<link rel="stylesheet" href="/alex-next/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/alex-next/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/alex-next/',
    scheme: 'Pisces',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: true,
    pangu: true,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="操作系统操作系统基础1.什么是操作系统操作系统是管理计算机硬件和软件资源的程序，是计算机的基石操作系统本质上是一个运行在计算机上的软件程序，用于管理计算机硬件和软件资源操作系统存在屏蔽了硬件层的复杂性操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性 ==2.什么是系统">
<meta name="keywords" content="计算机基础">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机基础面试题">
<meta property="og:url" content="https://alexander-wd.github.io/2022/12/24/面试题/计算机基础面试题/index.html">
<meta property="og:site_name" content="alex的博客 - github.com">
<meta property="og:description" content="操作系统操作系统基础1.什么是操作系统操作系统是管理计算机硬件和软件资源的程序，是计算机的基石操作系统本质上是一个运行在计算机上的软件程序，用于管理计算机硬件和软件资源操作系统存在屏蔽了硬件层的复杂性操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性 ==2.什么是系统">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2023-02-13T10:07:15.615Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="计算机基础面试题">
<meta name="twitter:description" content="操作系统操作系统基础1.什么是操作系统操作系统是管理计算机硬件和软件资源的程序，是计算机的基石操作系统本质上是一个运行在计算机上的软件程序，用于管理计算机硬件和软件资源操作系统存在屏蔽了硬件层的复杂性操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性 ==2.什么是系统">
  <link rel="canonical" href="https://alexander-wd.github.io/2022/12/24/面试题/计算机基础面试题/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>计算机基础面试题 | alex的博客 - github.com</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/alex-next/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">alex的博客 - github.com</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/alex-next/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/alex-next/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/alex-next/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/alex-next/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/alexander-wd" class="github-corner" title="alex GitHub" aria-label="alex GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://alexander-wd.github.io/alex-next/2022/12/24/面试题/计算机基础面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="alex">
      <meta itemprop="description" content="时光静好,与君语;细水流年,与君同;繁华落尽,与君老.">
      <meta itemprop="image" content="/alex-next/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="alex的博客 - github.com">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">计算机基础面试题

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2022-12-24 16:10:20" itemprop="dateCreated datePublished" datetime="2022-12-24T16:10:20+08:00">2022-12-24</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-13 18:07:15" itemprop="dateModified" datetime="2023-02-13T18:07:15+08:00">2023-02-13</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/alex-next/categories/面试题/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h4 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a>操作系统基础</h4><h5 id="1-什么是操作系统"><a href="#1-什么是操作系统" class="headerlink" title="1.什么是操作系统"></a>1.什么是操作系统</h5><p>操作系统是管理计算机硬件和软件资源的程序，是计算机的基石<br>操作系统本质上是一个运行在计算机上的软件程序，用于管理计算机硬件和软件资源<br>操作系统存在屏蔽了硬件层的复杂性<br>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性</p>
<h5 id="2-什么是系统调用呢"><a href="#2-什么是系统调用呢" class="headerlink" title="==2.什么是系统调用呢=="></a>==2.什么是系统调用呢==</h5><p>用户态和系统态<br>    用户态<br>        用户态运行的进程可以直接读取用户程序的数据<br>    系统态<br>        可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制<br>系统调用<br>    我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了<br>系统调用按功能分类<br>    设备管理<br>        完成设备的请求或释放，以及设备启动等功能。<br>    文件管理<br>        完成文件的读、写、创建及删除等功能。<br>    进程控制<br>        完成进程的创建、撤销、阻塞及唤醒等功能。<br>    进程通信<br>        完成进程之间的消息传递或信号传递等功能。<br>    内存管理<br>        完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</p>
<h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><h5 id="1-进程和线程的区别"><a href="#1-进程和线程的区别" class="headerlink" title="1.进程和线程的区别"></a>1.进程和线程的区别</h5><p>进程是资源分配的最小单位<br>    线程是 CPU 调度的最小单位<br>创建进程或撤销进程，系统都要为之分配或回收资源，操作系统开销远大于创建或撤销线程时的开销<br>不同进程地址空间相互独立，同一进程内的线程共享同一地址空间。一个进程的线程在另一个进程内是不可见的<br>进程间不会相互影响，而一个线程挂掉将可能导致整个进程挂掉<br>以JVM为例分析<br>    一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈</p>
<h5 id="2-进程有哪几种状态"><a href="#2-进程有哪几种状态" class="headerlink" title="2.进程有哪几种状态"></a>2.进程有哪几种状态</h5><p>创建<br>    进程正在被创建，尚未到就绪状态<br>就绪<br>    进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行<br>运行<br>    进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)<br>阻塞<br>    又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行<br>结束<br>    进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行<br>进程状态转换图</p>
<p><img alt="7" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/计算机基础/20230118163100.png"></p>
<h5 id="3-进程间的通信方式"><a href="#3-进程间的通信方式" class="headerlink" title="3.进程间的通信方式"></a>3.进程间的通信方式</h5><p>管道/匿名管道(Pipes)<br>    用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。<br>有名管道(Names Pipes)<br>    匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</p>
<p>信号(Signal)<br>    信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</p>
<p>==消息队列(Message Queuing)==<br>    消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。<br>==信号量(Semaphores)==<br>    信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。<br>    类比，Semaphore(AQS)<br>==共享内存(Shared memory)==<br>    使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。<br>    类比volatile<br>==套接字(Sockets)==<br>    此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。<br>信号(Signal)<br>    信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</p>
<h5 id="4-线程间的同步的方式"><a href="#4-线程间的同步的方式" class="headerlink" title="4.线程间的同步的方式"></a>4.线程间的同步的方式</h5><p>互斥量<br>    采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限<br>    同步锁(synchronized，ReentrantLock)<br>信号量<br>    它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量<br>    Semaphore(AQS)<br>事件<br>    通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作<br>    wait/notify<br>共享内存<br>    volatile关键字</p>
<h5 id="5-进程的调度算法"><a href="#5-进程的调度算法" class="headerlink" title="5.进程的调度算法"></a>5.进程的调度算法</h5><p>短作业优先(SJF)的调度算法<br>    从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。<br>时间片轮转调度算法<br>    时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。<br>多级反馈队列调度算法<br>    前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。<br>    短进程执行优先级最高，时间片小；长进程执行优先级低，时间片长。<br>    一个新进程进来先进入序数最小的队列(优先级最高，时间片最小)，拿到CPU时间片执行，时间皮用完，移到序数较大的队列中；以此类推<br>优先级调度<br>    为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。<br>先到先服务(FCFS)调度算法<br>    从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</p>
<h5 id="6-什么是死锁"><a href="#6-什么是死锁" class="headerlink" title="==6.什么是死锁=="></a>==6.什么是死锁==</h5><p>多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止</p>
<h5 id="7-死锁的四个必要条件是什么"><a href="#7-死锁的四个必要条件是什么" class="headerlink" title="==7.死锁的四个必要条件是什么=="></a>==7.死锁的四个必要条件是什么==</h5><p>互斥<br>    资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。<br>占有并等待<br>    一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。<br>非抢占<br>    资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。<br>循环等待<br>    有一组等待进程 {P0, P1,…, Pn}， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，……，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有<br>例：A有R1，等待R2;B有R2，等待R1</p>
<h5 id="8-解决死锁的方法"><a href="#8-解决死锁的方法" class="headerlink" title="==8.解决死锁的方法=="></a>==8.解决死锁的方法==</h5><p>预防<br>    概念<br>        采用某种策略，限制并发进程对资源的请求，从而使得死锁的必要条件在系统执行的任何时间上都不满足<br>    破坏互斥条件<br>        很多资源往往是不能同时访问的，不靠谱<br>    破坏非抢占条件<br>        会导致资源利用率下降，不靠谱<br>    破坏占有并等待条件<br>        静态分配策略<br>            在一开始就给线程分配执行所需要的所有资源<br>            可能有些资源要在执行比较靠后的时间采用，会严重降低资源利用率，不靠谱<br>    破坏循环等待条件<br>        层次分配策略<br>            在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源<br>            A有R1，等待R2;B有R2，等待R1，加入R2&gt;R1，那么B会先释放R2<br>避免<br>    概念<br>        系统在分配资源时，根据资源的使用情况提前做出预测，从而避免死锁的发生(允许存在四个必要条件)<br>    <a href="https://blog.csdn.net/qq_33414271/article/details/80245715" target="_blank" rel="noopener">银行家算法</a><br>        先 试探 分配给该进程资源<br>        然后通过 安全性算法 判断分配后系统是否处于安全状态<br>            若不安全则试探分配作废，让该进程继续等待<br>            若能够进入到安全的状态，则就 真的分配资源给该进程。<br>        缺点：需要不断做安全性检查，时间开销大<br>检测<br>    概念<br>        系统设有专门的机构，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。<br>    进程-资源分配图<br>        如果进程-资源分配图中无环路，则此时系统没有发生死锁<br>        如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁<br>        如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁<br>            如果能在进程-资源分配图中找出一个 既不阻塞又非独立的进程 ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 消除所有的边 ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 拓扑排序)<br>解除<br>    概念<br>        解除 是与检测相配套的一种措施，用于将进程从死锁状态下解脱出来<br>    立即结束所有进程的执行，重新启动操作系统<br>        这种方法简单，但以前所在的工作全部作废，损失很大。<br>    撤销涉及死锁的所有进程，解除死锁后继续运行<br>        这种方法能彻底打破死锁的循环等待条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。<br>    逐个撤销涉及死锁的进程，回收其资源直至死锁解除。<br>    抢占资源<br>        从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。<br>总结<br>    预防和避免像悲观锁，检测和解除像乐观锁</p>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><h5 id="1-操作系统的内存管理主要是做什么"><a href="#1-操作系统的内存管理主要是做什么" class="headerlink" title="1.操作系统的内存管理主要是做什么"></a>1.操作系统的内存管理主要是做什么</h5><p>主要负责内存的分配与回收<br>地址转换也就是将逻辑地址转换成相应的物理地址等功能</p>
<h5 id="2-常见的几种内存管理机制"><a href="#2-常见的几种内存管理机制" class="headerlink" title="2.常见的几种内存管理机制"></a>2.常见的几种内存管理机制</h5><p>连续分配管理方式<br>    为一个用户程序分配一个连续的内存空间<br>    块式管理<br>        将内存分为几个固定大小的块，每个块中只包含一个进程。<br>        如果程序运行需要内存的话，操作系统就分配给它一块，<br>        如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片<br>非连续分配管理方式<br>    允许一个程序使用的内存分布在离散或者说不相邻的内存中<br>    页式管理<br>        把主存分为大小相等且固定的一页一页的形式，页较小，相比于块式管理的划分粒度更小，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。<br>    段式管理<br>        页式管理虽然提高了内存利用率，但是页式管理其中的页并无任何实际意义。<br>        段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。<br>    段页式管理机制<br>        结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 段页式管理机制 中段与段之间以及段的内部的都是离散的。<br>    总结<br>        页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求</p>
<h5 id="3-快表和多级页表"><a href="#3-快表和多级页表" class="headerlink" title="3.快表和多级页表"></a>3.快表和多级页表</h5><p>快表<br>    在 页表方案 基础之上引入了 快表 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器<br>    步骤<br>        加入快表后,在地址转换时，首先在快表中查找，若找到就直接进行地址转换；<br>        未找到，则在主存页表继续查找，并把查到的页号和块号放入联想存储器中。<br>        快表的命中率很高，有效地提高了地址转换的速度。<br>    <a href="https://blog.csdn.net/SJ_Sniper/article/details/122838711" target="_blank" rel="noopener">参考</a><br>    快表命中率</p>
<p>​    <img alt="8" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/计算机基础/20230118180157.jpg"></p>
<p>多级页表<br>    为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。<br>    多级页表属于时间换空间的典型场景<br>    <a href="https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html" target="_blank" rel="noopener">参考</a><br>利用了程序的局部性原理</p>
<h5 id="4-分页机制和分段机制的共同点和区别"><a href="#4-分页机制和分段机制的共同点和区别" class="headerlink" title="4.分页机制和分段机制的共同点和区别"></a>4.分页机制和分段机制的共同点和区别</h5><p>共同点<br>    分页机制和分段机制都是为了提高内存利用率，减少内存碎片。<br>    页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。<br>区别<br>    页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。<br>    分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</p>
<h5 id="5-逻辑-虚拟-地址和物理地址"><a href="#5-逻辑-虚拟-地址和物理地址" class="headerlink" title="5.逻辑(虚拟)地址和物理地址"></a>5.逻辑(虚拟)地址和物理地址</h5><p>编程一般只有可能和逻辑地址打交道<br>逻辑地址<br>    在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定<br>物理地址<br>    物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址</p>
<h5 id="6-CPU-寻址了解吗-为什么需要虚拟地址空间"><a href="#6-CPU-寻址了解吗-为什么需要虚拟地址空间" class="headerlink" title="==6.CPU 寻址了解吗?为什么需要虚拟地址空间=="></a>==6.CPU 寻址了解吗?为什么需要虚拟地址空间==</h5><p>CPU寻址<br>    使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存<br>==为什么要有虚拟地址空间呢==<br>    没有虚拟地址空间的时候，程序直接访问和操作的都是物理内存，会有几个问题<br>        用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。<br>        想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃<br>        总结<br>            如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难</p>
<p>​    优势<br>​        程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。<br>​        程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。<br>​        不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</p>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><h5 id="1-什么是虚拟内存"><a href="#1-什么是虚拟内存" class="headerlink" title="1.什么是虚拟内存"></a>1.什么是虚拟内存</h5><p>概念<br>    虚拟内存是计算机系统内存管理的一种技术<br>    虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间<br>优势<br>    通过 虚拟内存 可以让程序可以拥有超过系统物理内存大小的可用内存空间。<br>    虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。</p>
<h5 id="2-局部性原理"><a href="#2-局部性原理" class="headerlink" title="==2.局部性原理=="></a>==2.局部性原理==</h5><p>局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。<br>时间局部性<br>    如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。<br>    产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。<br>    实现<br>        将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现</p>
<p>空间局部性<br>    一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。<br>    如数组<br>    实现<br>        使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现</p>
<h5 id="3-虚拟存储器"><a href="#3-虚拟存储器" class="headerlink" title="3.虚拟存储器"></a>3.虚拟存储器</h5><p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。<br>在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大得多的存储器</p>
<h5 id="4-虚拟内存的技术实现"><a href="#4-虚拟内存的技术实现" class="headerlink" title="==4.虚拟内存的技术实现=="></a>==4.虚拟内存的技术实现==</h5><p>请求分页存储管理<br>    ==建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能==<br>    步骤<br>        请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。<br>        假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中<br>请求分段存储管理<br>    建立在分段存储管理之上，增加了请求调段功能、分段置换功能。<br>请求段页式存储管理<br>要点<br>    一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；<br>    ==缺页中断==<br>        如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序；<br>    虚拟地址空间<br>        逻辑地址到物理地址的变换</p>
<h5 id="5-页面置换算法"><a href="#5-页面置换算法" class="headerlink" title="==5.页面置换算法=="></a>==5.页面置换算法==</h5><p>==为什么需要页面置换算法==<br>    地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断，若此时内存中没有空闲的页面，就会使用页面置换算法淘汰页面<br>OPT 页面置换算法（最佳页面置换算法）<br>    最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率<br>    但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法<br>FIFO页面置换算法（先进先出页面置换算法）<br>    总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。<br>LRU页面置换算法（最近最久未使用页面置换算法）<br>    LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。<br>LFU页面置换算法（最少使用页面置换算法）<br>    该置换算法选择在之前时期使用最少的页面作为淘汰页。</p>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h5 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1.OSI七层模型"></a>1.OSI七层模型</h5><p><img alt="1" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/计算机基础/20230118183256.png"></p>
<h5 id="2-TCP-IP四层模型"><a href="#2-TCP-IP四层模型" class="headerlink" title="2.TCP/IP四层模型"></a>2.TCP/IP四层模型</h5><p>应用层<br>    定义了信息交换的格式<br>传输层<br>    提供通用的数据传输服务<br>网络层<br>    提供通信服务<br>网络接口层<br>    封装成桢，无差别传输</p>
<h5 id="3-参考"><a href="#3-参考" class="headerlink" title="3.参考"></a>3.<a href="https://www.iamshuaidi.com/747.html" target="_blank" rel="noopener">参考</a></h5><h4 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h4><h5 id="1-TCP-三次握手"><a href="#1-TCP-三次握手" class="headerlink" title="==1.TCP 三次握手=="></a>==1.TCP 三次握手==</h5><p>详解</p>
<blockquote>
<p>​    人话概述<br>​        首先，我让信使运输一份信件给对方，对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。<br>​        于是他给我回信，我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以。<br>​        然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次，他若收到了，他便清楚了他的发件能力和我的收件能力是可以的。<br>​    第一次握手<br>​        客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。<br>​        人话<br>​            发送SYN，请求连接<br>​    第二次握手<br>​        服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。<br>​        人话<br>​            发送SYN和ACK，确认请求连接<br>​    第三次握手<br>​        客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。<br>​        人话<br>​            发送ACK，确认服务器的确认(主要让服务器明白)</p>
</blockquote>
<p>核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求</p>
<p>==追问==</p>
<blockquote>
<p>==为什么TCP连接的时候是3次？2次或4次不可以吗==<br>    2次不可以？<br>        2次的话服务器并不知道客户端是否已经收到自己的同步信号，可能这个同步信号会丢失(客户端接收有问题)，导致服务器和客户端的初始序号无法达成一致<br>    4次不可以？<br>        3次已经能满足可靠传输和传输效率了，4次多余<br>==第2次握手传回了ACK，为什么还要传回SYN==<br>    服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信。<br>==如果已经建立了连接，但是客户端突然出现故障了怎么办==<br>    TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。<br>==如果第1次握手中，客户端发给服务端的SYN丢了，怎么办==<br>    客户端会周期性超时重传，直到收到服务器的确认<br>==如果第2次握手中，服务器发给客户端的SYN+ACK丢了，怎么办==<br>    服务端会周期性超时重传SYN+ACK，直到收到客户端的确认<br>==如果第3次握手中，服务器发给客户端的确认(ACK)丢了，怎么办==<br>    首先，客户端不会为没有数据的ACK超时重传<br>    A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态<br>    这时，分三种情况<br>        双方都没数据，服务端会周期性超时重传SYN+ACK，直到收到客户端的确认<br>        若客户端有数据，服务端收到客户端的数据+ACK，自然会切换为Established状态<br>        若服务器有数据，发送不了，会周期性超时重传SYN+ACK，直到收到客户端的确认</p>
</blockquote>
<p>图解</p>
<p><img alt="2" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/计算机基础/20230118184004.png"></p>
<h5 id="2-TCP四次挥手"><a href="#2-TCP四次挥手" class="headerlink" title="==2.TCP四次挥手=="></a>==2.TCP四次挥手==</h5><p>详解</p>
<blockquote>
<p>人话概述<br>    第一次挥手 ： A 说“我没啥要说的了”<br>    第二次挥手 ：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话<br>    第三次挥手 ：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”<br>    第四次挥手 ：A 回答“知道了”，这样通话才算结束。<br>第一次挥手<br>    当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。<br>第二次挥手<br>    服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。<br>第三次挥手<br>    服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。<br>第四次挥手<br>    客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。</p>
</blockquote>
<p>追问</p>
<blockquote>
<p>==为什么TCP连接的时候是3次，关闭的时候却是4次==<br>    因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)<br>==为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手==<br>    因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。<br>==如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样==<br>    客户端没有收到 ACK 确认，服务器会重新发送 FIN 请求<br>==为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接==<br>    第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端没有因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN<br>    类比第三次握手时丢失ACK</p>
</blockquote>
<p>图解</p>
<p><img alt="3" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/计算机基础/20230118184012.png"></p>
<h5 id="3-TCP-与-UDP-的区别"><a href="#3-TCP-与-UDP-的区别" class="headerlink" title="==3.TCP 与 UDP 的区别=="></a>==3.TCP 与 UDP 的区别==</h5><p>是否面向连接<br>    UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。<br>是否是可靠传输<br>    远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。<br>是否有状态<br>    这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（这很渣男！）。<br>传输效率<br>    由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。<br>传输形式<br>    TCP 是面向字节流的，UDP 是面向报文的。<br>首部开销<br>    TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。<br>是否提供广播或多播服务<br>    TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</p>
<p>图解</p>
<p><img alt="4" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/计算机基础/20230118190231.png"></p>
<h5 id="4-什么时候选择-TCP-什么时候选-UDP"><a href="#4-什么时候选择-TCP-什么时候选-UDP" class="headerlink" title="4.什么时候选择 TCP,什么时候选 UDP"></a>4.什么时候选择 TCP,什么时候选 UDP</h5><p>UDP<br>    一般用于即时通信<br>        语音、 视频 、直播<br>TCP<br>    用于对传输准确性要求特别高的场景<br>        文件传输、发送和接收邮件、远程登录</p>
<h5 id="5-使用-TCP-的协议有哪些-使用-UDP-的协议有哪些"><a href="#5-使用-TCP-的协议有哪些-使用-UDP-的协议有哪些" class="headerlink" title="5.使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?"></a>5.使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?</h5><p>==TCP==<br>    HTTP 协议<br>        超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。<br>    HTTPS 协议<br>        更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议<br>    FTP 协议<br>        文件传输协议 FTP（File Transfer Protocol），提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。<br>    SMTP 协议<br>        简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，基于 TCP 协议，用来发送电子邮件。注意 ⚠️：接受邮件的协议不是 SMTP 而是 POP3 协议。<br>    POP3/IMAP 协议<br>        POP3 和 IMAP 两者都是负责邮件接收的协议。<br>    Telent 协议<br>        远程登陆协议，通过一个终端登陆到其他服务器。被一种称为 SSH 的非常安全的协议所取代。<br>    SSH 协议<br>        SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。<br>==UDP==<br>    DNS<br>        域名系统（DNS，Domain Name System）将人类可读的域名 (例如，www.baidu.com) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议。<br>    DHCP 协议<br>        动态主机配置协议，动态配置 IP 地址</p>
<h5 id="6-TCP-协议如何保证可靠传输"><a href="#6-TCP-协议如何保证可靠传输" class="headerlink" title="==6.TCP 协议如何保证可靠传输=="></a>==6.TCP 协议如何保证可靠传输==</h5><p>==基于数据块传输==<br>    应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。<br>对失序数据包重新排序以及去重<br>    TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。<br>校验和<br>    TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。<br>==超时重传==<br>    当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为已丢失并进行重传。<br>==流量控制==<br>    TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。<br>==拥塞控制==<br>    当网络拥塞时，减少数据的发送。</p>
<h5 id="7-TCP-如何实现流量控制"><a href="#7-TCP-如何实现流量控制" class="headerlink" title="7.TCP 如何实现流量控制"></a>7.TCP 如何实现流量控制</h5><p>TCP 利用滑动窗口实现流量控制<br>追问<br>    ==为什么需要流量控制==<br>        因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等<br>        如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 接收缓冲区(Receiving Buffers) 里（失序的数据包也会被存放在缓存区里）。<br>        如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。</p>
<h5 id="8-TCP-的拥塞控制是怎么实现的"><a href="#8-TCP-的拥塞控制是怎么实现的" class="headerlink" title="8.TCP 的拥塞控制是怎么实现的"></a>8.TCP 的拥塞控制是怎么实现的</h5><p>总结<br>    维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化，根据网络的拥塞程度使用四种不同的算法(慢开始、拥塞避免、快重传、快恢复)<br>追问<br>    ==拥塞控制和流量控制区别==<br>        拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。<br>        相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收</p>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h5 id="1-在浏览器中输入-url-地址-gt-gt-显示主页的过程"><a href="#1-在浏览器中输入-url-地址-gt-gt-显示主页的过程" class="headerlink" title="==1.在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程=="></a>==1.在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程==</h5><blockquote>
<p>1.使用DNS解析域名为IP地址<br>2.浏览器向web服务器发送HTTP请求<br>    若是HTTPS，还要使用SSL/TLS协议(握手)<br>3.与服务器建立TCP连接<br>    IP协议，OSPF协议(路由器间)<br>    ARP协议(IP地址转为MAC地址)<br>4.服务器发回HTML响应<br>5.浏览器开始显示HTML</p>
<p><img alt="5" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/计算机基础/20230118191216.jpg"></p>
</blockquote>
<p><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">参考</a></p>
<h5 id="2-HTTP-是不保存状态的协议-如何保存用户状态"><a href="#2-HTTP-是不保存状态的协议-如何保存用户状态" class="headerlink" title="2.HTTP 是不保存状态的协议, 如何保存用户状态"></a>2.HTTP 是不保存状态的协议, 如何保存用户状态</h5><p>Session + Cookie<br>token和session的区别<br>    <a href="https://blog.csdn.net/sinat_34191046/article/details/88740880" target="_blank" rel="noopener">token易扩展，session存在服务器中，但每台服务器session可能不同</a><br>    <a href="https://blog.csdn.net/u013451157/article/details/98478484" target="_blank" rel="noopener">token可以防止CSRF跨站请求伪造，因为浏览器访问默认不会带</a><br>    <a href="https://blog.csdn.net/weixin_44052462/article/details/122988438" target="_blank" rel="noopener">csrf原理</a></p>
<h5 id="3-HTTP-和-HTTPS-有什么区别"><a href="#3-HTTP-和-HTTPS-有什么区别" class="headerlink" title="==3.HTTP 和 HTTPS 有什么区别=="></a>==3.HTTP 和 HTTPS 有什么区别==</h5><p>端口号<br>    HTTP 默认是 80，HTTPS 默认是 443。<br>URL 前缀<br>    HTTP 的 URL 前缀是 <a href="http://，HTTPS" target="_blank" rel="noopener">http://，HTTPS</a> 的 URL 前缀是 https://。<br>安全性和资源消耗<br>     HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p>
<h5 id="4-HTTP1-0，1-1，2-0-的版本区别"><a href="#4-HTTP1-0，1-1，2-0-的版本区别" class="headerlink" title="4.HTTP1.0，1.1，2.0 的版本区别"></a>4.HTTP1.0，1.1，2.0 的版本区别</h5><p>1.0<br>    无状态(不记录请求记录)<br>    无连接(处理完之后立即断开TCP协议)<br>1.1<br>    开始默认使用Connection: keep-alive<br>        可以被多个请求复用<br>    管道机制<br>        在同一个TCP连接里面，客户端可以同时发送多个请求<br>2.0<br>    多路复用<br>        前提<br>            HTTP/2进行了二进制分帧<br>        在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应<br>    头部压缩<br>        使用encoder来减少需要传输的header大小</p>
<h5 id="5-token和session的区别"><a href="#5-token和session的区别" class="headerlink" title="==5.token和session的区别=="></a>==5.token和session的区别==</h5><p><a href="https://blog.csdn.net/sinat_34191046/article/details/88740880" target="_blank" rel="noopener">token易扩展，session存在服务器中，但每台服务器session可能不同</a><br><a href="https://blog.csdn.net/u013451157/article/details/98478484" target="_blank" rel="noopener">token可以防止CSRF跨站请求伪造，因为浏览器访问默认不会带</a><br>[csrf原理](</p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/alex-next/tags/计算机基础/" rel="tag"># 计算机基础</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/alex-next/2022/11/28/面试题/Spring面试题/" rel="next" title="spring面试题">
                  <i class="fa fa-chevron-left"></i> spring面试题
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/alex-next/2022/12/24/面试题/Springboot面试题/" rel="prev" title="SpringBoot面试题">
                  SpringBoot面试题 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="gitalk-container"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统"><span class="nav-number">1.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#操作系统基础"><span class="nav-number">1.1.</span> <span class="nav-text">操作系统基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-什么是操作系统"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.什么是操作系统</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-什么是系统调用呢"><span class="nav-number">1.1.2.</span> <span class="nav-text">==2.什么是系统调用呢==</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程和线程"><span class="nav-number">1.2.</span> <span class="nav-text">进程和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-进程和线程的区别"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.进程和线程的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-进程有哪几种状态"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.进程有哪几种状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-进程间的通信方式"><span class="nav-number">1.2.3.</span> <span class="nav-text">3.进程间的通信方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-线程间的同步的方式"><span class="nav-number">1.2.4.</span> <span class="nav-text">4.线程间的同步的方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-进程的调度算法"><span class="nav-number">1.2.5.</span> <span class="nav-text">5.进程的调度算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-什么是死锁"><span class="nav-number">1.2.6.</span> <span class="nav-text">==6.什么是死锁==</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-死锁的四个必要条件是什么"><span class="nav-number">1.2.7.</span> <span class="nav-text">==7.死锁的四个必要条件是什么==</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-解决死锁的方法"><span class="nav-number">1.2.8.</span> <span class="nav-text">==8.解决死锁的方法==</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存管理"><span class="nav-number">1.3.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-操作系统的内存管理主要是做什么"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.操作系统的内存管理主要是做什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-常见的几种内存管理机制"><span class="nav-number">1.3.2.</span> <span class="nav-text">2.常见的几种内存管理机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-快表和多级页表"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.快表和多级页表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-分页机制和分段机制的共同点和区别"><span class="nav-number">1.3.4.</span> <span class="nav-text">4.分页机制和分段机制的共同点和区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-逻辑-虚拟-地址和物理地址"><span class="nav-number">1.3.5.</span> <span class="nav-text">5.逻辑(虚拟)地址和物理地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-CPU-寻址了解吗-为什么需要虚拟地址空间"><span class="nav-number">1.3.6.</span> <span class="nav-text">==6.CPU 寻址了解吗?为什么需要虚拟地址空间==</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟内存"><span class="nav-number">1.4.</span> <span class="nav-text">虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-什么是虚拟内存"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.什么是虚拟内存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-局部性原理"><span class="nav-number">1.4.2.</span> <span class="nav-text">==2.局部性原理==</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-虚拟存储器"><span class="nav-number">1.4.3.</span> <span class="nav-text">3.虚拟存储器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-虚拟内存的技术实现"><span class="nav-number">1.4.4.</span> <span class="nav-text">==4.虚拟内存的技术实现==</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-页面置换算法"><span class="nav-number">1.4.5.</span> <span class="nav-text">==5.页面置换算法==</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算机网络"><span class="nav-number">2.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概述"><span class="nav-number">2.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-OSI七层模型"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.OSI七层模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-TCP-IP四层模型"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.TCP/IP四层模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-参考"><span class="nav-number">2.1.3.</span> <span class="nav-text">3.参考</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP与UDP"><span class="nav-number">2.2.</span> <span class="nav-text">TCP与UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-TCP-三次握手"><span class="nav-number">2.2.1.</span> <span class="nav-text">==1.TCP 三次握手==</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-TCP四次挥手"><span class="nav-number">2.2.2.</span> <span class="nav-text">==2.TCP四次挥手==</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-TCP-与-UDP-的区别"><span class="nav-number">2.2.3.</span> <span class="nav-text">==3.TCP 与 UDP 的区别==</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-什么时候选择-TCP-什么时候选-UDP"><span class="nav-number">2.2.4.</span> <span class="nav-text">4.什么时候选择 TCP,什么时候选 UDP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-使用-TCP-的协议有哪些-使用-UDP-的协议有哪些"><span class="nav-number">2.2.5.</span> <span class="nav-text">5.使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-TCP-协议如何保证可靠传输"><span class="nav-number">2.2.6.</span> <span class="nav-text">==6.TCP 协议如何保证可靠传输==</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-TCP-如何实现流量控制"><span class="nav-number">2.2.7.</span> <span class="nav-text">7.TCP 如何实现流量控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-TCP-的拥塞控制是怎么实现的"><span class="nav-number">2.2.8.</span> <span class="nav-text">8.TCP 的拥塞控制是怎么实现的</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP"><span class="nav-number">2.3.</span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-在浏览器中输入-url-地址-gt-gt-显示主页的过程"><span class="nav-number">2.3.1.</span> <span class="nav-text">==1.在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程==</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-HTTP-是不保存状态的协议-如何保存用户状态"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.HTTP 是不保存状态的协议, 如何保存用户状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-HTTP-和-HTTPS-有什么区别"><span class="nav-number">2.3.3.</span> <span class="nav-text">==3.HTTP 和 HTTPS 有什么区别==</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-HTTP1-0，1-1，2-0-的版本区别"><span class="nav-number">2.3.4.</span> <span class="nav-text">4.HTTP1.0，1.1，2.0 的版本区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-token和session的区别"><span class="nav-number">2.3.5.</span> <span class="nav-text">==5.token和session的区别==</span></a></li></ol></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/alex-next/images/avatar.jpg"
      alt="alex">
  <p class="site-author-name" itemprop="name">alex</p>
  <div class="site-description" itemprop="description">时光静好,与君语;细水流年,与君同;繁华落尽,与君老.</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/alex-next/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/alex-next/categories/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/alex-next/tags/">
          
        
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/alex-next/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">alex</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/alex-next/lib/anime.min.js?v=3.1.0"></script>
  <script src="/alex-next/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/alex-next/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script src="/alex-next/lib/pjax/pjax.min.js?v=0.2.8"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
<script src="/alex-next/js/utils.js?v=7.4.0"></script><script src="/alex-next/js/motion.js?v=7.4.0"></script>
<script src="/alex-next/js/schemes/pisces.js?v=7.4.0"></script>
<script src="/alex-next/js/next-boot.js?v=7.4.0"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var id = element.id || '';
    var src = element.src || '';
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (id !=='') {
      script.id = element.id;
    }
    if (src !== '') {
      script.src = src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  








  <script src="/alex-next/js/local-search.js?v=7.4.0"></script>













    <div id="pjax">

  

  
    
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    
  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: '84888b5ba3be0f56b2ed',
      clientSecret: '1306406ecbdc02b679df3c95b94985753d302d6a',
      repo: 'alex-next',
      owner: 'alexander-wd',
      admin: ['alexander-wd'],
      id: '48ec223da67724b77491d34784217f83',
        language: 'zh-CN',
      
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script>

    </div>
</body>
</html>
