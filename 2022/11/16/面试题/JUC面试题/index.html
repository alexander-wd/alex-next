<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/alex-next/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/alex-next/images/favicon.ico?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/alex-next/images/favicon.ico?v=7.4.0">
  <link rel="mask-icon" href="/alex-next/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/alex-next/atom.xml" title="alex的博客 - github.com" type="application/atom+xml">

<link rel="stylesheet" href="/alex-next/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/alex-next/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/alex-next/',
    scheme: 'Pisces',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: true,
    pangu: true,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="并发基础/理论1.并发编程的优缺点优点    充分利用多核CPU的计算能力    方便进行业务拆分，提升系统并发能力和性能缺点    内存泄漏    上下文切换    线程安全    死锁 2.并发编程三要素是什么原子性    线程切换带来的原子性问题可见性    线程缓存导致的可见性问题有序性    编译优化带来的有序性问题     3.并行和并发有什么区别并发    多个任务在同一个 CPU">
<meta name="keywords" content="JUC">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC面试题">
<meta property="og:url" content="https://alexander-wd.github.io/2022/11/16/面试题/JUC面试题/index.html">
<meta property="og:site_name" content="alex的博客 - github.com">
<meta property="og:description" content="并发基础/理论1.并发编程的优缺点优点    充分利用多核CPU的计算能力    方便进行业务拆分，提升系统并发能力和性能缺点    内存泄漏    上下文切换    线程安全    死锁 2.并发编程三要素是什么原子性    线程切换带来的原子性问题可见性    线程缓存导致的可见性问题有序性    编译优化带来的有序性问题     3.并行和并发有什么区别并发    多个任务在同一个 CPU">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2023-02-13T10:08:49.794Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JUC面试题">
<meta name="twitter:description" content="并发基础/理论1.并发编程的优缺点优点    充分利用多核CPU的计算能力    方便进行业务拆分，提升系统并发能力和性能缺点    内存泄漏    上下文切换    线程安全    死锁 2.并发编程三要素是什么原子性    线程切换带来的原子性问题可见性    线程缓存导致的可见性问题有序性    编译优化带来的有序性问题     3.并行和并发有什么区别并发    多个任务在同一个 CPU">
  <link rel="canonical" href="https://alexander-wd.github.io/2022/11/16/面试题/JUC面试题/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>JUC面试题 | alex的博客 - github.com</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/alex-next/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">alex的博客 - github.com</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/alex-next/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/alex-next/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/alex-next/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/alex-next/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/alexander-wd" class="github-corner" title="alex GitHub" aria-label="alex GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://alexander-wd.github.io/alex-next/2022/11/16/面试题/JUC面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="alex">
      <meta itemprop="description" content="时光静好,与君语;细水流年,与君同;繁华落尽,与君老.">
      <meta itemprop="image" content="/alex-next/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="alex的博客 - github.com">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">JUC面试题

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2022-11-16 16:10:20" itemprop="dateCreated datePublished" datetime="2022-11-16T16:10:20+08:00">2022-11-16</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-16 16:10:20" itemprop="dateModified" datetime="2023-02-13T18:08:49+08:00">2022-11-16</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/alex-next/categories/面试题/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="并发基础-理论"><a href="#并发基础-理论" class="headerlink" title="并发基础/理论"></a>并发基础/理论</h3><h4 id="1-并发编程的优缺点"><a href="#1-并发编程的优缺点" class="headerlink" title="1.并发编程的优缺点"></a>1.并发编程的优缺点</h4><p>优点<br>    充分利用多核CPU的计算能力<br>    方便进行业务拆分，提升系统并发能力和性能<br>缺点<br>    内存泄漏<br>    上下文切换<br>    线程安全<br>    死锁</p>
<h4 id="2-并发编程三要素是什么"><a href="#2-并发编程三要素是什么" class="headerlink" title="2.并发编程三要素是什么"></a>2.并发编程三要素是什么</h4><p>原子性<br>    线程切换带来的原子性问题<br>可见性<br>    线程缓存导致的可见性问题<br>有序性<br>    编译优化带来的有序性问题    </p>
<h4 id="3-并行和并发有什么区别"><a href="#3-并行和并发有什么区别" class="headerlink" title="3.并行和并发有什么区别"></a>3.并行和并发有什么区别</h4><p>并发<br>    多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行<br>并行<br>    单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”</p>
<h4 id="4-进程与线程的区别"><a href="#4-进程与线程的区别" class="headerlink" title="4.进程与线程的区别"></a>4.进程与线程的区别</h4><p>进程<br>    操作系统资源分配的基本单位<br>    有独立的代码和数据空间（程序上下文）<br>        程序之间的切换会有较大的开销<br>    每个独立的进程有程序运行的入口、顺序执行序列和程序出口<br>线程<br>    处理器任务调度和执行的基本单位<br>    同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC）<br>        线程之间切换的开销小<br>    但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行<br>同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的<br>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉</p>
<h5 id="4-1什么是上下文切换"><a href="#4-1什么是上下文切换" class="headerlink" title="4.1什么是上下文切换"></a>4.1什么是上下文切换</h5><p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换</p>
<h4 id="5-守护线程和用户线程有什么区别"><a href="#5-守护线程和用户线程有什么区别" class="headerlink" title="5.守护线程和用户线程有什么区别"></a>5.守护线程和用户线程有什么区别</h4><p>用户线程<br>    运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程<br>守护线程<br>    运行在后台，为其他前台线程服务。也可以说守护线程是 JVM 中非守护线程的 “佣人”。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作</p>
<h4 id="6-创建线程有哪几种方式"><a href="#6-创建线程有哪几种方式" class="headerlink" title="==6.创建线程有哪几种方式=="></a>==6.创建线程有哪几种方式==</h4><p>继承 Thread 类；<br>实现 Runnable 接口；<br>实现 Callable 接口；<br>使用 Executors 工具类创建线程池</p>
<h4 id="7-runnable-和-callable-有什么异同"><a href="#7-runnable-和-callable-有什么异同" class="headerlink" title="7.runnable 和 callable 有什么异同"></a>7.runnable 和 callable 有什么异同</h4><p>相同点<br>    都是接口<br>    都可以编写多线程程序<br>    都采用Thread.start()启动线程<br>不同点<br>    Runnable<br>        Runnable 接口 run 方法无返回值<br>        Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理<br>    Callable<br>        Callable 接口 call 方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果<br>        Callable 接口 call 方法允许抛出异常，可以获取异常信息</p>
<h4 id="8-线程的-run-和-start-有什么区别"><a href="#8-线程的-run-和-start-有什么区别" class="headerlink" title="8.线程的 run()和 start()有什么区别"></a>8.线程的 run()和 start()有什么区别</h4><p>start<br>    start() 方法用于启动线程<br>    而 start() 只能调用一次<br>    start()方法来启动一个线程，真正实现了多线程运行。调用start()方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， run()方法运行结束， 此线程终止。然后CPU再调度其它线程。<br>run<br>    run() 方法用于执行线程的运行时代码<br>    run() 可以重复调用<br>    run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p>
<h4 id="9-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法"><a href="#9-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法" class="headerlink" title="==9.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法=="></a>==9.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法==</h4><p>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。<br>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。<br>==总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。==</p>
<h4 id="10-sleep-和-wait-有什么区别"><a href="#10-sleep-和-wait-有什么区别" class="headerlink" title="10.sleep() 和 wait() 有什么区别"></a>10.sleep() 和 wait() 有什么区别</h4><p>两者都可以暂停线程的执行<br>区别<br>    类的不同：sleep() 是 Thread线程类的静态方法，wait() 是 Object类的方法。<br>    是否释放锁：sleep() 不释放锁；wait() 释放锁。<br>    用途不同：Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。<br>    用法不同：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。</p>
<h4 id="11-Thread-类中的-yield-方法有什么作用"><a href="#11-Thread-类中的-yield-方法有什么作用" class="headerlink" title="11.Thread 类中的 yield 方法有什么作用"></a>11.Thread 类中的 yield 方法有什么作用</h4><p>使当前线程从执行状态（运行状态）变为可执行态（就绪状态）<br>当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。 </p>
<h4 id="12-线程的-sleep-方法和-yield-方法有什么区别"><a href="#12-线程的-sleep-方法和-yield-方法有什么区别" class="headerlink" title="12.线程的 sleep()方法和 yield()方法有什么区别"></a>12.线程的 sleep()方法和 yield()方法有什么区别</h4><p>（1） sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；<br>（2） 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；<br>（3）sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；<br>（4）sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。</p>
<h4 id="13-如何停止一个正在运行的线程"><a href="#13-如何停止一个正在运行的线程" class="headerlink" title="13.如何停止一个正在运行的线程"></a>13.如何停止一个正在运行的线程</h4><p>1.使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。<br>2.使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。<br>3.使用interrupt方法中断线程。</p>
<h4 id="14-Java-中-interrupted-和-isInterrupted-方法的区别"><a href="#14-Java-中-interrupted-和-isInterrupted-方法的区别" class="headerlink" title="14.Java 中 interrupted 和 isInterrupted 方法的区别"></a>14.Java 中 interrupted 和 isInterrupted 方法的区别</h4><p>interrupt：用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。<br>    会在Thread.cpp底层执行LockSupport.unpark(t)，唤醒当前线程<br>interrupted：是静态方法，查看当前中断信号是true还是false并且清除中断信号。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了。<br>isInterrupted：查看当前中断信号是true还是false</p>
<h4 id="15-Java-如何实现多线程之间的通讯和协作"><a href="#15-Java-如何实现多线程之间的通讯和协作" class="headerlink" title="15.Java 如何实现多线程之间的通讯和协作"></a>15.Java 如何实现多线程之间的通讯和协作</h4><p>1.syncrhoized加锁的线程的Object类的wait()/notify()/notifyAll()<br>2.ReentrantLock类加锁的线程的Condition类的await()/signal()/signalAll()</p>
<h4 id="16-park-unpark和-wait-notify区别"><a href="#16-park-unpark和-wait-notify区别" class="headerlink" title="16.park/unpark和 wait/notify区别"></a>16.park/unpark和 wait/notify区别</h4><p>wait和notify方法必须和同步锁 synchronized一块使用。而park/unpark使用就比较灵活了，没有这个限制，可以在任何地方使用。<br>park/unpark 使用时没有先后顺序，都可以使线程不阻塞（前面代码已验证）。而wait必须在notify前先使用，如果先notify，再wait，则线程会一直等待。<br>notify只能随机释放一个线程，并不能指定某个特定线程，notifyAll是释放锁对象中的所有线程。而unpark方法可以唤醒指定的线程。<br>调用wait方法会使当前线程释放锁资源，但使用的前提是必须已经获得了锁。而park不会释放锁资源。</p>
<p><a href="https://blog.csdn.net/yemuxiaweiliang/article/details/120987740" target="_blank" rel="noopener">参考</a></p>
<h3 id="并发关键字"><a href="#并发关键字" class="headerlink" title="并发关键字"></a>并发关键字</h3><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><h5 id="1-synchronized-的作用"><a href="#1-synchronized-的作用" class="headerlink" title="1.synchronized 的作用"></a>1.synchronized 的作用</h5><p>在多线程的环境下，控制 synchronized     代码段不被多个线程同时执行<br>早期<br>    在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁是依赖于底层的操作系统的 Mutex Lock 来实现的，需要挂起或环形线程，线程间的切换涉及到从用户态转换为内核态，成本高，这是早期synchronized效率低下的原因<br>优化<br>    自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁</p>
<h5 id="2-说一下-synchronized-底层实现原理"><a href="#2-说一下-synchronized-底层实现原理" class="headerlink" title="==2.说一下 synchronized 底层实现原理=="></a>==2.说一下 synchronized 底层实现原理==</h5><p>首先要获取锁，而获取锁的过程就是monitorenter ，在执行完代码块之后，要释放锁，释放锁就是执行monitorexit指令。<br>Monitor在C++层面维护了ObjectMonitor的变量，有count计数器表示是否有线程竞争锁<br>==追问==<br>    ==为什么会有两个monitorexit呢==<br>        这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。<br>        因此最后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁<br>    ==synchronized可重入的原理==<br>        底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</p>
<h5 id="3-多线程中-synchronized-锁升级的原理是什么"><a href="#3-多线程中-synchronized-锁升级的原理是什么" class="headerlink" title="3.多线程中 synchronized 锁升级的原理是什么"></a>3.多线程中 synchronized 锁升级的原理是什么</h5><p>1.在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id<br>2.再次进入的时候会先判断 threadid 是否与其线程 id 一致<br>    如果一致则可以直接使用此对象<br>    如果不一致，则升级偏向锁为轻量级锁<br>3.通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁</p>
<p>不同线程竞争</p>
<p><img alt="JVM锁的膨胀升级" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JUC/20230119213935.jpg"></p>
<p>锁升级流程图</p>
<p><img alt="synchronized锁实现与升级过程" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JUC/20230119213956.png"></p>
<h5 id="4-synchronized怎么保证可见性、有序性、原子性"><a href="#4-synchronized怎么保证可见性、有序性、原子性" class="headerlink" title="==4.synchronized怎么保证可见性、有序性、原子性=="></a>==4.synchronized怎么保证可见性、有序性、原子性==</h5><p>原子性<br>可见性<br>    通过monitorenter/monitorexit的jvm字节码指令，在底层调用lock前缀指令开启内存屏障<br>有序性<br>    依然会发生重排序，只不过我们有同步代码块，可以保证只有一个线程执行同步代码中的代码。保证有序性</p>
<p><a href="https://blog.csdn.net/chenzengnian123/article/details/122686371" target="_blank" rel="noopener">参考</a></p>
<h5 id="5-synchronized-和-Lock-有什么区别"><a href="#5-synchronized-和-Lock-有什么区别" class="headerlink" title="5.synchronized 和 Lock 有什么区别"></a>5.synchronized 和 Lock 有什么区别</h5><p>首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类；<br>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。<br>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。<br>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p>
<h5 id="6-synchronized-和-ReentrantLock-的区别"><a href="#6-synchronized-和-ReentrantLock-的区别" class="headerlink" title="==6.synchronized 和 ReentrantLock 的区别=="></a>==6.synchronized 和 ReentrantLock 的区别==</h5><p><strong>都是可重入锁</strong><br><strong>区别</strong><br>    ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；<br>    ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；<br>    ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。<br>    二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的park 方法加锁，synchronized 操作的应该是对象头中 mark word<br>==ReentrantLock的新功能==<br>    等待可中断<br>        ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。<br>    可实现公平锁<br>        ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。<br>    可实现选择性通知（锁可以绑定多个条件）<br>        synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。</p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><h5 id="1-volatile-关键字的作用"><a href="#1-volatile-关键字的作用" class="headerlink" title="1.volatile 关键字的作用"></a>1.volatile 关键字的作用</h5><p>保证可见性和有序性(禁止指令重排)<br>和Atomic(CAS)结合保证原子性</p>
<h5 id="2-Java-中能创建-volatile-数组吗"><a href="#2-Java-中能创建-volatile-数组吗" class="headerlink" title="2.Java 中能创建 volatile 数组吗"></a>2.Java 中能创建 volatile 数组吗</h5><p>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了</p>
<h5 id="3-synchronized-和-volatile-的区别是什么"><a href="#3-synchronized-和-volatile-的区别是什么" class="headerlink" title="3.synchronized 和 volatile 的区别是什么"></a>3.synchronized 和 volatile 的区别是什么</h5><p>volatile 是变量修饰符；synchronized 可以修饰类、方法、变量。<br>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。==对于可见性来说，在JAVA底层都是调用了内存屏障，在硬件底层都是调用了Lock前缀指令从而触发了MESI协议保证了可见性。==</p>
<p><a href="https://blog.csdn.net/weixin_35688354/article/details/113452096" target="_blank" rel="noopener">参考</a></p>
<p>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。<br>volatile 标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化(指令重排)。</p>
<h5 id="4-volatile实现内存可见性、有序性原理"><a href="#4-volatile实现内存可见性、有序性原理" class="headerlink" title="==4.volatile实现内存可见性、有序性原理=="></a>==4.volatile实现内存可见性、有序性原理==</h5><p><a href="https://blog.csdn.net/it_lihongmin/article/details/109169260" target="_blank" rel="noopener">可见性</a><br>    硬件层面<br>        底层汇编会生成lock前缀指令，从而触发MESI缓存一致性协议，通过总线嗅探机制监听每个线程(工作内存)的变量是否改变<br>    JAVA层面<br>        内存屏障<br>有序性<br>    内存屏障(禁止指令重排)</p>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a><a href="https://cloud.tencent.com/developer/article/1379380" target="_blank" rel="noopener">final</a></h4><h3 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h3><h4 id="1-什么是-CAS"><a href="#1-什么是-CAS" class="headerlink" title="1.什么是 CAS"></a>1.什么是 CAS</h4><p>CAS 操作包含三个操作数 —— 内存位置(V)、预期原值(A)和新值(B)。<br>    如果内存地址里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。<br>    CAS是通过无限循环来获取数据的，如果在第一轮循环中，a 线程获取地址里面的值被b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执行。</p>
<h4 id="2-CAS-的会产生什么问题"><a href="#2-CAS-的会产生什么问题" class="headerlink" title="2.CAS 的会产生什么问题"></a>2.CAS 的会产生什么问题</h4><p>==ABA问题==<br>    描述<br>        比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。<br>    解决<br>        AtomicStampedReference每次更新加版本<br>==循环时间长开销大==<br>    描述<br>        对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized<br>    解决<br>        <a href="https://blog.csdn.net/qq_29373285/article/details/88566435" target="_blank" rel="noopener">LongAdder</a>：分段CAS操作<br>            默认一开始使用CAS单个cell作为base，当线程多了之后，开启多个cell单元，用于分担base的压力，之后需要值的时候返回base+所有cell的值<br>        示意图</p>
<p><img alt="img" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JUC/20230120163139"></p>
<h3 id="Lock基础-AQS"><a href="#Lock基础-AQS" class="headerlink" title="Lock基础(AQS)"></a>Lock基础(AQS)</h3><h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><h5 id="1-说下对同步器-AQS-的理解"><a href="#1-说下对同步器-AQS-的理解" class="headerlink" title="1.说下对同步器 AQS 的理解"></a>1.说下对同步器 AQS 的理解</h5><p>​    AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。<br>​    AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，BlockingQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。</p>
<h5 id="2-AQS-的原理是什么"><a href="#2-AQS-的原理是什么" class="headerlink" title="2.AQS 的原理是什么"></a>2.AQS 的原理是什么</h5><p>​    核心思想<br>​        如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。<br>​        如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中<br>​    AQS 使用一个 int 成员变量 (state) 来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS (unsafe类)对该同步状态进行原子操作实现对其值的修改<br>​    CLH中每个结点还有一个waitSatus用于表示下一个结点中的线程的声明状态</p>
<h5 id="3-AQS-对资源的共享模式有哪些"><a href="#3-AQS-对资源的共享模式有哪些" class="headerlink" title="3.AQS 对资源的共享模式有哪些"></a>3.AQS 对资源的共享模式有哪些</h5><p>​    Exclusive（独占）<br>​        ReentrantLock，又可分为公平锁和非公平锁<br>​    Share（共享）<br>​        多个线程可同时执行，如：CountDownLatch、Semaphore、 CyclicBarrier、ReadWriteLock</p>
<h5 id="4-AQS-底层使用了模板方法模式，你能说出几个需要重写的方法吗"><a href="#4-AQS-底层使用了模板方法模式，你能说出几个需要重写的方法吗" class="headerlink" title="4.AQS 底层使用了模板方法模式，你能说出几个需要重写的方法吗"></a>4.AQS 底层使用了模板方法模式，你能说出几个需要重写的方法吗</h5><p>​    tryAcquire(int)<br>​        独占方式。尝试获取资源，成功则返回 true，失败则返回 false。<br>​    tryRelease(int)<br>​        独占方式。尝试释放资源，成功则返回 true，失败则返回 false。<br>​    tryAcquireShared(int)<br>​        共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br>​    tryReleaseShared(int)<br>​        共享方式。尝试释放资源，成功则返回 true，失败则返回 false。                     </p>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><h5 id="1-CountDownLatch-怎么用？应用场景是什么？"><a href="#1-CountDownLatch-怎么用？应用场景是什么？" class="headerlink" title="1.CountDownLatch 怎么用？应用场景是什么？"></a>1.CountDownLatch 怎么用？应用场景是什么？</h5><p>​    核心API<br>​        countDown<br>​            计数器减一<br>​        await<br>​            等到计数器为0再唤醒当前线程<br>​    应用场景<br>​        当所有的数据处理完成后，再去执行后面的操作<br>​        多个线程需要等待其他线程的工作之后，再进行其后续工作。</p>
<h5 id="2-CountDownLatch-和-CyclicBarrier-的不同之处？"><a href="#2-CountDownLatch-和-CyclicBarrier-的不同之处？" class="headerlink" title="2.CountDownLatch 和 CyclicBarrier 的不同之处？"></a>2.CountDownLatch 和 CyclicBarrier 的不同之处？</h5><p>​    CountDownLatch 是计数器，只能使用一次，而 CyclicBarrier 的计数器提供 reset 功能，可以多次使用<br>​    含义不同<br>​        CountDownLatch: 一个或者多个线程(主线程)，等待其他多个线程完成某件事情之后才能执行<br>​        CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。<br>​    <a href="https://blog.csdn.net/liangyihuai/article/details/83106584" target="_blank" rel="noopener">参考</a></p>
<h5 id="3-CountDownLatch-类中主要的方法？"><a href="#3-CountDownLatch-类中主要的方法？" class="headerlink" title="3.CountDownLatch 类中主要的方法？"></a>3.CountDownLatch 类中主要的方法？</h5><p>​    countDown<br>​        计数器减一，如果计数达到零，释放所有等待的线程。<br>​    await<br>​        等到计数器为0再唤醒当前线程<br>​    getCount<br>​        返回当前计数</p>
<h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><h5 id="1-谈谈对-BlockingQueue-的理解？分别有哪些实现类"><a href="#1-谈谈对-BlockingQueue-的理解？分别有哪些实现类" class="headerlink" title="1.谈谈对 BlockingQueue 的理解？分别有哪些实现类"></a>1.谈谈对 BlockingQueue 的理解？分别有哪些实现类</h5><p>​    阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。<br>​    实现类<br>​        ArrayBlockingQueue 由数组支持的有界队列<br>​        LinkedBlockingQueue 由链接节点支持的可选有界队列<br>​        PriorityBlockingQueue 由优先级堆支持的无界优先级队列<br>​        DelayQueue 由优先级堆支持的、基于时间的调度队列</p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><h5 id="1-什么是ConcurrentHashMap"><a href="#1-什么是ConcurrentHashMap" class="headerlink" title="1.什么是ConcurrentHashMap"></a>1.什么是ConcurrentHashMap</h5><p>​    ConcurrentHashMap是Java中的一个线程安全且高效的HashMap实现<br>​    JDK1.8后，ConcurrentHashMap抛弃了原有的Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。</p>
<h5 id="2-Java-中-ConcurrentHashMap-的并发度是什么"><a href="#2-Java-中-ConcurrentHashMap-的并发度是什么" class="headerlink" title="2.Java 中 ConcurrentHashMap 的并发度是什么"></a>2.Java 中 ConcurrentHashMap 的并发度是什么</h5><p>​    ConcurrentHashMap 把实际 map 划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是 ConcurrentHashMap 类构造函数的一个可选参数，默认值为 16，这样在多线程情况下就能避免争用</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><h5 id="1-谈谈对-CopyOnWriteArrayList-的理解"><a href="#1-谈谈对-CopyOnWriteArrayList-的理解" class="headerlink" title="1.谈谈对 CopyOnWriteArrayList 的理解"></a>1.谈谈对 CopyOnWriteArrayList 的理解</h5><p>​    特性<br>​        适用场景为读多写少<br>​        不能读取实时性的数据，但能保证最终数据一致性<br>​        空间换时间<br>​    原理<br>​        内部维护了一个Object[]数组，通过getArray/setArray来获取/赋值<br>​        修改<br>​            如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。</p>
<h5 id="2-CopyOnWriteArrayList-是什么，可以用于什么应用场景"><a href="#2-CopyOnWriteArrayList-是什么，可以用于什么应用场景" class="headerlink" title="2.CopyOnWriteArrayList 是什么，可以用于什么应用场景"></a>2.CopyOnWriteArrayList 是什么，可以用于什么应用场景</h5><p>​    读多写少</p>
<h5 id="3-CopyOnWriteArrayList有哪些优缺点"><a href="#3-CopyOnWriteArrayList有哪些优缺点" class="headerlink" title="3.CopyOnWriteArrayList有哪些优缺点"></a>3.CopyOnWriteArrayList有哪些优缺点</h5><p>​    缺点<br>​        1. 由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。<br>​        2. 不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的，虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。<br>​        3. 由于实际使用中可能没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次 add/set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。<br>​    优点<br>​        读写分离，读和写分开<br>​        适合读多写少</p>
<h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><h5 id="1-谈谈对ConcurrentLinkedQueue理解"><a href="#1-谈谈对ConcurrentLinkedQueue理解" class="headerlink" title="1.谈谈对ConcurrentLinkedQueue理解"></a>1.谈谈对ConcurrentLinkedQueue理解</h5><p>​    高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列</p>
<h4 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h4><h5 id="1-谈谈对-ConcurrentSkipListMap-的理解"><a href="#1-谈谈对-ConcurrentSkipListMap-的理解" class="headerlink" title="1.谈谈对 ConcurrentSkipListMap 的理解"></a>1.谈谈对 ConcurrentSkipListMap 的理解</h5><p><a href="https://blog.csdn.net/hbtj_1216/article/details/114228578" target="_blank" rel="noopener">参考</a></p>
<p>​    特点<br>​        高并发场景<br>​        key是有序的<br>​        添加、删除、查找操作都是基于跳表结构（Skip List）实现的<br>​        key和value都不能为null<br>​    跳表<br>​        跳表由很多层组成；<br>​        每一层都是一个有序的链表；<br>​        最底层的链表包含所有元素；<br>​        对于每一层的任意一个节点，不仅有指向其下一个节点的指针，也有指向其下一层的指针；<br>​        如果一个元素出现在Level n层的链表中，则它在Level n层以下的链表也都会出现。</p>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h5 id="1-ThreadLocal-是什么？有哪些使用场景"><a href="#1-ThreadLocal-是什么？有哪些使用场景" class="headerlink" title="1.ThreadLocal 是什么？有哪些使用场景"></a>1.ThreadLocal 是什么？有哪些使用场景</h5><p>​    ThreadLocal 是一个本地线程副本变量工具类，在每个线程中都创建了一个 ThreadLocalMap 对象<br>​    使用场景<br>​        为每个线程分配一个 JDBC 连接 Connection。这样就可以保证每个线程的都在各自的 Connection 上进行数据库的操作，不会出现 A 线程关了 B线程正在使用的 Connection</p>
<h5 id="2-什么是线程局部变量"><a href="#2-什么是线程局部变量" class="headerlink" title="2.什么是线程局部变量"></a>2.什么是线程局部变量</h5><p>​    线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。</p>
<h5 id="3-ThreadLocal造成内存泄漏的原因"><a href="#3-ThreadLocal造成内存泄漏的原因" class="headerlink" title="3.ThreadLocal造成内存泄漏的原因"></a>3.ThreadLocal造成内存泄漏的原因</h5><p>​    ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。<br>​    所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。<br>​    这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露</p>
<h5 id="4-ThreadLocal内存泄漏解决方案"><a href="#4-ThreadLocal内存泄漏解决方案" class="headerlink" title="4.ThreadLocal内存泄漏解决方案"></a>4.ThreadLocal内存泄漏解决方案</h5><p>​    每次使用完ThreadLocal，都调用它的remove()方法，清除数据</p>
<h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h5><p>​    ThreadLocal的 key 是弱引用，那么在 ThreadLocal.get()的时候，发生GC之后，key 是否为null？<br>​    ThreadLocal中ThreadLocalMap的数据结构？<br>​    ThreadLocalMap的Hash 算法？<br>​    ThreadLocalMap中Hash 冲突如何解决？<br>​    ThreadLocalMap的扩容机制？<br>​    ThreadLocalMap中过期 key 的清理机制？探测式清理和启发式清理流程？<br>​    ThreadLocalMap.set()方法实现原理？<br>​    ThreadLocalMap.get()方法实现原理？<br>​    项目中ThreadLocal使用情况？遇到的坑？</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="1-什么是线程池？有哪几种创建方式"><a href="#1-什么是线程池？有哪几种创建方式" class="headerlink" title="1.什么是线程池？有哪几种创建方式"></a>1.什么是线程池？有哪几种创建方式</h4><p>​    线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。<br>​    Executors<br>​        newSingleThreadExecutor：创建一个单线程的线程池。<br>​        newFixedThreadPool：创建固定大小的线程池。<br>​        newCachedThreadPool：创建一个可缓存的线程池。<br>​        newScheduledThreadPool：创建一个大小无限的线程池。<br>​    new ThreadPoolExecutor</p>
<h4 id="2-线程池有什么优点"><a href="#2-线程池有什么优点" class="headerlink" title="2.线程池有什么优点"></a>2.线程池有什么优点</h4><p>​    降低资源消耗<br>​        重用存在的线程，减少对象创建销毁的开销<br>​    提高响应速度<br>​        可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要等到线程创建就能立即执行<br>​    提高线程的可管理性<br>​        线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控<br>​    附加功能<br>​        提供定时执行、定期执行、单线程、并发数控制等功能</p>
<h4 id="3-线程池都有哪些状态"><a href="#3-线程池都有哪些状态" class="headerlink" title="3.线程池都有哪些状态"></a>3.线程池都有哪些状态</h4><p><img alt="1" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JUC/20230120182934.png"></p>
<p>​    RUNNING<br>​        这是最正常的状态，接受新的任务，处理等待队列中的任务<br>​    SHUTDOWN<br>​        不接受新的任务提交，但是会继续处理等待队列中的任务<br>​    STOP<br>​        不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程<br>​    TIDYING<br>​        所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()<br>​    TERMINATED<br>​        terminated()方法结束后，线程池的状态就会变成这个</p>
<h4 id="4-在-Java-中-Executor-和-Executors-的区别"><a href="#4-在-Java-中-Executor-和-Executors-的区别" class="headerlink" title="4.在 Java 中 Executor 和 Executors 的区别"></a>4.在 Java 中 Executor 和 Executors 的区别</h4><p>​    Executor是线程池的顶层接口<br>​    Executors定义了一堆用户可以直接使用的线程池，但不推荐</p>
<h4 id="5-线程池中-submit-和-execute-方法有什么区别"><a href="#5-线程池中-submit-和-execute-方法有什么区别" class="headerlink" title="==5.线程池中 submit() 和 execute() 方法有什么区别=="></a>==5.线程池中 submit() 和 execute() 方法有什么区别==</h4><p>​    接收参数<br>​        execute()只能执行 Runnable 类型的任务。submit()可以执行 Runnable 和 Callable 类型的任务<br>​    返回值<br>​        submit()方法可以返回持有计算结果的 Future 对象，而execute()没有<br>​    异常处理<br>​        submit()方便Exception处理</p>
<h4 id="6-Executors和ThreaPoolExecutor创建线程池的区别-为什么不推荐Executors"><a href="#6-Executors和ThreaPoolExecutor创建线程池的区别-为什么不推荐Executors" class="headerlink" title="6.Executors和ThreaPoolExecutor创建线程池的区别(为什么不推荐Executors)"></a>6.Executors和ThreaPoolExecutor创建线程池的区别(为什么不推荐Executors)</h4><p>​    Executors 各个方法的弊端<br>​        newFixedThreadPool 和 newSingleThreadExecutor:<br>​            ==主要问题是允许请求的队列长度为 Integer.MAX_VALUE，堆积的请求处理队列可能会耗费非常大的内存==，甚至 OOM<br>​        newCachedThreadPool 和 newScheduledThreadPool:<br>​            主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM<br>​    ThreaPoolExecutor创建线程池方式只有一种，就是走它的构造函数，参数自己指定</p>
<h4 id="7-ThreadPoolExecutor构造函数重要参数分析"><a href="#7-ThreadPoolExecutor构造函数重要参数分析" class="headerlink" title="==7.ThreadPoolExecutor构造函数重要参数分析=="></a>==7.ThreadPoolExecutor构造函数重要参数分析==</h4><p>​    corePoolSize<br>​        核心线程数，线程数定义了最小可以同时运行的线程数量。<br>​    maximumPoolSize<br>​        线程池中允许存在的工作线程的最大数量<br>​    workQueue<br>​        当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在队列中<br>​    keepAliveTime<br>​        线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；<br>​    unit<br>​        keepAliveTime 参数的时间单位。<br>​    threadFactory<br>​        为线程池提供创建新线程的线程工厂<br>​    handler<br>​        线程池任务队列超过 maxinumPoolSize 之后的拒绝策略</p>
<h4 id="建议不同类别的业务用不同的线程池"><a href="#建议不同类别的业务用不同的线程池" class="headerlink" title="建议不同类别的业务用不同的线程池"></a>建议不同类别的业务用不同的线程池</h4><p>​    一般建议是不同的业务使用不同的线程池，配置线程池的时候根据当前业务的情况对当前线程池进行配置，因为不同的业务的并发以及对资源的使用情况都不同，重心优化系统性能瓶颈相关的业务。<br>​    否则，父子线程可能会互相死锁</p>
<h4 id="线程池架构-原理-流程"><a href="#线程池架构-原理-流程" class="headerlink" title="线程池架构(原理/流程)"></a>线程池架构(原理/流程)</h4><p><img alt="4" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JUC/20230120183334.png"></p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/alex-next/tags/JUC/" rel="tag"># JUC</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/alex-next/2022/10/30/面试题/JVM面试题/" rel="next" title="JVM面试题">
                  <i class="fa fa-chevron-left"></i> JVM面试题
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/alex-next/2022/11/18/工具配置/docker部署halo博客/" rel="prev" title="halo博客">
                  halo博客 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="gitalk-container"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#并发基础-理论"><span class="nav-number">1.</span> <span class="nav-text">并发基础/理论</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-并发编程的优缺点"><span class="nav-number">1.1.</span> <span class="nav-text">1.并发编程的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-并发编程三要素是什么"><span class="nav-number">1.2.</span> <span class="nav-text">2.并发编程三要素是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-并行和并发有什么区别"><span class="nav-number">1.3.</span> <span class="nav-text">3.并行和并发有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-进程与线程的区别"><span class="nav-number">1.4.</span> <span class="nav-text">4.进程与线程的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1什么是上下文切换"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1什么是上下文切换</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-守护线程和用户线程有什么区别"><span class="nav-number">1.5.</span> <span class="nav-text">5.守护线程和用户线程有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-创建线程有哪几种方式"><span class="nav-number">1.6.</span> <span class="nav-text">==6.创建线程有哪几种方式==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-runnable-和-callable-有什么异同"><span class="nav-number">1.7.</span> <span class="nav-text">7.runnable 和 callable 有什么异同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-线程的-run-和-start-有什么区别"><span class="nav-number">1.8.</span> <span class="nav-text">8.线程的 run()和 start()有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法"><span class="nav-number">1.9.</span> <span class="nav-text">==9.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-sleep-和-wait-有什么区别"><span class="nav-number">1.10.</span> <span class="nav-text">10.sleep() 和 wait() 有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-Thread-类中的-yield-方法有什么作用"><span class="nav-number">1.11.</span> <span class="nav-text">11.Thread 类中的 yield 方法有什么作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-线程的-sleep-方法和-yield-方法有什么区别"><span class="nav-number">1.12.</span> <span class="nav-text">12.线程的 sleep()方法和 yield()方法有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-如何停止一个正在运行的线程"><span class="nav-number">1.13.</span> <span class="nav-text">13.如何停止一个正在运行的线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-Java-中-interrupted-和-isInterrupted-方法的区别"><span class="nav-number">1.14.</span> <span class="nav-text">14.Java 中 interrupted 和 isInterrupted 方法的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-Java-如何实现多线程之间的通讯和协作"><span class="nav-number">1.15.</span> <span class="nav-text">15.Java 如何实现多线程之间的通讯和协作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-park-unpark和-wait-notify区别"><span class="nav-number">1.16.</span> <span class="nav-text">16.park/unpark和 wait/notify区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发关键字"><span class="nav-number">2.</span> <span class="nav-text">并发关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized"><span class="nav-number">2.1.</span> <span class="nav-text">synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-synchronized-的作用"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.synchronized 的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-说一下-synchronized-底层实现原理"><span class="nav-number">2.1.2.</span> <span class="nav-text">==2.说一下 synchronized 底层实现原理==</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-多线程中-synchronized-锁升级的原理是什么"><span class="nav-number">2.1.3.</span> <span class="nav-text">3.多线程中 synchronized 锁升级的原理是什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-synchronized怎么保证可见性、有序性、原子性"><span class="nav-number">2.1.4.</span> <span class="nav-text">==4.synchronized怎么保证可见性、有序性、原子性==</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-synchronized-和-Lock-有什么区别"><span class="nav-number">2.1.5.</span> <span class="nav-text">5.synchronized 和 Lock 有什么区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-synchronized-和-ReentrantLock-的区别"><span class="nav-number">2.1.6.</span> <span class="nav-text">==6.synchronized 和 ReentrantLock 的区别==</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile"><span class="nav-number">2.2.</span> <span class="nav-text">volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-volatile-关键字的作用"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.volatile 关键字的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Java-中能创建-volatile-数组吗"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.Java 中能创建 volatile 数组吗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-synchronized-和-volatile-的区别是什么"><span class="nav-number">2.2.3.</span> <span class="nav-text">3.synchronized 和 volatile 的区别是什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-volatile实现内存可见性、有序性原理"><span class="nav-number">2.2.4.</span> <span class="nav-text">==4.volatile实现内存可见性、有序性原理==</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#final"><span class="nav-number">2.3.</span> <span class="nav-text">final</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子操作类"><span class="nav-number">3.</span> <span class="nav-text">原子操作类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-什么是-CAS"><span class="nav-number">3.1.</span> <span class="nav-text">1.什么是 CAS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-CAS-的会产生什么问题"><span class="nav-number">3.2.</span> <span class="nav-text">2.CAS 的会产生什么问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock基础-AQS"><span class="nav-number">4.</span> <span class="nav-text">Lock基础(AQS)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS"><span class="nav-number">4.1.</span> <span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-说下对同步器-AQS-的理解"><span class="nav-number">4.1.1.</span> <span class="nav-text">1.说下对同步器 AQS 的理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-AQS-的原理是什么"><span class="nav-number">4.1.2.</span> <span class="nav-text">2.AQS 的原理是什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-AQS-对资源的共享模式有哪些"><span class="nav-number">4.1.3.</span> <span class="nav-text">3.AQS 对资源的共享模式有哪些</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-AQS-底层使用了模板方法模式，你能说出几个需要重写的方法吗"><span class="nav-number">4.1.4.</span> <span class="nav-text">4.AQS 底层使用了模板方法模式，你能说出几个需要重写的方法吗</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">4.2.</span> <span class="nav-text">CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-CountDownLatch-怎么用？应用场景是什么？"><span class="nav-number">4.2.1.</span> <span class="nav-text">1.CountDownLatch 怎么用？应用场景是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-CountDownLatch-和-CyclicBarrier-的不同之处？"><span class="nav-number">4.2.2.</span> <span class="nav-text">2.CountDownLatch 和 CyclicBarrier 的不同之处？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-CountDownLatch-类中主要的方法？"><span class="nav-number">4.2.3.</span> <span class="nav-text">3.CountDownLatch 类中主要的方法？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发容器"><span class="nav-number">5.</span> <span class="nav-text">并发容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BlockingQueue"><span class="nav-number">5.1.</span> <span class="nav-text">BlockingQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-谈谈对-BlockingQueue-的理解？分别有哪些实现类"><span class="nav-number">5.1.1.</span> <span class="nav-text">1.谈谈对 BlockingQueue 的理解？分别有哪些实现类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">5.2.</span> <span class="nav-text">ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-什么是ConcurrentHashMap"><span class="nav-number">5.2.1.</span> <span class="nav-text">1.什么是ConcurrentHashMap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Java-中-ConcurrentHashMap-的并发度是什么"><span class="nav-number">5.2.2.</span> <span class="nav-text">2.Java 中 ConcurrentHashMap 的并发度是什么</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CopyOnWriteArrayList"><span class="nav-number">5.3.</span> <span class="nav-text">CopyOnWriteArrayList</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-谈谈对-CopyOnWriteArrayList-的理解"><span class="nav-number">5.3.1.</span> <span class="nav-text">1.谈谈对 CopyOnWriteArrayList 的理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-CopyOnWriteArrayList-是什么，可以用于什么应用场景"><span class="nav-number">5.3.2.</span> <span class="nav-text">2.CopyOnWriteArrayList 是什么，可以用于什么应用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-CopyOnWriteArrayList有哪些优缺点"><span class="nav-number">5.3.3.</span> <span class="nav-text">3.CopyOnWriteArrayList有哪些优缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentLinkedQueue"><span class="nav-number">5.4.</span> <span class="nav-text">ConcurrentLinkedQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-谈谈对ConcurrentLinkedQueue理解"><span class="nav-number">5.4.1.</span> <span class="nav-text">1.谈谈对ConcurrentLinkedQueue理解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentSkipListMap"><span class="nav-number">5.5.</span> <span class="nav-text">ConcurrentSkipListMap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-谈谈对-ConcurrentSkipListMap-的理解"><span class="nav-number">5.5.1.</span> <span class="nav-text">1.谈谈对 ConcurrentSkipListMap 的理解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">5.6.</span> <span class="nav-text">ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-ThreadLocal-是什么？有哪些使用场景"><span class="nav-number">5.6.1.</span> <span class="nav-text">1.ThreadLocal 是什么？有哪些使用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-什么是线程局部变量"><span class="nav-number">5.6.2.</span> <span class="nav-text">2.什么是线程局部变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-ThreadLocal造成内存泄漏的原因"><span class="nav-number">5.6.3.</span> <span class="nav-text">3.ThreadLocal造成内存泄漏的原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-ThreadLocal内存泄漏解决方案"><span class="nav-number">5.6.4.</span> <span class="nav-text">4.ThreadLocal内存泄漏解决方案</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#拓展"><span class="nav-number">5.6.5.</span> <span class="nav-text">拓展</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池"><span class="nav-number">6.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-什么是线程池？有哪几种创建方式"><span class="nav-number">6.1.</span> <span class="nav-text">1.什么是线程池？有哪几种创建方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-线程池有什么优点"><span class="nav-number">6.2.</span> <span class="nav-text">2.线程池有什么优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-线程池都有哪些状态"><span class="nav-number">6.3.</span> <span class="nav-text">3.线程池都有哪些状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-在-Java-中-Executor-和-Executors-的区别"><span class="nav-number">6.4.</span> <span class="nav-text">4.在 Java 中 Executor 和 Executors 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-线程池中-submit-和-execute-方法有什么区别"><span class="nav-number">6.5.</span> <span class="nav-text">==5.线程池中 submit() 和 execute() 方法有什么区别==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-Executors和ThreaPoolExecutor创建线程池的区别-为什么不推荐Executors"><span class="nav-number">6.6.</span> <span class="nav-text">6.Executors和ThreaPoolExecutor创建线程池的区别(为什么不推荐Executors)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-ThreadPoolExecutor构造函数重要参数分析"><span class="nav-number">6.7.</span> <span class="nav-text">==7.ThreadPoolExecutor构造函数重要参数分析==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#建议不同类别的业务用不同的线程池"><span class="nav-number">6.8.</span> <span class="nav-text">建议不同类别的业务用不同的线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池架构-原理-流程"><span class="nav-number">6.9.</span> <span class="nav-text">线程池架构(原理/流程)</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/alex-next/images/avatar.jpg"
      alt="alex">
  <p class="site-author-name" itemprop="name">alex</p>
  <div class="site-description" itemprop="description">时光静好,与君语;细水流年,与君同;繁华落尽,与君老.</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/alex-next/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/alex-next/categories/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/alex-next/tags/">
          
        
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/alex-next/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">alex</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/alex-next/lib/anime.min.js?v=3.1.0"></script>
  <script src="/alex-next/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/alex-next/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script src="/alex-next/lib/pjax/pjax.min.js?v=0.2.8"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
<script src="/alex-next/js/utils.js?v=7.4.0"></script><script src="/alex-next/js/motion.js?v=7.4.0"></script>
<script src="/alex-next/js/schemes/pisces.js?v=7.4.0"></script>
<script src="/alex-next/js/next-boot.js?v=7.4.0"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var id = element.id || '';
    var src = element.src || '';
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (id !=='') {
      script.id = element.id;
    }
    if (src !== '') {
      script.src = src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  








  <script src="/alex-next/js/local-search.js?v=7.4.0"></script>













    <div id="pjax">

  

  
    
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    
  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: '84888b5ba3be0f56b2ed',
      clientSecret: '1306406ecbdc02b679df3c95b94985753d302d6a',
      repo: 'alex-next',
      owner: 'alexander-wd',
      admin: ['alexander-wd'],
      id: 'b2af563331508284bbb9dd135420adf9',
        language: 'zh-CN',
      
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script>

    </div>
</body>
</html>
