<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/alex-next/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/alex-next/images/favicon.ico?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/alex-next/images/favicon.ico?v=7.4.0">
  <link rel="mask-icon" href="/alex-next/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/alex-next/atom.xml" title="alex的博客 - github.com" type="application/atom+xml">

<link rel="stylesheet" href="/alex-next/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/alex-next/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/alex-next/',
    scheme: 'Pisces',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: true,
    pangu: true,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="参考spring笔记整体脑图 bean定义注册流程 springioc加载整体流程图 其他1.谈谈你理解的Spring是什么​    不止是IOC和AOP的容器框架，Spring还是一个生态圈​        生态圈​            springboot​            spring集成的各种框架​        IOC​            控制反转：将对象的控制权交给spri">
<meta name="keywords" content="spring">
<meta property="og:type" content="article">
<meta property="og:title" content="spring面试题">
<meta property="og:url" content="https://alexander-wd.github.io/2022/11/28/面试题/Spring面试题/index.html">
<meta property="og:site_name" content="alex的博客 - github.com">
<meta property="og:description" content="参考spring笔记整体脑图 bean定义注册流程 springioc加载整体流程图 其他1.谈谈你理解的Spring是什么​    不止是IOC和AOP的容器框架，Spring还是一个生态圈​        生态圈​            springboot​            spring集成的各种框架​        IOC​            控制反转：将对象的控制权交给spri">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2023-02-13T10:16:39.519Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="spring面试题">
<meta name="twitter:description" content="参考spring笔记整体脑图 bean定义注册流程 springioc加载整体流程图 其他1.谈谈你理解的Spring是什么​    不止是IOC和AOP的容器框架，Spring还是一个生态圈​        生态圈​            springboot​            spring集成的各种框架​        IOC​            控制反转：将对象的控制权交给spri">
  <link rel="canonical" href="https://alexander-wd.github.io/2022/11/28/面试题/Spring面试题/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>spring面试题 | alex的博客 - github.com</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/alex-next/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">alex的博客 - github.com</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/alex-next/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/alex-next/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/alex-next/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/alex-next/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/alexander-wd" class="github-corner" title="alex GitHub" aria-label="alex GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://alexander-wd.github.io/alex-next/2022/11/28/面试题/Spring面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="alex">
      <meta itemprop="description" content="时光静好,与君语;细水流年,与君同;繁华落尽,与君老.">
      <meta itemprop="image" content="/alex-next/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="alex的博客 - github.com">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">spring面试题

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2022-11-28 23:10:22" itemprop="dateCreated datePublished" datetime="2022-11-28T23:10:22+08:00">2022-11-28</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-13 18:16:39" itemprop="dateModified" datetime="2023-02-13T18:16:39+08:00">2023-02-13</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/alex-next/categories/面试题/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.processon.com/view/link/5f5075c763768959e2d109df" target="_blank" rel="noopener">spring笔记整体脑图</a></p>
<p><a href="https://www.processon.com/view/link/5f18298a7d9c0835d38a57c0" target="_blank" rel="noopener">bean定义注册流程</a></p>
<p><a href="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124162059.jpg" target="_blank" rel="noopener">springioc加载整体流程图</a></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="1-谈谈你理解的Spring是什么"><a href="#1-谈谈你理解的Spring是什么" class="headerlink" title="1.谈谈你理解的Spring是什么"></a>1.谈谈你理解的Spring是什么</h4><p>​    不止是IOC和AOP的容器框架，Spring还是一个生态圈<br>​        生态圈<br>​            springboot<br>​            spring集成的各种框架<br>​        <a href="https://blog.csdn.net/weixin_37711738/article/details/90020123" target="_blank" rel="noopener">IOC</a><br>​            控制反转：将对象的控制权交给spring，把应用从复杂的对象依赖关系管理中解放出来<br>​        AOP<br>​            无缝地给方法增强<br>​    标准答案</p>
<p><img alt="1" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124155639.png"></p>
<h4 id="2-Spring的优缺点是什么"><a href="#2-Spring的优缺点是什么" class="headerlink" title="2.Spring的优缺点是什么"></a>2.Spring的优缺点是什么</h4><p>​    思路<br>​        先总结Spring的特性：IOC、AOP、声明式事务、集成框架、JDBCTemplate、restTemplate(远程调用)、邮件(JavaMail)、异步调用<br>​    优点<br>​        IOC<br>​            集中管理了对象，是对象和对象之间的耦合性降低，更方便地维护对象(如：以前单例需要使用设计模式、懒加载)<br>​        AOP<br>​            不修改代码的情况下，对业务代码进行增强，减少重复代码，提高开发效率，维护方便<br>​        声明式事务<br>​            只需要@Transactional，提高开发效率<br>​        方便程序测试<br>​            结合junit非常方便测试<br>​        方便集成各种框架<br>​            拥有非常强大的粘合度、集成能力非常强，只需要简单配置就可以集成第三方框架<br>​        降低JAVAEE API使用难度<br>​            简化开发，封装了很多代码<br>​        java源码学习范例<br>​            Spring底层实现：反射、设计模式值得学习<br>​    缺点<br>​        应用层面没有缺点<br>​        简化开发，如果想深入底层了解非常困难<br>​        源码缺点：由于spring大而全，代码量非常庞大，一百多万行，想深入源码带来一定困难</p>
<h4 id="3-什么是SpringIOC容器，有什么用，优点是什么"><a href="#3-什么是SpringIOC容器，有什么用，优点是什么" class="headerlink" title="3.什么是SpringIOC容器，有什么用，优点是什么"></a>3.什么是SpringIOC容器，有什么用，优点是什么</h4><p>​    IOC<br>​        控制反转：原来需要new，耦合度高，不方便维护，引入IOC将创建对象的控制权交给Spring<br>​        现在如果要使用，只需要DI(依赖注入)@Autowired就可以使用对象了<br>​    优点<br>​        集中管理了对象，方便维护。降低耦合度</p>
<h4 id="4-IOC的实现机制是什么"><a href="#4-IOC的实现机制是什么" class="headerlink" title="==4.IOC的实现机制是什么=="></a>==4.IOC的实现机制是什么==</h4><p>​    工厂+反射<br>​        简单工厂：beanFactory.getBean，只有简单工厂需要一个一个if</p>
<p><img alt="2" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124155946.png">            </p>
<p>​        反射的方式</p>
<p><img alt="3" data-src="E:\desktop\自学\MyNote\面试题\spring图\3.png"></p>
<h4 id="5-IOC和DI的区别是什么"><a href="#5-IOC和DI的区别是什么" class="headerlink" title="5.IOC和DI的区别是什么"></a>5.IOC和DI的区别是什么</h4><p>​    IOC<br>​        控制反转：原来需要new，耦合度高，不方便维护，引入IOC将创建对象的控制权交给Spring<br>​        现在如果要使用，只需要DI(依赖注入)@Autowired就可以使用对象了<br>​        是一种设计思想<br>​    DI<br>​        DI是实现IOC的重要一环<br>​    bean和对象<br>​        对象是自己new的，bean是IOC里的</p>
<h4 id="6-紧耦合和松耦合有什么区别？如何编写松耦合代码"><a href="#6-紧耦合和松耦合有什么区别？如何编写松耦合代码" class="headerlink" title="6.紧耦合和松耦合有什么区别？如何编写松耦合代码"></a>6.紧耦合和松耦合有什么区别？如何编写松耦合代码</h4><p>​    紧耦合<br>​        类之间高度依赖<br>​    松耦合<br>​        松耦合是通过促进单一职责和接口分离、依赖倒置的设计原则来实现<br>​        单一职责</p>
<p><img alt="4" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124162413.png">        接口分离</p>
<p><img alt="5" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124162418.png">        </p>
<p>​    依赖倒置</p>
<p><img alt="6" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124162407.png"></p>
<h4 id="9-BeanFactory和ApplicationContext有什么区别"><a href="#9-BeanFactory和ApplicationContext有什么区别" class="headerlink" title="==9.BeanFactory和ApplicationContext有什么区别=="></a>==9.BeanFactory和ApplicationContext有什么区别==</h4><p>​    共同点<br>​        都可以作为容器，管理bean的生命周期<br>​    不同点<br>​        ApplicationContext相当于是4s店，不生产bean，而BeanFactory是工厂<br>​        ApplicationContext做的事情更多<br>​            会帮我们配置的bean注册进来<br>​            加载环境变量<br>​            支持国际化<br>​            事件监听<br>​            注册对外扩展点</p>
<h4 id="10-BeanFactory和FactoryBean有什么区别"><a href="#10-BeanFactory和FactoryBean有什么区别" class="headerlink" title="==10.BeanFactory和FactoryBean有什么区别=="></a>==10.BeanFactory和FactoryBean有什么区别==</h4><p>​    beanFactory是一个工厂，bean容器，管理bean的生命周期<br>​    FactoryBean是一个bean，由beanFactory生产管理<br>​        它是一个特殊的bean，是一个接口<br>​        使用FactoryBean#getObject()获取FactoryBean产生的对象，相当于工厂设计模式<br>​        细节<br>​            想要获取原本的实例，可以加上“&amp;”<br>​            被FactoryBean修饰后，会变成懒加载</p>
<h4 id="13-什么是Spring-Bean，JavaBean和SpringBean和对象的区别"><a href="#13-什么是Spring-Bean，JavaBean和SpringBean和对象的区别" class="headerlink" title="13.什么是Spring Bean，JavaBean和SpringBean和对象的区别"></a>13.什么是Spring Bean，JavaBean和SpringBean和对象的区别</h4><p>​    SpringBean<br>​        被Spring管理的对象<br>​    JavaBean<br>​        java的实体类</p>
<h4 id="14-配置Bean有哪几种方式"><a href="#14-配置Bean有哪几种方式" class="headerlink" title="14.配置Bean有哪几种方式"></a>14.配置Bean有哪几种方式</h4><p>​    xml<br>​    @Component(@Controller,@Service,@Repository)<br>​        前提：配置@Component-scan<br>​        Spring帮我们使用反射调用构造方法<br>​    @Bean<br>​        可以自己控制实例化过程<br>​    @Import<br>​        三种方式<br>​            ImportSelector接口<br>​            ImportBeanDefinitionRegistrar接口<br>​            @ImportResource<br>​        ==可以批量导入，可以导入不在扫描范围内的Bean==</p>
<h4 id="15-Spring支持的Bean的作用域"><a href="#15-Spring支持的Bean的作用域" class="headerlink" title="15.Spring支持的Bean的作用域"></a>15.Spring支持的Bean的作用域</h4><p>​    @Scope<br>​        单例<br>​        多例<br>​        request<br>​            一个请求创建一个bean<br>​        session<br>​            一次会话创建一个bean<br>​        application<br>​            一个全局应用共享一个bean<br>​        request、session和application在web应用才有<br>​    类比<a href="https://blog.csdn.net/ning_576555615/article/details/48494785" target="_blank" rel="noopener">JavaWeb四大作用域</a></p>
<h4 id="16-单例Bean的优势"><a href="#16-单例Bean的优势" class="headerlink" title="16.单例Bean的优势"></a>16.单例Bean的优势</h4><p>​    单例设计模式优势同<br>​    性能优势<br>​        减少生成实例消耗<br>​            spring通过反射或cglib生成bean<br>​            分配对象内存<br>​        减少jvm垃圾<br>​        能够快速从缓存中获取bean<br>​    参考答案</p>
<p><img alt="12" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124193641.png"></p>
<h4 id="17-Spring的bean是线程安全吗"><a href="#17-Spring的bean是线程安全吗" class="headerlink" title="==17.Spring的bean是线程安全吗=="></a>==17.Spring的bean是线程安全吗==</h4><p>​    单例bean的情况<br>​        如果在类中声明成员变量，并且有读写操作(有状态)，线程不安全，但是成员变量声明在方法中(无状态)，单例bean是安全的</p>
<h4 id="18-Spring如何处理线程并发问题"><a href="#18-Spring如何处理线程并发问题" class="headerlink" title="==18.Spring如何处理线程并发问题=="></a>==18.Spring如何处理线程并发问题==</h4><p>​    接Q.17<br>​    1.设置为多例<br>​        每个线程都会创建不同的对象<br>​    2.成员变量放到ThreadLocal中<br>​        成员变量会绑定在各自的线程上，不共享<br>​    3.同步锁synchronized<br>​        并行变成了串行，会影响系统吞吐量</p>
<h4 id="33-Spring有哪几种配置方式"><a href="#33-Spring有哪几种配置方式" class="headerlink" title="33.Spring有哪几种配置方式"></a>33.Spring有哪几种配置方式</h4><p>​    1.xml<br>​        spring诞生就有的<br>​        spring-xml  <bean><br>​    2.注解<br>​        Spring2.5<br>​        spring.xml  <component-scan>  @Component  @Autowired<br>​    3.java配置<br>​        javaConfig  Spring3.0+<br>​        @Configuration  @Bean</component-scan></bean></p>
<h4 id="34-JavaConfig是如何替代spring-xml的"><a href="#34-JavaConfig是如何替代spring-xml的" class="headerlink" title="==34.JavaConfig是如何替代spring.xml的=="></a>==34.JavaConfig是如何替代spring.xml的==</h4><p>​    应用<br>​        xml<br>​            ClassPathXmlApplicationContext<br>​            spring.xml<br>​            <bean scope lazy><br>​            <component-scan><br>​            引入外部属性配置文件<br>​                <contetx:property-placeholder location="db.properties"><br>​            <property value="${password}"><br>​            <import>指定其他配置文件<br>​        javaconfig<br>​            AnnotationConfigApplicationContext<br>​            @Configuration<br>​            @Bean @Scope @Lazy<br>​            @ComponentScan<br>​            @PropertySource(“classpath:db.properties”)<br>​            @Value(“${password}”)<br>​            @Import比较灵活<br>​    源码<br>​        Q.28<br>​        BeanFactory.getBean是一样的<br>​        参考</import></property></contetx:property-placeholder></component-scan></bean></p>
<p><img alt="25" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124194042.png"></p>
<h4 id="42-Configuration的作用及解析原理"><a href="#42-Configuration的作用及解析原理" class="headerlink" title="==42.@Configuration的作用及解析原理=="></a>==42.@Configuration的作用及解析原理==</h4><p>​    1.代替spring.xml配置文件<br>​    2.没有@Configuration也可以配置@Bean<br>​    ==3.@Configuration加与不加有什么区别==<br>​        加了@Configuration会为配置类创建Cglib代理，保证配置类@Bean方法调用Bean的单例，@Bean方法的调用就会通过getBean获取    </p>
<p>​    <img alt="28" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124210616.png"></p>
<p>​    原理<br>​        1.创建Spring上下文会注册ConfigurationClassPostProcessor<br>​        2.调用invokeBeanFactoryPostProcessors,就会调用ConfigurationClassPostProcessor就会解析各种注解(@Component，@Bean)<br>​        3.ConfigurationClassPostProcessor#postProcessBeanFactory会给配置类创建cglib动态代理</p>
<p><img alt="6" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124211115.png"></p>
<h4 id="64-Spring事件监听机制"><a href="#64-Spring事件监听机制" class="headerlink" title="64.Spring事件监听机制"></a>64.Spring事件监听机制</h4><p>​    观察者模式<br>​        事件<br>​        监听器<br>​        多播器<br>​    异步事件<br>​        多线程</p>
<h4 id="65-Spring中都用到了哪些设计模式"><a href="#65-Spring中都用到了哪些设计模式" class="headerlink" title="==65.Spring中都用到了哪些设计模式=="></a>==65.Spring中都用到了哪些设计模式==</h4><p>​    简单工厂<br>​        Beanfactory.getBean<br>​    工厂方法<br>​        FactoryBean.getObject<br>​    单例模式<br>​        Bean实例<br>​    适配器模式<br>​        SpringMVC的HandlerAdapter<br>​    装饰器模式<br>​        BeanWrapper<br>​    代理模式<br>​        AOP、事务<br>​    观察者模式<br>​        事件监听<br>​    策略模式<br>​        excludeFilters、includeFilters    @ComponentScan<br>​    模板方法模式<br>​        Spring几乎所有外接扩展(beanPostProcessor)<br>​    责任链模式<br>​        AOP、事务调用</p>
<h4 id="66-Spring是如何整合Mybatis管理Mapper接口的"><a href="#66-Spring是如何整合Mybatis管理Mapper接口的" class="headerlink" title="66.Spring是如何整合Mybatis管理Mapper接口的"></a>66.Spring是如何整合Mybatis管理Mapper接口的</h4><p>​    ==难点：给Mapper接口加上@Component由于注册BeanDefinition时不会注册接口类(参考解析@Component)且生产bean的时候也不会去生产接口的实例==<br>​    1.Mybatis提供mapper的jdk动态代理<br>​        注册BeanDefinition时不会注册接口类<br>​    2.实现BeanDefinitionRegistryPostProcessor动态注册BeanDefinition<br>​    3.实现自定义扫描器，重写ClassPathBeanDefinitionScanner排除接口的方法(isCandidateComponent)<br>​        批量扫描BeanDefinition<br>​    4.修改BeanDefinition的BeanClass替换为JDK动态代理实例(FactoryBean);偷天换日<br>​        生产bean的时候也不会去生产接口的实例<br>​    5.通过FactoryBean的工厂方法设计模式自由控制bean的实例化过程(getObject)<br>​<br>​    ==Spring注册BeanDefinition时不会注册接口类==</p>
<p>​    参考</p>
<p>​    <img alt="42" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124201403.png"></p>
<h3 id="IOC加载流程"><a href="#IOC加载流程" class="headerlink" title="IOC加载流程"></a>IOC加载流程</h3><h4 id="11-SpringIOC容器的加载过程"><a href="#11-SpringIOC容器的加载过程" class="headerlink" title="==11.SpringIOC容器的加载过程=="></a>==11.SpringIOC容器的加载过程==</h4><p>​    其实就是Bean的创建过程<br>​    new ApplicationContext()<br>​    invokeBeanFactoryPostProcessors<br>​        扫描包(@Component,@Import,@ComponentScan)，解析类信息，使用BeanDefinition存储类信息，注册为bean定义<br>​        使用beanDefinitionMap缓存起来<br>​    国际化、扩展点、监听器<br>​    finishBeanFactoryInitialization<br>​        判断是否符合生产标准<br>​            是单例<br>​            不是懒加载<br>​            不是抽象类<br>​        推断构造方法(spring通过构造方法反射)<br>​        通过反射实例化对象(纯静态)<br>​        需要属性赋值，则注入属性(@Autowired,@ByName…)<br>​        初始化<br>​            生命周期方法回调<br>​            需要动态代理，则创建动态代理<br>​        加入一级缓存<br>​    参考答案<br>​    <img alt="8" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124201613.png"></p>
<p><img alt="9" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124201616.png"></p>
<h4 id="12-SpringIOC有哪些扩展点，在什么时候调用"><a href="#12-SpringIOC有哪些扩展点，在什么时候调用" class="headerlink" title="==12.SpringIOC有哪些扩展点，在什么时候调用=="></a>==12.SpringIOC有哪些扩展点，在什么时候调用==</h4><p>​    1.实现BeanFactoryPostProcessor<br>​    2.实现BeanDefinitionRegistryPostProcessor</p>
<p>​    <img alt="10" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124204411.png"></p>
<p>​    3.BeanPostProcessor：bean的生命周期调用9次<br>​    4.初始化调用</p>
<p>​    <img alt="11" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124204415.png"></p>
<p>​    5.FactoryBean</p>
<h4 id="24-Spring在加载过程中Bean哪有几种形态"><a href="#24-Spring在加载过程中Bean哪有几种形态" class="headerlink" title="==24.Spring在加载过程中Bean哪有几种形态=="></a>==24.Spring在加载过程中Bean哪有几种形态==</h4><p>​    概念态<br>​    定义态<br>​    纯静态<br>​    成熟态<br>​    参考</p>
<p><img alt="17" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124204510.png"></p>
<h4 id="注册BeanDefinition"><a href="#注册BeanDefinition" class="headerlink" title="注册BeanDefinition"></a>注册BeanDefinition</h4><h5 id="8-BeanDefinition的作用"><a href="#8-BeanDefinition的作用" class="headerlink" title="==8.BeanDefinition的作用=="></a>==8.BeanDefinition的作用==</h5><p>​    主要负责存储bean的定义信息：决定Bean的生产方式<br>​        如对象的路径名、懒加载、单例、自动装配方式<br>​    先根据用户配置生成BeanDefinition，然后生成Bean</p>
<h5 id="28-描述BeanDefinition的加载过程"><a href="#28-描述BeanDefinition的加载过程" class="headerlink" title="28.描述BeanDefinition的加载过程"></a>28.描述BeanDefinition的加载过程</h5><p>​    BeanDefinitionReader读取配置文件<br>​    ConfigurationClassParser解析加了@Configuation的配置文件<br>​        解析@Component等注解<br>​    @ComponentScan为例ClassPathBeanDefinitionScanner#doScan<br>​        扫描包路径下的所有.class文件，扫描是否包含@Service,@Component注解<br>​    注册beanDefinition</p>
<h5 id="31-spring启动时，为什么先加载BeanFactoryPostProcessor"><a href="#31-spring启动时，为什么先加载BeanFactoryPostProcessor" class="headerlink" title="31.spring启动时，为什么先加载BeanFactoryPostProcessor"></a>31.spring启动时，为什么先加载BeanFactoryPostProcessor</h5><p>​    1.因为BeanDefinition会在IOC容器加载的时候先注册，而BeanFactoryPostProcessor就是在beanDefinition注册完后做扩展的<br>​    2.解析配置类的组件(生成BeanDefinition)ConfigurationClassPostProcessor实现了BeanFactoryPostProcessor(准确的来说是BeanDefinitionRegistryPostProcessor)，所以要先去加载BeanFactoryPostProcessor</p>
<h5 id="解析注解-系统的BeanDefinitionRegistryPostProcessor"><a href="#解析注解-系统的BeanDefinitionRegistryPostProcessor" class="headerlink" title="解析注解(系统的BeanDefinitionRegistryPostProcessor)"></a>解析注解(系统的BeanDefinitionRegistryPostProcessor)</h5><h6 id="45-为什么-ComponentScan不设置basePackage也会扫描"><a href="#45-为什么-ComponentScan不设置basePackage也会扫描" class="headerlink" title="45.为什么@ComponentScan不设置basePackage也会扫描"></a>45.为什么@ComponentScan不设置basePackage也会扫描</h6><p>​    因为Spring在解析@ComponentScan的时候，如果没设置basePackage，会将当前配置类所在包作为扫描路径</p>
<h6 id="35-Controller-Component-Repository-Service有什么区别"><a href="#35-Controller-Component-Repository-Service有什么区别" class="headerlink" title="35.@Controller,@Component,@Repository,@Service有什么区别"></a>35.@Controller,@Component,@Repository,@Service有什么区别</h6><p>​    元注解都是@Component<br>​    三层分别使用三个注解，代码阅读性更强，每个注解职责更清晰</p>
<h6 id="36-Import可以有几种用法"><a href="#36-Import可以有几种用法" class="headerlink" title="36.@Import可以有几种用法"></a>36.@Import可以有几种用法</h6><p>​    Q.14<br>​    @Import直接指定类<br>​        配置类按配置类解析，普通类解析为bean<br>​    ImportSelector.class<br>​        看一次性注册多个，返回一个String[]{}类的完整类路径，但不能干预实例化过程<br>​        DeferredImportSelector<br>​            延迟加载<br>​    ImportBeanDefinitionRegistrar<br>​        可以一次性注册多个<br>​        需要自己去创建注册beanDefinition，可以使用BeanDefinitionRegistry动态注册</p>
<h6 id="43-Bean的方法调用怎么保证单例"><a href="#43-Bean的方法调用怎么保证单例" class="headerlink" title="==43.@Bean的方法调用怎么保证单例=="></a>==43.@Bean的方法调用怎么保证单例==</h6><p>​    同@Configuration加与不加有什么区别<br>​        加了@Configuration会为配置类创建Cglib代理，保证配置类@Bean方法调用Bean的单例，@Bean方法的调用就会通过getBean获取<br>​    原理<br>​        1.创建Spring上下文会注册ConfigurationClassPostProcessor<br>​        2.调用invokeBeanFactoryPostProcessors,就会调用ConfigurationClassPostProcessor就会解析各种注解(@Component，@Bean)<br>​        3.ConfigurationClassPostProcessor#postProcessBeanFactory会给配置类创建cglib动态代理<br>​    参考</p>
<p><img alt="29" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124212108.png"></p>
<h6 id="32-Bean的生产顺序-BeanDefinition的注册顺序-是由什么决定的"><a href="#32-Bean的生产顺序-BeanDefinition的注册顺序-是由什么决定的" class="headerlink" title="==32.Bean的生产顺序(BeanDefinition的注册顺序)是由什么决定的=="></a>==32.Bean的生产顺序(BeanDefinition的注册顺序)是由什么决定的==</h6><p>​    bean的创建顺序由BeanDefinition的注册顺序来决定的，当然依赖关系也会影响Bean的创建顺序<br>​    ==追问：BeanDefinition的注册顺序是由什么决定的==<br>​        主要由注解的解析顺序决定<br>​            @Configuration<br>​            @Import导入的@Configuration<br>​            @Component<br>​            @Import—-class<br>​            @Import—-@Configuration—-@Bean<br>​            @Bean<br>​            @Import—-ImportBeanDefinitionRegistrar<br>​            自己实现的BeanDefinitionRegistryPostProcessor<br>​            后加载的会覆盖前面的<br>​        细节(@Order)</p>
<h6 id="44-将第三方的类配置成bean有哪些方式"><a href="#44-将第三方的类配置成bean有哪些方式" class="headerlink" title="==44.将第三方的类配置成bean有哪些方式=="></a>==44.将第三方的类配置成bean有哪些方式==</h6><p>​    Q.32<br>​    @Bean<br>​    @Import<br>​        Q.36<br>​        @Import直接导入类<br>​        ImportSelector<br>​        ImportBeanDefinitionRegistrar<br>​            可以自定义BeanDefinition<br>​    自己实现的BeanDefinitionRegistryPostProcessor</p>
<h5 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h5><h6 id="29-如何在所有BeanDefinition注册完后做扩展"><a href="#29-如何在所有BeanDefinition注册完后做扩展" class="headerlink" title="29.如何在所有BeanDefinition注册完后做扩展"></a>29.如何在所有BeanDefinition注册完后做扩展</h6><p>​        Q.12<br>​        BeanFactoryPostProcessor可以</p>
<h4 id="创建Bean"><a href="#创建Bean" class="headerlink" title="创建Bean"></a>创建Bean</h4><h5 id="7-BeanFactory的作用"><a href="#7-BeanFactory的作用" class="headerlink" title="==7.BeanFactory的作用=="></a>==7.BeanFactory的作用==</h5><p>​    Spring非常核心的一个顶层接口<br>​    主要职责：生产Bean<br>​    Spring容器(管理着Bean的生命周期 )<br>​    答案</p>
<p><img alt="7" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124212501.png"></p>
<h5 id="25-解释Spring框架中Bean的生命周期"><a href="#25-解释Spring框架中Bean的生命周期" class="headerlink" title="==25.解释Spring框架中Bean的生命周期=="></a>==25.解释Spring框架中Bean的生命周期==</h5><p>​    Bean的生命周期<br>​        从创建到销毁的过程<br>​    四大步<br>​        实例化<br>​            Q.19<br>​            推断构造函数，通过反射实例化<br>​            静态工厂、实例工厂<br>​        属性赋值<br>​            Q.22<br>​            解析自动装配(byName,byType)：DI体现<br>​            会出现循环依赖<br>​        初始化<br>​            调用XXXAware回调<br>​            调用初始化生命周期回调<br>​                Q.23<br>​            如果bean实现了AOP，创建动态代理<br>​        销毁<br>​            在spring容器关闭的时候进行调用<br>​            调用销毁生命周期回调<br>​    参考</p>
<p><img alt="18" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124212912.png"></p>
<h5 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h5><h6 id="19-Spring实例化Bean有几种方式"><a href="#19-Spring实例化Bean有几种方式" class="headerlink" title="19.Spring实例化Bean有几种方式"></a>19.Spring实例化Bean有几种方式</h6><p>​        1.构造器(反射)<br>​            存到BeanDefinition.beanClass<br>​            然后反射<br>​        2.静态工厂<br>​            factory-method指定的静态方法</p>
<p><img alt="13" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124213008.png"></p>
<p>​        3.实例工厂方式<br>​            factory-bean+factory-method<br>​            @Bean底层用的就是此方式</p>
<p><img alt="14" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124213016.png"></p>
<p>​        4.FactoryBean<br>​            getObject()</p>
<h5 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h5><h6 id="20-什么是bean的自动装配-装配"><a href="#20-什么是bean的自动装配-装配" class="headerlink" title="20.什么是bean的自动装配(装配)"></a>20.什么是bean的自动装配(装配)</h6><p>​    手动装配<br>​        <property></property>一个一个指定<br>​    自动装配<br>​        根据@Autowired、@Resource注入</p>
<h6 id="21-自动注入有什么限制-需要注意"><a href="#21-自动注入有什么限制-需要注意" class="headerlink" title="21.自动注入有什么限制(需要注意)"></a>21.自动注入有什么限制(需要注意)</h6><p>​    一定要声明set方法<br>​    可以使用<property><constructor>覆盖<br>​    不能自动装配简单的属性，如基本数据类型、字符串和类。但是手动注入(&lt;property&gt;,@Value)可以注入基本数据类型<br>​    模糊特性：自动装配不如显示装配精确</constructor></property></p>
<h6 id="22-自动装配方式有几种"><a href="#22-自动装配方式有几种" class="headerlink" title="22.自动装配方式有几种"></a>22.自动装配方式有几种</h6><p>​    no<br>​        默认<br>​        需要自己在xml里面配置<property ref><br>​    byName<br>​        根据setXXX的名字，不是属性名<br>​    byType<br>​        根据set方法传入的类型<br>​    constructor<br>​    autodetect<br>​        spring3.0后弃用<br>​    参考答案</property></p>
<p><img alt="15" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124213249.png"></p>
<h6 id="26-Spring如何解决bean的循环依赖"><a href="#26-Spring如何解决bean的循环依赖" class="headerlink" title="==26.Spring如何解决bean的循环依赖(*)=="></a>==26.Spring如何解决bean的循环依赖(<em>*</em>)==</h6><p>采用了三级缓存<br>    一级缓存<br>        存储完整的bean<br>        方便以后直接getBean获取对象<br>    二级缓存<br>        存储纯静态的bean<br>        ==避免多重循环依赖(b和c都依赖a),重复创建动态代理==<br>        ==保证多线程下bean的完整性==<br>    三级缓存<br>        存储了bean动态代理的一个函数接口<br>        ==不会立即调用：如果立即调用，不管bean是否是循环依赖，都会在实例化后创建proxy，但是正常bean，spring还是希望遵循生命周期在初始化创建动态代理；只有循环依赖，才会在实例化后创建动态代理==<br>        延时获取：提高性能，因为并不是所有的Bean都存在循环引用，所以当真正调用时再缓存该单例到二级缓存<br>        提高扩展性：采用bean的后置处理器方式可以提高扩展性<br>夺命连环问<br>    1.二级缓存能不能解决循环依赖<br>        a.如果只想解决循环依赖死循环：一级缓存就可以解决，但并发情况下会获取到不完整的bean<br>        b.二级缓存也可以解决循环依赖：可以避免重复循环依赖多次创建aop动态代理<br>    <a href="https://blog.csdn.net/weixin_48777366/article/details/123645686" target="_blank" rel="noopener">2.spring有没有解决多例bean的循环依赖</a><br>        没有解决，会报错BeanCurrentlyInCreationException<br>        a.多例bean不会使用缓存进行存储(多例bean 每次使用都需要重新创建)<br>        b.不缓存早期对象就无法解决循环依赖<br>    <a href="https://baijiahao.baidu.com/s?id=1676046519501587416&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">3.Spring有没有解决构造函数参数bean的循环依赖</a><br>        没有解决，beforeSingletonCreation报错？<br>            构造器会在实例化时候调用，一二三级缓存还没有<br>        可以通过@Lazy解决<br>            不会立即创建Bean，等到用到的时候才会创建<br>    参考答案</p>
<p>​    <img alt="21" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124214018.png"></p>
<p>参考</p>
<p><img alt="19" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124214141.png"></p>
<p>循环依赖图解</p>
<p><img alt="循环依赖课上图" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124214138.png"></p>
<h6 id="27-Spring如何在并发下避免获取不完整的Bean"><a href="#27-Spring如何在并发下避免获取不完整的Bean" class="headerlink" title="==27.Spring如何在并发下避免获取不完整的Bean=="></a>==27.Spring如何在并发下避免获取不完整的Bean==</h6><p>​    双重检查锁：2个同步锁(锁对象都是一级缓存)<br>​        1.getSingleton(A,boolean)</p>
<p>​        <img alt="23" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124214314.png"></p>
<p>​        2.getSingleton(A,objectFactory)</p>
<p>​    <img alt="22" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124214324.png"></p>
<p>​    追问<br>​        一级缓存为什么不加入锁<br>​            性能问题，其他线程可能要从一级缓存中获取bean<br>​    循环依赖图解(同Q.26)</p>
<h6 id="37-如何让自动注入没有找到依赖Bean时不会报错"><a href="#37-如何让自动注入没有找到依赖Bean时不会报错" class="headerlink" title="37.如何让自动注入没有找到依赖Bean时不会报错"></a>37.如何让自动注入没有找到依赖Bean时不会报错</h6><p>​    @Autowired(required = false)</p>
<h6 id="38-如何让自动注入找到多个依赖Bean不会报错"><a href="#38-如何让自动注入找到多个依赖Bean不会报错" class="headerlink" title="38.如何让自动注入找到多个依赖Bean不会报错"></a>38.如何让自动注入找到多个依赖Bean不会报错</h6><p>​    @Primary<br>​        设置此bean时主要的，优先级最高</p>
<h6 id="39-Autowired有什么作用"><a href="#39-Autowired有什么作用" class="headerlink" title="39.@Autowired有什么作用"></a>39.@Autowired有什么作用</h6><p>​    @Autowired对比byName,byType能更细粒度的注入属性(byName,byType会给所有set方法注入)<br>​    ==@Autowired默认按类型，按类型找到多个再按照名称，并且不需要提供get/set方法==</p>
<h6 id="属性注入方式"><a href="#属性注入方式" class="headerlink" title="属性注入方式"></a>属性注入方式</h6><p>​    set注入<br>​        在pupulateBean注入<br>​    构造器注入<br>​        在实例化的时候就实现了注入<br>​    @Autowired注入<br>​        @Autowired对比byName,byType能更细粒度的注入属性(byName,byType会给所有set方法注入)<br>​        @Autowired默认按类型，按类型找到多个再按照名称，并且不需要提供get/set方法</p>
<h6 id="40-Autowired和-Resource的区别"><a href="#40-Autowired和-Resource的区别" class="headerlink" title="40.@Autowired和@Resource的区别"></a>40.@Autowired和@Resource的区别</h6><p>​    @Autowired<br>​        是spring提供的<br>​        @Autowired默认按类型，按类型找到多个再按照名称，并且不需要提供get/set方法<br>​    @Resource<br>​        jdk提供<br>​        @esource默认按名字，按名字找到多个再按照类型</p>
<h6 id="41-Autowired注解自动装配底层原理"><a href="#41-Autowired注解自动装配底层原理" class="headerlink" title="==41.@Autowired注解自动装配底层原理=="></a>==41.@Autowired注解自动装配底层原理==</h6><p>​    通过BeanPostProcessor进行解析的<br>​        1.创建spring上下文时候注册AutowiredAnnotationBeanPostProcessor<br>​        2.实例化后预解析@Autowired类型、名称、属性等信息；在属性注入时，去IOC根据缓存的元数据信息返回注入bean<br>​    参考</p>
<p>​    <img alt="26" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124214837.png"></p>
<p>​    图解</p>
<p><img alt="27" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124214846.png"></p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><h6 id="23-Bean有哪些生命周期回调方法，有哪几种实现方式"><a href="#23-Bean有哪些生命周期回调方法，有哪几种实现方式" class="headerlink" title="==23.Bean有哪些生命周期回调方法，有哪几种实现方式=="></a>==23.Bean有哪些生命周期回调方法，有哪几种实现方式==</h6><p>​    初始化(从前到后)<br>​        @PostConstruct<br>​        InitializingBean接口<br>​        @Bean的init-method<br>​    销毁(从前到后)<br>​        @PreDestroy<br>​        DisposableBean接口<br>​        @Bean的destroy-method<br>​    参考</p>
<p><img alt="16" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124215050.png"></p>
<h5 id="30-如何在所有bean创建完后做扩展"><a href="#30-如何在所有bean创建完后做扩展" class="headerlink" title="==30.如何在所有bean创建完后做扩展=="></a>==30.如何在所有bean创建完后做扩展==</h5><p>​    哪里才算所有的Bean创建完<br>​        循环所有BeanDefinition执行getBean之后，所有bean就创建完了<br>​    1.SmartInitializingSingleton<br>​        finishBeanFactoryInitialization<br>​            preInstantiateSingletons<br>​                遍历完所有BeanDefinition之后<br>​    2.监听ContextRefreshedEvent事件<br>​        finishRefresh<br>​        注：注解形式解析类其实实现了SmartInitializingSingleton</p>
<p><img alt="24" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124215207.png"></p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="46-什么是AOP，能做什么"><a href="#46-什么是AOP，能做什么" class="headerlink" title="46.什么是AOP，能做什么"></a>46.什么是AOP，能做什么</h4><p>​    面向切面编程<br>​        用于与业务无关，但对多个对象产生影响的公共行为和逻辑。减少系统中的重复代码，降低了模块间的耦合度，提高了系统的可维护性<br>​        可用于权限认证、日志、事务</p>
<h4 id="47-解释Spring-AOP常见的概念名词"><a href="#47-解释Spring-AOP常见的概念名词" class="headerlink" title="47.解释Spring AOP常见的概念名词"></a>47.解释Spring AOP常见的概念名词</h4><p>​    切面Aspect<br>​        自己定义的切面类(@Aspectj)，管理了切点和通知<br>​    连接点Join point<br>​        指的就是被增强的业务方法(自己写的业务逻辑)<br>​    通知advice<br>​        就是需要增强到业务方法中的公共代码<br>​            前置通知<br>​            后置通知<br>​            环绕通知<br>​            异常通知<br>​            返回通知<br>​    切点Pointcut<br>​        通过切点表达式决定哪些方法需要被增强<br>​    目标对象<br>​        增强的对象，业务逻辑类的对象<br>​    顾问(Advisor)<br>​        Pointcut和Advice的一个结合<br>​        应用层面无需关心<br>​    织入Weaving<br>​        Aspectj独有<br>​        Spring aop织入方式：动态代理</p>
<h4 id="48-Spring通知有哪些类型"><a href="#48-Spring通知有哪些类型" class="headerlink" title="48.Spring通知有哪些类型"></a>48.Spring通知有哪些类型</h4><p>​    类型<br>​        前置通知<br>​        后置通知<br>​        环绕通知<br>​        异常通知<br>​        返回通知<br>​    执行顺序<br>​        spring5.2.7之前<br>​            后置通知在返回通知和异常通知之前<br>​        spring5.2.7之后<br>​            正常:around(before)-&gt; before -&gt; around(proceed方法体执行) -&gt; afterReturning -&gt; after -&gt; around(after)<br>​            异常:around(before)-&gt; before -&gt; around(proceed方法体执行) -&gt; AfterThrowing -&gt; after</p>
<h4 id="49-Spring-AOP和Aspectj-AOP有什么区别"><a href="#49-Spring-AOP和Aspectj-AOP有什么区别" class="headerlink" title="49.Spring AOP和Aspectj AOP有什么区别"></a>49.Spring AOP和Aspectj AOP有什么区别</h4><p>​    联系<br>​        Spring AOP提供了AspectJ的支持，但只能用到AspectJ的切点解析和匹配(@Aspect、@Before)<br>​        @Aspect、@Before等都是AspectJ发明的<br>​    区别<br>​        Spring<br>​            动态代理<br>​                使用接口：jdk<br>​                没有接口：cglib<br>​            在容器启动的时候生成代理实例<br>​                方法调用上也会增加栈的深度<br>​        AspectJ<br>​            静态代理<br>​                编译的时候动态修改.class文件<br>​            实际代码运行前(编译时)完成织入</p>
<p><img alt="30" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125160735.png"></p>
<h4 id="50-JDK动态代理和CGLIB动态代理"><a href="#50-JDK动态代理和CGLIB动态代理" class="headerlink" title="50.JDK动态代理和CGLIB动态代理"></a>50.JDK动态代理和CGLIB动态代理</h4><p>​    JDK动态代理<br>​        实现了接口<br>​        JDK在运行时为目标类生成一个动态代理类$proxy*.class<br>​        该代理类会实现目标类接口，并且代理类会实现接口所有的方法增强代码。<br>​        ==调用时，通过代理类先去  调用  处理类进行增强，在通过反射方式进行调用目标方法==<br>​    CGLIB动态代理<br>​        没有实现接口<br>​        使用ASM在运行时动态生成目标类的子类。会生成多个<br>​        会重写父类所有的方法增强代码<br>​        调用时，通过代理类进行增强，再  直接调用  父类对应的方法进行调用目标方法<br>​            如果某个类被标记为final，不能被继承，也无法做CGLIB动态代理<br>​            ==除了生成目标子类代理类，还有一个FastClass(路由类)，可以让(不是必须，Spring没使用)本类方法调用重复增强，不像jdk代理只能增强一次==<br>​    jdk生成动态代理快，调用慢(反射)，cglib生成慢(ASM多个类)，调用快<br>​        老版本cglib快，目前jdk快<br>​    参考</p>
<p><img alt="31" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125162016.png"></p>
<h4 id="51-JavaConfig如何启用AOP，如何强制使用cglib"><a href="#51-JavaConfig如何启用AOP，如何强制使用cglib" class="headerlink" title="51.JavaConfig如何启用AOP，如何强制使用cglib"></a>51.JavaConfig如何启用AOP，如何强制使用cglib</h4><p>​    启用AOP<br>​        @EnableAspectJAutoProxy<br>​            强制CGLIB<br>​                proxyTargetClass = true<br>​            在线程中暴露代理对象<br>​                exposeProxy = true<br>​                底层就会把代理对象存到ThreadLocal(绑定到当前线程上)中</p>
<h4 id="52-介绍AOP有几种实现方式"><a href="#52-介绍AOP有几种实现方式" class="headerlink" title="52.介绍AOP有几种实现方式"></a>52.介绍AOP有几种实现方式</h4><p>​    spring1.2<br>​        基于接口<br>​    spring2.0<br>​        xml<br>​    spring2.0<br>​        注解<br>​    AspectJ</p>
<h4 id="53-什么情况下AOP会失效，怎么解决"><a href="#53-什么情况下AOP会失效，怎么解决" class="headerlink" title="53.什么情况下AOP会失效，怎么解决"></a>53.什么情况下AOP会失效，怎么解决</h4><p>​    Q.51<br>​    失效原因<br>​        内部调用(方法内部调用另一个方法，事务相关!!!)不会触发AOP，必须走代理<br>​        方法是private，必须是public<br>​        目标类没有配置为bean<br>​        切点表达式不正确<br>​        Q.73<br>​    解决<br>​        从本类中自动注入当前bean(IOC存的就是代理类)<br>​        在线程中暴露代理对象<br>​            exposeProxy = true<br>​            底层就会把代理对象存到ThreadLocal(绑定到当前线程上)中</p>
<h4 id="54-Spring-AOP在哪里创建的动态代理"><a href="#54-Spring-AOP在哪里创建的动态代理" class="headerlink" title="==54.Spring AOP在哪里创建的动态代理=="></a>==54.Spring AOP在哪里创建的动态代理==</h4><p>​    1.普通bean<br>​        初始化后，使用beanPostProcessor创建<br>​    2.循环依赖<br>​        在属性注入的时候<br>​    参考</p>
<p><img alt="32" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125200212.png"></p>
<h4 id="55-描述AOP的完整实现流程"><a href="#55-描述AOP的完整实现流程" class="headerlink" title="==55.描述AOP的完整实现流程=="></a>==55.描述AOP的完整实现流程==</h4><p>​    @EnableAspectJAutoProxy会通过@Import注册一个BeanPostProcessor处理AOP<br>​    1.解析切面<br>​        实例化之前第一个BeanPostProcessor<br>​    2.创建代理<br>​        初始化后调用BeanPostProcessor拿到之前缓存的advisor，根据advisor的pointcut匹配当前bean是否命中<br>​    3.调用代理<br>​        拿到动态代理对象，判断是否是需要增强的方法<br>​        如果是需要增强的方法，就拿到所有的advisors<br>​        转换为Interceptor，通过责任链调用<br>​    参考</p>
<p><img alt="33" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125200314.png"></p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="56-事务四大特性"><a href="#56-事务四大特性" class="headerlink" title="56.事务四大特性"></a>56.事务四大特性</h4><p>​    原子性<br>​        要么都成功要么都失败<br>​    一致性<br>​        A转账给B，执行前执行后数据一致<br>​    隔离性<br>​        事务执行时，不被其他事务操作干扰<br>​    持久性<br>​        事务一旦提交，改变就是永久性的；遇到故障，也不会丢失提交事务的操作<br>​    参考</p>
<p><img alt="34" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125201452.png"></p>
<h4 id="57-Spring支持的事务管理类型，Spring事务实现方式有哪些"><a href="#57-Spring支持的事务管理类型，Spring事务实现方式有哪些" class="headerlink" title="57.Spring支持的事务管理类型，Spring事务实现方式有哪些"></a>57.Spring支持的事务管理类型，Spring事务实现方式有哪些</h4><p>​    事务管理类型<br>​        编程式事务<br>​        声明式事务<br>​    实现方式<br>​        基于接口<br>​            基于TransactionInterceptor的声明式事务<br>​            基于TransactionProxyFactoryBean的声明式事务<br>​        基于<tx>和<aop>命名空间的声明式事务<br>​        基于@Transactional全注解方式<br>​        参考</aop></tx></p>
<p><img alt="35" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125201634.png"></p>
<h4 id="58-说一下Spring的事务传播行为"><a href="#58-说一下Spring的事务传播行为" class="headerlink" title="==58.说一下Spring的事务传播行为=="></a>==58.说一下Spring的事务传播行为==</h4><p>​    ==事务的传播行为指的是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行==<br>​    事务传播行为</p>
<p><img alt="36" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125201859.png"></p>
<h4 id="59-说一下Spring的事务隔离级别"><a href="#59-说一下Spring的事务隔离级别" class="headerlink" title="==59.说一下Spring的事务隔离级别=="></a>==59.说一下Spring的事务隔离级别==</h4><p>​    并发产生的问题<br>​        脏读<br>​            事务A读取了事务B未提交的数据<br>​        不可重复读<br>​            事务A两次读取数据(一条数据)不一致<br>​        幻读<br>​            事务A两次统计数据条数(针对整张表)不一致<br>​    隔离级别<br>​        读未提交<br>​        读已提交<br>​        可重复读<br>​            行锁<br>​        串行化<br>​            表锁</p>
<h4 id="60-Spring事务实现原理"><a href="#60-Spring事务实现原理" class="headerlink" title="==60.Spring事务实现原理=="></a>==60.Spring事务实现原理==</h4><p>​    基于AOP，和AOP相似<br>​    @EnableTransactionManagement<br>​    1.解析切面<br>​        实例化之前第一个beanPostProcessor解析Spring事务自定义的advisor信息<br>​    2.创建代理<br>​        bean的初始化后beanPostProcessor，匹配(方法、类上、接口或父类上有没有@Transactional)<br>​    3.调用代理<br>​        创建数据库连接Connection，修改数据库连接属性autoCommit=false！！！<br>​        执行目标方法，执行sql<br>​        执行完后，有异常回滚，没异常提交</p>
<h4 id="61-Spring事务传播行为实现原理"><a href="#61-Spring事务传播行为实现原理" class="headerlink" title="==61.Spring事务传播行为实现原理=="></a>==61.Spring事务传播行为实现原理==</h4><p>​    源码在调用事务中<br>​    思路：connection存在ThreadLocal中，事务进来会判断是否已经有connection，有说明是内嵌事务；之后判断事务隔离级别<br>​        TransactionInfo.newTransaction用于判断融入(内嵌事务不提交)还是创建新事务(内嵌事务提交)<br>​        融入:TransactionInfo.newTransaction=false<br>​            无需暂存，直接用外部事务ThreadLocal中的信息<br>​        创建新事务:TransactionInfo.newTransaction=false<br>​            执行前暂存外部事务connection，隔离级别等各种事务信息<br>​            执行后把事务信息存到ThreadLocal中<br>​        细节<br>​            根据TransactionInfo.newTransaction判断是否要提交<br>​            当前执行的事务都有一个connection存到了ThreadLocal中<br>​    参考</p>
<p><img alt="37" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125202657.png"></p>
<p>​    融入</p>
<p><img alt="38" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125202700.png"></p>
<p>​    创建新事务</p>
<p><img alt="39" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125202703.png"></p>
<h4 id="62-Spring多线程事务能否保证事务的一致性"><a href="#62-Spring多线程事务能否保证事务的一致性" class="headerlink" title="==62.Spring多线程事务能否保证事务的一致性=="></a>==62.Spring多线程事务能否保证事务的一致性==</h4><p>​    事务信息存在ThreadLocal中，多个线程是存在多个ThreadLocal中，所以一个线程永远只能有一个事务；因此不能保证多线程事务一致性<br>​    解决<br>​        编程式事务<br>​        分布式事务<br>​    参考</p>
<p><img alt="40" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125203043.png"></p>
<h4 id="63-Spring事务的失效原因"><a href="#63-Spring事务的失效原因" class="headerlink" title="63.Spring事务的失效原因"></a>63.Spring事务的失效原因</h4><p>​    Q.53<br>​<br>​    自己捕获了异常<br>​    Q.73<br>​    内部调用</p>
<p>参考</p>
<p><img alt="41" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125203228.png"></p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/alex-next/tags/spring/" rel="tag"># spring</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/alex-next/2022/11/18/工具配置/docker部署halo博客/" rel="next" title="halo博客">
                  <i class="fa fa-chevron-left"></i> halo博客
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/alex-next/2022/12/24/面试题/计算机基础面试题/" rel="prev" title="计算机基础面试题">
                  计算机基础面试题 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="gitalk-container"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#参考"><span class="nav-number">1.</span> <span class="nav-text">参考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他"><span class="nav-number">2.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-谈谈你理解的Spring是什么"><span class="nav-number">2.1.</span> <span class="nav-text">1.谈谈你理解的Spring是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Spring的优缺点是什么"><span class="nav-number">2.2.</span> <span class="nav-text">2.Spring的优缺点是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-什么是SpringIOC容器，有什么用，优点是什么"><span class="nav-number">2.3.</span> <span class="nav-text">3.什么是SpringIOC容器，有什么用，优点是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-IOC的实现机制是什么"><span class="nav-number">2.4.</span> <span class="nav-text">==4.IOC的实现机制是什么==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-IOC和DI的区别是什么"><span class="nav-number">2.5.</span> <span class="nav-text">5.IOC和DI的区别是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-紧耦合和松耦合有什么区别？如何编写松耦合代码"><span class="nav-number">2.6.</span> <span class="nav-text">6.紧耦合和松耦合有什么区别？如何编写松耦合代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-BeanFactory和ApplicationContext有什么区别"><span class="nav-number">2.7.</span> <span class="nav-text">==9.BeanFactory和ApplicationContext有什么区别==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-BeanFactory和FactoryBean有什么区别"><span class="nav-number">2.8.</span> <span class="nav-text">==10.BeanFactory和FactoryBean有什么区别==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-什么是Spring-Bean，JavaBean和SpringBean和对象的区别"><span class="nav-number">2.9.</span> <span class="nav-text">13.什么是Spring Bean，JavaBean和SpringBean和对象的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-配置Bean有哪几种方式"><span class="nav-number">2.10.</span> <span class="nav-text">14.配置Bean有哪几种方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-Spring支持的Bean的作用域"><span class="nav-number">2.11.</span> <span class="nav-text">15.Spring支持的Bean的作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-单例Bean的优势"><span class="nav-number">2.12.</span> <span class="nav-text">16.单例Bean的优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-Spring的bean是线程安全吗"><span class="nav-number">2.13.</span> <span class="nav-text">==17.Spring的bean是线程安全吗==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-Spring如何处理线程并发问题"><span class="nav-number">2.14.</span> <span class="nav-text">==18.Spring如何处理线程并发问题==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#33-Spring有哪几种配置方式"><span class="nav-number">2.15.</span> <span class="nav-text">33.Spring有哪几种配置方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#34-JavaConfig是如何替代spring-xml的"><span class="nav-number">2.16.</span> <span class="nav-text">==34.JavaConfig是如何替代spring.xml的==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#42-Configuration的作用及解析原理"><span class="nav-number">2.17.</span> <span class="nav-text">==42.@Configuration的作用及解析原理==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#64-Spring事件监听机制"><span class="nav-number">2.18.</span> <span class="nav-text">64.Spring事件监听机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#65-Spring中都用到了哪些设计模式"><span class="nav-number">2.19.</span> <span class="nav-text">==65.Spring中都用到了哪些设计模式==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#66-Spring是如何整合Mybatis管理Mapper接口的"><span class="nav-number">2.20.</span> <span class="nav-text">66.Spring是如何整合Mybatis管理Mapper接口的</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IOC加载流程"><span class="nav-number">3.</span> <span class="nav-text">IOC加载流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-SpringIOC容器的加载过程"><span class="nav-number">3.1.</span> <span class="nav-text">==11.SpringIOC容器的加载过程==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-SpringIOC有哪些扩展点，在什么时候调用"><span class="nav-number">3.2.</span> <span class="nav-text">==12.SpringIOC有哪些扩展点，在什么时候调用==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-Spring在加载过程中Bean哪有几种形态"><span class="nav-number">3.3.</span> <span class="nav-text">==24.Spring在加载过程中Bean哪有几种形态==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注册BeanDefinition"><span class="nav-number">3.4.</span> <span class="nav-text">注册BeanDefinition</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#8-BeanDefinition的作用"><span class="nav-number">3.4.1.</span> <span class="nav-text">==8.BeanDefinition的作用==</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#28-描述BeanDefinition的加载过程"><span class="nav-number">3.4.2.</span> <span class="nav-text">28.描述BeanDefinition的加载过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#31-spring启动时，为什么先加载BeanFactoryPostProcessor"><span class="nav-number">3.4.3.</span> <span class="nav-text">31.spring启动时，为什么先加载BeanFactoryPostProcessor</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#解析注解-系统的BeanDefinitionRegistryPostProcessor"><span class="nav-number">3.4.4.</span> <span class="nav-text">解析注解(系统的BeanDefinitionRegistryPostProcessor)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#45-为什么-ComponentScan不设置basePackage也会扫描"><span class="nav-number">3.4.4.1.</span> <span class="nav-text">45.为什么@ComponentScan不设置basePackage也会扫描</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#35-Controller-Component-Repository-Service有什么区别"><span class="nav-number">3.4.4.2.</span> <span class="nav-text">35.@Controller,@Component,@Repository,@Service有什么区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#36-Import可以有几种用法"><span class="nav-number">3.4.4.3.</span> <span class="nav-text">36.@Import可以有几种用法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#43-Bean的方法调用怎么保证单例"><span class="nav-number">3.4.4.4.</span> <span class="nav-text">==43.@Bean的方法调用怎么保证单例==</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#32-Bean的生产顺序-BeanDefinition的注册顺序-是由什么决定的"><span class="nav-number">3.4.4.5.</span> <span class="nav-text">==32.Bean的生产顺序(BeanDefinition的注册顺序)是由什么决定的==</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#44-将第三方的类配置成bean有哪些方式"><span class="nav-number">3.4.4.6.</span> <span class="nav-text">==44.将第三方的类配置成bean有哪些方式==</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BeanFactoryPostProcessor"><span class="nav-number">3.4.5.</span> <span class="nav-text">BeanFactoryPostProcessor</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#29-如何在所有BeanDefinition注册完后做扩展"><span class="nav-number">3.4.5.1.</span> <span class="nav-text">29.如何在所有BeanDefinition注册完后做扩展</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建Bean"><span class="nav-number">3.5.</span> <span class="nav-text">创建Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-BeanFactory的作用"><span class="nav-number">3.5.1.</span> <span class="nav-text">==7.BeanFactory的作用==</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#25-解释Spring框架中Bean的生命周期"><span class="nav-number">3.5.2.</span> <span class="nav-text">==25.解释Spring框架中Bean的生命周期==</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实例化"><span class="nav-number">3.5.3.</span> <span class="nav-text">实例化</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#19-Spring实例化Bean有几种方式"><span class="nav-number">3.5.3.1.</span> <span class="nav-text">19.Spring实例化Bean有几种方式</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#属性赋值"><span class="nav-number">3.5.4.</span> <span class="nav-text">属性赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#20-什么是bean的自动装配-装配"><span class="nav-number">3.5.4.1.</span> <span class="nav-text">20.什么是bean的自动装配(装配)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#21-自动注入有什么限制-需要注意"><span class="nav-number">3.5.4.2.</span> <span class="nav-text">21.自动注入有什么限制(需要注意)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#22-自动装配方式有几种"><span class="nav-number">3.5.4.3.</span> <span class="nav-text">22.自动装配方式有几种</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#26-Spring如何解决bean的循环依赖"><span class="nav-number">3.5.4.4.</span> <span class="nav-text">==26.Spring如何解决bean的循环依赖(*)==</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#27-Spring如何在并发下避免获取不完整的Bean"><span class="nav-number">3.5.4.5.</span> <span class="nav-text">==27.Spring如何在并发下避免获取不完整的Bean==</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#37-如何让自动注入没有找到依赖Bean时不会报错"><span class="nav-number">3.5.4.6.</span> <span class="nav-text">37.如何让自动注入没有找到依赖Bean时不会报错</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#38-如何让自动注入找到多个依赖Bean不会报错"><span class="nav-number">3.5.4.7.</span> <span class="nav-text">38.如何让自动注入找到多个依赖Bean不会报错</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#39-Autowired有什么作用"><span class="nav-number">3.5.4.8.</span> <span class="nav-text">39.@Autowired有什么作用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#属性注入方式"><span class="nav-number">3.5.4.9.</span> <span class="nav-text">属性注入方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#40-Autowired和-Resource的区别"><span class="nav-number">3.5.4.10.</span> <span class="nav-text">40.@Autowired和@Resource的区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#41-Autowired注解自动装配底层原理"><span class="nav-number">3.5.4.11.</span> <span class="nav-text">==41.@Autowired注解自动装配底层原理==</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#初始化"><span class="nav-number">3.5.5.</span> <span class="nav-text">初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#23-Bean有哪些生命周期回调方法，有哪几种实现方式"><span class="nav-number">3.5.5.1.</span> <span class="nav-text">==23.Bean有哪些生命周期回调方法，有哪几种实现方式==</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#30-如何在所有bean创建完后做扩展"><span class="nav-number">3.5.6.</span> <span class="nav-text">==30.如何在所有bean创建完后做扩展==</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOP"><span class="nav-number">4.</span> <span class="nav-text">AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#46-什么是AOP，能做什么"><span class="nav-number">4.1.</span> <span class="nav-text">46.什么是AOP，能做什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#47-解释Spring-AOP常见的概念名词"><span class="nav-number">4.2.</span> <span class="nav-text">47.解释Spring AOP常见的概念名词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#48-Spring通知有哪些类型"><span class="nav-number">4.3.</span> <span class="nav-text">48.Spring通知有哪些类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#49-Spring-AOP和Aspectj-AOP有什么区别"><span class="nav-number">4.4.</span> <span class="nav-text">49.Spring AOP和Aspectj AOP有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#50-JDK动态代理和CGLIB动态代理"><span class="nav-number">4.5.</span> <span class="nav-text">50.JDK动态代理和CGLIB动态代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#51-JavaConfig如何启用AOP，如何强制使用cglib"><span class="nav-number">4.6.</span> <span class="nav-text">51.JavaConfig如何启用AOP，如何强制使用cglib</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#52-介绍AOP有几种实现方式"><span class="nav-number">4.7.</span> <span class="nav-text">52.介绍AOP有几种实现方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#53-什么情况下AOP会失效，怎么解决"><span class="nav-number">4.8.</span> <span class="nav-text">53.什么情况下AOP会失效，怎么解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#54-Spring-AOP在哪里创建的动态代理"><span class="nav-number">4.9.</span> <span class="nav-text">==54.Spring AOP在哪里创建的动态代理==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#55-描述AOP的完整实现流程"><span class="nav-number">4.10.</span> <span class="nav-text">==55.描述AOP的完整实现流程==</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事务"><span class="nav-number">5.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#56-事务四大特性"><span class="nav-number">5.1.</span> <span class="nav-text">56.事务四大特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#57-Spring支持的事务管理类型，Spring事务实现方式有哪些"><span class="nav-number">5.2.</span> <span class="nav-text">57.Spring支持的事务管理类型，Spring事务实现方式有哪些</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#58-说一下Spring的事务传播行为"><span class="nav-number">5.3.</span> <span class="nav-text">==58.说一下Spring的事务传播行为==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#59-说一下Spring的事务隔离级别"><span class="nav-number">5.4.</span> <span class="nav-text">==59.说一下Spring的事务隔离级别==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#60-Spring事务实现原理"><span class="nav-number">5.5.</span> <span class="nav-text">==60.Spring事务实现原理==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#61-Spring事务传播行为实现原理"><span class="nav-number">5.6.</span> <span class="nav-text">==61.Spring事务传播行为实现原理==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#62-Spring多线程事务能否保证事务的一致性"><span class="nav-number">5.7.</span> <span class="nav-text">==62.Spring多线程事务能否保证事务的一致性==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#63-Spring事务的失效原因"><span class="nav-number">5.8.</span> <span class="nav-text">63.Spring事务的失效原因</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/alex-next/images/avatar.jpg"
      alt="alex">
  <p class="site-author-name" itemprop="name">alex</p>
  <div class="site-description" itemprop="description">时光静好,与君语;细水流年,与君同;繁华落尽,与君老.</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/alex-next/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/alex-next/categories/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/alex-next/tags/">
          
        
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/alex-next/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">alex</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/alex-next/lib/anime.min.js?v=3.1.0"></script>
  <script src="/alex-next/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/alex-next/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script src="/alex-next/lib/pjax/pjax.min.js?v=0.2.8"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
<script src="/alex-next/js/utils.js?v=7.4.0"></script><script src="/alex-next/js/motion.js?v=7.4.0"></script>
<script src="/alex-next/js/schemes/pisces.js?v=7.4.0"></script>
<script src="/alex-next/js/next-boot.js?v=7.4.0"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var id = element.id || '';
    var src = element.src || '';
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (id !=='') {
      script.id = element.id;
    }
    if (src !== '') {
      script.src = src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  








  <script src="/alex-next/js/local-search.js?v=7.4.0"></script>













    <div id="pjax">

  

  
    
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    
  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: '84888b5ba3be0f56b2ed',
      clientSecret: '1306406ecbdc02b679df3c95b94985753d302d6a',
      repo: 'alex-next',
      owner: 'alexander-wd',
      admin: ['alexander-wd'],
      id: '49849800f3fb45fa77483f27bafe23b5',
        language: 'zh-CN',
      
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script>

    </div>
</body>
</html>
