<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/alex-next/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/alex-next/images/favicon.ico?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/alex-next/images/favicon.ico?v=7.4.0">
  <link rel="mask-icon" href="/alex-next/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/alex-next/atom.xml" title="alex的博客 - github.com" type="application/atom+xml">

<link rel="stylesheet" href="/alex-next/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/alex-next/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/alex-next/',
    scheme: 'Pisces',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: true,
    pangu: true,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="时光静好,与君语;细水流年,与君同;繁华落尽,与君老.">
<meta name="keywords" content="python">
<meta property="og:type" content="website">
<meta property="og:title" content="alex的博客 - github.com">
<meta property="og:url" content="https://alexander-wd.github.io/page/3/index.html">
<meta property="og:site_name" content="alex的博客 - github.com">
<meta property="og:description" content="时光静好,与君语;细水流年,与君同;繁华落尽,与君老.">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="alex的博客 - github.com">
<meta name="twitter:description" content="时光静好,与君语;细水流年,与君同;繁华落尽,与君老.">
  <link rel="canonical" href="https://alexander-wd.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>alex的博客 - github.com</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/alex-next/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">alex的博客 - github.com</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/alex-next/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/alex-next/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/alex-next/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/alex-next/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/alexander-wd" class="github-corner" title="alex GitHub" aria-label="alex GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://alexander-wd.github.io/alex-next/2022/06/01/javaEE/spring源码/spring源码(一)--IOC容器整体/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="alex">
      <meta itemprop="description" content="时光静好,与君语;细水流年,与君同;繁华落尽,与君老.">
      <meta itemprop="image" content="/alex-next/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="alex的博客 - github.com">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/alex-next/2022/06/01/javaEE/spring源码/spring源码(一)--IOC容器整体/" class="post-title-link" itemprop="url">spring源码(一)--IOC容器整体</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2022-06-01 22:10:20" itemprop="dateCreated datePublished" datetime="2022-06-01T22:10:20+08:00">2022-06-01</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-13 17:41:12" itemprop="dateModified" datetime="2023-02-13T17:41:12+08:00">2023-02-13</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/alex-next/categories/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="IOC容器源码-大体"><a href="#IOC容器源码-大体" class="headerlink" title="IOC容器源码(大体)"></a>IOC容器源码(大体)</h2><h3 id="1-整体介绍"><a href="#1-整体介绍" class="headerlink" title="1.整体介绍"></a>1.整体介绍</h3><ul>
<li><p>IOC控制反转的意义</p>
<ul>
<li>当一个依赖的类改变了，不用处处都改，只需要改变IOC容器中的bean</li>
</ul>
</li>
<li><p>BeanFactory和ApplicationContext区别</p>
</li>
<li><p>循环依赖</p>
<ul>
<li>设置三级缓存解决</li>
</ul>
</li>
<li><p>扩展点</p>
<ul>
<li>集成其他框架时，用的非常多</li>
<li><p>BeanFactoryPostProcessor</p>
<ul>
<li>集成其他框架时，用的非常多</li>
</ul>
</li>
<li><p>BeanDefinitionRegistryPostProcessor</p>
<ul>
<li>用于注册扩展的bean定义，相当于“增加图纸”</li>
</ul>
</li>
</ul>
</li>
<li><p>问题</p>
<ul>
<li>描述下BeanFactory</li>
<li><p>BeanFactory和ApplicationContext的区别</p>
<ul>
<li>BeanFactory是spring的顶层核心接口，工厂只负责按照要求(beanDefinition)生产bean，要生产成什么样由ApplicationContext决定</li>
<li>ApplicationContext面向的是用户，需要提供各种人性化的服务，继承了BeanFactory，离开了BeanFactory生产不了bean(就行各种店铺离不开工厂)</li>
</ul>
</li>
<li><p>简述SpringIOC的加载过程</p>
</li>
<li><p>简述Bean的生命周期</p>
<ul>
<li><p>实例化</p>
<ul>
<li><ol>
<li>实例化Bean对象，这个时候Bean的对象是非常低级的，基本不能够被我们使用，因为连最基本的属性都没有设置，可以理解为 连Autowired注解都是没有解析的； </li>
</ol>
</li>
</ul>
</li>
<li><p>属性注入</p>
<ul>
<li><ol>
<li>填充属性，当做完这一步，Bean对象基本是完整的了，可以理解为Autowired注解已经解析完毕，依赖注入完成了； </li>
</ol>
</li>
</ul>
</li>
<li><p>初始化Initialization</p>
<ul>
<li><p>invokeAwareMethods</p>
<ul>
<li><ol>
<li>如果Bean实现了BeanNameAware接口，则调用setBeanName方法； </li>
</ol>
</li>
<li><ol>
<li>如果Bean实现了BeanClassLoaderAware接口，则调用setBeanClassLoader方法；</li>
</ol>
</li>
<li><ol>
<li>如果Bean实现了BeanFactoryAware接口，则调用setBeanFactory方法； </li>
</ol>
</li>
</ul>
</li>
<li><ol>
<li>调用BeanPostProcessor的postProcessBeforeInitialization方法；</li>
</ol>
</li>
<li><p>init</p>
<ul>
<li><ol>
<li>如果Bean实现了InitializingBean接口，调用afterPropertiesSet方法； </li>
</ol>
</li>
<li><ol>
<li>如果Bean定义了init-method方法，则调用Bean的init-method方法；</li>
</ol>
</li>
<li><ol>
<li>调用BeanPostProcessor的postProcessAfterInitialization方法；当进行到这一步，Bean已经被准备就绪了，一直停留在应用的 上下文中，直到被销毁；</li>
</ol>
</li>
</ul>
</li>
<li><p>close()</p>
<ul>
<li><ol>
<li>如果应用的上下文被销毁了，如果Bean实现了DisposableBean接口，则调用destroy方法，如果Bean定义了destory-method 声明了销毁方法也会被调用。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Spring中有哪些扩展接口及调用时机</p>
<ul>
<li>BeanFactoryPostProcessor</li>
<li>FactoryBean</li>
<li>BeanPostProcessor</li>
<li>初始化生命周期回调方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-源码介绍-IOC容器初始化过程"><a href="#2-源码介绍-IOC容器初始化过程" class="headerlink" title="2.源码介绍(IOC容器初始化过程)"></a>2.源码介绍(IOC容器初始化过程)</h3><ul>
<li><p>源码编译</p>
<ul>
<li><p>问题</p>
<ul>
<li><p>Error resolving plugin</p>
</li>
<li><p>Kotlin: warnings found and -Werror specified</p>
</li>
<li><p>CoroutinesRegistrar不存在</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用配置类的设计理念更先进</p>
</li>
<li><p>问题</p>
<ul>
<li><p>FactoryBean和BeanFactory区别</p>
<ul>
<li>FactoryBean就是一个扩展点，BeanFactory是使用了简单工厂模式，用于生产bean</li>
</ul>
</li>
<li><p>BeanFactoryPostProcessor和BeanPostProcessor区别</p>
<ul>
<li>BeanFactoryPostProcessor用于扩展bean定义，BeanPostProcessor用于扩展bean</li>
</ul>
</li>
<li><p>介绍下BeanFactoryPostProcessor在Spring中的用途</p>
<ul>
<li>扩展点，mybatis基于此与spring集成</li>
</ul>
</li>
<li><p>@Component、@Import和@Bean区别</p>
<ul>
<li>@Component无法注入接口，只能注入类，@Bean可以自定义实现，可以控制bean的实例化过程，可以注入接口的实现类</li>
<li><p>@Import可以批量注入，可以导入不在扫描范围里的Bean，所以集成第三方框架一般都用@Import</p>
<ul>
<li><p>ImportSelector无法改变Bean的使用顺序，如Springboot中想要自定义某个默认的Bean(SqlSessionFactory)，就不能实现</p>
<ul>
<li>@ConditionalOnBean(SqlSessionFactory.class)配置了该bean，才注册</li>
<li>可以使用DeffredImportSelector，最后导入</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="AnnotationConfigApplicationContext-MainConfig-class"><a href="#AnnotationConfigApplicationContext-MainConfig-class" class="headerlink" title="AnnotationConfigApplicationContext(MainConfig.class)"></a>AnnotationConfigApplicationContext(MainConfig.class)</h3><ul>
<li><p>this();</p>
<ul>
<li><p>this.beanFactory = new DefaultListableBeanFactory();</p>
<p>调用父类的构造函数，初始化BeanFactory</p>
<ul>
<li><p>解释</p>
<ul>
<li>调用父类的构造函数，初始化BeanFactory</li>
<li>DefaultListableBeanFactory还继承了BeanDefinitionRegistry的功能</li>
<li>DefaultListableBeanFactory属性</li>
</ul>
</li>
</ul>
</li>
<li><p>this.reader = new AnnotatedBeanDefinitionReader(this);</p>
<ul>
<li><p>解释</p>
<ul>
<li><p>注册spring内置的PostProcessor到BeanDefinitionMap中，这几个类是spring的创始类</p>
<ul>
<li><p>AutowiredAnnotationBeanPostProcessor</p>
<p>用于解析@Autowired</p>
</li>
<li><p>internalConfigurationAnnotationProcessorConfigurationClassPostProcessor</p>
<p>在这个类中，会解析加了@Configuration的配置类，还会解析@ComponentScan、@ComponentScans注解扫描的包，以及解析@Import等注解。</p>
</li>
<li><p>RequiredAnnotationBeanPostProcessor</p>
<p>用于解析@Required</p>
</li>
<li><p>CommonAnnotationBeanPostProcessor</p>
<p>它负责解析<br>@Resource、@WebServiceRef、@EJB三个注解。<br>这三个注解都是定义在javax.*包下的注解，属于java中的注解。</p>
</li>
<li><p>EventListenerMethodProcessor</p>
</li>
<li><p>DefaultEventListenerFactory</p>
<p>负责创建监听器：ApplicationListenerMethodAdapter<br>为标注了@EventListener的方法<br>创建调用监听适配器：ApplicationListenerMethodAdapter</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);</p>
<p>public static Set<beandefinitionholder> registerAnnotationConfigProcessors(</beandefinitionholder></p>
<pre><code>  BeanDefinitionRegistry registry, @Nullable Object source) {
</code></pre><p>   DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);<br>   if (beanFactory != null) {</p>
<pre><code>  if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {
     //注册了实现Order接口的排序器
     beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);
  }
  //设置@AutoWired的候选的解析器：ContextAnnotationAutowireCandidateResolver
  // getLazyResolutionProxyIfNecessary方法，它也是唯一实现。
  //如果字段上带有@Lazy注解，表示进行懒加载 Spring不会立即创建注入属性的实例，而是生成代理对象，来代替实例
  if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {
     beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());
  }
</code></pre><p>   }</p>
<p>   Set<beandefinitionholder> beanDefs = new LinkedHashSet&lt;&gt;(8);</beandefinitionholder></p>
<p>   /**</p>
<pre><code>* 为我们容器中注册了解析我们配置类的后置处理器ConfigurationClassPostProcessor
* 名字叫:org.springframework.context.annotation.internalConfigurationAnnotationProcessor
*/
</code></pre><p>   if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {</p>
<pre><code>  RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
  def.setSource(source);
  beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
</code></pre><p>   }</p>
<p>   /**</p>
<pre><code>* 为我们容器中注册了处理@Autowired 注解的处理器AutowiredAnnotationBeanPostProcessor
* 名字叫:org.springframework.context.annotation.internalAutowiredAnnotationProcessor
*/
</code></pre><p>   if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {</p>
<pre><code>  RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);
  def.setSource(source);
  beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
</code></pre><p>   }</p>
<p>   /**</p>
<pre><code>* 为我们容器中注册处理@Required属性的注解处理器RequiredAnnotationBeanPostProcessor
* 名字叫:org.springframework.context.annotation.internalRequiredAnnotationProcessor
*/
</code></pre><p>   if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {</p>
<pre><code>  RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);
  def.setSource(source);
  beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
</code></pre><p>   }</p>
<p>   /**</p>
<pre><code>* 为我们容器注册处理JSR规范的注解处理器CommonAnnotationBeanPostProcessor
* org.springframework.context.annotation.internalCommonAnnotationProcessor
*/
</code></pre><p>   if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {</p>
<pre><code>  RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);
  def.setSource(source);
  beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));
</code></pre><p>   }</p>
<p>   /**</p>
<pre><code>* 处理jpa注解的处理器org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor
*/
</code></pre><p>   if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {</p>
<pre><code>  RootBeanDefinition def = new RootBeanDefinition();
  try {
     def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,
           AnnotationConfigUtils.class.getClassLoader()));
  }
  catch (ClassNotFoundException ex) {
     throw new IllegalStateException(
           &quot;Cannot load optional framework class: &quot; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);
  }
  def.setSource(source);
  beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));
</code></pre><p>   }</p>
<p>   /**</p>
<pre><code>* 处理监听方法的注解@EventListener解析器EventListenerMethodProcessor
*/
</code></pre><p>   if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {</p>
<pre><code>  RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);
  def.setSource(source);
  beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));
</code></pre><p>   }</p>
<p>   /**</p>
<pre><code>* 注册事件监听器工厂
*/
</code></pre><p>   if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {</p>
<pre><code>  RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);
  def.setSource(source);
  beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));
</code></pre><p>   }</p>
<p>   return beanDefs;<br>}</p>
<ul>
<li><p>registerPostProcessor()</p>
<p>注册某个具体的内置PostProcessor，会存放到BeanDefinitionMap中</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>this.scanner = new ClassPathBeanDefinitionScanner(this);</p>
<ul>
<li><p>解释</p>
<ul>
<li>会加载系统环境变量和资源读取器，并且里面定义了扫描包的核心方法doScan()</li>
<li>但是这里的scanner只用于applicationContext调用调度扫描包注册beanDefinition</li>
<li>还有个非常重要的地方，new ClassPathBeanDefinitionScanner的时候会调用registerDefaultFilters();在里面注册扫描时过滤候选component的includeFilters</li>
</ul>
</li>
<li><p>registerDefaultFilters();</p>
</li>
<li><p>setEnvironment(environment);</p>
<ul>
<li>设置环境对象</li>
</ul>
</li>
<li><p>setResourceLoader(resourceLoader);</p>
<ul>
<li>设置资源加载器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>register(componentClasses);</p>
<p>for (Class&lt;?&gt; annotatedClass : annotatedClasses) {<br>   registerBean(annotatedClass);<br>}</p>
<ul>
<li><p>解释</p>
<ul>
<li>将配置类(@Configuration标注的)注册到BeanDefinitionMap中。(这个类是启动容器的配置类)</li>
</ul>
</li>
</ul>
</li>
<li><p>refresh();</p>
<ul>
<li><p>invokeBeanFactoryPostProcessors(beanFactory);</p>
<ul>
<li><p>解释</p>
<ul>
<li>调用我们的bean工厂的后置处理器</li>
<li>会在此将class扫描成beanDefinition到beanDefinitionMap中</li>
<li>bean工厂的后置处理器调用</li>
</ul>
</li>
<li><p>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</p>
<ul>
<li><p>解释</p>
<ul>
<li>if (beanFactory instanceof BeanDefinitionRegistry)可以发现这句代码，如果是applicationContext就进入，有众多流程</li>
<li><p>若仅仅是beanFactory，则执行如下代码</p>
<p>invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</p>
</li>
</ul>
</li>
<li><p>invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</p>
<ul>
<li><p>解释</p>
<ul>
<li>获取容器中的ConfigurationClassPostProcessor的后置处理器进行bean定义的扫描，解析@Bean,@Component,@Service等等注解，添加到beanDefinitionMap中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>getBeanFactoryPostProcessors()</p>
<ul>
<li>我们自己调用addBeanFactoryPostProcessor的自定义BeanFactoryPostProcessor</li>
</ul>
</li>
</ul>
</li>
<li><p>registerBeanPostProcessors(beanFactory);</p>
<ul>
<li><p>解释</p>
<ul>
<li>注册BeanPostProcessor</li>
</ul>
</li>
<li><p>后置处理器9处调用</p>
</li>
<li><p>registerBeanPostProcessors</p>
<ul>
<li><p>注册主要的几个BeanPostProcessor</p>
<ul>
<li><p>AutowiredAnnotationBeanPostProcessor</p>
<p>解析@Autowired</p>
</li>
<li><p>RequiredAnnotationBeanPostProcessor</p>
<p>解析@Required</p>
</li>
<li><p>CommonAnnotationBeanPostProcessor</p>
<p>解析@Resource、@WebServiceRef、@EJB</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>finishBeanFactoryInitialization(beanFactory);</p>
<ul>
<li><p>解释</p>
<ul>
<li>整个bean的创建过程</li>
</ul>
</li>
<li><p>beanFactory.preInstantiateSingletons();</p>
<p>实例化单例bean</p>
<ul>
<li><p>getBean</p>
<ul>
<li><p>doGetBean</p>
<ul>
<li>实例化createBean</li>
<li>属性注入@Autowired   @Value</li>
<li><p>初始化initMethod   destroy</p>
<ul>
<li>Aware</li>
<li>@PostConstruct</li>
<li>InitializingBean</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><ul>
<li><p>spring底层核心常用注解</p>
<ul>
<li><p>1.配置</p>
<ul>
<li>@Configuration</li>
<li>@Bean</li>
</ul>
</li>
<li><p>2.包扫描</p>
<ul>
<li><p>@ComponentScan</p>
<ul>
<li>excludeFilters</li>
<li>includeFilters</li>
<li>Filter</li>
</ul>
</li>
</ul>
</li>
<li><p>3.配置bean的作用域</p>
<ul>
<li><p>@Scope</p>
<ul>
<li>a) singleton 单实例的(默认) </li>
<li>b) prototype 多实例的 </li>
<li>c) request 同一次请求 </li>
<li>d) session 同一个会话级别</li>
</ul>
</li>
</ul>
</li>
<li><p>4.Bean的懒加载</p>
<ul>
<li>@Lazy</li>
</ul>
</li>
<li><p>5.条件判断</p>
<ul>
<li>@Conditional</li>
</ul>
</li>
<li><p>6.往IOC中添加组件</p>
<ul>
<li><p>@CompentScan +@Controller @Service @Respository @compent</p>
<ul>
<li>针对我们自己写的组件可以通过该方式来进行加载到容器中。</li>
</ul>
</li>
<li><p>@Bean</p>
<ul>
<li>适用于导入第三方组件的类</li>
</ul>
</li>
<li><p>@Import</p>
<ul>
<li>导入组件的id为全类名路径</li>
<li>ImportSelector</li>
<li>ImportBeanDefinitionRegister</li>
</ul>
</li>
<li><p>实现FactoryBean</p>
</li>
</ul>
</li>
<li><p>7.Bean的初始化和销毁方法</p>
<ul>
<li>@Bean(initMethod = “init”,destroyMethod = “destroy”)</li>
<li>实现InitializingBean和DisposableBean</li>
<li>使用@PostConstruct 和@ProDestory标注方法</li>
<li>实现BeanPostProcessor重写postProcessBeforeInitialization和postProcessAfterInitialization</li>
</ul>
</li>
<li><p>8.给组件赋值</p>
<ul>
<li>@Value +@PropertySource</li>
</ul>
</li>
<li><p>9.自动装配</p>
<ul>
<li>@Autowired</li>
<li><p>@Qualifier</p>
<ul>
<li>指定特定的bean装配，===在@bean后加@Primary</li>
</ul>
</li>
<li><p>@Resource</p>
</li>
<li>@Inject</li>
</ul>
</li>
<li><p>10.使用IOC的组件，如ApplicationContext</p>
<ul>
<li>实现XXXAware接口</li>
</ul>
</li>
<li><p>11.@Profile</p>
<ul>
<li>根据不同环境激活bean</li>
<li>运行时jvm参数来切换 -Dspring.profiles.active=test|dev|prod</li>
</ul>
</li>
</ul>
</li>
<li><p>IOC容器整体加载流程图</p>
</li>
<li>IOC容器整体加载流程图(详细)</li>
<li>spring设计模式</li>
<li><p>spring源码脑图</p>
</li>
<li><p>spring中文文档</p>
</li>
<li><p>IOC概念</p>
</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://alexander-wd.github.io/alex-next/2022/05/28/javaEE/mysql深入/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="alex">
      <meta itemprop="description" content="时光静好,与君语;细水流年,与君同;繁华落尽,与君老.">
      <meta itemprop="image" content="/alex-next/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="alex的博客 - github.com">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/alex-next/2022/05/28/javaEE/mysql深入/" class="post-title-link" itemprop="url">mysql深入学习笔记</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2022-05-28 12:03:12" itemprop="dateCreated datePublished" datetime="2022-05-28T12:03:12+08:00">2022-05-28</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-13 17:58:43" itemprop="dateModified" datetime="2023-02-13T17:58:43+08:00">2023-02-13</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/alex-next/categories/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><h2 id="1-索引底层原理"><a href="#1-索引底层原理" class="headerlink" title="1.索引底层原理"></a>1.索引底层原理</h2><h3 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h3><p>索引是帮助MySQL高效获取数据的排好序的数据结构</p>
<ul>
<li><p>二叉树</p>
<ul>
<li>若插入数据有顺序，会退化成链表</li>
</ul>
</li>
<li><p>红黑树</p>
<ul>
<li>若查找元素为叶子结点，树的高度依旧很高，效率变低</li>
</ul>
</li>
<li><p>Hash表</p>
<ul>
<li></li>
<li>仅能进行等值查询，不支持范围查询</li>
</ul>
</li>
<li><p>B Tree</p>
<ul>
<li>结构</li>
</ul>
</li>
<li><p>B+Tree(mysql采用)</p>
<ul>
<li>结构</li>
<li>mysql设置页大小为16KB(show global status like ‘Innodb_page_size’)，索引存放大小8B(bigint)，页地址大小6B，一页可放1170个结点，只需三次I/O操作(若一开始，就将根节点放入常驻内存，I/O次数会更少)  注：叶子节点会存放数据，一行数据最多算1KB，页大小有16KB，叶子节点一页可以放16个结点。mysql每次会取一页放入bufferpool</li>
</ul>
</li>
<li><p>B树和B+树</p>
<ul>
<li>节点中的数据索引从左到右递增排列</li>
<li><p>B+树叶子结点用指针连接</p>
<ul>
<li>与范围查找相关如rol&gt;20:B+树可以顺着找到的结点找下去，而B树只能从根节点重新找</li>
</ul>
</li>
<li><p>按照B树，一个结点1KB的数据，一页能放16个结点，树的高度要远远大于3</p>
</li>
</ul>
</li>
<li><p>问题</p>
<ul>
<li><p>为什么用B+树不用B树</p>
<ul>
<li>按照B树，一个结点1KB的数据，一页能放16个结点，树的高度要远远大于3</li>
<li>与范围查找相关，如rol&gt;20:B+树可以顺着找到的结点找下去，而B树只能从根节点重新找</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="存储引擎-针对表"><a href="#存储引擎-针对表" class="headerlink" title="存储引擎(针对表)"></a>存储引擎(针对表)</h3><ul>
<li><p>MyISAM</p>
<ul>
<li>存储结构</li>
<li>先根据MYI文件找出具体的索引值，在从MYD文件中找出数据</li>
<li>非聚集索引(MyISAM、非主键索引等需要回表的索引)：索引和数据分开存储</li>
</ul>
</li>
<li><p>Innodb</p>
<ul>
<li>存储结构</li>
<li>聚集索引：索引和数据存在一起（叶子结点包含了完整的数据记录）</li>
</ul>
</li>
<li><p>问题</p>
<ul>
<li><p>为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键？</p>
<ul>
<li><p>为什么必须要有主键</p>
<ul>
<li>如果设置了主键，就会使用主键作为聚集索引。</li>
<li>如果你没有创建主键，他会寻找一个不为null的字段作为主键索引。</li>
<li>如果还是没有则会隐式的创建一个字段作为主键。</li>
</ul>
</li>
<li><p>为什么使用整型</p>
<ul>
<li>1.整型比较比字符串要快，因为字符串要逐个比较ASCII值，节省硬盘空间；整型容易比较大小进行排序</li>
</ul>
</li>
<li><p>为什么要求自增</p>
<ul>
<li>mysql为了维护索引的有序性，使得新增的主键会在B+tree叶子节点中最后末尾添加，使得树分叉概率变小</li>
<li>换句话说，如果不是自增的，B+树会自己做调整，分裂出新节点，效率不如自增</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么非主键索引结构叶子节点存储的是主键值？</p>
<ul>
<li>1.节省存储空间</li>
<li>2.一致性：若非主键索引也存了完整的数据记录，那么非主键索引和主键索引的索引文件要保证数据一致性的问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="联合索引-复合索引"><a href="#联合索引-复合索引" class="headerlink" title="联合索引(复合索引)"></a>联合索引(复合索引)</h3><ul>
<li></li>
<li><p>最左前缀原理</p>
<ul>
<li>B+树底层就是排好序的，如果不按最左前缀，是乱序的</li>
</ul>
</li>
</ul>
<h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>如果索引的列在 select 所需获得的列中（因为在 mysql 中索引是根据索引列的值进行排序的，所以索引节点中存在该列中的部分值）或者根据一次索引查询就能获得记录就不需要回表，如果 select 所需获得列中有大量的非索引列，索引就需要到表中找到相应的列的信息，这就叫回表。</p>
<ul>
<li>图解</li>
<li>参考</li>
</ul>
<h2 id="2-索引之explain"><a href="#2-索引之explain" class="headerlink" title="2.索引之explain"></a>2.索引之explain</h2><h3 id="重要的原则"><a href="#重要的原则" class="headerlink" title="重要的原则"></a>重要的原则</h3><ul>
<li>如果发现使用索引还不如全表扫描的效率（非主键索引会回表），会放弃使用索引，这里的索引一般为非主键索引。</li>
</ul>
<h3 id="1-id"><a href="#1-id" class="headerlink" title="1.id"></a>1.id</h3><ul>
<li>id越大执行的优先级越高</li>
</ul>
<h3 id="2-select-type"><a href="#2-select-type" class="headerlink" title="2.select_type"></a>2.select_type</h3><p>select_type 表示对应行是简单还是复杂的查询。</p>
<ul>
<li><p>simple:简单查询</p>
<ul>
<li>explain select * from film where id = 2;</li>
</ul>
</li>
<li><p>primary:复杂查询最外层的select</p>
</li>
<li>subquery：包含在 select 中的子查询（不在 from 子句中）</li>
<li>derived：包含在 from 子句中的子查询。</li>
<li><p>union：在 union 中的第二个和随后的 select</p>
<ul>
<li>explain select 1 union all select 1;</li>
</ul>
</li>
</ul>
<h3 id="3-table"><a href="#3-table" class="headerlink" title="3.table"></a>3.table</h3><ul>
<li>这一列表示 explain 的一行正在访问哪个表</li>
</ul>
<h3 id="4-type"><a href="#4-type" class="headerlink" title="4.type"></a>4.type</h3><p>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。<br>依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL<br>一般来说，得保证查询达到range级别，最好达到ref<br>NULL：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表</p>
<ul>
<li>1.system：表中只有一条记录</li>
<li><p>2.const：表示通过索引一次就找到了，结果集只有一条</p>
<ul>
<li>select * from test01 where id  = 1;，其中id是primary key或者unique索引，并且最终只查出有且仅有一条数据。</li>
</ul>
</li>
<li><p>3.eq_ref：本表中和关联表表中的每行都能有且仅能组合成的一行</p>
</li>
<li>4.ref：不使用唯一索引，可能找出多个符合条件的行</li>
<li><p>5.range：只检索给定范围的行，一般就是在WHERE语句中出现了BETWEEN、&lt; &gt;、in等的查询。</p>
<ul>
<li>如select * from test01 where id&gt;1;</li>
</ul>
</li>
<li><p>6.index：扫描全索引就能拿到结果，不需要回表</p>
<ul>
<li>explain select id,empno from emp;其中empno为非主键索引</li>
<li>explain select id,empno,sal,comm from emp;其中id为主键，empno、sal、comm为复合索引，非主键索引数据中会存放id，方便回表</li>
<li>explain select empno,sal,comm from emp;</li>
</ul>
</li>
<li><p>7.all：全表扫描</p>
</li>
</ul>
<h3 id="5-possible-keys"><a href="#5-possible-keys" class="headerlink" title="5.possible_keys"></a>5.possible_keys</h3><ul>
<li>这一列显示查询可能使用哪些索引来查找。</li>
</ul>
<h3 id="6-key"><a href="#6-key" class="headerlink" title="6.key"></a>6.key</h3><ul>
<li>这一列显示mysql实际采用哪个索引来优化对该表的访问。</li>
</ul>
<h3 id="7-key-len"><a href="#7-key-len" class="headerlink" title="7.key_len"></a>7.key_len</h3><ul>
<li>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。</li>
<li>int:4字节；varchar(n):3n+2字节；如果字段允许为NULL，需要1字节记录是否为NULL</li>
</ul>
<h3 id="8-ref"><a href="#8-ref" class="headerlink" title="8.ref"></a>8.ref</h3><ul>
<li>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）</li>
</ul>
<h3 id="9-rows"><a href="#9-rows" class="headerlink" title="9.rows"></a>9.rows</h3><ul>
<li>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</li>
</ul>
<h3 id="10-Extra"><a href="#10-Extra" class="headerlink" title="10.Extra"></a>10.Extra</h3><ul>
<li><p>1.Using index:使用覆盖索引—提倡</p>
<p>  mysql执行计划explain结果里的key有使用索引，如果select后面查询的字段都可以从这个索引的树中<br>  获取，这种情况一般可以说是用到了覆盖索引，extra里一般都有using index；覆盖索引一般针对的是辅助索引，整个<br>  查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值</p>
<ul>
<li>数据在辅助索引中就能拿到，不需要通过辅助索引找到主键树拿数据</li>
</ul>
</li>
<li><p>2.Using where</p>
<ul>
<li>使用 where 语句来处理结果，并且查询的列未被索引覆盖</li>
<li>explain select * from actor where name = ‘a’;</li>
</ul>
</li>
<li><p>3.Using index condition</p>
<ul>
<li>查询的列不完全被索引覆盖，where条件中是一个前导列的范围；</li>
<li>explain select * from film_actor where film_id &gt; 1;</li>
</ul>
</li>
<li><p>4.Using temporary</p>
<p>  mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。</p>
<ul>
<li>explain select distinct name from actor;若name列无索引，会创建临时表；若name列有索引，就会随着索引树去重</li>
</ul>
</li>
<li><p>5.Using filesort</p>
<p>  将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一<br>  般也是要考虑使用索引来优化的。</p>
<ul>
<li>通常就是要排序的列没有创建索引，而造成外部排序，数据小的时候用内存排序，数据大的时候会用磁盘排序(速度慢)</li>
</ul>
</li>
</ul>
<h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><ul>
<li><p>explain select * from emp where empno = 10002 and ename like ‘aa%’ and job like ‘a%’;(见第四节)</p>
<ul>
<li>empno,ename,job是复合索引，按照B+Tree分析ename是有序的，根据aa%条件，我觉得这相当于范围查询，而不是等值查询啊，若是范围查询，job是无序的，自然用不上索引；所以我认为只有empno和ename能用到索引，但事实确是empno,ename,job都能用到索引？</li>
</ul>
</li>
</ul>
<h2 id="3-mysql组件"><a href="#3-mysql组件" class="headerlink" title="3.mysql组件"></a>3.mysql组件</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，<br>这个时候用的就是你输入的用户名和密码。</p>
<ul>
<li>修改user的信息</li>
<li>修改完权限后要重新连接，权限才会生效</li>
</ul>
<h3 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h3><ul>
<li>1、词法分析 2、语法分析 3、语义分析 4、构造执行树 5、生成执行计划 6、计划的执行</li>
</ul>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><ul>
<li>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接 顺序。甚至，不使用索引</li>
</ul>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><h3 id="bin-log"><a href="#bin-log" class="headerlink" title="bin-log"></a>bin-log</h3><ul>
<li>开启之后能够恢复开启之后删除的数据</li>
</ul>
<h2 id="4-优化索引实战（一）"><a href="#4-优化索引实战（一）" class="headerlink" title="4.优化索引实战（一）"></a>4.优化索引实战（一）</h2><h3 id="1-强制走索引效率不一定高"><a href="#1-强制走索引效率不一定高" class="headerlink" title="1.强制走索引效率不一定高"></a>1.强制走索引效率不一定高</h3><ul>
<li>EXPLAIN SELECT * FROM employees force index(idx_name_age_position) WHERE name &gt; ‘LiLei’ AND age = 22 AND position =’manager’;</li>
</ul>
<h3 id="2-利用覆盖索引优化可能不走索引的情况"><a href="#2-利用覆盖索引优化可能不走索引的情况" class="headerlink" title="2.利用覆盖索引优化可能不走索引的情况"></a>2.利用覆盖索引优化可能不走索引的情况</h3><ul>
<li>EXPLAIN SELECT name,age,position FROM employees WHERE name &gt; ‘LiLei’ AND age = 22 AND position =’manag er’;</li>
</ul>
<h3 id="3-in和or在表数据量比较大的情况会走索引，在表记录不多的情况下会选择全表扫描"><a href="#3-in和or在表数据量比较大的情况会走索引，在表记录不多的情况下会选择全表扫描" class="headerlink" title="3.in和or在表数据量比较大的情况会走索引，在表记录不多的情况下会选择全表扫描"></a>3.in和or在表数据量比较大的情况会走索引，在表记录不多的情况下会选择全表扫描</h3><h3 id="4-like-KK-一般情况都会走索引"><a href="#4-like-KK-一般情况都会走索引" class="headerlink" title="4.like KK% 一般情况都会走索引"></a>4.like KK% 一般情况都会走索引</h3><ul>
<li><p>索引下推</p>
<ul>
<li><p>可以在索引遍历过程中，对索引中包含的所有字段先做判断，过滤掉不符合条件的记录之后再回表，可以有效的减少回表次数</p>
</li>
<li><blockquote>
<p>,&gt;=这种范围查询一般不走索引下推是因为，回表查询还不如全表扫描</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="trace工具"><a href="#trace工具" class="headerlink" title="trace工具"></a>trace工具</h3><p>set session optimizer_trace=”enabled=on”,end_markers_in_json=on; ‐‐开启trace<br>select <em> from employees where name &gt; ‘a’ order by position;<br>SELECT </em> FROM information_schema.OPTIMIZER_TRACE;</p>
<ul>
<li>可以查看Mysql内部优化sql语句的过程</li>
</ul>
<h3 id="Order-By-和Group-By"><a href="#Order-By-和Group-By" class="headerlink" title="Order By 和Group By"></a>Order By 和Group By</h3><ul>
<li>Extra里没有Using filesort就是用到了索引</li>
<li>mysql8之前desc不支持索引</li>
</ul>
<h3 id="Using-filesort"><a href="#Using-filesort" class="headerlink" title="Using filesort"></a>Using filesort</h3><ul>
<li><p>单路排序</p>
<ul>
<li>排序的时候把所有字段取到内存中</li>
</ul>
</li>
<li><p>多路排序</p>
<ul>
<li>排序的时候只把排序列和id取到内存中，之后从原表中找出其他字段</li>
</ul>
</li>
<li><p>单路排序占内存，速度快；多路排序省空间，速度慢</p>
</li>
</ul>
<h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><ul>
<li>1、代码先行，索引后上</li>
<li>2、联合索引尽量覆盖条件</li>
<li><p>3、不要在小基数字段上建立索引</p>
<ul>
<li>如，性别</li>
</ul>
</li>
<li><p>4、长字符串我们可以采用前缀索引</p>
<ul>
<li>index(name(20),age,position)。</li>
</ul>
</li>
<li><p>5、where与order by冲突时优先where</p>
</li>
<li>6、基于慢sql查询做优化</li>
</ul>
<h2 id="5-优化索引实战（二）"><a href="#5-优化索引实战（二）" class="headerlink" title="5.优化索引实战（二）"></a>5.优化索引实战（二）</h2><h3 id="1-分页查询优化"><a href="#1-分页查询优化" class="headerlink" title="1.分页查询优化"></a>1.分页查询优化</h3><p>select * from employees limit 10000,10;</p>
<ul>
<li><p>select * from employees limit 10000,10; 原理</p>
<ul>
<li>从索引10000的数据行开始读10条数据</li>
<li>并不是只查10条数据，而是先读取10010条数据，然后抛弃前10000行数据</li>
</ul>
</li>
<li><p>EXPLAIN select * from employees ORDER BY name limit 90000,5优化</p>
<ul>
<li>分析：name字段由于mysql自身优化机制不会走索引，会Using filesort</li>
<li>优化：select * from employees e inner join (select id from employees order by name limit 90000,5) ed on e.id = ed.id;  先找出这5行数据的id，再自连接效率更高</li>
</ul>
</li>
</ul>
<h3 id="2-join关联查询优化"><a href="#2-join关联查询优化" class="headerlink" title="2.join关联查询优化"></a>2.join关联查询优化</h3><ul>
<li><p>表关联算法</p>
<ul>
<li><p>1.嵌套循环连接算法(NLJ)</p>
<ul>
<li><p>sql语句</p>
<ul>
<li>EXPLAIN select * from t1 inner join t2 on t1.a= t2.a;</li>
</ul>
</li>
<li><p>步骤</p>
<ul>
<li><ol>
<li>从表 t2 中读取一行数据（如果t2表有查询过滤条件的，会从过滤结果里取出一行数据）；  </li>
</ol>
</li>
<li><ol>
<li>从第 1 步的数据中，取出关联字段 a，到表 t1 中查找；</li>
</ol>
</li>
<li><ol>
<li>取出表 t1 中满足条件的行，跟 t2 中获取到的结果合并，作为结果返回给客户端；</li>
</ol>
</li>
<li><ol>
<li>重复上面 3 步。</li>
</ol>
</li>
</ul>
</li>
<li><p>分析</p>
<ul>
<li>整个过程会读取 t2 表的所有数据(扫描100行)，然后遍历这每行数据中字段 a 的值，根据 t2 表中 a 的值索引扫描 t1 表 中的对应行(扫描100次 t1 表的索引，1次扫描可以认为最终只扫描 t1 表一行完整数据，也就是总共 t1 表也扫描了100 行)。因此整个过程扫描了 200 行。</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>每次从小表中取出一行数据到内存，再从大表中取数据，若有索引，只需要取一次，否则遍历大表；取出数据后拼接小表和大表的数据作为结果集。</li>
<li>适合有索引</li>
</ul>
</li>
</ul>
</li>
<li><p>2.基于块的嵌套循环连接算法(BNL)</p>
<ul>
<li><p>步骤</p>
<ul>
<li><ol>
<li>把 t2 的所有数据放入到 join_buffer 中  </li>
</ol>
</li>
<li><ol>
<li>把表 t1 中每一行取出来，跟 join_buffer 中的数据做对比</li>
</ol>
</li>
<li><ol>
<li>返回满足 join 条件的数据</li>
</ol>
</li>
</ul>
</li>
<li><p>分析</p>
<ul>
<li>整个过程对表 t1 和 t2 都做了一次全表扫描，因此扫描的总行数为10000(表 t1 的数据总量) + 100(表 t2 的数据总量) = 10100。并且 join_buffer 里的数据是无序的，因此对表 t1 中的每一行，都要做 100 次判断，所以内存中的判断次数是 100 * 10000= 100 万次。</li>
</ul>
</li>
<li><p>若join_buffer放不下</p>
<ul>
<li><p>分段放</p>
<p>  比如 t2 表有1000行记录， join_buffer 一次只能放800行数据，那么执行过程就是先往 join_buffer 里放800行记录，然后从 t1 表里取数据跟 join_buffer 中数据对比得到部分结果，然后清空 join_buffer ，再放入 t2 表剩余200行记录，再次从 t1 表里取数据跟 join_buffer 中数据对比。所以就多扫了一次 t1 表。</p>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>将小表的所有数据都放入join_buffer中，再从大表中依次取数据比对</li>
<li>适合无索引</li>
</ul>
</li>
</ul>
</li>
<li><p>细节</p>
<ul>
<li><p>扫描的含义</p>
<ul>
<li>从磁盘中取数据，NLJ有索引的时候，只需要根据索引(在内存中)从磁盘中取一次数据，速度很快</li>
</ul>
</li>
<li><p>join_buffer</p>
<ul>
<li>在无索引的时候BNL是在内存中操作的，相比NLJ无索引只从磁盘读速度快</li>
</ul>
</li>
<li><p>数据量小的作为驱动表，大的表做被驱动表</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>优化原则</p>
<ul>
<li>1.关联字段加索引</li>
<li>2.小表驱动大表</li>
</ul>
</li>
<li><p>in和Exists</p>
<ul>
<li>in：当B表的数据集小于A表的数据集时，in优于exists</li>
<li>exists：当A表的数据集小于B表的数据集时，exists优于in</li>
</ul>
</li>
</ul>
<h3 id="3-count优化"><a href="#3-count优化" class="headerlink" title="3.count优化"></a>3.count优化</h3><ul>
<li>四个sql的执行计划一样，说明这四个sql执行效率应该差不多，推荐使用count(*)</li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul>
<li>int的长度指填充大小，如长度为5的int数据3填充后为00003,定义时需要加 ZEROFILL</li>
</ul>
<h2 id="6-事务隔离级别和锁机制"><a href="#6-事务隔离级别和锁机制" class="headerlink" title="6.事务隔离级别和锁机制"></a>6.事务隔离级别和锁机制</h2><h3 id="1-事务的ACID属性"><a href="#1-事务的ACID属性" class="headerlink" title="1.事务的ACID属性"></a>1.事务的ACID属性</h3><ul>
<li><p>1.原子性</p>
<ul>
<li>事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。操作层面</li>
</ul>
</li>
<li><p>2.一致性</p>
<ul>
<li>在事务开始和完成时,数据都必须保持一致状态。要么数据全部跟着操作修改，要么全都不变。数据层面</li>
</ul>
</li>
<li><p>3.隔离性</p>
<ul>
<li>数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独 立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。</li>
</ul>
</li>
<li><p>4.持久性</p>
<ul>
<li>事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。</li>
</ul>
</li>
</ul>
<h3 id="2-并发带来的问题"><a href="#2-并发带来的问题" class="headerlink" title="2.并发带来的问题"></a>2.并发带来的问题</h3><ul>
<li><p>1.脏写</p>
<ul>
<li>事务A的更新覆盖了事务B的更新。主要就是事务A的回滚将事务B的更新重置了</li>
</ul>
</li>
<li><p>2.脏读</p>
<ul>
<li>事务A读取了事务B修改但未提交的更新。事务B的回滚使事务A读取的修改数据无效</li>
</ul>
</li>
<li><p>3.不可重复读</p>
<ul>
<li>事务A内部的相同查询语句在不同时刻读出的结果不一致，不符合隔离性。针对某个字段的更新</li>
</ul>
</li>
<li><p>4.幻读</p>
<ul>
<li>事务A读取到了事务B提交的新增数据，在不同时刻读出的数据条数不同，不符合隔离性。针对某张表的插入删除</li>
</ul>
</li>
</ul>
<h3 id="3-事务的隔离级别"><a href="#3-事务的隔离级别" class="headerlink" title="3.事务的隔离级别"></a>3.事务的隔离级别</h3><ul>
<li></li>
<li><p>问题</p>
<ul>
<li><p>可重复读：update account set balance = balance - 50 where id =1，由于可重复读的机制，balance值不要用java减了之后赋值，而是用sql减，这涉及到MVCC机制(维护了一致性)</p>
<ul>
<li>事务A读出balance为400，事务B在事务A执行过程中修改为350，事务A不能根据读出的400(可重复读)做更新，而是根据350做更新(使用sql自减)(MVCC机制，维护了数据一致性)</li>
</ul>
</li>
<li><p>串行化：查了哪条数据哪条数据就会加锁</p>
</li>
<li><p>可重复读和串行化解决隔离性的区别</p>
<ul>
<li>可重复读解决了以字段为单位的隔离性，串行化解决了以行为单位的隔离性</li>
<li>可重复读使用了MVCC解决隔离性，这使读操作能正常进行；串行化使用读锁解决问题，插入或读取了某行就会上锁，直至事务结束。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-锁分类"><a href="#4-锁分类" class="headerlink" title="4.锁分类"></a>4.锁分类</h3><ul>
<li><p>乐观锁</p>
<ul>
<li>类似CAS操作</li>
</ul>
</li>
<li><p>悲观锁</p>
<ul>
<li><p>读锁</p>
<ul>
<li>针对同一份数据，多个读操作可以同时进行而不会互相影响</li>
</ul>
</li>
<li><p>写锁</p>
<ul>
<li><p>表锁</p>
<ul>
<li>每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低； 一般用在整表数据迁移的场景。</li>
<li><p>操作</p>
<ul>
<li>lock table 表名称 read(write),表名称2 read(write);</li>
<li>show open tables;</li>
<li>unlock tables;</li>
</ul>
</li>
</ul>
</li>
<li><p>行锁</p>
<ul>
<li>每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>间隙锁</p>
<ul>
<li>执行update account set name = ‘zhuge’ where id &gt; 8 and id &lt;18;存在间隙(3,10),(10,20),(20,正无穷),则会把(3,20]加锁</li>
<li>间隙锁默认在可重复读隔离级别下会生效</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁,在执行update、insert、delete操作会自动给涉及的表加写锁。</li>
<li>InnoDB在执行查询语句SELECT时(非串行隔离级别)，不会加读锁。但是update、insert、delete操作会加行锁</li>
<li>总而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞</li>
</ul>
</li>
</ul>
<h3 id="5-锁优化建议"><a href="#5-锁优化建议" class="headerlink" title="5.锁优化建议"></a>5.锁优化建议</h3><ul>
<li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁 </li>
<li>合理设计索引，尽量缩小锁的范围</li>
<li>尽可能减少检索条件范围，避免间隙锁</li>
<li>尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行</li>
<li>尽可能低级别事务隔离</li>
</ul>
<h3 id="InnoDB与MYISAM的最大不同有两点"><a href="#InnoDB与MYISAM的最大不同有两点" class="headerlink" title="InnoDB与MYISAM的最大不同有两点"></a>InnoDB与MYISAM的最大不同有两点</h3><ul>
<li>InnoDB支持事务</li>
<li>InnoDB支持行锁</li>
<li><p>其他</p>
<ul>
<li>InnoDB有undo日志和redo日志，MYISAM没有</li>
<li>InnoDB使用聚集索引，MYISAM使用非聚集索引</li>
</ul>
</li>
</ul>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul>
<li><p>常看当前数据库的事务隔离级别</p>
<ul>
<li>show variables like ‘tx_isolation’; </li>
</ul>
</li>
<li><p>设置事务隔离级别</p>
<ul>
<li>set tx_isolation=’read-uncommitted’;</li>
<li>set tx_isolation=’read-committed’;</li>
<li>set tx_isolation=’repeatable-read’;</li>
<li>set tx_isolation=’serializable’;</li>
</ul>
</li>
<li><p>开启事务，提交事务</p>
<ul>
<li>begin; sql语句;commit;</li>
</ul>
</li>
</ul>
<h2 id="7-MVCC多版本并发控制机制及BufferPool缓存机制"><a href="#7-MVCC多版本并发控制机制及BufferPool缓存机制" class="headerlink" title="7.MVCC多版本并发控制机制及BufferPool缓存机制"></a>7.MVCC多版本并发控制机制及BufferPool缓存机制</h2><h3 id="1-MVCC机制"><a href="#1-MVCC机制" class="headerlink" title="1.MVCC机制"></a>1.MVCC机制</h3><p>在读已提交和可重复读隔离级别下实现</p>
<ul>
<li><p>1.undo日志</p>
<ul>
<li>在每个事务修改完后，Mysql会保留修改前的数据undo回滚 日志</li>
</ul>
</li>
<li><p>2.read view机制</p>
<ul>
<li><p>可重复读</p>
<ul>
<li>事务开始后第一条select语句会生成一个read-view一致性视图，直到事务结束都不变</li>
</ul>
</li>
<li><p>读已提交</p>
<ul>
<li>事务开始后，每条select语句都会生成一个新的read-view一致性视图</li>
</ul>
</li>
<li><p>这个视图由执行查询时所有未提交事务id数组（数组里最小的id为min_id）和已创建的最大事务id（max_id）组成，事务里的任何sql查询结果需要从对应 版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。</p>
</li>
</ul>
</li>
<li><p>3.版本链比对规则</p>
<ul>
<li><ol>
<li>如果 row 的 trx_id 落在绿色部分( trx_id&lt;min_id )，表示这个版本是已提交的事务生成的，这个数据是可见的； </li>
</ol>
</li>
<li><ol>
<li>如果 row 的 trx_id 落在红色部分( trx_id&gt;max_id )，表示这个版本是由将来启动的事务生成的，是不可见的(若 row 的 trx_id 就是当前自己的事务是可见的）；</li>
</ol>
</li>
<li><ol>
<li><p>如果 row 的 trx_id 落在黄色部分(min_id &lt;=trx_id&lt;= max_id)，那就包括两种情况</p>
<ul>
<li>a. 若 row 的 trx_id 在视图数组中，表示这个版本是由还没提交的事务生成的，不可见(若 row 的 trx_id 就是当前自 己的事务是可见的)；</li>
<li>b. 若 row 的 trx_id 不在视图数组中，表示这个版本是已经提交了的事务生成的，可见。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>MVCC机制的实现就是通过read-view机制与undo版本链比对机制，使得不同的事务会根据数据版本链对比规则读取 同一条数据在版本链上的不同版本数据。</li>
</ul>
</li>
<li><p>细节</p>
<ul>
<li><p>可重复读隔离级别</p>
<ul>
<li>一致性视图在事务结束之前都不会变化</li>
</ul>
</li>
<li><p>读已提交</p>
<ul>
<li>每次执行查询sql都会重新生成一致性视图</li>
</ul>
</li>
</ul>
</li>
<li><p>举例</p>
</li>
</ul>
<h3 id="2-BufferPool缓存机制"><a href="#2-BufferPool缓存机制" class="headerlink" title="2.BufferPool缓存机制"></a>2.BufferPool缓存机制</h3><ul>
<li><p>为什么Mysql不能直接更新磁盘上的数据而且设置这么一套复杂的机制来执行SQL了？</p>
<ul>
<li>因为磁盘随机读写的性能是非常差的，所以直接更新磁盘文件是不能让数据库抗住很高并发的。</li>
<li>Mysql这套机制看起来复杂，但它可以保证每个更新请求都是更新内存BufferPool，然后顺序写日志文件，同时还能 保证各种异常情况下的数据一致性。</li>
<li>更新内存的性能是极高的，然后顺序写磁盘上的redo日志文件的性能也是非常高的，要远高于随机读写磁盘文件。</li>
</ul>
</li>
<li><p>redo log和binlog区别</p>
<ul>
<li><p>redo日志</p>
<ul>
<li>redo日志让Mysql拥有了故障恢复的能力</li>
<li><p>redo log用来维护BufferPool，binlog用来维护磁盘数据</p>
<ul>
<li>比如事务提交完，但还没写入磁盘，系统宕机了，使用redo log是恢复了BufferPool里的数据(数据页)</li>
</ul>
</li>
<li><p>记录的是innodb引擎数据页的变更，并没有记录具体的sql，只是把数据页修改的前后数据记录下来。</p>
</li>
<li>恢复数据不需要解析sql语句，速度快</li>
</ul>
</li>
<li><p>binlog日志</p>
<ul>
<li>binlog保证了MySQL集群架构的数据一致性</li>
<li>是数据的变更操作日志，记录数据的变更。解析出来是sql语句</li>
</ul>
</li>
</ul>
</li>
<li><p>redo日志和binlog详解(redo的二阶段提交)</p>
</li>
</ul>
<h3 id="事务的ACID实现原理"><a href="#事务的ACID实现原理" class="headerlink" title="事务的ACID实现原理"></a>事务的ACID实现原理</h3><ul>
<li><p>原子性</p>
<ul>
<li>undo log</li>
</ul>
</li>
<li><p>持久性</p>
<ul>
<li>BufferPool缓存机制+redo log + binlog</li>
</ul>
</li>
<li><p>隔离性</p>
<ul>
<li>MVCC解决写+读</li>
<li>解锁解决写+写</li>
</ul>
</li>
<li><p>一致性</p>
<ul>
<li>一致性是事物追求的最终目标，前面提到的原子性，隔离性，持久性都是为了保证数据库的一致性。此外除了数据库底层的保障，一致性的实现也需要应用层的保障。</li>
</ul>
</li>
</ul>
<h2 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h2>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://alexander-wd.github.io/alex-next/2022/04/24/javaEE/JUC学习记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="alex">
      <meta itemprop="description" content="时光静好,与君语;细水流年,与君同;繁华落尽,与君老.">
      <meta itemprop="image" content="/alex-next/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="alex的博客 - github.com">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/alex-next/2022/04/24/javaEE/JUC学习记录/" class="post-title-link" itemprop="url">JUC学习笔记</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2022-04-24 16:03:12" itemprop="dateCreated datePublished" datetime="2022-04-24T16:03:12+08:00">2022-04-24</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-13 17:53:17" itemprop="dateModified" datetime="2023-02-13T17:53:17+08:00">2023-02-13</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/alex-next/categories/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="1-Java内存模型JMM"><a href="#1-Java内存模型JMM" class="headerlink" title="1.Java内存模型JMM"></a>1.Java内存模型JMM</h2><h3 id="JMM架构"><a href="#JMM架构" class="headerlink" title="JMM架构"></a>JMM架构</h3><ul>
<li><p>八大原子操作</p>
<ul>
<li>(1)lock:作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>
<li>(2)unlock:作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其它线程锁定。</li>
<li>(3)read:作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li>(4)load:作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>(5)use:作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时都会执行这个操作。</li>
<li>(6)assign:作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>(7)store:作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write使用。</li>
<li>(8)write:作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
</li>
</ul>
<h3 id="并发编程的三大问题"><a href="#并发编程的三大问题" class="headerlink" title="并发编程的三大问题"></a>并发编程的三大问题</h3><ul>
<li><p>原子性</p>
<p>  原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。<br>  public class Jmm04_CodeAtomic {</p>
<pre><code>private volatile static int counter = 0;
static Object object = new Object();

public static void main(String[] args) {

  for (int i = 0; i &lt; 10; i++) {
    Thread thread = new Thread(()-&gt;{
      for (int j = 0; j &lt; 1000; j++) {
        synchronized (object){
          counter++;//分三步- 读，自加，写回
        }
      }
    });
    thread.start();
  }

  try {
    Thread.sleep(3000);
  } catch (InterruptedException e) {
    e.printStackTrace();
  }

  System.out.println(counter);

}
</code></pre><p>  }</p>
</li>
<li><p>可见性</p>
<p>  是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。<br>  public class Jmm03_CodeVisibility {</p>
<pre><code>private static boolean initFlag = false;

private volatile static int counter = 0;

public static void refresh(){
  log.info(&quot;refresh data.......&quot;);
  initFlag = true;
  log.info(&quot;refresh data success.......&quot;);
}

public static void main(String[] args){
  Thread threadA = new Thread(()-&gt;{
    while (!initFlag){
      //System.out.println(&quot;runing&quot;);
      counter++;
    }
    log.info(&quot;线程：&quot; + Thread.currentThread().getName()

 + &quot;当前线程嗅探到initFlag的状态的改变&quot;);
   eadA&quot;);
       threadA.start();

  try {
    Thread.sleep(500);
  } catch (InterruptedException e) {
    e.printStackTrace();
  }

  Thread threadB = new Thread(()-&gt;{
    refresh();
  },&quot;threadB&quot;);
  threadB.start();
}
</code></pre><p>  }</p>
<ul>
<li><p>问题：在代码中不加volatile关键字，使用Integer,System.out.println()，volatile counter等方法也能做到volatile的效果，为什么？</p>
<ul>
<li>上下文切换，即initFlag变量和volatile修饰的counter变量在底层有可能放到了一个缓存行里，而counter被volatile修饰，会每次刷新，这时，initFlag也会跟着一起刷新。其他情况同理。<br>  ps:为什么空while循环不会刷新initFlag，因为空while循环会一直占着CPU。</li>
</ul>
</li>
</ul>
</li>
<li><p>有序性</p>
<p>  public static void main(String[] args) throws InterruptedException {</p>
<pre><code>  int i = 0;
  for (;;){
    i++;
    x = 0; y = 0;
    a = 0; b = 0;
    Thread t1 = new Thread(new Runnable() {
      public void run() {
        shortWait(10000);
        a = 1;
        x = b;
        UnsafeInstance.reflectGetUnsafe().fullFence();
        ///
        //
        //
      }
    });

    Thread t2 = new Thread(new Runnable() {
      public void run() {
        b = 1;
        UnsafeInstance.reflectGetUnsafe().fullFence();
        y = a;
      }
    });

    t1.start();
    t2.start();
    t1.join();
    t2.join();

    String result = &quot;第&quot; + i + &quot;次 (&quot; + x + &quot;,&quot; + y + &quot;）&quot;;
    if(x == 0 &amp;&amp; y == 0) {
      System.out.println(result);
      break;
    } else {
      log.info(result);
    }
  }

}
</code></pre><ul>
<li><p>指令重排：java语言规范规定JVM线程内部维持顺序化语义。即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致。但是这只是针对单线程而言。</p>
<ul>
<li>指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性</li>
</ul>
</li>
<li><p>指令重排≠有序性</p>
</li>
<li><p>指令重排的一个经典优化案例双重锁检查(DCL)</p>
<p>  public class Singleton {</p>
<pre><code>private static Singleton instance; // 不使用volatile关键字

// 双重锁检验
public static Singleton getInstance() {
  if (instance == null) { // 第7行
    synchronized (Singleton.class) {
      if (instance == null) {
        instance = new Singleton(); // 第10行
      }
    }
  }
  return instance;
}
</code></pre><p>  }</p>
<ul>
<li>对象的创建并不是一个原子操作，而是有分配空间，初始化和<init>，如果不禁止重排序，可能会初始化一个空对象</init></li>
</ul>
</li>
<li><p>Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有操作都是天然有序的。如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内似表现为串行的语义”，后半句是指“指令重排”现象和“工作内存与主内存同步延迟”现象。</p>
</li>
</ul>
</li>
</ul>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ul>
<li><p>volatile</p>
<ul>
<li><p>能解决哪些并发编程的三大问题</p>
<ul>
<li><p>可见性</p>
<ul>
<li>硬件层面：底层汇编会生成lock前缀指令，从而触发MESI缓存一致性协议，通过总线嗅探机制监听每个线程(工作内存)的变量是否改变</li>
<li><p>JAVA层面</p>
<ul>
<li>内存屏障</li>
</ul>
</li>
</ul>
</li>
<li><p>有序性(基于内存屏障)</p>
</li>
</ul>
</li>
<li><p>能禁止指令重排(基于内存屏障)</p>
<ul>
<li>Java是否能指令重排的规则(volatile读前写后不重排)</li>
</ul>
</li>
<li><p>及时可见性，可能某些操作比如System.out.println()也能做到可见性，但这种方式不是及时的</p>
</li>
</ul>
</li>
<li><p>synchronized</p>
<ul>
<li><p>能解决哪些并发编程的三大问题</p>
<ul>
<li>原子性</li>
<li><p>可见性</p>
<ul>
<li>通过monitorenter/monitorexit的jvm字节码指令，在底层调用lock前缀指令开启内存屏障</li>
</ul>
</li>
<li><p>有序性</p>
<ul>
<li>依然会发生重排序，只不过我们有同步代码块，可以保证只有一个线程执行同步代码中的代码。保证有序性</li>
</ul>
</li>
</ul>
</li>
<li><p>能保证有序性，但是不能像volatile一样禁止指令重排序，所以会产生DCL的问题</p>
</li>
</ul>
</li>
</ul>
<h3 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h3><ul>
<li>MESI协议状态切换图</li>
<li>java文件执行全流程</li>
</ul>
<h3 id="内存屏障-Java内部用于解决并发编程的三大问题"><a href="#内存屏障-Java内部用于解决并发编程的三大问题" class="headerlink" title="内存屏障(Java内部用于解决并发编程的三大问题)"></a>内存屏障(Java内部用于解决并发编程的三大问题)</h3><ul>
<li><p>硬件层面(Intel提供)</p>
<ul>
<li>lfence，是一种Load Barrier 读屏障</li>
<li>sfence, 是一种Store Barrier 写屏障</li>
<li>mfence, 是一种全能型的屏障，具备ifence和sfence的能力</li>
<li><p>Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对 CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。</p>
<ul>
<li>因为不同的内存屏障，需要不同的汇编指令，jvm内部对这些指令进行了简化，统一用lock前缀指令。</li>
</ul>
</li>
</ul>
</li>
<li><p>Java实现的内存屏障</p>
<ul>
<li>LoadLoad屏障： 对于这样的语句 Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。 </li>
<li>StoreStore屏障：对于这样的语句 Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。 </li>
<li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被执行前，保证Load1要读取的数据被读取完毕。 </li>
<li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。</li>
</ul>
</li>
</ul>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul>
<li><p>happens-before原则</p>
<ul>
<li><ol>
<li>程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执 行。</li>
</ol>
</li>
<li><ol>
<li>锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是 说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个 锁)。</li>
</ol>
</li>
<li><ol>
<li>volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简 单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的 值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的 线程总是能够看到该变量的最新值。</li>
</ol>
</li>
<li><ol>
<li>线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B 的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享 变量的修改对线程B可见</li>
</ol>
</li>
<li><ol>
<li>传递性 A先于B ，B先于C 那么A必然先于C</li>
</ol>
</li>
<li><ol>
<li>线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待 当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的 join方法成功返回后，线程B对共享变量的修改将对线程A可见。</li>
</ol>
</li>
<li><ol>
<li>线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到 中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</li>
</ol>
</li>
<li><ol>
<li>对象终结规则对象的构造函数执行，结束先于finalize()方法</li>
</ol>
</li>
</ul>
</li>
<li><p>as-if-serial：不管再怎么指令重排序，程序的执行结果被能被改变</p>
</li>
</ul>
<h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><ul>
<li>Java字节码指令是原子操作吗</li>
</ul>
<h3 id="如何查看字节码-第二节课-和汇编-第三节课52-54"><a href="#如何查看字节码-第二节课-和汇编-第三节课52-54" class="headerlink" title="如何查看字节码(第二节课)和汇编(第三节课52:54)"></a>如何查看字节码(第二节课)和汇编(第三节课52:54)</h3><h2 id="2-synchronized详解"><a href="#2-synchronized详解" class="headerlink" title="2.synchronized详解"></a>2.synchronized详解</h2><h3 id="解决线程并发安全问题，采用的是序列化访问临界资源"><a href="#解决线程并发安全问题，采用的是序列化访问临界资源" class="headerlink" title="解决线程并发安全问题，采用的是序列化访问临界资源"></a>解决线程并发安全问题，采用的是序列化访问临界资源</h3><ul>
<li>1.synchronized</li>
<li>2.lock</li>
</ul>
<h3 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h3><ul>
<li>synchronized关键字会被编译成字节码后会被翻译成monitorenter 和 monitorexit 两条指令分别在同步块逻辑代码的起始位置 与结束位置。</li>
<li><p>Monitor</p>
<ul>
<li><p>概念</p>
<ul>
<li>每一个Java对象自打娘胎里出来就带了一把 看不见的锁，它叫做内部锁或者Monitor锁。也就是通常说Synchronized的对象锁</li>
</ul>
</li>
<li><p>存储位置</p>
<ul>
<li>Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向），Synchronized锁便是通过这种方式 获取锁的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="不同粒度的锁在对象中的存储"><a href="#不同粒度的锁在对象中的存储" class="headerlink" title="不同粒度的锁在对象中的存储"></a>不同粒度的锁在对象中的存储</h3><ul>
<li>对象内存布局</li>
<li>在mark word中的存储</li>
</ul>
<h3 id="锁升级：不同线程竞争激烈的结果"><a href="#锁升级：不同线程竞争激烈的结果" class="headerlink" title="锁升级：不同线程竞争激烈的结果"></a>锁升级：不同线程竞争激烈的结果</h3><ul>
<li>锁升级过程</li>
</ul>
<h3 id="锁粗化：JIT编译器如果发现有代码里连续多次加锁释放锁的代码，会给合并为一个锁"><a href="#锁粗化：JIT编译器如果发现有代码里连续多次加锁释放锁的代码，会给合并为一个锁" class="headerlink" title="锁粗化：JIT编译器如果发现有代码里连续多次加锁释放锁的代码，会给合并为一个锁"></a>锁粗化：JIT编译器如果发现有代码里连续多次加锁释放锁的代码，会给合并为一个锁</h3><ul>
<li>synchronized(this) {}<br>  synchronized(this) {}synchronized(this) {}</li>
</ul>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><ul>
<li>依赖逃逸分析，如果一个锁对象在栈桢中为局部变量，不会被外部引用，会消除对应的锁</li>
</ul>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><ul>
<li><p>在main方法启动之后发现直接使用的轻量级锁，直接跳过了偏向锁，为什么？</p>
<ul>
<li>JVM会延迟启动偏向锁。JVM本身启动的时候，就会开启10多个线程，避免无谓的偏向锁-&gt;重量级锁的过程，会延迟启动偏向锁。</li>
</ul>
</li>
</ul>
<h2 id="3-AQS-AbstractQueuedSynchronizer-详解"><a href="#3-AQS-AbstractQueuedSynchronizer-详解" class="headerlink" title="3.AQS(AbstractQueuedSynchronizer)详解"></a>3.AQS(AbstractQueuedSynchronizer)详解</h2><h3 id="第一节"><a href="#第一节" class="headerlink" title="第一节"></a>第一节</h3><ul>
<li><p>大体框架</p>
<ul>
<li><p>queue队列(CLH同步队列)</p>
<p>  一个有头尾结点的双向链式队列</p>
</li>
<li><p>CAS</p>
<p>  protected final boolean tryAcquire(int acquires) {</p>
<pre><code>  final Thread current = Thread.currentThread();
  int c = getState();// 获取当前的信号量State
  if (c == 0) {// 若现在没有线程占用，则进入
      if (!hasQueuedPredecessors() &amp;&amp;  // 判断队列中是否有线程阻塞，这是公平锁和非公平锁的区别
          compareAndSetState(0, acquires)) {// CAS+轮询操作
          setExclusiveOwnerThread(current);
          return true;
      }
  }
  else if (current == getExclusiveOwnerThread()) {
      int nextc = c + acquires;
      if (nextc &lt; 0)
          throw new Error(&quot;Maximum lock count exceeded&quot;);
      setState(nextc);
      return true;
  }
  return false;
</code></pre><p>  }</p>
</li>
<li><p>LockSupport</p>
</li>
<li><p>自旋</p>
</li>
<li><p>伪代码</p>
<p>  ReentrantLock lock = new ReentrantLock();<br>  lock.lock();//加锁<br>  (while(true){// 自旋</p>
<pre><code>  if(CAS加锁成功){
      break;
  }
  Queue.add(Thread);// 加入队列
  LockSupport.park()// 阻塞
</code></pre><p>  })// lock.lock()的具体实现</p>
<p>  T0获取锁<br>  具体的业务逻辑</p>
<p>  lock.unlock();// 释放锁<br>  (Thread t = Queue.get();// 取出一个线程<br>  LockSupport.unpark(t);// 唤醒<br>  )// lock.unlock();具体实现</p>
</li>
</ul>
</li>
<li><p>AQS特性</p>
<ul>
<li>阻塞等待队列</li>
<li><p>共享/独占</p>
<ul>
<li>共享：多个线程可以同时执行，如Semaphore/CountDownLatch</li>
<li>独占：只有一个线程能执行，如ReentrantLock</li>
</ul>
</li>
<li><p>公平/非公平</p>
<ul>
<li>ReentrantLock类内部实现了Sync类，Sync类继承了AQS类；而FairSync和NonfairSync都继承Sync类</li>
<li>FairSync实现公平锁</li>
<li>NonfairSync实现非公平锁</li>
</ul>
</li>
<li><p>可重入</p>
<ul>
<li>当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的</li>
</ul>
</li>
<li><p>允许中断</p>
</li>
</ul>
</li>
</ul>
<h3 id="第二节"><a href="#第二节" class="headerlink" title="第二节"></a>第二节</h3><ul>
<li><p>AQS代码(独占方式)(ReentrantLock)详解</p>
<ul>
<li><p>可参考的md</p>
<ul>
<li>方法总结</li>
</ul>
</li>
<li><p>lock()实现:acquire(1)</p>
<p>  public final void acquire(int arg) {</p>
<pre><code>  if (!tryAcquire(arg) &amp;&amp;
      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
      selfInterrupt();
</code></pre><p>  }</p>
<ul>
<li><p>tryAcquire(arg):锁竞争具体逻辑</p>
<p>  protected final boolean tryAcquire(int acquires) {</p>
<pre><code>  final Thread current = Thread.currentThread();
  int c = getState();
  if (c == 0) {
      if (!hasQueuedPredecessors() &amp;&amp; // 公平锁判断下队列有没有阻塞线程
          compareAndSetState(0, acquires)) {
          setExclusiveOwnerThread(current);
          return true;
      }
  }
  else if (current == getExclusiveOwnerThread()) {
  // 可重入锁的体现，这里不存在并发安全问题
      int nextc = c + acquires;
      if (nextc &lt; 0)
          throw new Error(&quot;Maximum lock count exceeded&quot;);
      setState(nextc);
      return true;
  }
  return false;
</code></pre><p>  }</p>
</li>
<li><p>解释细节</p>
<ul>
<li>传1表示state锁的状态，后面上锁会给锁状态+1</li>
</ul>
</li>
<li><p>addWaiter(Node.EXCLUSIVE):将Thread放到队列中</p>
<p>  private Node addWaiter(Node mode) {</p>
<pre><code>  Node node = new Node(Thread.currentThread(), mode);
  // Try the fast path of enq; backup to full enq on failure
  Node pred = tail;
  if (pred != null) {
      node.prev = pred;
      if (compareAndSetTail(pred, node)) {
          pred.next = node;
          return node;
      }
  }
  enq(node);
  return node;
</code></pre><p>  }</p>
<ul>
<li><p>enq(node):队列为空或竞争入队会进入此方法</p>
<p>  private Node enq(final Node node) {</p>
<pre><code>  for (;;) {
      Node t = tail;
      if (t == null) { // Must initialize
          if (compareAndSetHead(new Node()))
              tail = head;
      } else {
          node.prev = t;
          if (compareAndSetTail(t, node)) {
              t.next = node;
              return t;
          }
      }
  }
</code></pre><p>  }</p>
<ul>
<li>入队要使用compareAndSetTail(t, node)，因为入队也可能存在并发问题</li>
</ul>
</li>
</ul>
</li>
<li><p>acquireQueued(addWaiter(Node.EXCLUSIVE),arg)</p>
<p>  final boolean acquireQueued(final Node node, int arg) {</p>
<pre><code>  boolean failed = true;
  try {
      boolean interrupted = false;
      for (;;) {
          final Node p = node.predecessor();
          if (p == head &amp;&amp; tryAcquire(arg)) {
              setHead(node);
              p.next = null; // help GC
              failed = false;
              return interrupted;
          }
          if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
              parkAndCheckInterrupt())
              interrupted = true;
      }
  } finally {
      if (failed)
          cancelAcquire(node);
  }
</code></pre><p>  }</p>
<ul>
<li><p>解释细节</p>
<ul>
<li>节点阻塞之前还得再尝试一次获取锁(因为线程阻塞唤醒比较耗费资源)</li>
<li>1.若能够获取到，节点出队，并且把head往后挪一个节点，新的头结点就是当前节点；</li>
<li><p>2.不能获取到，阻塞等待被唤醒</p>
<ul>
<li>1.首先第1轮循环、修改head的状态，修改成signal=-1标记处可以被唤醒.</li>
<li>2.第2轮循环，阻塞线程，并且需要判断线程是否是有中断信号唤醒的！</li>
</ul>
</li>
</ul>
</li>
<li><p>shouldParkAfterFailedAcquire(p, node)</p>
<p>  private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {</p>
<pre><code>  int ws = pred.waitStatus;
  if (ws == Node.SIGNAL)
      /*
       * This node has already set status asking a release
       * to signal it, so it can safely park.
       */
      return true;
  if (ws &gt; 0) {
      /*
       * Predecessor was cancelled. Skip over predecessors and
       * indicate retry.
       */
      do {
          node.prev = pred = pred.prev;
      } while (pred.waitStatus &gt; 0);
      pred.next = node;
  } else {
      /*
       * waitStatus must be 0 or PROPAGATE.  Indicate that we
       * need a signal, but don&#39;t park yet.  Caller will need to
       * retry to make sure it cannot acquire before parking.
       */
      compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
  }
  return false;
</code></pre><p>  }</p>
<ul>
<li><p>waitStatus节点的生命状态：信号量</p>
<ul>
<li>SIGNAL = -1 //可被唤醒</li>
<li>CANCELLED = 1 //代表出现异常，中断引起的，需要废弃结束</li>
<li>CONDITION = -2 // 等待condition唤醒</li>
<li>PROPAGATE = -3 // 传播</li>
<li>0 - 初始状态Init状态</li>
</ul>
</li>
<li><p>执行到此方法说明该线程要被阻塞，那么就要把waitstate设置为signal，下次才能被唤醒</p>
<p>  compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</p>
</li>
</ul>
</li>
<li><p>parkAndCheckInterrupt()：阻塞该线程</p>
<p>  private final boolean parkAndCheckInterrupt() {</p>
<pre><code>  LockSupport.park(this);
  return Thread.interrupted();
</code></pre><p>  }</p>
<ul>
<li>LockSupport.park(this)</li>
<li>Thread.interrupted()</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>unlock实现:release(1)</p>
<p>  public void unlock() {</p>
<pre><code>  sync.release(1);
</code></pre><p>  }<br>  public final boolean release(int arg) {</p>
<pre><code>  if (tryRelease(arg)) {
      Node h = head;
      if (h != null &amp;&amp; h.waitStatus != 0)
          unparkSuccessor(h);
      return true;
  }
  return false;
</code></pre><p>  }</p>
<ul>
<li><p>解释细节</p>
<ul>
<li>传1表示state锁的状态，后面上锁会给锁状态-1</li>
<li>与上锁时的shouldParkAfterFailedAcquire(p, node)方法对应，waitstate!=0才能执行unparkSuccessor(h)</li>
</ul>
</li>
<li><p>tryRelease(arg)</p>
<p>  protected final boolean tryRelease(int releases) {</p>
<pre><code>  int c = getState() - releases;
  if (Thread.currentThread() != getExclusiveOwnerThread())
      throw new IllegalMonitorStateException();
  boolean free = false;
  if (c == 0) {
      free = true;
      setExclusiveOwnerThread(null);
  }
  setState(c);
  return free;
</code></pre><p>  }</p>
<ul>
<li>给锁状态-1，由于可重入性，-1之后state依然不为0，那么持有锁的线程依旧是当前线程，返回false；否则返回true</li>
</ul>
</li>
<li><p>unparkSuccessor(h)</p>
<p>  private void unparkSuccessor(Node node) {</p>
<pre><code>  /*
   * If status is negative (i.e., possibly needing signal) try
   * to clear in anticipation of signalling.  It is OK if this
   * fails or if status is changed by waiting thread.
   */
  int ws = node.waitStatus;
  if (ws &lt; 0)
      compareAndSetWaitStatus(node, ws, 0);

  /*
   * Thread to unpark is held in successor, which is normally
   * just the next node.  But if cancelled or apparently null,
   * traverse backwards from tail to find the actual
   * non-cancelled successor.
   */
  Node s = node.next;
  if (s == null || s.waitStatus &gt; 0) {
      s = null;
      for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
          if (t.waitStatus &lt;= 0)
              s = t;
  }
  if (s != null)
      LockSupport.unpark(s.thread);
</code></pre><p>  }</p>
<ul>
<li><p>解释细节</p>
<ul>
<li>首先会用compareAndSetWaitStatus(node, ws, 0);将waitstate变为0，然后接着执行acquireQueued方法去抢锁(非公平锁)，如果失败，则将waitstate变为-1</li>
</ul>
</li>
<li><p>移除当前线程结点，获取队列中的下一个节点</p>
<p>  Node s = node.next;<br>  if (s == null || s.waitStatus &gt; 0) {</p>
<pre><code>  s = null;
  for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
      if (t.waitStatus &lt;= 0)
          s = t;
</code></pre><p>  }</p>
</li>
<li><p>LockSupport.unpark(s.thread)：释放锁，唤醒队列中的下一个进程</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第三节：阻塞队列"><a href="#第三节：阻塞队列" class="headerlink" title="第三节：阻塞队列"></a>第三节：阻塞队列</h3><ul>
<li><p>lockInterruptibly()</p>
<ul>
<li><p>中断的几个常用方法</p>
<ul>
<li><p>Thread.interrupted()：检测调用这个方法的线程是否已经中断，并将中断状态设置为false</p>
<p>  public static boolean interrupted()</p>
</li>
<li><p>void interrupt()：用于设置一个线程的中断状态为 true</p>
</li>
<li><p>boolean isInterrupted()：持有线程实例引用即可检测线程中断状态</p>
</li>
</ul>
</li>
<li><p>当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待(即阻塞)的情况下，是可以响应中断的。而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p>
</li>
</ul>
</li>
<li><p>lockSupport</p>
<ul>
<li>使用void interrupt()方法会给线程打上一个标记，即设置中断状态为true，那么LockSupport.park()会判断状态，若为true，便不能阻塞该线程，要使用LockSupport.park(Object)才行</li>
<li><p>LockSupport.unpark</p>
<ul>
<li>unpark只是给当前线程设置一个许可证。如果当前线程已经被阻塞了（即调用了park），则会转为不阻塞的状态。</li>
<li>park和unpark的调用顺序无所谓，只要unpark设置了这个许可证，park方法就可以在任意时刻消费许可证，从而不会阻塞方法。</li>
</ul>
</li>
<li><p>注意void interrupt()</p>
<ul>
<li>若线程处于活跃状态，该方法只能将线程中断状态变为true，并不能真正的中断线程，需要被调用的线程自己进行配合才行。</li>
<li>若线程处于阻塞状态，在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。</li>
<li>会在Thread.cpp底层执行LockSupport.unpark(t)，唤醒当前线程</li>
</ul>
</li>
</ul>
</li>
<li><p>阻塞队列BlockingQueue</p>
<ul>
<li><p>分类</p>
<ul>
<li>ArrayBlockingQueue 由数组支持的有界队列</li>
<li>LinkedBlockingQueue 由链接节点支持的可选有界队列</li>
<li>PriorityBlockingQueue 由优先级堆支持的无界优先级队列</li>
<li>DelayQueue 由优先级堆支持的、基于时间的调度队列</li>
</ul>
</li>
<li><p>数据结构</p>
<ul>
<li><p>ArrayBlockingQueue</p>
<ul>
<li>其中Condition类是AQS类的内部类</li>
</ul>
</li>
<li><p>实现实例</p>
<p>  package CODE.多线程;</p>
<p>  import java.util.concurrent.locks.Condition;<br>  import java.util.concurrent.locks.Lock;<br>  import java.util.concurrent.locks.ReentrantLock;</p>
<p>  //Conditon实现有界队列<br>  class BoundQueue<t><br>  {</t></p>
<pre><code>private Object[] items;
private int counts=0; //intems中元素个数
private Lock lock=new ReentrantLock();
private Condition fullCondition=lock.newCondition();
private Condition emptyCondition=lock.newCondition();
public BoundQueue(int size)
{
  items=new Object[size];
}

//向数组里添加元素，如果数组满，进入等待状态
public void add(T t,int addIndex) throws InterruptedException {
  try
  {
    lock.lock();
    //数组已满，添加线程需要进入等待状态
    while(counts==items.length)
    {
      System.out.println(&quot;数组已满，需要等待&quot;);
      fullCondition.await();
    }
    System.out.println(Thread.currentThread().getName()+&quot;在添加元素&quot;);
    items[addIndex]=t;
    counts++;
    //元素添加完毕，需要唤醒清空队列
    emptyCondition.signal();
  }finally {
    lock.unlock();
  }

}
//删除元素方法，如果当前数组为空，移除线程进入等待状态直到数组不为空
public T remove(int removeIndex) throws InterruptedException {
  try
  {
    lock.lock();
    while(counts==0)
    {
      System.out.println(&quot;数组已空，删除等待&quot;);
      emptyCondition.await();
    }
    Object x=items[removeIndex];
    System.out.println(Thread.currentThread().getName()+&quot;在删除元素&quot;);
    counts--;
    //唤醒添加线程
    fullCondition.signal();
    return (T)x; //从大类型到小类型需要强转
  }finally {
    lock.unlock();
  }
}
</code></pre><p>  }<br>  class MyThread implements Runnable<br>  {</p>
<pre><code>private BoundQueue boundQueue;
private int flag;
public MyThread(int flag,BoundQueue boundQueue)
{
  this.boundQueue=boundQueue;
  this.flag=flag;
}
public void run()
{
  if(flag==1)
  {
    try {
      boundQueue.add(&quot;asb&quot;,0);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }
  else
  {
    try {
      boundQueue.remove(1);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }
}
</code></pre><p>  }<br>  public class Bound {</p>
<pre><code>public static void main(String[] args) {
  BoundQueue&lt;String&gt; boundQueue=new BoundQueue&lt;&gt;(2);
  MyThread addthread=new MyThread(1,boundQueue);
  MyThread removethread=new MyThread(0,boundQueue);
  new Thread(removethread,&quot;删除线程1&quot;).start();
  new Thread(addthread,&quot;添加线程1&quot;).start();
  new Thread(addthread,&quot;添加线程2&quot;).start();
}
</code></pre><p>  }</p>
</li>
<li><p>同步队列(CLH)和阻塞队列</p>
<ul>
<li><p>同步队列(CLH)</p>
<ul>
<li>是一个有头尾结点的双向链式队列。(AQS源码)</li>
<li><p>个人理解</p>
<ul>
<li>同步队列可以类比Java线程的就绪态，满足执行条件(IO资源等)，但没拿到CPU时间片。</li>
</ul>
</li>
</ul>
</li>
<li><p>等待队列</p>
<ul>
<li>是一个无头结点单向的链式队列；</li>
<li><p>个人理解</p>
<ul>
<li>等待队列可以类比Java线程的阻塞态，不满足执行条件(生产者(队列满了)消费者(队列空了))</li>
</ul>
</li>
</ul>
</li>
<li><p>共同</p>
<ul>
<li>在ConditionObject 通过持有等待队列的头尾指针来管理等待队列。这个Node复用了AQS的Node类，也就是等待队列和同步队列的结点共用一个Node类。</li>
</ul>
</li>
</ul>
</li>
<li><p>condition类</p>
<ul>
<li><p>结构</p>
<ul>
<li>public class ConditionObject implements Condition, java.io.Serializable {<br> private transient Node firstWaiter;<br> private transient Node lastWaiter;<br> }</li>
<li>在ConditionObject 通过持有等待队列的头尾指针来管理等待队列。这个Node复用了AQS的Node类，也就是等待队列和同步队列的结点共用一个Node类。</li>
</ul>
</li>
<li><p>wait/notify和await/signal</p>
<ul>
<li>从整体上看Object的wait与notify是与对象监视器（synchronized同步代码块或者同步方法中）配合完成线程间的等待通知机制</li>
<li>而Condition的await和signal与Lock配合完成等待通知机制，前者是JVM底层级别（不可以看源码），后者是Java语言级别，具有更高的可控制性和扩展性（可以看源码）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ArrayBlockingQueue源码分析</p>
<ul>
<li><p>生产者以put()为例</p>
<p>  public void put(E e) throws InterruptedException {</p>
<pre><code>  checkNotNull(e);
  final ReentrantLock lock = this.lock;
  lock.lockInterruptibly();
  try {
      while (count == items.length)
          notFull.await();
      enqueue(e);
  } finally {
      lock.unlock();
  }
</code></pre><p>  }</p>
<ul>
<li><p>解释细节</p>
<ul>
<li>如果数组已满，生产者进程进入等待队列；否则，生产元素，唤醒消费者</li>
</ul>
</li>
<li><p>notFull.await();</p>
<p>  public final void await() throws InterruptedException {</p>
<pre><code>  if (Thread.interrupted())
      throw new InterruptedException();
  Node node = addConditionWaiter();
  int savedState = fullyRelease(node);
  int interruptMode = 0;
  while (!isOnSyncQueue(node)) {
      LockSupport.park(this);
      if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
          break;
  }
  if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
      interruptMode = REINTERRUPT;
  if (node.nextWaiter != null) // clean up if cancelled
      unlinkCancelledWaiters();
  if (interruptMode != 0)
      reportInterruptAfterWait(interruptMode);
</code></pre><p>  }</p>
<ul>
<li><p>解释细节</p>
<ul>
<li>1.当前线程释放lock，进入等待队列，并且唤醒同步队列中下一个结点；</li>
<li>2.当前线程被signal/signalAll后从等待队列移至同步队列，直到获取lock才从await方法返回或者在等待时被中断会做中断处理。</li>
</ul>
</li>
<li><p>addConditionWaiter();</p>
<p>  private Node addConditionWaiter() {</p>
<pre><code>  Node t = lastWaiter;
  // If lastWaiter is cancelled, clean out.
  if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {
      unlinkCancelledWaiters();
      t = lastWaiter;
  }
  Node node = new Node(Thread.currentThread(), Node.CONDITION);
  if (t == null)
      firstWaiter = node;
  else
      t.nextWaiter = node;
  lastWaiter = node;
  return node;
</code></pre><p>  }</p>
<ul>
<li><p>过程</p>
<ul>
<li>1.如果等待队列最后一个结点是取消状态，将这个线程移除；</li>
<li>2.将当前线程包装成Node结点，如果等待队列为空（firstWaiter为null），将firstWaiter指向新包装的Node结点，否则，将当前线程尾插到等待队列，更新lastWaiter（尾节点）。</li>
</ul>
</li>
<li><p>细节</p>
<ul>
<li>等待队列是一个无头结点单向的链式队列；</li>
<li>同步队列(CLH)是一个有头尾结点的双向链式队列。</li>
</ul>
</li>
<li><p>将当前线程添加到等待队列中</p>
</li>
</ul>
</li>
<li><p>fullyRelease(node)</p>
<p>  final int fullyRelease(Node node) {</p>
<pre><code>  boolean failed = true;
  try {
      int savedState = getState();
      if (release(savedState)) {
          failed = false;
          return savedState;
      } else {
          throw new IllegalMonitorStateException();
      }
  } finally {
      if (failed)
          node.waitStatus = Node.CANCELLED;
  }
</code></pre><p>  }</p>
<ul>
<li>当前线程结点尾插到等待队列后，会调用release()方法释放lock锁，唤醒同步队列(CLH)中下一个结点</li>
<li><p>tryRelease</p>
<ul>
<li>给锁状态-1，由于可重入性，-1之后state依然不为0，那么持有锁的线程依旧是当前线程，返回false；否则返回true</li>
</ul>
</li>
<li><p>unparkSuccessor</p>
<ul>
<li>唤醒一个CLH结点</li>
</ul>
</li>
</ul>
</li>
<li><p>isOnSyncQueue(node)</p>
<p>  final boolean isOnSyncQueue(Node node) {</p>
<pre><code>  if (node.waitStatus == Node.CONDITION || node.prev == null)
      return false;
  if (node.next != null) // If has successor, it must be on queue
      return true;
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>                    return findNodeFromTail(node);

                }

                - 如果在等待队列中，则阻塞该进程；后续有线程调用codition的signal或者signalAll方法该线程会进入到同步队列

        - enqueue(e);

            private void enqueue(E x) {
                // assert lock.getHoldCount() == 1;
                // assert items[putIndex] == null;
                final Object[] items = this.items;
                items[putIndex] = x;
                if (++putIndex == items.length)
                    putIndex = 0;
                count++;
                notEmpty.signal();
            }

            - notEmpty.signal();

                public final void signal() {
                //当前线程是否持有lock
                    if (!isHeldExclusively())
                        throw new IllegalMonitorStateException();
                //获取等待队列中第一个结点，第一个结点不为空，doSignal()
                    Node first = firstWaiter;
                    if (first != null)
                        doSignal(first);
                }

                - 当调用condition.signal()会使等待队列等待时间最長的线程结点也就是头结点移动到同步队列；当调用condition.signalAll()会使等待队列中所有结点移动到同步队列中。

                - doSignal(first);

                    private void doSignal(Node first) {
                        do {
                    //先将等待队列第一个结点指向下一个结点，如果为空，证明等待队列只有当前线程，那么将lastWaiter指向null
                            if ( (firstWaiter = first.nextWaiter) == null)
                                lastWaiter = null;
                            first.nextWaiter = null;
                        } 
                    //transferForSignal方法对该线程节点做真正的处理
                    while (!transferForSignal(first) &amp;&amp;
                                 (first = firstWaiter) != null);
                    }

                    - transferForSignal(first)

                        final boolean transferForSignal(Node node) {
                            /*
                             * If cannot change waitStatus, the node has been cancelled.
                             */
                        //首先将结点状态设置为0
                            if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
                                return false;

                            /*
                             * Splice onto queue and try to set waitStatus of predecessor to
                             * indicate that thread is (probably) waiting. If cancelled or
                             * attempt to set waitStatus fails, wake up to resync (in which
                             * case the waitStatus can be transiently and harmlessly wrong).
                             */

                        //将结点使用enq尾插到同步队列中
                            Node p = enq(node);
                            int ws = p.waitStatus;
                            if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
                                LockSupport.unpark(node.thread);
                            return true;
                        }

    - 消费者以take()为例

        public E take() throws InterruptedException {
            final ReentrantLock lock = this.lock;
            lock.lockInterruptibly();
            try {
                while (count == 0)
                    notEmpty.await();
                return dequeue();
            } finally {
                lock.unlock();
            }
        }

        - notEmpty.await();
        - dequeue();

- put()整体流程

    - 1.lock.lock

        - 一开始会AQS竞争锁
        - 没有争取到的先进入CLH队列，后续等待唤醒

    - 2.若不满足入队条件(如数组满了)(await)

        - 将执行权让出，进入等待队列

    - 3.后续singal方法唤醒该线程(数组不是满的了,符合执行条件,但可能多个线程都符合执行条件)

        - 将当前线程移入CLH队列，竞争锁

    - 4.执行业务逻辑
</code></pre><h3 id="第四节：Semaphore-共享模式-及相关AQS应用详解"><a href="#第四节：Semaphore-共享模式-及相关AQS应用详解" class="headerlink" title="第四节：Semaphore(共享模式)及相关AQS应用详解"></a>第四节：Semaphore(共享模式)及相关AQS应用详解</h3><ul>
<li><p>Semaphore</p>
<ul>
<li><p>使用场景：限流，如Hytrix</p>
</li>
<li><p>案例</p>
<p>  public static void main(String[] args) {</p>
<pre><code>  Semaphore semaphore = new Semaphore(3);

  for (int i = 0; i &lt; 10; i++) {
     new Thread(() -&gt;{
       try {
         semaphore.acquire();
         System.out.println(Thread.currentThread().getName() + &quot;\t 进入抢购秒杀页面，准备抢小米9&quot;);
         //停3秒后离开
         try {
           TimeUnit.SECONDS.sleep(3);
         } catch (InterruptedException e) {
           e.printStackTrace();
         }
         System.out.println(Thread.currentThread().getName() + &quot;\t 离开抢购秒杀页面，成功抢到小米9&quot;);
       } catch (InterruptedException e) {
         e.printStackTrace();
       }finally {
         semaphore.release();
       }
     },&quot;用户&quot; + String.valueOf(i)).start();
  }
}
</code></pre></li>
</ul>
</li>
<li><p>CountDownLatch</p>
<ul>
<li><p>使用场景</p>
<ul>
<li><p>多个线程需要等待其他线程的工作之后，再进行其后续工作。即让多个线程在同一个起跑线进行</p>
<ul>
<li><p>案例</p>
<p>  public static void main(String[] args) throws InterruptedException {</p>
<pre><code>  final CountDownLatch latch = new CountDownLatch(1);
  new Thread(() -&gt; {
    System.out.println(Thread.currentThread().getName() + &quot; Do some initial working.&quot;);
    try {
      Thread.sleep(1000);
      latch.await();
      System.out.println(Thread.currentThread().getName() + &quot; Do other working.&quot;);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }).start();

  new Thread(() -&gt; {
    System.out.println(Thread.currentThread().getName() + &quot; Do some initial working.&quot;);
    try {
      Thread.sleep(1000);
      latch.await();
      System.out.println(Thread.currentThread().getName() + &quot; Do other working.&quot;);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }).start();

  new Thread(() -&gt; {
    System.out.println(&quot;asyn prepare for some data.&quot;);
    try {
      Thread.sleep(2000);
      System.out.println(&quot;Data prepare for done.&quot;);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }finally {
      latch.countDown();
    }
  }).start();

}
</code></pre></li>
</ul>
</li>
<li><p>当线程池中指定的线程数执行完，再去执行后面的操作</p>
<ul>
<li><p>案例</p>
<p>  public static void main(String[] args) throws InterruptedException {</p>
<pre><code>  CountDownLatch countDownLatch = new CountDownLatch(6);

  for (int i = 0; i &lt; 6; i++) {
     new Thread(() -&gt;{
      System.out.println(&quot;\t\t&quot; + Thread.currentThread().getName() + &quot;处理完毕~~~&quot;);
      countDownLatch.countDown();
      System.out.println(&quot;非调用者线程-&quot; + Thread.currentThread().getName() + &quot;-还可以干点其他事&quot;);
     }, Country.forEach_Country(i + 1).getCountryName()).start();
  }

  countDownLatch.await();
  System.out.println(&quot;-----------------------------&quot;);
  System.out.println(&quot;\t 所有任务都已经处理完毕，可以往后执行了！&quot;);
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>CyclicBarrier</p>
<ul>
<li><p>和CountDownLatch类似，区别在于CyclicBarrier可以重复使用</p>
<ul>
<li><p>案例</p>
<p>  public static void main(String[] args) {</p>
<pre><code>  CyclicBarrier cyclicBarrier = new CyclicBarrier(7,() -&gt; System.out.println(&quot;收集到7颗龙珠,召唤神龙&quot;));

  for (int i = 0; i &lt; 7; i++) {
     final int temp = i + 1;
     new Thread(() -&gt;{
      System.out.println(Thread.currentThread().getName() + &quot;\t收集到第&quot; + temp + &quot;颗龙珠&quot;);
       try {
         int await = cyclicBarrier.await();
         System.out.println(&quot;还剩几个:&quot; + await);
       } catch (InterruptedException e) {
         e.printStackTrace();
       } catch (BrokenBarrierException e) {
         e.printStackTrace();
       }
     },&quot;线程&quot; + String.valueOf(i)).start();
  }
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>Exchanger(不常用)</p>
</li>
</ul>
<h2 id="4-Atomic类-amp-Unsafe类"><a href="#4-Atomic类-amp-Unsafe类" class="headerlink" title="4.Atomic类&amp;Unsafe类"></a>4.Atomic类&amp;Unsafe类</h2><h3 id="CAS-CompareAndSet"><a href="#CAS-CompareAndSet" class="headerlink" title="CAS(CompareAndSet)"></a>CAS(CompareAndSet)</h3><ul>
<li><p>相关Atomic类</p>
<ul>
<li><p>数组类型</p>
<ul>
<li>AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</li>
</ul>
</li>
<li><p>属性原子修改器（Updater）</p>
<ul>
<li>AtomicIntegerFieldUpdater、 AtomicLongFieldUpdater、AtomicReferenceFieldUpdater</li>
<li>此类方法封装了Unsafe类获取偏移量的操作</li>
</ul>
</li>
</ul>
</li>
<li><p>三大基本CAS</p>
<ul>
<li>compareAndSwapObject<br>  compareAndSwapInt<br>  compareAndSwapLong</li>
<li>基于硬件原语-CMPXCHG实现原子操作cas</li>
</ul>
</li>
<li><p>问题</p>
<ul>
<li><p>ABA问题</p>
<ul>
<li><p>描述：B从A那偷偷取钱，之后投资赚了钱，把钱又偷偷还给了A</p>
</li>
<li><p>解决</p>
<ul>
<li><p>每次修改的时候加个版本</p>
</li>
<li><p>使用AtomicStampedReference类</p>
<p>  static AtomicStampedReference<integer> num = new AtomicStampedReference&lt;&gt;(100,1);</integer></p>
<pre><code>public static void main(String[] args) {
  int stamp = num.getStamp();//初始版本号

  new Thread(() -&gt;{
    num.compareAndSet(100,101,num.getStamp(),num.getStamp() + 1);
    System.out.println(Thread.currentThread().getName() + &quot;\t 版本号&quot; + num.getStamp());
    num.compareAndSet(101,100,num.getStamp(),num.getStamp() + 1);
    System.out.println(Thread.currentThread().getName() + &quot;\t 版本号&quot; + num.getStamp());
  },&quot;线程A&quot;).start();
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>                new Thread(() -&gt;{
                  try {
                    TimeUnit.SECONDS.sleep(3);
                  } catch (InterruptedException e) {
                    e.printStackTrace();
                  }
                  boolean b = num.compareAndSet(100, 209, stamp, num.getStamp() + 1);
                  System.out.println(b + &quot;\t 当前版本号: \t&quot; + num.getStamp());
                  System.out.println(&quot;当前最新值 \t&quot; + num.getReference().toString());
                },&quot;线程B&quot;).start();
              }

- CAS 长时间一直不成功，会给 CPU 带来很大的开销

    - 解决

        - LongAdder：分段CAS操作

            - 默认一开始使用CAS单个cell作为base，当线程多了之后，开启多个cell单元，用于分担base的压力，之后需要值的时候返回base+所有cell的值

        - 示意图
</code></pre><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><ul>
<li><p>为我们提供了类似C、C++手动管理内存的能力，可能会造成内存泄漏</p>
</li>
<li><p>应用</p>
<ul>
<li>文件上传，并发量也比较高；可以用unsafe申请堆外内存</li>
</ul>
</li>
<li><p>案例</p>
<ul>
<li><p>//在AtomicInteger类中获取到value的偏移量，从而操作value<br>private static final Unsafe unsafe = Unsafe.getUnsafe();<br>private static final long valueOffset;</p>
<p>static {</p>
<pre><code>try {
    valueOffset = unsafe.objectFieldOffset
        (AtomicInteger.class.getDeclaredField(&quot;value&quot;));
} catch (Exception ex) { throw new Error(ex); }
</code></pre><p>}</p>
</li>
</ul>
</li>
</ul>
<h2 id="5-HashMap-amp-ConcurrentHashMap"><a href="#5-HashMap-amp-ConcurrentHashMap" class="headerlink" title="5.HashMap&amp;ConcurrentHashMap"></a>5.HashMap&amp;ConcurrentHashMap</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul>
<li><p>为什么初始容量必须是2的整数次幂</p>
<ul>
<li>1.计算hashcode时，return h &amp; (length-1);因为要获取数组下标使用位运算，如果不是2的整数次幂，会出错</li>
<li>2.使用位运算，而不是用mod运算，是因为位运算效率比mod运算高得多，后续扩容效率更高。</li>
</ul>
</li>
<li><p>加载因子为什么是0.75</p>
<ul>
<li>时间和空间上比较均衡</li>
<li>目的:为了减少hash碰撞table长度会扩容一倍</li>
</ul>
</li>
<li><p>1.7:数组+链表</p>
<ul>
<li><p>示意图</p>
</li>
<li><p>put()</p>
<p>  public V put(K key, V value) {</p>
<pre><code>   // 1.第一次put元素
  // 数组为空进行参数初始化-表示第一次put元素
  if (table == EMPTY_TABLE) {
    // 数组初始化/参数初始化
    // 第一次put时，threshold经过构造方法赋值为16
    inflateTable(threshold);
  }
  // 2.添加key为null的元素
  if (key == null)
    return putForNullKey(value);
    // 3.添加key非null的元素
  // 计算hash值
  int hash = hash(key);
  // 计算数组对应下标值
  int i = indexFor(hash, table.length);
  // 遍历数组下标为i的链表
  for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
    Object k;
    // hash冲突 &amp;&amp; key相同
    if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
      // 获取遍历节点元素值
      V oldValue = e.value;
      // 对value进行覆盖
      e.value = value;
      // value被覆盖时调用
      e.recordAccess(this);
      // 返回旧元素值
      return oldValue;
    }
  }
  // 操作次数++
  modCount++;
  // 添加Entry节点
  addEntry(hash, key, value, i);
  return null;
}
</code></pre><ul>
<li><p>indexFor():根据hashCode计算数组下标</p>
<p>  static int indexFor(int h, int length) {</p>
<pre><code>return h &amp; (length-1);
</code></pre><p>  }</p>
</li>
<li><p>addEntry():添加链表节点</p>
<p>  // 添加Entry节点</p>
<pre><code>void addEntry(int hash, K key, V value, int bucketIndex) {
  // map元素个数 &gt; 扩容阈值 &amp;&amp; 当前数组位置对应链表不为空
  if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
    // 将源数组中的元素值散列至新数组
    resize(2 * table.length);
    // 计算hash值 - 重新计算
    hash = (null != key) ? hash(key) : 0;
    // 计算对应新数组下标位置
    bucketIndex = indexFor(hash, table.length);
  }
  // 添加Eentry节点
  createEntry(hash, key, value, bucketIndex);
}
</code></pre><ul>
<li><p>resize():扩容</p>
<p>  // 将源数组中的元素值散列至新数组</p>
<pre><code>void resize(int newCapacity) {
  // 获取源数组
  Entry[] oldTable = table;
  // 获取源数组长度
  int oldCapacity = oldTable.length;
  // 数组长度最大值设置
  if (oldCapacity == MAXIMUM_CAPACITY) {
    threshold = Integer.MAX_VALUE;
    return;
  }
  // 创建长度为源数组长度2倍的新数组
  Entry[] newTable = new Entry[newCapacity];
  // 将源数组中的元素值散列至新数组
  transfer(newTable, initHashSeedAsNeeded(newCapacity));
  // 将新数组赋值至源数组
  table = newTable;
  // 重新计算扩容阈值
  threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
}
</code></pre><ul>
<li><p>transfer():挨个将链表节点复制到新数组链表上，同时重新计算hash值</p>
<p>  void transfer(Entry[] newTable, boolean rehash) {</p>
<pre><code>  // 获取新数组长度
  int newCapacity = newTable.length;
  // 遍历源数组，将元素按照一定规则散列至新数组
  // 外循环：遍历数组
  for (Entry&lt;K,V&gt; e : table) {
    // 内循环：遍历数组位置对应链表
    while(null != e) {
      // 获取当前节点下一个节点
      Entry&lt;K,V&gt; next = e.next;
      if (rehash) {
        // true：重新计算hash值
        e.hash = null == e.key ? 0 : hash(e.key);
      }
      // 获取对应新数组的下标值
      int i = indexFor(e.hash, newCapacity);
      // 下面三步一定要连起来去思考：
      // **前提条件，2次循环都作用于新数组同一下标位置的情况：
      // 第一次循环时，newTable[i]为空，先赋值给当前遍历节点的下个节点，再将当前遍历节点赋值给对应新下标的新数组，最后继续循环
      // 第二次循环时，newTable[i]为上次(存入同一下标位置对应新数组的链表)，然后赋值给当前遍历节点的下个节点(此节点实则为上一次遍历节点的下一个节点，
      //   从这里可以看出，HashMap1.7这里用的是头插法)，再将此链表赋值给同一下标位置的新数组中，最后不为空继续循环；
      e.next = newTable[i];
      newTable[i] = e;
      e = next;
    }
  }
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>1.8:数组+链表+红黑树</p>
<ul>
<li><p>红黑树</p>
<ul>
<li><p>为什么不用二叉平衡树</p>
<ul>
<li>在频繁需要写的场景中AVL效率不高</li>
<li>红黑树牺牲严格的平衡性，换来了写操作时少量的旋转操作</li>
</ul>
</li>
</ul>
</li>
<li><p>重要参数</p>
<ul>
<li>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; Hash表默认初始容量</li>
<li>MAXIMUM_CAPACITY = 1 &lt;&lt; 30; 最大Hash表容量</li>
<li>DEFAULT_LOAD_FACTOR = 0.75f；默认加载因子</li>
<li>TREEIFY_THRESHOLD = 8；链表转红黑树阈值</li>
<li>UNTREEIFY_THRESHOLD = 6；红黑树转链表阈值</li>
<li>MIN_TREEIFY_CAPACITY = 64；链表转红黑树时hash表最小容量阈值，达不到优先扩容。</li>
</ul>
</li>
<li><p>putVal()</p>
<p>  final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</p>
<pre><code>             boolean evict) {
  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
  if ((tab = table) == null || (n = tab.length) == 0)
      n = (tab = resize()).length;
  if ((p = tab[i = (n - 1) &amp; hash]) == null)
      tab[i] = newNode(hash, key, value, null);
  else {
      Node&lt;K,V&gt; e; K k;
      if (p.hash == hash &amp;&amp;
          ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
          e = p;
      else if (p instanceof TreeNode)
          e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
      else {
          for (int binCount = 0; ; ++binCount) {
              if ((e = p.next) == null) {
                  p.next = newNode(hash, key, value, null);
                  if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                      treeifyBin(tab, hash);
                  break;
              }
              if (e.hash == hash &amp;&amp;
                  ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                  break;
              p = e;
          }
      }
      if (e != null) { // existing mapping for key
          V oldValue = e.value;
          if (!onlyIfAbsent || oldValue == null)
              e.value = value;
          afterNodeAccess(e);
          return oldValue;
      }
  }
  ++modCount;
  if (++size &gt; threshold)
      resize();
  afterNodeInsertion(evict);
  return null;
</code></pre><p>  }</p>
<ul>
<li><p>treeifyBin()</p>
<p>  final void treeifyBin(Node<k,v>[] tab, int hash) {</k,v></p>
<pre><code>  int n, index; Node&lt;K,V&gt; e;
  if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
      resize();
  else if ((e = tab[index = (n - 1) &amp; hash]) != null) {
      TreeNode&lt;K,V&gt; hd = null, tl = null;
      do {
          TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);
          if (tl == null)
              hd = p;
          else {
              p.prev = tl;
              tl.next = p;
          }
          tl = p;
      } while ((e = e.next) != null);
      if ((tab[index] = hd) != null)
          hd.treeify(tab);
  }
</code></pre><p>  }</p>
<ul>
<li>若链表节点数目超过TREEIFY_THRESHOLD(默认为8)，转换为红黑树</li>
<li><p>resize();</p>
<ul>
<li>Node<k,v>[] table这个数组大小 小于MIN_TREEIFY_CAPACITY时选择扩容，反之，树形化</k,v></li>
</ul>
</li>
</ul>
</li>
<li><p>流程图</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ConcurrentHashMap-替代了HashTable-因为它的方法基本用Synchronized修饰"><a href="#ConcurrentHashMap-替代了HashTable-因为它的方法基本用Synchronized修饰" class="headerlink" title="ConcurrentHashMap(替代了HashTable,因为它的方法基本用Synchronized修饰)"></a>ConcurrentHashMap(替代了HashTable,因为它的方法基本用Synchronized修饰)</h3><ul>
<li><p>1.7基于ReentrantLock(Segment)实现分段锁</p>
<ul>
<li><p>put()</p>
<ul>
<li>第一次计算key的hash，找到Segment元素的位置；</li>
<li>判断当前Segment元素是否初始化，若没有初始化，则通过CAS进行初始化；</li>
<li>第二次计算key的hash，找到HashEntry数组的位置；</li>
<li>由于Segment继承了ReentrantLock锁，所以TryLock() 尝试获取锁，如果锁获取成功，将数据插入到HashEntry位置，如果遇到Hash冲突，则插入到链表的末端；如果锁被其他线程获取，那么就会以自旋的方式重新获取锁，超过指定的次数之后还获取不到的话，就会挂起，等待唤醒；</li>
</ul>
</li>
<li><p>锁粒度为Segment</p>
</li>
</ul>
</li>
<li><p>1.8CAS+基于synchronized实现分段锁</p>
<ul>
<li><p>put()</p>
<p>  final V putVal(K key, V value, boolean onlyIfAbsent) {</p>
<pre><code>  if (key == null || value == null) throw new NullPointerException();
  int hash = spread(key.hashCode());
  int binCount = 0;
  for (Node&lt;K,V&gt;[] tab = table;;) {
      Node&lt;K,V&gt; f; int n, i, fh;
      if (tab == null || (n = tab.length) == 0)
          tab = initTable();
      else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
          if (casTabAt(tab, i, null,
                       new Node&lt;K,V&gt;(hash, key, value, null)))
              break;                   // no lock when adding to empty bin
      }
      else if ((fh = f.hash) == MOVED)
          tab = helpTransfer(tab, f);
      else {
          V oldVal = null;
          synchronized (f) {
              if (tabAt(tab, i) == f) {
                  if (fh &gt;= 0) {
                      binCount = 1;
                      for (Node&lt;K,V&gt; e = f;; ++binCount) {
                          K ek;
                          if (e.hash == hash &amp;&amp;
                              ((ek = e.key) == key ||
                               (ek != null &amp;&amp; key.equals(ek)))) {
                              oldVal = e.val;
                              if (!onlyIfAbsent)
                                  e.val = value;
                              break;
                          }
                          Node&lt;K,V&gt; pred = e;
                          if ((e = e.next) == null) {
                              pred.next = new Node&lt;K,V&gt;(hash, key,
                                                        value, null);
                              break;
                          }
                      }
                  }
                  else if (f instanceof TreeBin) {
                      Node&lt;K,V&gt; p;
                      binCount = 2;
                      if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                     value)) != null) {
                          oldVal = p.val;
                          if (!onlyIfAbsent)
                              p.val = value;
                      }
                  }
              }
          }
          if (binCount != 0) {
              if (binCount &gt;= TREEIFY_THRESHOLD)
                  treeifyBin(tab, i);
              if (oldVal != null)
                  return oldVal;
              break;
          }
      }
  }
  addCount(1L, binCount);
  return null;
</code></pre><p>  }</p>
<ul>
<li><p>如果没有初始化就先调用initTable（）方法来进行初始化过程；</p>
<p>  if (tab == null || (n = tab.length) == 0)</p>
<pre><code>  tab = initTable();
</code></pre></li>
<li><p>如果没有hash冲突就直接CAS插入；</p>
<p>  else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {</p>
<pre><code>  if (casTabAt(tab, i, null,
               new Node&lt;K,V&gt;(hash, key, value, null)))
      break;                   // no lock when adding to empty bin
</code></pre><p>  }</p>
</li>
<li><p>如果还在进行扩容操作就先进行扩容；</p>
<p>  else if ((fh = f.hash) == MOVED)</p>
<pre><code>  tab = helpTransfer(tab, f);
</code></pre><ul>
<li>如果HashTable触发了扩容，就会把当前Node设置为ForwardingNode</li>
</ul>
</li>
<li><p>如果存在hash冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入；</p>
<p>  if (fh &gt;= 0) {</p>
<pre><code>  binCount = 1;
  for (Node&lt;K,V&gt; e = f;; ++binCount) {
      K ek;
      if (e.hash == hash &amp;&amp;
          ((ek = e.key) == key ||
           (ek != null &amp;&amp; key.equals(ek)))) {
          oldVal = e.val;
          if (!onlyIfAbsent)
              e.val = value;
          break;
      }
      Node&lt;K,V&gt; pred = e;
      if ((e = e.next) == null) {
          pred.next = new Node&lt;K,V&gt;(hash, key,
                                    value, null);
          break;
      }
  }
</code></pre><p>  }</p>
</li>
<li><p>最后一个如果该链表的数量大于阈值8，就要先转换成黑红树的结构，break再一次进入循环；</p>
<p>  else if (f instanceof TreeBin) {</p>
<pre><code>  Node&lt;K,V&gt; p;
  binCount = 2;
  if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                 value)) != null) {
      oldVal = p.val;
      if (!onlyIfAbsent)
          p.val = value;
  }
</code></pre><p>  }</p>
</li>
<li><p>如果添加成功就调用addCount（）方法统计size，并且检查是否需要扩容；</p>
<p>  if (binCount != 0) {</p>
<pre><code>  if (binCount &gt;= TREEIFY_THRESHOLD)
      treeifyBin(tab, i);
  if (oldVal != null)
      return oldVal;
  break;
</code></pre><p>  }</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>参考</p>
</li>
</ul>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><ul>
<li><p>特性</p>
<ul>
<li>适用场景为读多写少</li>
<li>不能读取实时性的数据，但能保证最终数据一致性</li>
<li>空间换时间</li>
</ul>
</li>
<li><p>add()</p>
<ul>
<li>public boolean add(E e) {<br>  final ReentrantLock lock = this.lock;<br>  lock.lock();<br>  try {<pre><code>  Object[] elements = getArray();
  int len = elements.length;
  Object[] newElements = Arrays.copyOf(elements, len + 1);
  newElements[len] = e;
  setArray(newElements);
  return true;
</code></pre>  } finally {<pre><code>  lock.unlock();
</code></pre>  }<br>  }</li>
<li>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</li>
<li>写操作需要加锁，防止并发写入时导致写入数据丢失。</li>
<li>写操作结束之后需要把原始数组指向新的复制数组。</li>
</ul>
</li>
</ul>
<h3 id="需要key有序"><a href="#需要key有序" class="headerlink" title="需要key有序"></a>需要key有序</h3><ul>
<li>TreeMap：线程不安全</li>
<li><p>ConcurrentSkipListMap:和索引结构类似</p>
<ul>
<li>时间复杂度O(logn)，和索引类似</li>
<li>参考</li>
</ul>
</li>
</ul>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><ul>
<li><p>1.ThreadLocal 是什么？有哪些使用场景</p>
<ul>
<li>ThreadLocal 是一个本地线程副本变量工具类，在每个线程中都创建了一个 ThreadLocalMap 对象</li>
<li><p>使用场景</p>
<ul>
<li>为每个线程分配一个 JDBC 连接 Connection。这样就可以保证每个线程的都在各自的 Connection 上进行数据库的操作，不会出现 A 线程关了 B线程正在使用的 Connection</li>
</ul>
</li>
</ul>
</li>
<li><p>2.什么是线程局部变量</p>
<ul>
<li>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。</li>
</ul>
</li>
<li><p>3.ThreadLocal造成内存泄漏的原因</p>
<ul>
<li>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。</li>
<li>所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</li>
<li>这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露</li>
</ul>
</li>
<li><p>4.ThreadLocal内存泄漏解决方案</p>
<ul>
<li>每次使用完ThreadLocal，都调用它的remove()方法，清除数据</li>
</ul>
</li>
<li><p>拓展</p>
<ul>
<li>ThreadLocal的 key 是弱引用，那么在 ThreadLocal.get()的时候，发生GC之后，key 是否为null？</li>
<li><p>ThreadLocal中ThreadLocalMap的数据结构？</p>
<ul>
<li>set时候会获取到每个Thread.ThreadLocalMap，往这个map中放值</li>
</ul>
</li>
<li><p>ThreadLocalMap的Hash 算法？</p>
</li>
<li>ThreadLocalMap中Hash 冲突如何解决？</li>
<li>ThreadLocalMap的扩容机制？</li>
<li>ThreadLocalMap中过期 key 的清理机制？探测式清理和启发式清理流程？</li>
<li>ThreadLocalMap.set()方法实现原理？</li>
<li>ThreadLocalMap.get()方法实现原理？</li>
<li>项目中ThreadLocal使用情况？遇到的坑？</li>
</ul>
</li>
</ul>
<h2 id="6-ThreadPoolExecutor线程池"><a href="#6-ThreadPoolExecutor线程池" class="headerlink" title="6.ThreadPoolExecutor线程池"></a>6.ThreadPoolExecutor线程池</h2><h3 id="工人-猪的例子很好-1-20左右"><a href="#工人-猪的例子很好-1-20左右" class="headerlink" title="工人-猪的例子很好(1:20左右)"></a>工人-猪的例子很好(1:20左右)</h3><h3 id="线程状态图"><a href="#线程状态图" class="headerlink" title="线程状态图"></a>线程状态图</h3><h3 id="线程池的目的和优势"><a href="#线程池的目的和优势" class="headerlink" title="线程池的目的和优势"></a>线程池的目的和优势</h3><ul>
<li>重用存在的线程，减少线程创建，消亡的开销，提高性能</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="ThreadPoolExecutor构造函数的重要参数"><a href="#ThreadPoolExecutor构造函数的重要参数" class="headerlink" title="ThreadPoolExecutor构造函数的重要参数"></a>ThreadPoolExecutor构造函数的重要参数</h3><p>public ThreadPoolExecutor(int corePoolSize,<br>               int maximumPoolSize,<br>               long keepAliveTime,<br>               TimeUnit unit,<br>               BlockingQueue<runnable> workQueue,<br>               ThreadFactory threadFactory,<br>               RejectedExecutionHandler handler)</runnable></p>
<ul>
<li>corePoolSize：核心线程数</li>
<li>maximumPoolSize：线程池最大线程数</li>
<li>keepAliveTime：允许线程最大闲置时间</li>
<li>unit：闲置时间单位</li>
<li>workQueue：一个阻塞队列，用于保存等待被执行的任务</li>
<li>threadFactory：线程工厂，用于创建新线程</li>
<li><p>handler：拒绝策略</p>
<ul>
<li>AbortPolicy：直接抛出异常，默认策略</li>
<li>CallerRunsPolicy：用调用者所在的线程来执行任务</li>
<li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务</li>
<li>DiscardPolicy：直接丢弃任务</li>
</ul>
</li>
</ul>
<h3 id="线程池重要属性"><a href="#线程池重要属性" class="headerlink" title="线程池重要属性"></a>线程池重要属性</h3><ul>
<li><p>ctl 是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段</p>
<p>  private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));<br>   private static final int COUNT_BITS = Integer.SIZE - 3;<br>   private static final int CAPACITY  = (1 &lt;&lt; COUNT_BITS) - 1;</p>
</li>
</ul>
<h3 id="线程池架构"><a href="#线程池架构" class="headerlink" title="线程池架构"></a>线程池架构</h3><ul>
<li>并没有标注哪些是核心线程，移除线程时，是随机移除，最后只要保证线程数等于传入的核心线程数即可</li>
</ul>
<h3 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h3><p>public void execute(Runnable command) {<br>  if (command == null)<br>    throw new NullPointerException();<br>  /*</p>
<pre><code> * clt记录着runState和workerCount
 */
</code></pre><p>  int c = ctl.get();<br>  /*</p>
<pre><code> * workerCountOf方法取出低29位的值，表示当前活动的线程数；
 * 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中；
 * 并把任务添加到该线程中。
 */
</code></pre><p>  if (workerCountOf(c) &lt; corePoolSize) {<br>      /*</p>
<pre><code>     * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；
     * 如果为true，根据corePoolSize来判断；
     * 如果为false，则根据maximumPoolSize来判断
     */
if (addWorker(command, true))
  return;
/*
     * 如果添加失败，则重新获取ctl值
     */
c = ctl.get();
</code></pre><p>  }<br>  /*</p>
<pre><code> * 如果当前线程池是运行状态并且任务添加到队列成功
 */
</code></pre><p>  if (isRunning(c) &amp;&amp; workQueue.offer(command)) {<br>      // 重新获取ctl值<br>    int recheck = ctl.get();<br>    // 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，<br>        // 这时需要移除该command<br>        // 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回<br>    if (! isRunning(recheck) &amp;&amp; remove(command))<br>      reject(command);<br>    /*</p>
<pre><code>     * 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法
     * 这里传入的参数表示：
     * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；
     * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；
     * 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。
     */
else if (workerCountOf(recheck) == 0)
  addWorker(null, false);
</code></pre><p>  }<br>  /*</p>
<pre><code> * 如果执行到这里，有两种情况：
 * 1. 线程池已经不是RUNNING状态；
 * 2. 线程池是RUNNING状态，但workerCount &gt;= corePoolSize并且workQueue已满。
 * 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；
 * 如果失败则拒绝该任务
 */
</code></pre><p>  else if (!addWorker(command, false))<br>    reject(command);<br>}</p>
<ul>
<li><p>方法解释</p>
<ul>
<li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；</li>
<li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
<li><p>整体流程图</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li><p>addWorker(Runnable firstTask, boolean core)：添加线程</p>
<p>  private boolean addWorker(Runnable firstTask, boolean core) {</p>
<pre><code>  boolean workerStarted = false;
  boolean workerAdded = false;
  Worker w = null;
  try {
      w = new Worker(firstTask);
      final Thread t = w.thread;
      if (t != null) {
          final ReentrantLock mainLock = this.mainLock;
          mainLock.lock();
          try {
              // Recheck while holding lock.
              // Back out on ThreadFactory failure or if
              // shut down before lock acquired.
              int rs = runStateOf(ctl.get());

              if (rs &lt; SHUTDOWN ||
                  (rs == SHUTDOWN &amp;&amp; firstTask == null)) {
                  if (t.isAlive()) // precheck that t is startable
                      throw new IllegalThreadStateException();
                  workers.add(w);
                  int s = workers.size();
                  if (s &gt; largestPoolSize)
                      largestPoolSize = s;
                  workerAdded = true;
              }
          } finally {
              mainLock.unlock();
          }
          if (workerAdded) {
              t.start();
              workerStarted = true;
          }
      }
  } finally {
      if (! workerStarted)
          addWorkerFailed(w);
  }
  return workerStarted;
</code></pre><p>  }</p>
<ul>
<li><p>细节</p>
<ul>
<li><p>Worker类：封装了Thread，继承了AQS类，即“工人”</p>
<p>  private final class Worker</p>
<pre><code>  extends AbstractQueuedSynchronizer
  implements Runnable
</code></pre><p>  {</p>
<pre><code>  /**
   * This class will never be serialized, but we provide a
   * serialVersionUID to suppress a javac warning.
   */
  private static final long serialVersionUID = 6138294804551838833L;

  /** Thread this worker is running in.  Null if factory fails. */
  final Thread thread;
  /** Initial task to run.  Possibly null. */
  Runnable firstTask;
  /** Per-thread task counter */
  volatile long completedTasks;
</code></pre></li>
</ul>
</li>
<li><p>t.start()会执行runWorker(Worker w)：执行当前任务</p>
<p>  Thread wt = Thread.currentThread();<br>  Runnable task = w.firstTask;<br>  w.firstTask = null;<br>  w.unlock(); // allow interrupts<br>  boolean completedAbruptly = true;<br>  try {</p>
<pre><code>  while (task != null || (task = getTask()) != null) {
      w.lock();
      // If pool is stopping, ensure thread is interrupted;
      // if not, ensure thread is not interrupted.  This
      // requires a recheck in second case to deal with
      // shutdownNow race while clearing interrupt
      if ((runStateAtLeast(ctl.get(), STOP) ||
           (Thread.interrupted() &amp;&amp;
            runStateAtLeast(ctl.get(), STOP))) &amp;&amp;
          !wt.isInterrupted())
          wt.interrupt();
      try {
          beforeExecute(wt, task);
          Throwable thrown = null;
          try {
              task.run();
          } catch (RuntimeException x) {
              thrown = x; throw x;
          } catch (Error x) {
              thrown = x; throw x;
          } catch (Throwable x) {
              thrown = x; throw new Error(x);
          } finally {
              afterExecute(task, thrown);
          }
      } finally {
          task = null;
          w.completedTasks++;
          w.unlock();
      }
  }
  completedAbruptly = false;
</code></pre><p>  } finally {</p>
<pre><code>  processWorkerExit(w, completedAbruptly);
</code></pre><p>  }</p>
<ul>
<li><p>getTask():从阻塞队列中获取任务</p>
<p>  boolean timedOut = false; // Did the last poll() time out?</p>
<p>  for (;;) {</p>
<pre><code>  // Are workers subject to culling?
  boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;

  try {
      Runnable r = timed ?
          workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
          workQueue.take();
      if (r != null)
          return r;
      timedOut = true;
  } catch (InterruptedException retry) {
      timedOut = false;
  }
</code></pre><p>  }</p>
<ul>
<li><p>细节</p>
<ul>
<li>getTask()返回null的话，在runWorker()中会跳出while循环，执行processWorkerExit()，从而执行workers.remove()移除该工作线程</li>
</ul>
</li>
<li><p>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) ，如果在keepAliveTime内未获取到任务，返回null</p>
</li>
<li>workQueue.take();如果队列为空，会阻塞直到队列不为空</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul>
<li><p>美团线程池骚操作</p>
</li>
<li><p>线程池源码详解</p>
</li>
</ul>
<h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><ul>
<li>tomcat的线程池用于处理请求，springboot自建的线程池用于处理业务</li>
</ul>
<h2 id="7-ScheduledThreadPoolExecutor"><a href="#7-ScheduledThreadPoolExecutor" class="headerlink" title="7.ScheduledThreadPoolExecutor"></a>7.ScheduledThreadPoolExecutor</h2><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ul>
<li><p>执行流程图</p>
</li>
<li><p>构造方法</p>
<ul>
<li><p>ScheduledThreadPoolExecutor(int corePoolSize)</p>
<p>  public ScheduledThreadPoolExecutor(int corePoolSize) {</p>
<pre><code>  super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
        new DelayedWorkQueue());
</code></pre><p>  }</p>
<ul>
<li>继承了父类的构造方法</li>
<li>想实现定时任务，所以要依靠DelayedWorkQueue</li>
</ul>
</li>
<li><p>ScheduledFutureTask：调用定时任务方法时，传入Runnable类后会封装成ScheduledFutureTask</p>
<p>  ScheduledFutureTask(Runnable r, V result, long ns, long period) {</p>
<pre><code>  super(r, result);
  this.time = ns;
  this.period = period;
  this.sequenceNumber = sequencer.getAndIncrement();
</code></pre><p>  }</p>
<ul>
<li>ScheduledFutureTask类继承图</li>
</ul>
</li>
</ul>
</li>
<li><p>两种延迟(定时)任务方法</p>
<ul>
<li><p>scheduleAtFixedRate</p>
<p>  public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</p>
<pre><code>                                            long initialDelay,
                                            long period,
                                            TimeUnit unit) {
  if (command == null || unit == null)
      throw new NullPointerException();
  if (period &lt;= 0)
      throw new IllegalArgumentException();
  ScheduledFutureTask&lt;Void&gt; sft =
      new ScheduledFutureTask&lt;Void&gt;(command,
                                    null,
                                    triggerTime(initialDelay, unit),
                                    unit.toNanos(period));
  RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);
  sft.outerTask = t;
  delayedExecute(t);
  return t;
</code></pre><p>  }</p>
<ul>
<li><p>decorateTask(command, sft)</p>
<p>  protected <v> RunnableScheduledFuture<v> decorateTask(</v></v></p>
<pre><code>  Runnable runnable, RunnableScheduledFuture&lt;V&gt; task) {
  return task;
</code></pre><p>  }</p>
<ul>
<li>默认返回传入的task，可以重载自定义</li>
</ul>
</li>
<li><p>sft.outerTask = t;</p>
<ul>
<li>将任务赋值给outerTask，方便后面定时执行</li>
</ul>
</li>
<li><p>delayedExecute(t);</p>
<ul>
<li><p>super.getQueue().add(task);</p>
<ul>
<li>与ThreadPoolExecutor不同的是，这里直接把任务加入延迟队列</li>
</ul>
</li>
<li><p>ensurePrestart();该方法会走ThreadPoolExecutor，从队列中取任务执行，并且构造函数传入的是DelayedWorkQueue，详细流程参考ThreadPoolExecutor</p>
<ul>
<li><p>DelayedWorkQueue.take()取任务执行</p>
<p>  public RunnableScheduledFuture&lt;?&gt; take() throws InterruptedException {</p>
<pre><code>  final ReentrantLock lock = this.lock;
  lock.lockInterruptibly();
  try {
      for (;;) {
          RunnableScheduledFuture&lt;?&gt; first = queue[0];
          if (first == null)
              available.await();
          else {
              long delay = first.getDelay(NANOSECONDS);
              if (delay &lt;= 0)
                  return finishPoll(first);
              first = null; // don&#39;t retain ref while waiting
              if (leader != null)
                  available.await();
              else {
                  Thread thisThread = Thread.currentThread();
                  leader = thisThread;
                  try {
                      available.awaitNanos(delay);
                  } finally {
                      if (leader == thisThread)
                          leader = null;
                  }
              }
          }
      }
  } finally {
      if (leader == null &amp;&amp; queue[0] != null)
          available.signal();
      lock.unlock();
  }
</code></pre><p>  }</p>
<ul>
<li>available.awaitNanos(delay);阻塞到执行时间</li>
</ul>
</li>
<li><p>ScheduledFutureTask.run()</p>
<p>  public void run() {</p>
<pre><code>  boolean periodic = isPeriodic();
  if (!canRunInCurrentRunState(periodic))
      cancel(false);
  else if (!periodic)
      ScheduledFutureTask.super.run();
  else if (ScheduledFutureTask.super.runAndReset()) {
      setNextRunTime();
      reExecutePeriodic(outerTask);
  }
</code></pre><p>  }</p>
<ul>
<li><p>setNextRunTime();</p>
<p>  private void setNextRunTime() {</p>
<pre><code>  long p = period;
  if (p &gt; 0)
      time += p;
  else
      time = triggerTime(-p);
</code></pre><p>  }</p>
<ul>
<li>计算下次任务执行时间</li>
</ul>
</li>
<li><p>reExecutePeriodic(outerTask);</p>
<p>  void reExecutePeriodic(RunnableScheduledFuture&lt;?&gt; task) {</p>
<pre><code>  if (canRunInCurrentRunState(true)) {
      super.getQueue().add(task);
      if (!canRunInCurrentRunState(true) &amp;&amp; remove(task))
          task.cancel(false);
      else
          ensurePrestart();
  }
</code></pre><p>  }</p>
<ul>
<li>与ensurePrestart类似：把任务放到队列中，重新创建线程执行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>scheduleWithFixedDelay</p>
<p>  public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</p>
<pre><code>                                               long initialDelay,
                                               long delay,
                                               TimeUnit unit) {
  if (command == null || unit == null)
      throw new NullPointerException();
  if (delay &lt;= 0)
      throw new IllegalArgumentException();
  ScheduledFutureTask&lt;Void&gt; sft =
      new ScheduledFutureTask&lt;Void&gt;(command,
                                    null,
                                    triggerTime(initialDelay, unit),
                                    unit.toNanos(-delay));
  RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);
  sft.outerTask = t;
  delayedExecute(t);
  return t;
</code></pre><p>  }</p>
<ul>
<li>与scheduleAtFixedRate不同的是delay会变成-delay，然后在setNextRunTime();设置执行时间</li>
</ul>
</li>
</ul>
</li>
<li><p>使用实例</p>
<p>  @Slf4j<br>  public class ScheduleThreadPoolRunner {</p>
<pre><code>public static void main(String[] args) {
  ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);

  //发心跳，service1-&gt;service2,每次过5s，发送一个心跳，证明s2可用
  scheduledThreadPoolExecutor.scheduleWithFixedDelay(() -&gt; {
    log.info(&quot;send heart beat&quot;);
    long starttime = System.currentTimeMillis(), nowtime = starttime;
    while ((nowtime - starttime) &lt; 5000) {
      nowtime = System.currentTimeMillis();
      try {
        Thread.sleep(100);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
    log.info(&quot;task over....&quot;);
  }, 1000, 2000, TimeUnit.MILLISECONDS);
}
</code></pre><p>  }</p>
</li>
</ul>
<h3 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h3><ul>
<li><p>按照执行时间的升序来排列</p>
</li>
<li><p>依赖的数据结构是堆</p>
</li>
<li><p>offer()</p>
<p>  public boolean offer(Runnable x) {</p>
<pre><code>  if (x == null)
      throw new NullPointerException();
  RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;
  final ReentrantLock lock = this.lock;
  lock.lock();
  try {
      int i = size;
      if (i &gt;= queue.length)
          grow();
      size = i + 1;
      if (i == 0) {
          queue[0] = e;
          setIndex(e, 0);
      } else {
          siftUp(i, e);
      }
      if (queue[0] == e) {
          leader = null;
          available.signal();
      }
  } finally {
      lock.unlock();
  }
  return true;
</code></pre><p>  }</p>
</li>
</ul>
<h2 id="8-Future-amp-ForkJoin"><a href="#8-Future-amp-ForkJoin" class="headerlink" title="8.Future&amp;ForkJoin"></a>8.Future&amp;ForkJoin</h2><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><ul>
<li><p>异步执行任务</p>
</li>
<li><p>使用get()阻塞直到任务完成</p>
</li>
<li><p>get()</p>
<p>  public V get() throws InterruptedException, ExecutionException {</p>
<pre><code>  int s = state;
  if (s &lt;= COMPLETING)
      s = awaitDone(false, 0L);
  return report(s);
</code></pre><p>  }</p>
</li>
</ul>
<h3 id="ForkJoin-不常用"><a href="#ForkJoin-不常用" class="headerlink" title="ForkJoin(不常用)"></a>ForkJoin(不常用)</h3><ul>
<li><p>分而治之，充分利用CPU</p>
<ul>
<li>每个线程都有一个工作队列Deque</li>
</ul>
</li>
<li><p>工作窃取算法</p>
<ul>
<li>scan()方法扫描到就会窃取其他线程的任务</li>
</ul>
</li>
<li><p>流程图</p>
</li>
<li><p>工作场景</p>
<ul>
<li>数据清洗</li>
<li>排序</li>
<li>查找</li>
<li>数据量特别大</li>
</ul>
</li>
</ul>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><ul>
<li>美团</li>
</ul>
<h2 id="9-disruptor-思想先进，用得不多"><a href="#9-disruptor-思想先进，用得不多" class="headerlink" title="9.disruptor(思想先进，用得不多)"></a>9.disruptor(思想先进，用得不多)</h2><h3 id="工作原理图"><a href="#工作原理图" class="headerlink" title="工作原理图"></a>工作原理图</h3><h3 id="对阻塞队列的一种改进"><a href="#对阻塞队列的一种改进" class="headerlink" title="对阻塞队列的一种改进"></a>对阻塞队列的一种改进</h3><ul>
<li>阻塞队列同时只能有一个线程在工作</li>
<li>disruptor支持多生产-消费</li>
<li>基本无锁</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://alexander-wd.github.io/alex-next/2022/03/22/javaEE/JVM学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="alex">
      <meta itemprop="description" content="时光静好,与君语;细水流年,与君同;繁华落尽,与君老.">
      <meta itemprop="image" content="/alex-next/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="alex的博客 - github.com">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/alex-next/2022/03/22/javaEE/JVM学习笔记/" class="post-title-link" itemprop="url">JVM学习笔记</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2022-03-22 16:03:12" itemprop="dateCreated datePublished" datetime="2022-03-22T16:03:12+08:00">2022-03-22</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-13 17:56:29" itemprop="dateModified" datetime="2023-02-13T17:56:29+08:00">2023-02-13</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/alex-next/categories/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="1-类加载机制"><a href="#1-类加载机制" class="headerlink" title="1.类加载机制"></a>1.类加载机制</h2><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h3><p>在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的 main()方法，new对象等等，在加载阶段会在内存中生成一个代表这个类的 java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>
<ul>
<li><p>1.类加载器初始化过程</p>
<p>  参见类运行加载全过程图可知其中会创建JVM启动器实例sun.misc.Launcher。<br>  sun.misc.Launcher初始化使用了单例模式设计，保证一个JVM虚拟机内只有一个 sun.misc.Launcher实例。<br>   在Launcher构造方法内部，其创建了两个类加载器，<br>  分别是<br>  sun.misc.Launcher.ExtClassLoader(扩展类加载器)和sun.misc.Launcher.AppClassLoader(应 用类加载器)。 JVM默认使用Launcher的getClassLoader()方法返回的类加载器AppClassLoader的实例加载我们 的应用程序。</p>
<ul>
<li>类加载运行全过程图</li>
<li><p>类加载器</p>
<ul>
<li>1.引导类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如rt.jar、charsets.jar等 </li>
<li>2.扩展类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR类包</li>
<li>3.应用程序类加载器：负责加载ClassPath路径下的类包，主要就是加载你自己写的那些类</li>
<li>4.自定义加载器：负责加载用户自定义路径下的类包 </li>
</ul>
</li>
</ul>
</li>
<li><p>2.双亲委派机制</p>
<ol>
<li>首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接 返回。<ol>
<li>如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加 载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加载器来加载。</li>
</ol>
</li>
<li>如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的 findClass方法来完成类加载。(注意AppClassLoader和ExtClassLoader的findClass方法均在URLClassLoader中实现)</li>
</ol>
<ul>
<li><p>双亲委派机制</p>
</li>
<li><p>为什么要设计双亲委派机制</p>
<ul>
<li>1.沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心<br>  API库被随意篡改 </li>
<li>2.避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证被加载类的唯一性</li>
</ul>
</li>
<li><p>细节</p>
<p>  双亲委派机制<br>  向上委托主要是判断要加载的类有没有被加载到内存，如果已被加载到内存，就没必要继续向上委托。<br>  而父类向下委托则是判断自己的类路径中有没有该类，有的话直接加载进内存。</p>
</li>
</ul>
</li>
<li><p>2.*全盘负责委托机制</p>
<ul>
<li>“全盘负责”是指当一个ClassLoder装载一个类时，除非显示的使用另外一个ClassLoder，该类<br>  所依赖及引用的类也由这个ClassLoder载入。 </li>
</ul>
</li>
</ul>
<h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h3><p>校验字节码文件的正确性</p>
<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3.准备"></a>3.准备</h3><p>给类的静态变量分配内存，并赋予默认值</p>
<h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h3><p>将符号引用替换为直接引用(也就是得到类或者字段、方法在内存中的指针或者偏移量)，该阶段会把一些静态方法(符号引用，<br>比如 main()方法替换为指向数据所存内存的指针或句柄等(直接引用)，<br>这是所谓的静态链接过程(类加载期间完成)，动态链接是在程序运行期间完成的将符号引用替换为直接引用，下节课会讲到动态链接</p>
<h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h3><p>对类的静态变量初始化为指定的值，<br>执行静态代码块</p>
<h3 id="6-结果"><a href="#6-结果" class="headerlink" title="6.结果"></a>6.结果</h3><p>类被加载到方法区中后主要包含<br>运行时常量池、类型信息、字段信息、方法信息、类加载器的 引用、对应class实例的引用等信息。<br>类加载器的引用：这个类到类加载器实例的引用 对应class实例的引用：类加载器在加载类信息放到方法区中后，会创建一个对应的Class 类型的 对象实例放到堆(Heap)中, 作为开发人员访问方法区中类定义的入口和切入点。</p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，<br>一个是 loadClass(String, boolean)，实现了双亲委派机制，<br>还有一个方法是findClass，默认实现是空 方法，所以我们自定义类加载器主要是重写findClass方法。<br>注:AppClassLoader和ExtClassLoader都继承了URLClassLoader，所以在后续向下委托过程中都能够在各自的类路径中找到并加载相应的类，<br>所以重写findClass方法实际上就是为了实现defineClass方法，将类路径的类加载进来。</p>
<h3 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h3><p>主要思路：<br>在双亲委派的核心方法loadClass中，删掉原有双亲委派的代码，判断哪些类需要双薪委派，哪些类不需要。<br>注：因为Object,String 等JAVA类库中的类只能通过BootStrapClassLoader进行加载。</p>
<ul>
<li>示例</li>
</ul>
<h3 id="tomcat类加载器分析-P13"><a href="#tomcat类加载器分析-P13" class="headerlink" title="tomcat类加载器分析(P13)"></a>tomcat类加载器分析(P13)</h3><ul>
<li><p>1.为什么要打破双亲委派机制</p>
<ul>
<li><p>1.一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。</p>
<ul>
<li>默认的类加载机制是无法加载两个相同类库的不同版本的，默认 的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。</li>
</ul>
</li>
<li><p>2.部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程 序，那么要有10份相同的类库加载进虚拟机。</p>
<ul>
<li>默认的类加载机制是可以实现的，因为他的职责就是保证唯一性</li>
</ul>
</li>
<li><p>3.web容器也有自己依赖的类库，不能与应用程序的类库混淆。基于安全考虑，应该让容器的 类库和程序的类库隔离开来。</p>
<ul>
<li>和第一个问题一样</li>
</ul>
</li>
<li><p>4.web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中 运行，但程序运行后修改jsp已经是司空见惯的事情， web容器需要支持 jsp 修改后不用重启。</p>
<ul>
<li><p>我们想我们要怎么实现jsp文件的热加载，jsp 文件其实也就是class文 件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp 是不会重新加载的。</p>
<ul>
<li>每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载 器。重新创建类加载器，重新加载jsp文件。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="如何判断两个class对象是否相同？"><a href="#如何判断两个class对象是否相同？" class="headerlink" title="如何判断两个class对象是否相同？"></a>如何判断两个class对象是否相同？</h3><ul>
<li>1.类的完整类名必须一致，包括包名</li>
<li>2.加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</li>
</ul>
<h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><ul>
<li><p>1.为什么自定义的类加载器的parent属性是AppClassLoader</p>
<p>  通常实现自己的类加载器都会继承ClassLoader类，<br>  在执行自己的类加载器构造方法时，会先执行父类(ClassLoader)的构造方法，父类构造方法中会将parent属性设置为AppClassLoader。</p>
<ul>
<li>参考图</li>
</ul>
</li>
</ul>
<h2 id="2-对象创建到回收整体流程"><a href="#2-对象创建到回收整体流程" class="headerlink" title="2.对象创建到回收整体流程"></a>2.对象创建到回收整体流程</h2><h3 id="JDK体系结构"><a href="#JDK体系结构" class="headerlink" title="JDK体系结构"></a>JDK体系结构</h3><p>JDK包含了JRE和各种开发工具(如java.exe,javap.exe,javac.exe)，<br>而JRE又包含了JVM和各种JAVA常用类库(如util,concurrency,)</p>
<ul>
<li>参考</li>
</ul>
<h3 id="Java的跨平台特性"><a href="#Java的跨平台特性" class="headerlink" title="Java的跨平台特性"></a>Java的跨平台特性</h3><h3 id="整体结构和内存模型"><a href="#整体结构和内存模型" class="headerlink" title="整体结构和内存模型"></a>整体结构和内存模型</h3><ul>
<li><p>运行时数据区</p>
<ul>
<li>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域</li>
</ul>
</li>
<li><p>五大区域</p>
<ul>
<li><p>程序计数器</p>
<ul>
<li>当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成</li>
</ul>
</li>
<li><p>虚拟机栈(线程栈)</p>
<ul>
<li>用于存储局部变量表、操作数栈、动态链接、方法出口等信息</li>
</ul>
</li>
<li><p>本地方法栈</p>
<ul>
<li>与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的</li>
<li><p>局部变量表</p>
<ul>
<li>存基本数据类型和对象引用</li>
</ul>
</li>
<li><p>操作数栈</p>
<ul>
<li>方法调用的中转站</li>
</ul>
</li>
<li><p>动态链接</p>
<ul>
<li>动态链接的作用就是为了将符号引用转换为调用方法的直接引用(与类装载解析阶段是将静态方法的符号引用转换为直接引用不同)</li>
</ul>
</li>
<li><p>方法出口</p>
<ul>
<li>return 或异常</li>
</ul>
</li>
</ul>
</li>
<li><p>堆</p>
<ul>
<li>Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存</li>
</ul>
</li>
<li><p>方法区</p>
<ul>
<li>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据</li>
</ul>
</li>
</ul>
</li>
<li><p>线程共享</p>
<ul>
<li>堆</li>
<li>方法区</li>
</ul>
</li>
<li><p>线程私有</p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
</li>
</ul>
<h3 id="元空间默认是21M，如果设置过小，满了之后会频繁full-gc"><a href="#元空间默认是21M，如果设置过小，满了之后会频繁full-gc" class="headerlink" title="元空间默认是21M，如果设置过小，满了之后会频繁full gc"></a>元空间默认是21M，如果设置过小，满了之后会频繁full gc</h3><p>-XX：MetaspaceSize： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M，达到该值就会触发 full gc进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超 过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。</p>
<h3 id="方法区、元空间、永久代"><a href="#方法区、元空间、永久代" class="headerlink" title="方法区、元空间、永久代"></a>方法区、元空间、永久代</h3><h2 id="3-内存分配机制"><a href="#3-内存分配机制" class="headerlink" title="3.内存分配机制"></a>3.内存分配机制</h2><h3 id="方法区中的类元信息使用C-实现的，是JVM调用代码使用的，类加载完成之后会在堆中生成Class对象，这个是供开发人员使用的"><a href="#方法区中的类元信息使用C-实现的，是JVM调用代码使用的，类加载完成之后会在堆中生成Class对象，这个是供开发人员使用的" class="headerlink" title="方法区中的类元信息使用C++实现的，是JVM调用代码使用的，类加载完成之后会在堆中生成Class对象，这个是供开发人员使用的"></a>方法区中的类元信息使用C++实现的，是JVM调用代码使用的，类加载完成之后会在堆中生成Class对象，这个是供开发人员使用的</h3><h3 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1.对象的创建"></a>1.对象的创建</h3><ul>
<li><p>对象创建主要流程</p>
</li>
<li><p>1.类加载检查</p>
<p>  首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个<br>  符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
</li>
<li><p>2.分配内存(详见对象内存分配)</p>
<ul>
<li><p>分配内存的方法</p>
<ul>
<li>指针碰撞：类比顺序链表，依次分配内存</li>
<li>空闲链表：类比单链表，哪有空间就存哪</li>
</ul>
</li>
<li><p>解决并发问题</p>
<ul>
<li><p>CAS轮询</p>
<p>  类比并发中的CAS操作，失败重试</p>
</li>
<li><p>本地线程分配缓冲TLAB</p>
<p>  每个线程在堆中预先分配一小块内存，若不够，再CAS轮询</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>3.初始化</p>
<p>  内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）， 如果使用TLAB，这一工作过程也<br>  可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问<br>  到这些字段的数据类型所对应的零值。</p>
</li>
<li><p>4.设置对象头</p>
<ul>
<li><p>1.对象头</p>
<ul>
<li>mark word</li>
<li>Klass Pointer类型指针：对象指向它的类元数据的指针</li>
<li>数组长度(4字节，只有数组对象才有)</li>
</ul>
</li>
<li><p>对象的内存布局</p>
<ul>
<li><p>1.对象头</p>
<ul>
<li>如上</li>
</ul>
</li>
<li><p>2.实例数据</p>
</li>
<li><p>3.对齐填充</p>
<ul>
<li><p>一般以8B为倍数填充，因为计算机组成原理告诉我们一行一行找比一个一个找效率高</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>5.执行<init>方法</init></p>
<p>  执行<init>方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋值（注意，这与上面的赋<br>  零值不同，这是由程序员赋的值），和执行构造方法。</init></p>
</li>
<li><p>指针压缩</p>
<ul>
<li>节省空间</li>
<li>减少GC</li>
<li>对象指针在栈中，对象实体在堆中</li>
</ul>
</li>
<li><p>对象创建初始化与类加载中的初始化对比</p>
<ul>
<li>1.类加载的整体过程都包含在对象创建的加载类中，是对象创建的其中一步(类加载检查，检查是否已加载该类，没加载，就执行第一章的类加载的过程)</li>
<li>2.类加载中的初始化 ，是初始化静态变量以及执行静态代码块，而对象创建的初始化是初始化普通变量(赋0值)</li>
</ul>
</li>
</ul>
<h3 id="2-对象内存分配"><a href="#2-对象内存分配" class="headerlink" title="2.对象内存分配"></a>2.对象内存分配</h3><ul>
<li><p>对象内存分配流程图</p>
</li>
<li><p>1.对象栈上分配(很少发生)：分配到栈空间上，方法结束能够立即回收，减少GC压力</p>
<ul>
<li><p>逃逸分析</p>
<ul>
<li>就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。</li>
</ul>
</li>
<li><p>标量替换</p>
<ul>
<li>通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该 对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就 不会因为没有一大块连续空间导致对象内存不够分配。</li>
</ul>
</li>
<li><p>标量与聚合量</p>
<ul>
<li>例如int,long是标量，对象是聚合量</li>
</ul>
</li>
</ul>
</li>
<li><p>2.对象在Eden区分配</p>
<p>  大量的对象被分配在eden区，eden区满了后会触发minor gc，可能会有99%以上的对象成为垃圾被回收掉，剩余存活的对象会被挪到为空的那块survivor区，下一次eden区满了后又会触发minor gc，把eden区和survivor区垃圾对象回收，把剩余存活的对象一次性挪动到另外一块为空的survivor区，因为新生代的对象都是朝生夕死的，存活时间很短，所以JVM默认的8:1:1的比例是很合适的，让eden区尽量的大，survivor区够用即可，<br>  JVM默认有这个参数-XX:+UseAdaptiveSizePolicy(默认开启)，会导致这个8:1:1比例自动变化，如果不想这个比例有变 化可以设置参数-XX:-UseAdaptiveSizePolicy</p>
</li>
<li><p>大对象直接进入老年代</p>
<ul>
<li>避免大对象分配内存时复制操作而降低效率</li>
<li><p>-XX:PretenureSizeThreshold 可以设置大 对象的大小，只在 Serial 和ParNew两个收集器下 有效。</p>
<ul>
<li>比如设置JVM参数：-XX:PretenureSizeThreshold=1000000 (单位是字节) -XX:+UseSerialGC</li>
</ul>
</li>
</ul>
</li>
<li><p>长期存活的对象将进入老年代</p>
<ul>
<li>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1。</li>
<li>对象晋升到老年代 的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置</li>
</ul>
</li>
<li><p>对象动态年龄判断</p>
<p>  当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的 50%(-XX:TargetSurvivorRatio可以指定)，那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了，<br>  例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会 把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。对象动态年 龄判断机制一般是在minor gc之后触发的。</p>
<ul>
<li>详解</li>
</ul>
</li>
<li><p>老年代空间分配担保机制</p>
</li>
</ul>
<h3 id="3-对象内存回收"><a href="#3-对象内存回收" class="headerlink" title="3.对象内存回收"></a>3.对象内存回收</h3><ul>
<li><p>minorGC和fullGC</p>
<ul>
<li>minorGC:发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。</li>
<li>fullGC:一般会回收老年代 ，年轻代，方法区的垃圾，Major GC的速度一般会比Minor GC的慢 10倍以上</li>
<li>minorGC在eden区满了回收，fullGC在old区满了回收</li>
</ul>
</li>
<li><p>1.引用计数法</p>
<ul>
<li>算法：每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0 的对象就是不可能再被使用的。</li>
<li>弊端：循环引用发生内存泄漏</li>
</ul>
</li>
<li><p>2.可达性分析算法</p>
<ul>
<li>将“GC Roots” 对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为非垃圾对象，其余未标记的 对象都是垃圾对象 GC Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等</li>
</ul>
</li>
<li><p>finalize()方法最终判定对象是否存活(不常用)</p>
</li>
<li><p>如何判断一个类是无用的类</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
</ul>
<h2 id="4-垃圾回收"><a href="#4-垃圾回收" class="headerlink" title="4.垃圾回收"></a>4.垃圾回收</h2><h3 id="1-垃圾回收算法"><a href="#1-垃圾回收算法" class="headerlink" title="1.垃圾回收算法"></a>1.垃圾回收算法</h3><ul>
<li><p>分代收集理论</p>
<p>  在新生代中，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可 以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，<br>  所以我们必须选 择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法慢10倍以上。</p>
</li>
<li><p>1.复制算法</p>
</li>
<li><p>2.标记清除算法</p>
</li>
<li><p>3.标记整理算法</p>
</li>
</ul>
<h3 id="2-垃圾收集器"><a href="#2-垃圾收集器" class="headerlink" title="2.垃圾收集器"></a>2.垃圾收集器</h3><ul>
<li><p>1.Serial</p>
<ul>
<li>-XX:+UseSerialGC -XX:+UseSerialOldGC</li>
</ul>
</li>
<li><p>2.Parallel</p>
<ul>
<li>-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代)</li>
</ul>
</li>
<li><p>3.ParNew</p>
<ul>
<li>-XX:+UseParNewGC，和Parallel相似，主要区别是ParNew可以和CMS收集器配合使用</li>
</ul>
</li>
<li><p>4.CMS</p>
<ul>
<li><p>-XX:+UseConcMarkSweepGC(old)</p>
</li>
<li><p>步骤</p>
<ul>
<li><p>1.初始标记</p>
<ul>
<li>STW暂停所有其他线程，记录下gc roots直接能引用的对象，速度很快。</li>
</ul>
</li>
<li><p>2.并发标记</p>
<p>  这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。</p>
<ul>
<li>从gc roots的直接关联对象开始遍历整个对象图的过程</li>
</ul>
</li>
<li><p>3.重新标记</p>
<p>  这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三色标记里的增量更新算法(见下面详解)做重新标记。</p>
<ul>
<li>会STW，为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对 象的标记记录</li>
</ul>
</li>
<li><p>4.并发清理</p>
<ul>
<li>开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理</li>
</ul>
</li>
<li><p>5.并发重置</p>
<ul>
<li>重置本次GC过程中的标记数据</li>
</ul>
</li>
</ul>
</li>
<li><p>优点和缺点</p>
<ul>
<li><p>优点</p>
<ul>
<li>并发收集、低停顿，对用户反馈友好</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>对CPU资源敏感(会和服务抢资源)</p>
</li>
<li><p>无法处理浮动垃圾</p>
<p>  在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了</p>
</li>
<li><p>使用标记清除算法结束后会产生大量空间碎片</p>
</li>
<li><p>执行过程中的不确定性:若一边回收，一边运行，可能没回收完，就会触发Full GC，会报”concurrent mode failure”，会STW，退化为用serial old收集器处理</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>核心参数</p>
<ul>
<li>-XX:+UseConcMarkSweepGC：启用cms</li>
<li>-XX:ConcGCThreads：并发的GC线程数</li>
<li>-XX:+UseCMSCompactAtFullCollection：FullGC之后做压缩整理（减少碎片），解决缺点第三条</li>
<li>-XX:CMSFullGCsBeforeCompaction：多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一 次</li>
<li>-XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC（默认是92，这是百分比）</li>
<li>-XX:+UseCMSInitiatingOccupancyOnly：只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设 定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整</li>
<li>-XX:+CMSScavengeBeforeRemark：在CMS GC前启动一次minor gc，目的在于减少老年代对年轻代的引 用，降低CMS GC的标记阶段时的开销，一般CMS的GC耗时 80%都在标记阶段</li>
<li>-XX:+CMSParallellnitialMarkEnabled：表示在初始标记的时候多线程执行，缩短STW</li>
<li>-XX:+CMSParallelRemarkEnabled：在重新标记的时候多线程执行，缩短STW;</li>
</ul>
</li>
</ul>
</li>
<li><p>5.G1</p>
<ul>
<li><p>重要特性</p>
<p>  软实时（soft real-time）。所谓的实时垃圾回收，是指在要求的时间内完成垃圾回收。“软实时”则是指，用户可以指定垃圾回收时间的限时，G1会努力在这个时限内完成垃圾回收，但是G1并不担保每次都能在这个时限内完成垃圾回收。通过设定一个合理的目标，可以让达到90%以上的垃圾回收时间都在这个时限内。</p>
</li>
<li><p>回收流程图</p>
</li>
<li><p>特点</p>
<ul>
<li><p>可预测的停顿</p>
<ul>
<li>这是 G1 相对于 CMS 的一个大优势</li>
</ul>
</li>
<li><p>空间整合</p>
<ul>
<li>与 CMS 的“标记-清理”算法不同</li>
<li>G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li>
</ul>
</li>
<li><p>分代收集</p>
<ul>
<li>虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念</li>
</ul>
</li>
<li><p>并行与并发</p>
<ul>
<li>G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。</li>
<li>部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
</ul>
</li>
<li><p>有优先级的回收策略</p>
<ul>
<li><p>在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字 Garbage-First的由来)</p>
<ul>
<li>比如一个Region花200ms能回收10M垃圾，另外一个Region花50ms能回收20M垃圾，在回收时间有限情况下，G1当然会优先选择后面这个Region回收。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>步骤</p>
<ul>
<li><p>初始标记</p>
<ul>
<li>同CMS</li>
</ul>
</li>
<li><p>并发标记</p>
<ul>
<li>同CMS</li>
</ul>
</li>
<li><p>最终标记</p>
<ul>
<li>同CMS重新标记</li>
</ul>
</li>
<li><p>筛选回收</p>
<ul>
<li>会STW</li>
<li><p>首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划</p>
<ul>
<li>例：老年代此时有1000个 Region都满了，但是因为根据预期停顿时间，本次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得 知，可能回收其中800个Region刚好需要200ms，那么就只会回收800个Region(Collection Set，要回收的集合)，尽量把GC导致的停顿时间控制在我们指定的范围内。</li>
<li>可以用JVM参数 -XX:MaxGCPauseMillis指定GC停顿时间</li>
</ul>
</li>
<li><p>不管是年轻代或是老年代，回收算法主要用的是复制算法</p>
<ul>
<li>将一个region中的存活对象复制到另一个region中，这种不会像CMS那样 回收完因为有很多内存碎片还需要整理一次，G1采用复制算法回收几乎不会有太多内存碎片</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>G1 垃圾收集分类</p>
<ul>
<li><p>Young GC</p>
<ul>
<li>YoungGC并不是说现有的Eden区放满了就会马上触发，而是接近参数 -XX:MaxGCPauseMills 设定的值</li>
</ul>
</li>
<li><p>Mixed GC</p>
<ul>
<li>老年代的堆占有率达到参数(-XX:InitiatingHeapOccupancyPercent)设定的值则触发</li>
<li>回收所有的 Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区</li>
</ul>
</li>
<li><p>Full GC</p>
<ul>
<li>Mixed GC使用复制算法发现没有足够的空region就会触发</li>
<li>STW，使用Serial单线程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>*6.ZGC(了解)</p>
<ul>
<li><p>过程</p>
<ul>
<li>1.并发标记：和G1差不多，只不过会用颜色指针记录GC信息</li>
<li>2.并发预备重分配：找出哪些region需要回收</li>
<li>3.并发重分配：利用复制算法GC，每个region维护了一个转发表，后续使用读屏障的地址就是根据转发表获取</li>
<li>4.并发重映射：复制算法将存活对象移到新region中，其他引用该存活对象的引用也要修改，比较耗时，并发执行或者到下次GC并发标记</li>
</ul>
</li>
<li><p>颜色指针</p>
<ul>
<li>概念:GC过程中，将对象可达性标记信息记在引用对象的指针上的技术(无需进行对象访问就可以获得 GC 信息)—结合并发重分配和读屏障理解</li>
<li><p>优点</p>
<ul>
<li>因为可达性标记信息都记录在引用对象指针上，所以region的存活对象被移走后，这个region就能被回收，而不用等到所有引用该对象的对象都修改完毕。</li>
<li>大幅减少GC过程中内存屏障的使用次数</li>
<li>具有强大的扩展性</li>
</ul>
</li>
<li><p>结合读屏障实现垃圾回收</p>
<ul>
<li>如果这时候对象在GC时被移动了，接下来JVM就会加上一个读屏障，这个 屏障会把读出的指针更新到对象的新地址上，并且把堆里的这个指针“修正”到原本的字段里。</li>
</ul>
</li>
</ul>
</li>
<li><p>读屏障</p>
<ul>
<li>在读操作之前，改变引用地址</li>
</ul>
</li>
</ul>
</li>
<li><p>并发标记底层原理—三色标记算法</p>
<ul>
<li><p>标记颜色含义</p>
<ul>
<li>黑色： 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描 过， 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过 灰色对象） 指向某个白色对象。</li>
<li>灰色： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。</li>
<li>白色： 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若 在分析结束的阶段， 仍然是白色的对象， 即代表不可达。</li>
</ul>
</li>
<li><p>步骤</p>
<ul>
<li>1.初始时，所有对象都在 【白色集合】中；</li>
<li>2.将GC Roots 直接引用到的对象 挪到 【灰色集合】中；</li>
<li><p>3.从灰色集合中获取对象：</p>
<ul>
<li>将本对象 引用到的 其他对象 全部挪到 【灰色集合】中；</li>
<li>将本对象 挪到 【黑色集合】里面。</li>
</ul>
</li>
<li><p>重复步骤3，直至【灰色集合】为空时结束。</p>
</li>
</ul>
</li>
<li><p>产生的问题</p>
<ul>
<li><p>浮动垃圾(多标)</p>
<ul>
<li><p>原因</p>
<ul>
<li>并发标记过程中一开始标记为非垃圾，之后方法结束gc root被销毁，只能等下一轮gc</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li>并发清理或并发标记过程中产生的新对象都标记为黑色，本轮不进行清除</li>
</ul>
</li>
</ul>
</li>
<li><p>对象消失(漏标)</p>
<ul>
<li><p>原因</p>
<ul>
<li>在并发标记时，若一个对象本来是垃圾，后又被其他对象引用(救回来了)，这时候这个垃圾如果被GC，会产生严重的bug</li>
<li><p>示例：先赋null，后赋值</p>
<ul>
<li>objE.fieldG = null</li>
<li>objD.fieldG = G</li>
</ul>
</li>
</ul>
</li>
<li><p>产生漏标需要满足的条件</p>
<ul>
<li>赋值器插入了一条或者多条从黑色对象到白色对象的新引用；</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p>增量更新</p>
<p>  当黑色对象插入新的指向白色对象的引用关系时， 就将这个新插入的引用记录下来， 等并发扫描结束之后， 再将这些记录过的引用关系中的黑色对象为根， 重新扫描一次。这可以简化理解为， 黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了。</p>
<ul>
<li>当黑色对象插入新的指向白色对象的引用时，就将这个新加入的引用记录下来，待并发标记完成后，重新对这种新增的引用记录进行扫描</li>
<li><p>实质</p>
<ul>
<li>破坏第一个条件</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>会重新扫描这个黑色对象的所有引用,比较浪费时间</li>
</ul>
</li>
</ul>
</li>
<li><p>原始快照</p>
<ul>
<li>记录从灰色对象删除的引用，并发标记完成后，对该记录进行重新扫描,并将重新扫描到的白色对象直接标记为黑色，不用一层层遍历</li>
<li><p>实质</p>
<ul>
<li>破坏第二个条件</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>这个白色对象有可能并没有黑色对象去引用它，导致它本来应该被回收掉却在本次GC活了下来，产生浮动垃圾</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>相比增量更新来说，只需从灰色对象开始扫描，节省时间。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>解决方案底层原理</p>
<ul>
<li>增量更新和原始快照对引用关系的记录(无论是删除还是新增的引用)，虚拟机的记录操作都是通过写屏障实现的</li>
<li><p>增量更新</p>
<ul>
<li>类似AOP，在成员变量赋值后，记录下新增的引用记录</li>
</ul>
</li>
<li><p>原始快照(SATB)</p>
<ul>
<li>类似AOP，在成员变量赋值前(比如a.b=null引用消失)，记录下来</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>疑惑</p>
<ul>
<li><p>在增量更新中。灰色对象引用了白色对象，不用管吗</p>
<ul>
<li><p>根据三色标记算法步骤得知，灰色对象引用白色对象，不用管，不会造成漏标（在前灰色对象未扫描时，被其他灰色对象引用，这个其后的灰色对象必定会紧接着被扫描到，而黑色对象不会再被扫描到）</p>
<ul>
<li><p>灰色对象未扫描到(灰色)</p>
<ul>
<li>那么就会按照步骤继续扫描</li>
</ul>
</li>
<li><p>灰色对象被扫描到(不可能是灰色，必是黑色)</p>
<ul>
<li>如果是黑色，那就是黑色对象引用了白色对象的问题了，就记录下来</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>G1和CMS的区别</p>
<ul>
<li>1.G1垃圾回收器是compacting的，使用的是复制算法，因此其回收得到的空间是连续的。这避免了CMS回收器因为不连续空间所造成的问题。如需要更大的堆空间，更多的floating garbage。连续空间意味着G1垃圾回收器可以不必采用空闲链表的内存分配方式，而可以直接采用bump-the-pointer的方式；</li>
<li>2.G1回收器的内存与CMS回收器要求的内存模型有极大的不同。G1将内存划分一个个固定大小的region，每个region可以是年轻代、老年代的一个。内存的回收是以region作为基本单位的；</li>
<li>3.CMS：标记清除；G1从整体上是标记整理，局部是标记复制。</li>
<li>4.G1软实时的特性，STW时间可控</li>
</ul>
</li>
<li><p>记忆集和卡表</p>
<ul>
<li><p>原因</p>
<ul>
<li>！！！避免把整个老年代加入GCRoots扫描范围。！！！在新生代做GCRoots可达性扫描过程中可能会碰到跨代引用的对象，这种如果又去对老年代再去扫描效率太低了。</li>
</ul>
</li>
<li><p>记忆集和卡表的关系</p>
<ul>
<li>卡表是记忆集的一种实现方式</li>
<li>类比为Java语言中HashMap与Map的关系</li>
</ul>
</li>
<li><p>卡表存储</p>
<ul>
<li>卡表就是一个数组，每个元素成为卡页，是一个特定大小的内存块</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li>一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变脏，否则为0</li>
<li>GC时，只要筛选本收集区的卡表中变脏的元素加入GCRoots里</li>
</ul>
</li>
<li><p>原理/维护</p>
<ul>
<li>写屏障，类似AOP，更新卡表对应的标识</li>
</ul>
</li>
</ul>
</li>
<li><p>安全点和安全域</p>
<ul>
<li><p>安全点</p>
<ul>
<li><p>概念</p>
<ul>
<li>安全点就是指代码中一些特定的位置,当线程运行到这些位置时它的状态是确定的,这样JVM就可以安全的进行一些操作,比 如GC等</li>
</ul>
</li>
<li><p>常见的安全点</p>
<ul>
<li><ol>
<li>方法返回之前 </li>
</ol>
</li>
<li><ol>
<li>调用某个方法之后 </li>
</ol>
</li>
<li><ol>
<li>抛出异常的位置 </li>
</ol>
</li>
<li><ol>
<li>循环的末尾</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>安全域</p>
<ul>
<li><p>概念</p>
<ul>
<li>Safe Region 是指在一段代码片段中，引用关系不会发生变化。在这个区域内的任意地方开始 GC 都是安全的。</li>
</ul>
</li>
<li><p>比较</p>
<ul>
<li>安全域是对正在执行的线程设定的</li>
<li>如果一个线程处于 Sleep 或中断状态，它就不能响应 JVM 的中断请求，再运行到 Safe Point 上。 因此 JVM 引入了 Safe Region</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-调优实战"><a href="#5-调优实战" class="headerlink" title="5.调优实战"></a>5.调优实战</h2><h3 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h3><ul>
<li>集成了以下所有命令的功能</li>
</ul>
<h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><ul>
<li>查看启动的java进程pid</li>
</ul>
<h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><ul>
<li><p>jmap -histo pid:查看内存信息，实例个数</p>
</li>
<li><p>jmap -heap pid:查看堆信息</p>
</li>
<li><p>jmap ‐dump:format=b,file=eureka.hprof 进程号:将进程信息导出来分析</p>
<p>  也可以设置内存溢出自动导出dump文件(内存很大的时候，可能会导不出来) </p>
<ol>
<li>-XX:+HeapDumpOnOutOfMemoryError </li>
<li>-XX:HeapDumpPath=./ （路径）</li>
</ol>
</li>
</ul>
<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><ul>
<li>jstack pid:查找死锁</li>
<li>jstack pid|grep nid:追踪CPU过高的原因</li>
</ul>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><ul>
<li>jinfo -flags pid:查看jvm参数</li>
<li>jinfo -sysprops pid:查看java系统参数</li>
</ul>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><ul>
<li>jstat -gc pid:最常用，查看gc的各种信息</li>
</ul>
<h3 id="根据jstat推测出内存模型"><a href="#根据jstat推测出内存模型" class="headerlink" title="根据jstat推测出内存模型"></a>根据jstat推测出内存模型</h3><h3 id="arthas"><a href="#arthas" class="headerlink" title="arthas"></a>arthas</h3><h3 id="gc日志分析"><a href="#gc日志分析" class="headerlink" title="gc日志分析"></a>gc日志分析</h3><ul>
<li>GC日志分析工具</li>
</ul>
<h3 id="调优常用参数"><a href="#调优常用参数" class="headerlink" title="调优常用参数"></a>调优常用参数</h3><h2 id="6-字符串常量池"><a href="#6-字符串常量池" class="headerlink" title="6.字符串常量池"></a>6.字符串常量池</h2><h3 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h3><p>记住，常量池中存的也是引用地址，真正的字符串对象存在堆内存中<br>s.intern()的操作:<br>若常量池中没有字符串s的引用地址，则在常量池中存一份s的引用地址；<br>若常量池中有字符串s的引用地址，无需操作，直接返回常量池中的引用。</p>
<p>String s = new String(“a”)+new String(“bc”);// “a”和”bc”的引用放到常量池中，”abc”<br>String s2 = s.intern();// 将”abc”的引用地址放在常量池中，即s的值<br>String x = “abc”;// “abc”在常量池中已有引用地址，即s2或s的值，无需再创建<br>System.out.println(s2==x);//true<br>System.out.println(s==x);//true<br>System.out.println(s==s2);//true</p>
<ul>
<li>图解</li>
</ul>
<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>new StringBuilder(“aa”).append(“bb”).toString();结果:”aa”和”bb”在字符串常量池中，”aabb”在堆中</p>
<h3 id="字符串加法"><a href="#字符串加法" class="headerlink" title="字符串加法"></a>字符串加法</h3><p>String a = “aa”;<br>String b = “bb”;<br>String c = a+b;<br>第三行代码等同于<br>new StringBuilder.append(a).append(b).toString();</p>
<h3 id="八种基本类型的包装类和对象池"><a href="#八种基本类型的包装类和对象池" class="headerlink" title="八种基本类型的包装类和对象池"></a>八种基本类型的包装类和对象池</h3><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li><p>解释:”在常量池中创建对象”</p>
<ul>
<li>对象依旧在堆内存中，常量池里存的只是对象的引用</li>
</ul>
</li>
<li><p>String s = “abc”</p>
<ul>
<li><p>创建对象s的时候，JVM会先去常量池中通过 equals(key) 方法，判断是否有相同的对象</p>
<ul>
<li>如果有，则直接返回该对象在常量池中的引用</li>
<li>如果没有，则会在常量池中创建一个新对象，再返回引用</li>
</ul>
</li>
</ul>
</li>
<li><p>new String(“abc”)</p>
<ul>
<li>如果字符串常量池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”</li>
<li>如果字符串常量池中没有字符串常量“abc”，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象</li>
<li>最后，将堆内存中的引用返回</li>
</ul>
</li>
<li><p>s.intern()</p>
<ul>
<li>若常量池中没有字符串s的引用地址，则在常量池中存一份s的引用地址</li>
<li>若常量池中有字符串s的引用地址，无需操作，直接返回常量池中的引用</li>
</ul>
</li>
<li><p>在编译时能确定的</p>
<ul>
<li><p>以下几种情况</p>
<ul>
<li>String s2=”zhu” + “ge”</li>
<li>String b = “a” + 1</li>
<li>final String bb = “b”</li>
<li>静态方法获取的不行</li>
</ul>
</li>
<li><p>在编译期间会优化成一个字符串，存的只是常量池中的引用</p>
</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li><p>String bb = “b”String b = “a” + bb</p>
<ul>
<li>含变量的字符串相加等同于<br>  new StringBuilder.append(“a”).append(bb).toString();只会(相加操作)在堆中创建”ab”对象，并不会在常量池中存一个引用</li>
</ul>
</li>
<li><p>StringBuilder的toString()</p>
<ul>
<li>会在堆中创建字符串对象，但不会在常量池中存引用</li>
</ul>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>字面量直观点的理解，代码中能看到的字符串，在常量池中必有引用</li>
<li>编译期是否能确定取决于定义的字符串能不能确定</li>
</ul>
</li>
<li><p>特例</p>
<ul>
<li>“java”等关键字一开始就在常量池中</li>
</ul>
</li>
</ul>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://alexander-wd.github.io/alex-next/2021/09/03/javaEE/springboot源码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="alex">
      <meta itemprop="description" content="时光静好,与君语;细水流年,与君同;繁华落尽,与君老.">
      <meta itemprop="image" content="/alex-next/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="alex的博客 - github.com">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/alex-next/2021/09/03/javaEE/springboot源码/" class="post-title-link" itemprop="url">springboot源码学习</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2021-09-03 15:03:12" itemprop="dateCreated datePublished" datetime="2021-09-03T15:03:12+08:00">2021-09-03</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-13 18:10:46" itemprop="dateModified" datetime="2023-02-13T18:10:46+08:00">2023-02-13</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/alex-next/categories/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="为何springboot的jar包能直接运行"><a href="#为何springboot的jar包能直接运行" class="headerlink" title="为何springboot的jar包能直接运行"></a>为何springboot的jar包能直接运行</h3><h3 id="true依赖不会传播给子项目"><a href="#true依赖不会传播给子项目" class="headerlink" title="true依赖不会传播给子项目"></a><optional>true<optional>依赖不会传播给子项目</optional></optional></h3><h3 id="外置tomcat"><a href="#外置tomcat" class="headerlink" title="外置tomcat"></a>外置tomcat</h3><ul>
<li>SPI</li>
</ul>
<h2 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h2><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><ul>
<li><p>@AutoConfigurationPackage</p>
<ul>
<li>注册了一个保存当前配置类所在包的一个Bean</li>
</ul>
</li>
<li><p>使用了@Import导入了AutoConfigurationImportSelector</p>
<ul>
<li><p>AutoConfigurationGroup#process</p>
<ul>
<li><p>getAutoConfigurationEntry</p>
<ul>
<li><p>getCandidateConfigurations</p>
<ul>
<li>找出候选的自动配置类</li>
<li><p>SpringFactoriesLoader.loadFactoryNames</p>
<ul>
<li>会去所有jar包中从META-INF/spring.factories中读取到自动配置类</li>
</ul>
</li>
</ul>
</li>
<li><p>removeDuplicates</p>
<ul>
<li>去重</li>
</ul>
</li>
<li><p>getConfigurationClassFilter().filter</p>
<ul>
<li>过滤出当前项目需要的自动配置类</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>以HttpEncodingAutoConfiguration为例参考pdf文件</p>
<ul>
<li>application.properties 声明spring.application.name</li>
<li>通过@ConfigurationProperties注解绑定到对应的XxxxProperties配 置实体类上</li>
<li>然后再通过@EnableConfigurationProperties注解导入到Spring容器中</li>
</ul>
</li>
</ul>
<h3 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h3><h3 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h3><ul>
<li><p>@Import可以批量注入，可以导入不在扫描范围里的Bean，所以集成第三方框架一般都用@Import</p>
<ul>
<li><p>ImportSelector无法改变Bean的使用顺序，如Springboot中想要自定义某个默认的Bean(SqlSessionFactory)，就不能实现</p>
<ul>
<li>@ConditionalOnBean(SqlSessionFactory.class)存在了SqlSessionFactory，才注册当前bean</li>
<li><p>可以使用DeferredImportSelector，最后导入，延时加载+分组排序</p>
<ul>
<li>DeferredImportSelector最后导入的都是默认配置，但不会覆盖原有的，因为会结合@Conditional判断是否导入</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><h3 id="课上图"><a href="#课上图" class="headerlink" title="课上图"></a>课上图</h3><h2 id="idea启动原理"><a href="#idea启动原理" class="headerlink" title="idea启动原理"></a>idea启动原理</h2><h3 id="SpringApplication-run"><a href="#SpringApplication-run" class="headerlink" title="SpringApplication.run"></a>SpringApplication.run</h3><ul>
<li><p>new SpringApplication(primarySources)</p>
<ul>
<li>初始化</li>
<li><p>this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</p>
<ul>
<li>把启动类存入primarySources</li>
</ul>
</li>
<li><p>WebApplicationType.deduceFromClasspath();</p>
<ul>
<li>推断当前容器类型</li>
</ul>
</li>
<li><p>setInitializers(getSpringFactoriesInstances)</p>
<ul>
<li>从spring.factories读取初始化器</li>
</ul>
</li>
<li><p>setListeners(getSpringFactoriesInstances)</p>
<ul>
<li>从spring.factories读取监听器</li>
</ul>
</li>
</ul>
</li>
<li><p>run</p>
<ul>
<li><p>listeners.starting();</p>
<ul>
<li>发布ApplicationStartingEvent</li>
</ul>
</li>
<li><p>prepareEnvironment</p>
<ul>
<li><p>读取环境配置信息</p>
</li>
<li><p>configureEnvironment</p>
<ul>
<li><p>configurePropertySources</p>
<ul>
<li>读取SpringApplication.defaultProperties 和命令行参数</li>
</ul>
</li>
<li><p>configureProfiles</p>
<ul>
<li>根据环境变量中spring.profiles.active 和 SpringApplication.additionalProfiles 激活当前profile</li>
</ul>
</li>
</ul>
</li>
<li><p>ConfigurationPropertySources.attach(environment);</p>
<ul>
<li>将环境更新为@ConfigurationProperties的数据</li>
</ul>
</li>
<li><p>listeners.environmentPrepared(environment)</p>
<ul>
<li><p>发布ApplicationEnvironmentPreparedEvent事件，之后ConfigFileApplicationListener会读取配置文件(application.yml)</p>
<ul>
<li><ul>

* <li>file:./config/</li>

* <li>file:./config/{@literal *}/</li>

* <li>file:./</li>

* <li>classpath:config/</li>

* <li>classpath:</li>

* </ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>printBanner(environment);</p>
<ul>
<li>打印banner</li>
</ul>
</li>
<li><p>createApplicationContext</p>
<ul>
<li>实例化上下文对象</li>
</ul>
</li>
<li><p>prepareContext</p>
<ul>
<li><p>context.setEnvironment</p>
<ul>
<li>将环境信息存到上下文(Context)中</li>
</ul>
</li>
<li><p>logStartupInfo</p>
<ul>
<li>打印启动信息</li>
</ul>
</li>
<li><p>logStartupProfileInfo</p>
<ul>
<li>打印激活的profile信息</li>
</ul>
</li>
<li><p>load</p>
<ul>
<li>读取启动类为BeanDefinition</li>
</ul>
</li>
</ul>
</li>
<li><p>refreshContext</p>
<ul>
<li>调用spring的refresh方法，加载IOC容器</li>
<li><p>ServletWebServerApplicationContext#onrefresh</p>
<ul>
<li><p>createWebServer</p>
<ul>
<li>servletContext = getServletContext()</li>
<li><p>getWebServerFactory</p>
<ul>
<li>从IOC容器中获取ServletWebServerFactory</li>
</ul>
</li>
<li><p>getSelfInitializer()</p>
<ul>
<li>获取ServletContextInitializer的onStartup方法</li>
<li><p>return this::selfInitialize;</p>
<ul>
<li>servletContext.addServlet(name, this.servlet);</li>
<li><p>循环beans.onStartup(servletContext)</p>
<ul>
<li><p>RegistrationBean#onStartup</p>
<ul>
<li><p>register</p>
<ul>
<li><p>ServletRegistrationBean#addRegistration</p>
<ul>
<li>往servletContext添加了DispatcherServlet</li>
<li>servletContext.addServlet(name, this.servlet);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>getWebServer(getSelfInitializer())</p>
<ul>
<li>new Tomcat()</li>
<li><p>prepareContext</p>
<ul>
<li><p>configureContext</p>
<ul>
<li><p>new TomcatStarter(initializers)</p>
<ul>
<li>后续会调用TomcatStarter#onStartup，执行ServletContainerInitializer</li>
</ul>
</li>
<li><p>TomcatEmbeddedContext.addServletContainerInitializer</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>getTomcatWebServer</p>
<ul>
<li><p>this.tomcat.start();</p>
<ul>
<li>会去调用TomcatStarter的onStartup方法，从而循环回调Initializer的onStartup方法</li>
</ul>
</li>
<li><p>startDaemonAwaitThread</p>
<ul>
<li>没有访问就挂起线程，否则程序一下就会结束</li>
<li>this.tomcat.getServer().await()</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>afterRefresh</p>
<ul>
<li>待扩展</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="原理图-1"><a href="#原理图-1" class="headerlink" title="原理图"></a>原理图</h3><h2 id="外部tomcat启动springboot原理-SPI"><a href="#外部tomcat启动springboot原理-SPI" class="headerlink" title="外部tomcat启动springboot原理(SPI)"></a>外部tomcat启动springboot原理(SPI)</h2><h3 id="当servlet容器启动时候，就会去META-INF-services-文件夹中找到javax-servlet-ServletContainerInitializer"><a href="#当servlet容器启动时候，就会去META-INF-services-文件夹中找到javax-servlet-ServletContainerInitializer" class="headerlink" title="当servlet容器启动时候，就会去META-INF/services 文件夹中找到javax.servlet.ServletContainerInitializer"></a>当servlet容器启动时候，就会去META-INF/services 文件夹中找到javax.servlet.ServletContainerInitializer</h3><ul>
<li>ServletContainerInitializer类继承图(和ServletContextInitializer作用类似)</li>
</ul>
<h3 id="HandlesTypes-WebApplicationInitializer-class"><a href="#HandlesTypes-WebApplicationInitializer-class" class="headerlink" title="@HandlesTypes(WebApplicationInitializer.class)"></a>@HandlesTypes(WebApplicationInitializer.class)</h3><ul>
<li><p>会去找WebApplicationInitializer，即SpringBootServletInitializer，我们自己会去实现这么一个类</p>
<ul>
<li>SpringBootServletInitializer继承图</li>
</ul>
</li>
</ul>
<h3 id="SpringServletContainerInitializer-onStartup"><a href="#SpringServletContainerInitializer-onStartup" class="headerlink" title="SpringServletContainerInitializer#onStartup"></a>SpringServletContainerInitializer#onStartup</h3><ul>
<li>找到WebApplicationInitializer后传入onStartup</li>
<li><p>ReflectionUtils.accessibleConstructor(waiClass).newInstance()</p>
<ul>
<li>循环实例化WebApplicationInitializer</li>
</ul>
</li>
<li><p>执行自己的SpringBootServletInitializer#onStartup</p>
<ul>
<li><p>createRootApplicationContext</p>
<ul>
<li><p>configure(builder);</p>
<ul>
<li>传入自己的SpringbootApplication启动类</li>
<li>builder.sources(Application.class);</li>
</ul>
</li>
<li><p>builder.build();</p>
<ul>
<li>构建一个SpringApplication</li>
</ul>
</li>
<li><p>run(application);</p>
<ul>
<li>启动</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>AbstractDispatcherServletInitializer#onStartup</p>
<ul>
<li><p>servletContext.addServlet(servletName, dispatcherServlet)</p>
<ul>
<li>添加了一个DispatcherServlet</li>
</ul>
</li>
</ul>
</li>
<li><p>AbstractContextLoaderInitializer</p>
</li>
</ul>
<h2 id="jar包启动springboot原理-内置了tomcat"><a href="#jar包启动springboot原理-内置了tomcat" class="headerlink" title="jar包启动springboot原理(内置了tomcat)"></a>jar包启动springboot原理(内置了tomcat)</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li>1.加载META/MANIFEST.MF</li>
<li>2.运行JarLauncher(Main-Class: org.springframework.boot.loader.JarLauncher)</li>
<li><p>3.JarLauncher加载BOOT-INF/classes和BOOT-INF/lib</p>
<ul>
<li>Fat jar的启动Main函数是JarLauncher</li>
</ul>
</li>
<li><p>JarLauncher创建一个LaunchedURLClassLoader来加载/lib下面的jar，并以一 个新线程启动springboot应用类的Main函数。</p>
</li>
<li>4.找到Start-Class，即自己定义的SpringBoot启动类</li>
</ul>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p>Java没有提供任何标准的方式来加载嵌套的jar文件</p>
<ul>
<li>JarLauncher通过加载BOOT-INF/classes目录及BOOT-INF/lib目录下jar文件，实现了fat jar的启动。 </li>
<li>SpringBoot通过扩展JarFile、JarURLConnection及URLStreamHandler，实现了jar in jar中资源的加载。 </li>
<li>SpringBoot通过扩展URLClassLoader–LauncherURLClassLoader，实现了jar in jar中class文件的加载。</li>
</ul>
</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://alexander-wd.github.io/alex-next/2021/08/29/javaEE/Docker基础篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="alex">
      <meta itemprop="description" content="时光静好,与君语;细水流年,与君同;繁华落尽,与君老.">
      <meta itemprop="image" content="/alex-next/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="alex的博客 - github.com">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/alex-next/2021/08/29/javaEE/Docker基础篇/" class="post-title-link" itemprop="url">docker基础篇</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2021-08-29 14:10:20" itemprop="dateCreated datePublished" datetime="2021-08-29T14:10:20+08:00">2021-08-29</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-13 17:16:45" itemprop="dateModified" datetime="2023-02-13T17:16:45+08:00">2023-02-13</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/alex-next/categories/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章-Docker简介"><a href="#第一章-Docker简介" class="headerlink" title="第一章 Docker简介"></a>第一章 Docker简介</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><h3 id="问题：为什么会有-docker-的出现"><a href="#问题：为什么会有-docker-的出现" class="headerlink" title="问题：为什么会有 docker 的出现"></a>问题：为什么会有 docker 的出现</h3><p>一款产 品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验<br><strong>Docker</strong>之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案。<br>环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装?也就是说，安装的时候，把原始环境-模-样地复制过来。开发人员利用Docker可以消除协作编码时“在我的机器上可正常工作”的问题。</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811094546.png"></p>
<p>之前在服务器配置一个应用的运行环境，要安装各种软件，就拿尚硅谷电商项目的环境来说吧，<strong>Java/TomcatMySQL/JDBC</strong>驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在<strong>Windows</strong>上安装的这些环境，到了Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。</p>
<p>传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等java为例)。而为了让这程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，<strong>开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。</strong>Docker镜 像的设计<strong>，使得Docker得以打过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运.作。</strong></p>
<h3 id="docker理念"><a href="#docker理念" class="headerlink" title="docker理念"></a>docker理念</h3><p>Docker是基于Go语言实现的云开源项目。<br>Docker的主要目标是“<strong>Build, Ship[ and Run Any App,Anywhere</strong>“，也就是通过对应用组件的封装、分发、部署、运行等生命期的管理，使用户的APP (可以是一个WEB应用或数据库应用等等)及其运行环境能够做到“<strong>一次封装，到处运行</strong>”。</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811094648.png"></p>
<p> Linux容器技术的出现就解决了这样一 一个问题，而Docker就是在它的基础上发展过来的。将应用运行在Docker容器上面，而Docker容器在任何操作系统上都是一-致的，这就实现了跨平台、跨服务器。<strong>只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作</strong></p>
<h3 id="一句话"><a href="#一句话" class="headerlink" title="一句话"></a>一句话</h3><p>解决了运行环境和配置问题的软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术</p>
<h2 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h2><h3 id="之前的虚拟机技术"><a href="#之前的虚拟机技术" class="headerlink" title="之前的虚拟机技术"></a>之前的虚拟机技术</h3><p>虚拟机<strong>(virtual machine)</strong>就是带环境安装的一种解决方案。</p>
<p>它可以在一种操作系统里面运行另一种作系统，比如在<strong>Windows系统里面运行Linux系统</strong>。应用程序对此毫无感知，因为虚拟机看上去跟真实系统- -模-样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095046.png"></p>
<p>虚拟机的缺点:</p>
<p>1、资源占用多</p>
<p>2、冗余步骤多</p>
<p>3、启动慢</p>
<h3 id="容器虚拟化技术"><a href="#容器虚拟化技术" class="headerlink" title="容器虚拟化技术"></a>容器虚拟化技术</h3><p>由于前面虛拟机存在这些缺点，<strong>Linux</strong> 发展出了另一种虚拟化技术: <strong>Linux 容器</strong>(Linux Containers,缩为LXC)。</p>
<p><strong>Linux容器不是模拟一个完整的操作系统</strong>，而是对进程进行隔离。有了容器，就可以将软件运行所的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。.</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095112.png"></p>
<p>比较了<strong>Docker</strong>和传统虚拟化方式的不同之处:</p>
<p>1、传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程;</p>
<p>2、而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，<strong>而且也没有进行硬件虚拟</strong>。因此容器要比传统虚拟机为轻便。</p>
<p>3、每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。</p>
<h3 id="开发-运维-DevOps"><a href="#开发-运维-DevOps" class="headerlink" title="开发/运维(DevOps)"></a>开发/运维(DevOps)</h3><p>一次构建、随处运行，</p>
<h4 id="更快速的应用交付和部署"><a href="#更快速的应用交付和部署" class="headerlink" title="更快速的应用交付和部署"></a>更快速的应用交付和部署</h4><p>​        传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker化<br>之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测<br>试验证时间。</p>
<h4 id="更便捷的升级和扩缩容"><a href="#更便捷的升级和扩缩容" class="headerlink" title="更便捷的升级和扩缩容"></a>更便捷的升级和扩缩容</h4><p>​        随着微服务架构和Docker的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个Docker容器将变成-块“积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。</p>
<h4 id="更简单的系统运维"><a href="#更简单的系统运维" class="headerlink" title="更简单的系统运维"></a>更简单的系统运维</h4><p>​        应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度—致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。</p>
<h4 id="更高效的计算资源利用"><a href="#更高效的计算资源利用" class="headerlink" title="更高效的计算资源利用"></a>更高效的计算资源利用</h4><p>​    <strong>Docker是内核级虚拟化</strong>，其不像传统的虚拟化技术一样 需要额外的Hypervisor支持，所以在-台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率。</p>
<h3 id="企业级"><a href="#企业级" class="headerlink" title="企业级"></a>企业级</h3><p>新浪</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095119.png"></p>
<p>美团</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095124.png"></p>
<p>蘑菇街</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095129.png"></p>
<h3 id="去哪下"><a href="#去哪下" class="headerlink" title="去哪下"></a>去哪下</h3><h4 id="1、官网"><a href="#1、官网" class="headerlink" title="1、官网"></a>1、官网</h4><p>docker官网： <a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a></p>
<p>docker中文网站: <a href="https://www.docker-cn.com/" target="_blank" rel="noopener">https://www.docker-cn.com/</a></p>
<h4 id="2、仓库"><a href="#2、仓库" class="headerlink" title="2、仓库"></a>2、仓库</h4><p>Docker Hub官网：<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p>
<h1 id="第二章-Docker安装"><a href="#第二章-Docker安装" class="headerlink" title="第二章 Docker安装"></a>第二章 Docker安装</h1><h2 id="前提说明"><a href="#前提说明" class="headerlink" title="前提说明"></a>前提说明</h2><p><strong>CentOS Docker安装</strong><br>Docker支持以下的CentOS版本:<br>CentOS 7 (64-bit)<br>CentOS 6.5 (64-bit)或更高的版本</p>
<p><strong>前提条件</strong><br>目前，CentOS 仅发行版本中的内核支持Docker。<br>Docker运行在CentOS 7.上，要求系统为64位、系统内核版本为3.10以上。<br>Docker运行在CentOS-6.5或更高的版本的CentOS上，要求系统为64位、系<strong>统内核版本为2.6.32-431或者更高版本。</strong></p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095135.png"></p>
<h2 id="Docker-的基本组成"><a href="#Docker-的基本组成" class="headerlink" title="Docker 的基本组成"></a>Docker 的基本组成</h2><h3 id="docker架构图"><a href="#docker架构图" class="headerlink" title="docker架构图"></a>docker架构图</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20220813182938.png"></p>
<h3 id="镜像-image"><a href="#镜像-image" class="headerlink" title="镜像( image )"></a>镜像( image )</h3><p>Docker镜像(lmage)就是-一个只读的模板。镜像可以用来创建Docker容器，个镜像可以创建很多容器</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095144.png"></p>
<h3 id="容器-container"><a href="#容器-container" class="headerlink" title="容器( container)"></a>容器( container)</h3><p>Docker利用容器(Container) 独立运行的一个或一组应用。<strong>容器是用镜像创建的运行实例。</strong><br>它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。<br><strong>可以把容器看做是一个简 易版的Linux环境</strong>(包括root用户权限、进程空间、用户空间和网络空间等)和运行在其中的应用程序。<br>容器的定义和镜像几乎一模一样，也是一堆层的统一视角， 唯- -区别在于容器的最上面那-层是可读可写的。</p>
<h3 id="仓库-repository"><a href="#仓库-repository" class="headerlink" title="仓库( repository)"></a>仓库( repository)</h3><p>仓库(<strong>Repository</strong>) 是<strong>集中存放镜像</strong>文件的场所。<br>仓库(<strong>Repository</strong>)和仓库注册服务器(<strong>Registry</strong>) 是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多镜像，<br>每个镜像有不同的标签(tag) 。</p>
<p>仓库分为公开仓库(<strong>Public</strong>) 和私有仓库(<strong>Private</strong>) 两种形式。<br><strong>最大的公开仓库是Docker Hub(ttps://hub. docker.com/)</strong><br>存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云、网易云等</p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结 ()"></a>小总结 ()</h3><p>需要正确的理解仓储/镜像/容器这几个概念:</p>
<p>Docker本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一-个可交付的运行环境，这个打好的运行环境就似乎image镜像文件。只有通过这个镜像文件才能生成Docker容器。image文件可以看作是容器的模板。Docker根据image文件生成容器的实例。同一个image文件，可以生成多个同时运行的容器实例。</p>
<p>image文件生成的容器实例，本身也是一一个文件，称为镜像文件。</p>
<p>一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一-个对应的运行实例，也就是我们的容器至于仓储，就是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以了。|</p>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="Centos6-8安装Docker"><a href="#Centos6-8安装Docker" class="headerlink" title="Centos6.8安装Docker"></a>Centos6.8安装Docker</h3><p>1、yum install -y epel-release</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095150.png"></p>
<p>2、yum install -y docker-io</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095156.png"></p>
<p>3、安装后的配置文件： etc/sysconfig/docker</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095201.png"></p>
<p>4、启动 Docker后台服务: service docker start</p>
<p>5、docker version 验证</p>
<h3 id="Centos7-0安装Docker"><a href="#Centos7-0安装Docker" class="headerlink" title="Centos7.0安装Docker"></a>Centos7.0安装Docker</h3><p><a href="https://docs.docker.com/engine/install/centos/" target="_blank" rel="noopener">https://docs.docker.com/engine/install/centos/</a></p>
<h2 id="永远的helloworld"><a href="#永远的helloworld" class="headerlink" title="永远的helloworld"></a>永远的helloworld</h2><h3 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h3><p>是什么</p>
<p>​    <a href="https://promotion.aliyun.com/ntms/act/kubernetes.html" target="_blank" rel="noopener">https://promotion.aliyun.com/ntms/act/kubernetes.html</a></p>
<p>注册一个属于自己的阿里云账户( 可复用淘宝账号)</p>
<p>获得加速器地址连接</p>
<p>​    登录阿里云开发者平台</p>
<p>​    获取加速器地址</p>
<p>配置本机Docker运行镜像加速器</p>
<p>​    鉴于国内网络问题，后续拉取Docker镜像十分缓慢，我们可以需要配置加速器来解决，<br>我使用的是阿里云的本人自己账号的镜像地址(需要自己注册有一个属于你自己的): ht:po/. mirror aliyuncns .com</p>
<ul>
<li>vim /etc/sysconfig/docker<br>将获得的自己账户下的阿里云加速地址配置进<br>other_ args-=”—registry-mirror=<a href="https://你自" target="_blank" rel="noopener">https://你自</a> 己的账号加速信息.mirror .aliyuncs.com</li>
</ul>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095235.png"></p>
<p>重新启动 Docker 后台服务：service docker restart</p>
<p>Linux系统下配置完加速器需要检查是否生效</p>
<h3 id="网易云加速"><a href="#网易云加速" class="headerlink" title="网易云加速"></a>网易云加速</h3><p>基本上同上述阿里云</p>
<p>启动Docker后台容器(测试运行 hello-world )</p>
<p>​    docker run hello world</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095239.png"></p>
<p>run干了什么</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095244.png"></p>
<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><h3 id="Docker是怎样工作的"><a href="#Docker是怎样工作的" class="headerlink" title="Docker是怎样工作的"></a>Docker是怎样工作的</h3><p>Docker是一个Client-Server结构的系统，Docker守 护进程运行在主机上，然后通过Socket连 接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。<strong>容器，是一个运行时环境，就是我们前面说到的集装箱。</strong></p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095248.png"></p>
<h3 id="为什么Docker比较比vm快"><a href="#为什么Docker比较比vm快" class="headerlink" title="为什么Docker比较比vm快"></a>为什么Docker比较比vm快</h3><p>1、<strong>docker</strong>有着比虚拟机更少的抽象层。由亍docker不需要<strong>Hypervisor</strong>实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。<br>2、<strong>docker</strong>利用的是宿主机的内核,而不需要<strong>Guest OS</strong>。因此,当新建一个 容器时,docker不需要和虚拟机一样 重新加载- - 个操作系统内核仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建—个虚拟机时,虚拟机软件需要加载GuestOS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一-个docker容器只需要几秒钟。</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095252.png"></p>
<h1 id="第三章-Docker常用命令"><a href="#第三章-Docker常用命令" class="headerlink" title="第三章 Docker常用命令"></a>第三章 Docker常用命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker Version</span><br><span class="line"></span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line">docker --help</span><br><span class="line">	自己查看官网解释，高手都是自己练出来的，百度上只不过是翻译了下，加了点例子</span><br></pre></td></tr></table></figure>
<h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><h3 id="docker-images-列出本机上的镜像"><a href="#docker-images-列出本机上的镜像" class="headerlink" title="docker images 列出本机上的镜像"></a>docker images 列出本机上的镜像</h3><h3 id="OPTIONS-说明："><a href="#OPTIONS-说明：" class="headerlink" title="OPTIONS 说明："></a><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095259.png">OPTIONS 说明：</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-a 列出本地所有的镜像(含中间映射层)</span><br><span class="line">-q 只显示镜像ID</span><br><span class="line">--digests 显示镜像的摘要信息</span><br><span class="line">--no-trunc 显示完整的镜像信息</span><br></pre></td></tr></table></figure>
<h3 id="docker-search-某个XXX镜像的名字"><a href="#docker-search-某个XXX镜像的名字" class="headerlink" title="docker search 某个XXX镜像的名字"></a>docker search 某个XXX镜像的名字</h3><p>​    网站 www.dockerhub.com</p>
<p>​    docker search [OPTIONS] 镜像名字</p>
<p>​    OPTIONS 说明</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--no-trun 显示完整的镜像描述</span><br><span class="line">-s 列出收藏数不小于指定值的镜像</span><br><span class="line">--automated 只列出 automated build类型的镜像</span><br></pre></td></tr></table></figure>
<h3 id="docker-pull-某个镜像的名字"><a href="#docker-pull-某个镜像的名字" class="headerlink" title="docker pull 某个镜像的名字"></a>docker pull 某个镜像的名字</h3><p>​    下载镜像</p>
<p>​     docker pull 镜像名字[:TAG]</p>
<h3 id="docker-rmi-某个XXX镜像的名字ID"><a href="#docker-rmi-某个XXX镜像的名字ID" class="headerlink" title="docker rmi 某个XXX镜像的名字ID"></a>docker rmi 某个XXX镜像的名字ID</h3><p>​    删除镜像</p>
<p>​    删除单个 docker rm -f 镜像ID</p>
<p>​    删除多个 docker rm -f 镜像名1:TAG 镜像名2:TAG</p>
<p>​    删除多个 docker rmi -f ${docker images -qa}</p>
<h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p>有镜像才能创建容器，这是根本前提(下载一个Centos镜像演示)</p>
<p>​    docker pull centos</p>
<h3 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h3><p>​    docker run [OPTIONS] IMAGE [COMMAND][ARG]</p>
<p>​    OPTIONS 说明 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS说明(常用) :有些是一个减号，有些是两个减号</span><br><span class="line">--name=<span class="string">"容器新名字"</span>:为容器指定一个名称;</span><br><span class="line">-d:后台运行容器，并返回容器ID， 也即启动守护式容器;</span><br><span class="line">-i:以交互模式运行容器，通常与-t同时使用;</span><br><span class="line">-t:为容器重新分配一个伪输入终端，通常与-i同时使用;</span><br><span class="line">-P:随机端口映射;</span><br><span class="line">-p:指定端口映射，有以下四种格式</span><br><span class="line">ip:hostPort:containerPort</span><br><span class="line">ip::containerPort</span><br><span class="line">hostPort:containerPort</span><br><span class="line">containerPort</span><br></pre></td></tr></table></figure>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095306.png"></p>
<h3 id="列出当前所有正在运行的容器"><a href="#列出当前所有正在运行的容器" class="headerlink" title="列出当前所有正在运行的容器"></a>列出当前所有<strong>正在运行</strong>的容器</h3><p>​    dockers ps [OPTIONS]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS说明(常用) :</span><br><span class="line">-a :列出当前所有正在运行的容器+历史上运行过的</span><br><span class="line">-|:显示最近创建的容器。</span><br><span class="line">-n:显示最近n个创建的容器。</span><br><span class="line">-q :静默模式，只显示容器编号。</span><br><span class="line">--no-trunc :不截断输出。</span><br></pre></td></tr></table></figure>
<h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><p>两种退出方式</p>
<p>​    exit 容器不停止退出，bash窗口停止</p>
<p>​    ctrl+P+Q 容器不停止，bash窗口不停止</p>
<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>docker start 容器ID或容器签名</p>
<h3 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h3><p>docker restart 容器ID或容器签名</p>
<h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><p>docker stop 容器ID或容器签名</p>
<h3 id="强制停止容器"><a href="#强制停止容器" class="headerlink" title="强制停止容器"></a>强制停止容器</h3><p>docker kill 容器ID或容器签名</p>
<h3 id="删除已停止的容器"><a href="#删除已停止的容器" class="headerlink" title="删除已停止的容器"></a>删除已停止的容器</h3><p>docker rm 容器ID  -f</p>
<p>​    一次性删除多个容器</p>
<p>​    docker rm -f $(docker ps -a -q)</p>
<p>​    docker ps -a -q | xargs docker rm</p>
<h2 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h2><h3 id="启动守护式容器"><a href="#启动守护式容器" class="headerlink" title="启动守护式容器"></a>启动守护式容器</h3><p>使用镜像centos:latest以后台模式启动一个容器<br>docker run -d centos</p>
<p>问题:然后docker ps -a进行查看,<strong>会发现容器已经退出</strong><br>很重要的要说明的一点: <strong>Docker容器后台运行,就必须有一个前台进程.</strong><br>容器运行的命令如果不是那些<strong>一直挂起的命令</strong> (比如运行top，tail) ，就是会自动退出的。<br>这个是<strong>docker</strong>的机制问题,比如你的web容器，我们以<strong>nginx</strong>为例，正常情况下,我们配置启动服务只需要启动响应的<strong>service</strong>即可。例如<br>service nginx start<br>但是,这样做,<strong>nginx</strong>为后台进程模式运行,就导致<strong>docker</strong>前台没有运行的应用,这样的容器后台启动后，会立即自杀因为他觉得他没事可做了.所以，最佳的解决方案是将你要运行的程序以前台进程的形式运行</p>
<h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><p>docker logs -f -t —tail 容器ID </p>
<p>​    -t 是加入时间戳</p>
<p>​    -f 跟随最新的日志打印</p>
<p>​    —tail 数字显示最后多少条</p>
<h3 id="查看容器内的进程"><a href="#查看容器内的进程" class="headerlink" title="查看容器内的进程"></a>查看容器内的进程</h3><p>docker top 容器ID</p>
<h3 id="查看容器内部细节"><a href="#查看容器内部细节" class="headerlink" title="查看容器内部细节"></a>查看容器内部细节</h3><p>docker inspect 容器ID</p>
<h3 id="进入正在运行的容器并以命令行交互"><a href="#进入正在运行的容器并以命令行交互" class="headerlink" title="进入正在运行的容器并以命令行交互"></a>进入正在运行的容器并以命令行交互</h3><p>docker exec -it 容器ID bashShell</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095314.png"></p>
<p>重新进入docker attach 容器ID</p>
<p>上述两个区别</p>
<p>attach 直接进入容器启动命令的终端，不会启动新的进程</p>
<p>exec 实在容器中打开新的终端，并且可以穷的那个新的进程</p>
<h3 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h3><p>docker cp 容器ID:容器内路径 目的主机路径</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095318.png"></p>
<h2 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h2><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095323.png"></p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095333.png"></p>
<h1 id="第四章-Docker-镜像"><a href="#第四章-Docker-镜像" class="headerlink" title="第四章 Docker 镜像"></a>第四章 Docker 镜像</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的有内容，包括代码、运行时、库、环境变量和配置文件。</p>
<h3 id="UnionFS-联合文件系统"><a href="#UnionFS-联合文件系统" class="headerlink" title="UnionFS(联合文件系统)"></a>UnionFS(联合文件系统)</h3><p>UnionFS (状节又件示统)<br>UnionFS (联合文件系统) : Union文件系统(UnionFS)是一一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修作为一 次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a singlevirtualfilesystem)。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)可以制作各种具.体的应用镜像。</p>
<p>特性:一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文<br>件系统会包含所有底层的文件和目录</p>
<h3 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h3><p><strong>Docker镜像加载原理:</strong><br>    <strong>docker</strong>的镜像实际上由一层一层的文件系统组成，这种层级的文件系统<strong>UnionFS。</strong></p>
<p><strong>botfs(boot file system)</strong>主要包含<strong>bootloader</strong>和<strong>kernel</strong>, <strong>bootloader</strong>主 要是引导加载<strong>kernel</strong>, <strong>Linux</strong>刚启动时会加载bootfs文件系统，在<strong>Docker</strong>镜像的最底层是<strong>bootfs</strong>。这一-层与我们典型的<strong>Linux/Unix</strong>系统是- - -样的，包含boot加载器和内核。当boot加载完成之 后整个内核就都在内存中了，此时内存的使用权己由bootfs转交给内核，此时系统也会卸载bootfs。</p>
<p><strong>rootfs (root file system)，</strong>在<strong>bootfs</strong>之 上。 包含的就是典型Linux系统中的<strong>/dev, /proc, /bin, /etc</strong>等标准目录和文件。<strong>rootfs</strong>就 是各种不同的操作系统发行版，比如<strong>Ubuntu</strong>，<strong>Centos</strong>等等。</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095340.png"></p>
<p>平时我们安装的虚拟机的Centos都是好几个G ，为什么docker这里才要200m</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095345.png"></p>
<p>对于一个精简的<strong>OS, rootfs</strong>可 以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用<strong>Host</strong>的<strong>kernel</strong>,自只需要提供rootfs就行了。由此可见对于不同的<strong>linux</strong>发行版, <strong>bootfs</strong>基本是一致的, <strong>rootfs</strong>会有差别，因此不同的发行版可以公用<strong>bootfs</strong>。</p>
<h3 id="分层的镜像"><a href="#分层的镜像" class="headerlink" title="分层的镜像"></a>分层的镜像</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095349.png"></p>
<h3 id="分层的镜像-1"><a href="#分层的镜像-1" class="headerlink" title="分层的镜像"></a>分层的镜像</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095353.png"></p>
<h3 id="为什么-Docker纪念馆想要采用这种分层结构"><a href="#为什么-Docker纪念馆想要采用这种分层结构" class="headerlink" title="为什么 Docker纪念馆想要采用这种分层结构"></a>为什么 Docker纪念馆想要采用这种分层结构</h3><p>最大的一个好处就是-<strong>共享资源</strong><br>比如:<strong>有多个镜像都从相同的base镜像构建而来</strong>，那么宿主机只需在磁盘上保存一份<strong>base</strong>镜像,<br>同时内存中也只需加载一份<strong>base</strong>镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到<strong>镜像的顶部</strong>，这一层通常被称为<strong>容器层</strong>，容器层之下都叫<strong>镜像层</strong></p>
<h2 id="Docker镜像Commit操作"><a href="#Docker镜像Commit操作" class="headerlink" title="Docker镜像Commit操作"></a>Docker镜像Commit操作</h2><p>docker commit 提交容器副本使之称为一个新的镜像</p>
<p>docker commit -m=”提交的描述信息” -a=”作者” 容器ID 要创建的目标镜像名:[标签名]</p>
<h3 id="案例演示："><a href="#案例演示：" class="headerlink" title="案例演示："></a>案例演示：</h3><p>1、从Hub上下载tomcat镜像到本地并成功运行</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095358.png"></p>
<p>docker run -d -p 8080:8080 tomcat</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-p主机端口：docker容器端口</span><br><span class="line">-P:随机分配端口</span><br><span class="line">i:交互</span><br><span class="line">t:终端</span><br></pre></td></tr></table></figure>
<p>2、故意删除上一步镜像生产tomcat容器的文档</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095404.png"></p>
<p>3、也即当前的tomcat运行实例是一个没有文档内容的容器，以他为模板commit一个没有doc的tomcat新镜像 atguigu/tomcat02</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095408.png"></p>
<p>4、启动我们的新镜像并和原来的对比</p>
<p>​    启动atuigu/tomcat02 没有doc</p>
<p>​    启动原来tomcat他有doc</p>
<h1 id="第五章-Docker容器数据卷"><a href="#第五章-Docker容器数据卷" class="headerlink" title="第五章 Docker容器数据卷"></a>第五章 Docker容器数据卷</h1><h2 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h2><p>先来看看<strong>Docker</strong>的理念:<br><em>将运用与运行的环境打包形成容器运行，运行可以伴随着容器，但是我们对数据的要求希望是持久化的
</em>容器之间希望有可能共享数据<br><strong>Docker</strong>容器产生的数据，如果不通过<strong>docker</strong> <strong>commit</strong>生成新的镜像，使得数据做为镜像的一部分保存下来，<br>那么当容器删除后，数据自然也就没有了。<br>为了能保存数据在docker中我们使用卷。|</p>
<p>一句话：有点类似我们Redis里面的rdb和aof文件</p>
<h2 id="能干嘛-1"><a href="#能干嘛-1" class="headerlink" title="能干嘛"></a>能干嘛</h2><p>卷就是目录或文件，存在于一个或多个容器中，由<strong>docker</strong>挂载到容器，但不属于联合文件系统，因此能够绕过Union FileSystem提供一些用 于持续存储或共享数据的特性:<br>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不 会在容器删除时删除其挂载的数据卷</p>
<p>特点:<br>1:数据卷可在容器之间共享或重用数据<br>2:卷中的更改可以直接生效<br>3:数据卷中的更改不会包含在镜像的更新中<br>4:数据卷的生命周期一直持续到没有容器使用它为止</p>
<p><strong>容器的持久化</strong></p>
<p><strong>容器间继承+共享数据</strong></p>
<h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><h3 id="容器内添加"><a href="#容器内添加" class="headerlink" title="容器内添加"></a>容器内添加</h3><h4 id="直接命令添加"><a href="#直接命令添加" class="headerlink" title="直接命令添加"></a>直接命令添加</h4><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095414.png"></p>
<p>docker run -it -v /宿主机绝对路径目录:/容器内目录 镜像名</p>
<p>查看数据卷是否挂载成功</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095419.png"></p>
<p>容器和宿主机之间数据共享</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095423.png"></p>
<p>容器停止退出后，主机修改后的数据是否同步</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095427.png"></p>
<p>命令(带权限)</p>
<p>​    docker run -it -v /宿主机绝对路径目录:/容器内目录<strong>:ro</strong> 镜像名</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095430.png"></p>
<h4 id="DockerFile添加"><a href="#DockerFile添加" class="headerlink" title="DockerFile添加"></a>DockerFile添加</h4><p>根目录下新建mydocker文件夹并进入</p>
<p>可在Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095434.png"></p>
<p>File构建</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095438.png"></p>
<p>build后生成镜像</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095446.png"></p>
<p>获得一个新镜像zzyy/centos</p>
<p>run容器</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095450.png"></p>
<p>通过上述步骤，容器内的卷目录地址已经知道，对应的主机目录在哪</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095454.png"></p>
<p><strong>主机对应默认地址</strong></p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095458.png"></p>
<p>备注</p>
<p>Docker挂载主机目录Docker访问出现cannot open directory . Permission denied<br>解决办法:在挂载目录后多加一个—privileged=true参数即可</p>
<h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器.</p>
<h3 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h3><p>以上一步新建的zzyy/centos为模板并运行容器 doc1/doc2/doc3</p>
<p>他们已经具有容器卷</p>
<p>​    /dataVolumeContainer1</p>
<p>​    /dataVolumeContainer2</p>
<h3 id="容器间传递共享-—volumes-from"><a href="#容器间传递共享-—volumes-from" class="headerlink" title="容器间传递共享(—volumes -from)"></a>容器间传递共享(—volumes -from)</h3><h4 id="先启动一个父容器doc1"><a href="#先启动一个父容器doc1" class="headerlink" title="先启动一个父容器doc1"></a>先启动一个父容器doc1</h4><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095502.png"></p>
<p>启动后在 dataVolumeContainer1中新增内容</p>
<h4 id="doc2-doc3-继承doc1"><a href="#doc2-doc3-继承doc1" class="headerlink" title="doc2/doc3 继承doc1"></a>doc2/doc3 继承doc1</h4><p>​    <strong>—volumes -from</strong></p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095506.png"></p>
<p>doc2/doc3 分别在dataVolumeContainer2各自新增内容</p>
<h4 id="回到doc1可以看到02-03各自添加的都能共享了"><a href="#回到doc1可以看到02-03各自添加的都能共享了" class="headerlink" title="回到doc1可以看到02/03各自添加的都能共享了"></a>回到doc1可以看到02/03各自添加的都能共享了</h4><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095510.png"></p>
<h4 id="删除doc1-doc2修改后doc3是否可以访问"><a href="#删除doc1-doc2修改后doc3是否可以访问" class="headerlink" title="删除doc1 doc2修改后doc3是否可以访问"></a>删除doc1 doc2修改后doc3是否可以访问</h4><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095515.png"></p>
<h4 id="删除doc02后doc3是否访问"><a href="#删除doc02后doc3是否访问" class="headerlink" title="删除doc02后doc3是否访问"></a>删除doc02后doc3是否访问</h4><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095519.png"></p>
<p>在进一步</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095523.png"></p>
<h4 id="新建doc04继承doc03-然后删除doc03"><a href="#新建doc04继承doc03-然后删除doc03" class="headerlink" title="新建doc04继承doc03 然后删除doc03"></a>新建doc04继承doc03 然后删除doc03</h4><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095527.png"></p>
<p><strong>结论：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止</strong></p>
<h1 id="第六章-DockerFile解析"><a href="#第六章-DockerFile解析" class="headerlink" title="第六章 DockerFile解析"></a>第六章 DockerFile解析</h1><h2 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h2><h3 id="Dockerfile是用来构建Docker镜像的构建文件，由一系列命令和参数构成的脚本"><a href="#Dockerfile是用来构建Docker镜像的构建文件，由一系列命令和参数构成的脚本" class="headerlink" title="Dockerfile是用来构建Docker镜像的构建文件，由一系列命令和参数构成的脚本"></a>Dockerfile是用来构建Docker镜像的构建文件，由一系列命令和参数构成的脚本</h3><h3 id="构建三步骤"><a href="#构建三步骤" class="headerlink" title="构建三步骤"></a>构建三步骤</h3><p>​    编写Dockerfile文件</p>
<p>​    docker build</p>
<p>​    docker run</p>
<h3 id="文件什么样？？？"><a href="#文件什么样？？？" class="headerlink" title="文件什么样？？？"></a>文件什么样？？？</h3><p>​    熟悉的Centos为例</p>
<p><a href="http://hub.docker.com/_/centos" target="_blank" rel="noopener">http://hub.docker.com/_/centos</a></p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095531.png"></p>
<h2 id="DockerFile构建过程解析"><a href="#DockerFile构建过程解析" class="headerlink" title="DockerFile构建过程解析"></a>DockerFile构建过程解析</h2><p>Dockerfile内容基础知识</p>
<p>1、每条保留字指令都必须为大写字母且后面要跟随至少一个参数<br>2、 指令按照从.上到下，顺序执行<br>3、#表示注释<br>4、每条指令都会创建一个新的镜像层，并对镜像进行提交</p>
<h3 id="Docker执行Dockerfile的大致流程"><a href="#Docker执行Dockerfile的大致流程" class="headerlink" title="Docker执行Dockerfile的大致流程"></a>Docker执行Dockerfile的大致流程</h3><p>1、 docker 从基础镜像运行一个容器<br>2、执行一-条指令并对容器作出修改<br>3、执行类似docker commit的操作提交- -个新的镜像层<br>4、docker再基 于刚提交的镜像运行一一个新容器<br>5、执行dockerfile中的 下一条指令直到所有指令都执行完成</p>
<h3 id="小总结-2"><a href="#小总结-2" class="headerlink" title="小总结"></a>小总结</h3><p>从应用软件的角度来看，Dockerfile、 Docker镜像与Docker容器分别代表软件的三个不同阶段，<br>Dockerfile是软件的原材料<br>Docker镜像是软件的交付品<br>Docker容器则可以认为是软件的运行态。<br>Dockerfile面向开发，Docker镜 像成为交付标准，Docker容 器则涉及部署与运维，三者缺- -不可，合力充当Docker体系的基石。</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095538.png"></p>
<p>1、Dockerfile，需要定义一个Dockerfile，Dockerfile定 义了进程需要的一切东西。Dockerfile涉 及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;<br>2、Docker镜像，在用Dockerfile定义一文件之后，docker build时会产生- -个Docker镜像，当运行Docker镜像时，会真正开始提供服务;<br>3、Docker容器，容器是直接提供服务的。</p>
<h2 id="DockerFile体系结构-保留字指令"><a href="#DockerFile体系结构-保留字指令" class="headerlink" title="DockerFile体系结构(保留字指令)"></a>DockerFile体系结构(保留字指令)</h2><p><img style="zoom:200%;" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095546.png"></p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095551.png"></p>
<p>小总结</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095555.png"></p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="Base-镜像-scratch"><a href="#Base-镜像-scratch" class="headerlink" title="Base 镜像(scratch)"></a>Base 镜像(scratch)</h3><p>Docker Hub中 99%的镜像都是通过在base镜像中安装和配置需要的软件构建出来的</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095559.png"></p>
<h3 id="自定义镜像mycentos"><a href="#自定义镜像mycentos" class="headerlink" title="自定义镜像mycentos"></a>自定义镜像mycentos</h3><h4 id="1、编写"><a href="#1、编写" class="headerlink" title="1、编写"></a>1、编写</h4><p>​    Hub默认Centos镜像是什么情况</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095603.png"></p>
<p>准备Dockerfile文件</p>
<p>myCentOS内容Dockerfile</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095607.png"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER ZZYY&lt;zzyy167@126.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo "success--------------ok"</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>
<h4 id="2、构建"><a href="#2、构建" class="headerlink" title="2、构建"></a>2、构建</h4><p>docker build -t 新镜像名字:TAG .</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095613.png"></p>
<h4 id="3、运行"><a href="#3、运行" class="headerlink" title="3、运行"></a>3、运行</h4><p>docker run -it 新镜像名字:TAG </p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095617.png"></p>
<h4 id="4、列出镜像的变更历史"><a href="#4、列出镜像的变更历史" class="headerlink" title="4、列出镜像的变更历史"></a>4、列出镜像的变更历史</h4><p>docker history 镜像名</p>
<p>CMD/ENTRYPOINT 镜像案例</p>
<p>都是指定一个容器启动时要运行的命令</p>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>​    Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被dockerrun之后的参数替换</p>
<p>​    Case</p>
<p>​    tomcat的讲解演示 docker run -it -p 8080:8080 tomcat ls -l</p>
<h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>​    docker run 之后的参数会被当做参数传递给 ENTRYPOINT 之后形成新的命令组合</p>
<p>​    Case </p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095622.png"></p>
<p>制作CMD版可以查询IP信息的容器</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095625.png"></p>
<h4 id="curl的命令解释"><a href="#curl的命令解释" class="headerlink" title="curl的命令解释"></a>curl的命令解释</h4><p><strong>curl</strong>命令可以用来执行下载、发送各种<strong>HTTP</strong>请求，指定<strong>HTTP</strong>头部等操作。</p>
<p>如果系统没有<strong>curl</strong>可以使用<strong>yum install curl</strong>安装，也可以下载安装。<br><strong>curl是将下载文件输出到stdout</strong><br>使用命令: curl <a href="http://www" target="_blank" rel="noopener">http://www</a> .baidu.com<br>执行后，www.baidu.com的html就会显示在屏幕上了</p>
<p>这是最简单的使用方法。用这个命令获得了htp://curl.haxx.se指向的页面，同样，如果这里的URL指向的是—个文件或者一幅图都可以直接下载到本地。如果下载的是HTML文档，那么缺省的将只显示文件头部，即HTML文档的header。要全部显示，请加参数-i</p>
<p>WHY</p>
<p>我们可以看到可执行文件找不到的报错，<strong>executable file not found。</strong><br>之前我们说过，<strong>跟在镜像名后面的是command,运行时会替换CMD的默认值。</strong><br>因此这里的-i替换了原来的CMD，而不是添加在原来的curl -s htp://ip.cn后面。而-i 根本不是命令，所以自然找不到。<br>那么如果我们希望加入-i这参数，我们就必须重新完整的输入这个命令:<br><strong>$ docker run myip curl -s <a href="http://ip.cn" target="_blank" rel="noopener">http://ip.cn</a> -i</strong></p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095631.png"></p>
<h3 id="自定义镜像Tomcat"><a href="#自定义镜像Tomcat" class="headerlink" title="自定义镜像Tomcat"></a>自定义镜像Tomcat</h3><h4 id="1、mkdir-p-zzyy-mydockerfile-tomcat9"><a href="#1、mkdir-p-zzyy-mydockerfile-tomcat9" class="headerlink" title="1、mkdir -p /zzyy/mydockerfile/tomcat9"></a>1、mkdir -p /zzyy/mydockerfile/tomcat9</h4><h4 id="2、在上述目录下-touch-c-txt"><a href="#2、在上述目录下-touch-c-txt" class="headerlink" title="2、在上述目录下 touch c.txt"></a>2、在上述目录下 touch c.txt</h4><h4 id="3、将jdk和tomcat安装的压缩包拷贝进上一步目录"><a href="#3、将jdk和tomcat安装的压缩包拷贝进上一步目录" class="headerlink" title="3、将jdk和tomcat安装的压缩包拷贝进上一步目录"></a>3、将jdk和tomcat安装的压缩包拷贝进上一步目录</h4><h4 id="4、在zzyyuse-mydockerfile-tomcat9目录下新建Dockerfile文件"><a href="#4、在zzyyuse-mydockerfile-tomcat9目录下新建Dockerfile文件" class="headerlink" title="4、在zzyyuse/mydockerfile/tomcat9目录下新建Dockerfile文件"></a>4、在zzyyuse/mydockerfile/tomcat9目录下新建Dockerfile文件</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span> zzyy&lt;zzyybs@ <span class="number">126</span>.com&gt;</span><br><span class="line"><span class="comment">#把宿主机当前上下文的c .txt拷贝到容器/usr/local/路径下</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> c.txt /usr/<span class="built_in">local</span>/cincontainer.txt</span></span><br><span class="line"><span class="comment">#把java与tomcat添加到容器中</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> jdk-8u171-linux x64.tar .gz /usr/<span class="built_in">local</span>/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> apache-tomcat-9.0.8.tar.gz /usr/ocal/</span></span><br><span class="line"><span class="comment">#安装vim编辑器</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install vim</span></span><br><span class="line"><span class="comment">#设置工 作访问时候的WORKDIR路径， 登录落脚点</span></span><br><span class="line"><span class="keyword">ENV</span> MYPATH /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="comment">#配:置java与tomcat环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_ HOME /usr/localjdk1 .<span class="number">8.0</span>_ <span class="number">171</span></span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH $JAVA_ HOME/lib/dt.jar:$JAVA_ HOME/lib/tools.jar</span><br><span class="line"><span class="keyword">ENV</span> CATALINA_ HOME /usr/local/apache-tomcat-<span class="number">9.0</span>.<span class="number">8</span></span><br><span class="line"><span class="keyword">ENV</span> CATALINA_ BASE /usr/ocal/apache-tomcat-<span class="number">9.0</span>.<span class="number">8</span></span><br><span class="line"><span class="keyword">ENV</span> PATH $PATH:$JAVA_ HOME/bin:$CATALINA_ HOME/ib:$CATALINA_ HOME/bin</span><br><span class="line"><span class="comment">#容器运行时监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment">#启动时运行tomcat</span></span><br><span class="line"><span class="comment"># ENTRYPOINT ["/usrl/local/apache-tomcat-9.0.8/bin/startup.sh" ]</span></span><br><span class="line"><span class="comment"># CMD ["/usr/local/apache-tomcat-9.0.8/bin/catalina.sh","run"]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /usr/<span class="built_in">local</span>/apache-tomcat-9.0.8/bin/startup.sh &amp;&amp; tail -F /usr/<span class="built_in">local</span>/apache-tomcat-9.0.8/<span class="keyword">in</span>/logs/catalina.out</span></span><br></pre></td></tr></table></figure>
<p>目录内容</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095636.png"></p>
<h4 id="5、构建"><a href="#5、构建" class="headerlink" title="5、构建"></a>5、构建</h4><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095640.png"></p>
<p>构建完成</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095643.png"></p>
<h4 id="6、run"><a href="#6、run" class="headerlink" title="6、run"></a>6、run</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d -p 9080:8080 -name myt9</span></span><br><span class="line"> -v /zyuse/mydockerfiletomcat9/test:/usrlocal/apache-tomcat9.<span class="number">0.8</span>/webapps/test</span><br><span class="line"> -v /zzyyuse/mydockerfile/tomcat9/tomcat9logs/:/usrlocal/apache-tomcat-<span class="number">9.0</span>.<span class="number">8</span>/logs -privileged=true zzyytomcat9</span><br></pre></td></tr></table></figure>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095647.png"></p>
<p>备注</p>
<p>Docker挂载主机目录Docker访问出现cannot open directory : Permission denied解决办法:在挂载目录后多加一个—privileged=true参数即可</p>
<h4 id="7、验证"><a href="#7、验证" class="headerlink" title="7、验证"></a>7、验证</h4><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095652.png"></p>
<h4 id="8、综合前-述容器卷测试的web服务test发布"><a href="#8、综合前-述容器卷测试的web服务test发布" class="headerlink" title="8、综合前 述容器卷测试的web服务test发布"></a>8、综合前 述容器卷测试的web服务test发布</h4><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095656.png"></p>
<p>web.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1 .0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmIns:xsi</span>=<span class="string">"http://www.w3.org/2001/XML Schema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmIns</span>=<span class="string">"http://java sun.com/xm/ns/javaee"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaL</span> <span class="attr">ocation</span>=<span class="string">"http://java. sun.com/xml/ns/javaee htp:/:/java. sun.com/xml/ns/javaee/web-app_ 2_ _5.xsd"</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">"WebApp_ ID"</span> <span class="attr">version</span>=<span class="string">"2.5"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">display-name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>a.jsp</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC“<span class="comment">//W3C//DTD HTML 4.01 Transitional//EN" http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here &lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">welcome-</span><br><span class="line">&lt;%=<span class="string">"i am in docker tomcat self "</span>%&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;% System.out,.printIn(<span class="string">"==========docker tomcat self"</span>);%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/htmI&gt;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span> <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC“//W3C//DTD HTML 4.01 Transitional//EN" http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">welcome-</span><br><span class="line"><span class="tag">&lt;<span class="name">%="i</span> <span class="attr">am</span> <span class="attr">in</span> <span class="attr">docker</span> <span class="attr">tomcat</span> <span class="attr">self</span> "%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">System.out</span>,<span class="attr">.printIn</span>("==========<span class="string">docker</span> <span class="attr">tomcat</span> <span class="attr">self</span>");%&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">htmI</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="小总结-3"><a href="#小总结-3" class="headerlink" title="小总结"></a>小总结</h2><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095705.png"></p>
<h1 id="第七章-Docker常用安装"><a href="#第七章-Docker常用安装" class="headerlink" title="第七章 Docker常用安装"></a>第七章 Docker常用安装</h1><h2 id="总体步骤"><a href="#总体步骤" class="headerlink" title="总体步骤"></a>总体步骤</h2><blockquote>
<p>搜索镜像</p>
<p>拉取镜像</p>
<p>查看镜像</p>
<p>启动镜像</p>
<p>停止容器</p>
<p>移除容器</p>
</blockquote>
<h2 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h2><h3 id="docker-hub-上查找mysql镜像"><a href="#docker-hub-上查找mysql镜像" class="headerlink" title="docker hub 上查找mysql镜像"></a>docker hub 上查找mysql镜像</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095710.png"></p>
<h3 id="从-docker-hub-阿里云加速器-拉取mysql镜像到本地标签为5-6"><a href="#从-docker-hub-阿里云加速器-拉取mysql镜像到本地标签为5-6" class="headerlink" title="从 docker hub(阿里云加速器)拉取mysql镜像到本地标签为5.6"></a>从 docker hub(阿里云加速器)拉取mysql镜像到本地标签为5.6</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095713.png"></p>
<h3 id="使用mysql5-6镜像创建容器-也叫运行镜像"><a href="#使用mysql5-6镜像创建容器-也叫运行镜像" class="headerlink" title="使用mysql5.6镜像创建容器(也叫运行镜像)"></a>使用mysql5.6镜像创建容器(也叫运行镜像)</h3><p>使用mysql镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 12345:3306 --name mysql </span><br><span class="line">-v /ggcc/mysql/conf:/etc/mysql/conf.d </span><br><span class="line">-v /ggcc/mysql/logs:/logs </span><br><span class="line">-v /ggcc/mysql/data:/var/lib/mysql </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6</span><br><span class="line">----------------------------------------------</span><br><span class="line">命令说明:</span><br><span class="line">-p 12345:3306:将主机的12345端口映射到docker容器的3306端口。</span><br><span class="line">-name mysq:运行服务名字</span><br><span class="line">-V /ggcc/mysql/conf:/etc/mysql/conf.d :将主机/zzyyuse/mysq|录下的conf/my.cnf挂载到容器的/etc/mysql/conf.d</span><br><span class="line">-v /ggcc/mysqlogs/logs: 将主机/zzyyuse/mysq|目 录下的logs 目录挂载到容器的/logs。</span><br><span class="line">-V /ggcc/mysqldata:/var/lib/mysql :将主机lzzyyuse/mysql目录下的data目录挂载到容器的/var/lib/mysql .</span><br><span class="line">-e MYSQL_ ROOT_ PASSWORD=123456: 初始化root用户的密码。.</span><br><span class="line">-d mysql:5.6:后台程序运行mysql5.6 </span><br><span class="line">----------------------------------------------</span><br><span class="line">docker exec -it Mysql运行成功后的容器ID /bin/bash</span><br><span class="line">----------------------------------------------</span><br><span class="line">数据备份小测试</span><br><span class="line">docker exec mysql服务容器ID sh -c 'exec mysqldump --all-databases -uroot -p"123456"' &gt;/ggcc/all-database.sql</span><br></pre></td></tr></table></figure>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095717.png"></p>
<h3 id="数据备份测试"><a href="#数据备份测试" class="headerlink" title="数据备份测试"></a>数据备份测试</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095721.png"></p>
<h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><h3 id="从docker-hu上-阿里云加速器-拉取redis镜像到本地标签为：3-2"><a href="#从docker-hu上-阿里云加速器-拉取redis镜像到本地标签为：3-2" class="headerlink" title="从docker hu上(阿里云加速器)拉取redis镜像到本地标签为：3.2"></a>从docker hu上(阿里云加速器)拉取redis镜像到本地标签为：3.2</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095728.png"></p>
<h3 id="使用redis3-2镜像创建容器-也叫运行镜像"><a href="#使用redis3-2镜像创建容器-也叫运行镜像" class="headerlink" title="使用redis3.2镜像创建容器(也叫运行镜像)"></a>使用redis3.2镜像创建容器(也叫运行镜像)</h3><p>​    使用镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 -v /ggcc/myredis/data:/data -v /ggcc/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis redis-server /usr/local/etc/redis/redis.conf --appendonly yes</span><br></pre></td></tr></table></figure>
<h3 id="在主机-ggcc-myredis-conf-redis-conf目录上新建redis-conf文件"><a href="#在主机-ggcc-myredis-conf-redis-conf目录上新建redis-conf文件" class="headerlink" title="在主机/ggcc/myredis/conf/redis.conf目录上新建redis.conf文件"></a>在主机/ggcc/myredis/conf/redis.conf目录上新建redis.conf文件</h3><p>vim /ggcc/myredis/conf/redis.conf/redis.conf</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br><span class="line">1750</span><br><span class="line">1751</span><br><span class="line">1752</span><br><span class="line">1753</span><br><span class="line">1754</span><br><span class="line">1755</span><br><span class="line">1756</span><br><span class="line">1757</span><br><span class="line">1758</span><br><span class="line">1759</span><br><span class="line">1760</span><br><span class="line">1761</span><br><span class="line">1762</span><br><span class="line">1763</span><br><span class="line">1764</span><br><span class="line">1765</span><br><span class="line">1766</span><br><span class="line">1767</span><br><span class="line">1768</span><br><span class="line">1769</span><br><span class="line">1770</span><br><span class="line">1771</span><br><span class="line">1772</span><br><span class="line">1773</span><br><span class="line">1774</span><br><span class="line">1775</span><br><span class="line">1776</span><br><span class="line">1777</span><br><span class="line">1778</span><br><span class="line">1779</span><br><span class="line">1780</span><br><span class="line">1781</span><br><span class="line">1782</span><br><span class="line">1783</span><br><span class="line">1784</span><br><span class="line">1785</span><br><span class="line">1786</span><br><span class="line">1787</span><br><span class="line">1788</span><br><span class="line">1789</span><br><span class="line">1790</span><br><span class="line">1791</span><br><span class="line">1792</span><br><span class="line">1793</span><br><span class="line">1794</span><br><span class="line">1795</span><br><span class="line">1796</span><br><span class="line">1797</span><br><span class="line">1798</span><br><span class="line">1799</span><br><span class="line">1800</span><br><span class="line">1801</span><br><span class="line">1802</span><br><span class="line">1803</span><br><span class="line">1804</span><br><span class="line">1805</span><br><span class="line">1806</span><br><span class="line">1807</span><br><span class="line">1808</span><br><span class="line">1809</span><br><span class="line">1810</span><br><span class="line">1811</span><br><span class="line">1812</span><br><span class="line">1813</span><br><span class="line">1814</span><br><span class="line">1815</span><br><span class="line">1816</span><br><span class="line">1817</span><br><span class="line">1818</span><br><span class="line">1819</span><br><span class="line">1820</span><br><span class="line">1821</span><br><span class="line">1822</span><br><span class="line">1823</span><br><span class="line">1824</span><br><span class="line">1825</span><br><span class="line">1826</span><br><span class="line">1827</span><br><span class="line">1828</span><br><span class="line">1829</span><br><span class="line">1830</span><br><span class="line">1831</span><br><span class="line">1832</span><br><span class="line">1833</span><br><span class="line">1834</span><br><span class="line">1835</span><br><span class="line">1836</span><br><span class="line">1837</span><br><span class="line">1838</span><br><span class="line">1839</span><br><span class="line">1840</span><br><span class="line">1841</span><br><span class="line">1842</span><br><span class="line">1843</span><br><span class="line">1844</span><br><span class="line">1845</span><br><span class="line">1846</span><br><span class="line">1847</span><br><span class="line">1848</span><br><span class="line">1849</span><br><span class="line">1850</span><br><span class="line">1851</span><br><span class="line">1852</span><br><span class="line">1853</span><br><span class="line">1854</span><br><span class="line">1855</span><br><span class="line">1856</span><br><span class="line">1857</span><br><span class="line">1858</span><br><span class="line">1859</span><br><span class="line">1860</span><br><span class="line">1861</span><br></pre></td><td class="code"><pre><span class="line"># Redis configuration file example.</span><br><span class="line">#</span><br><span class="line"># Note that in order to read the configuration file, Redis must be</span><br><span class="line"># started with the file path as first argument:</span><br><span class="line">#</span><br><span class="line"># ./redis-server /path/to/redis.conf</span><br><span class="line"></span><br><span class="line"># Note on units: when memory size is needed, it is possible to specify</span><br><span class="line"># it in the usual form of 1k 5GB 4M and so forth:</span><br><span class="line">#</span><br><span class="line"># 1k =&gt; 1000 bytes</span><br><span class="line"># 1kb =&gt; 1024 bytes</span><br><span class="line"># 1m =&gt; 1000000 bytes</span><br><span class="line"># 1mb =&gt; 1024*1024 bytes</span><br><span class="line"># 1g =&gt; 1000000000 bytes</span><br><span class="line"># 1gb =&gt; 1024*1024*1024 bytes</span><br><span class="line">#</span><br><span class="line"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span><br><span class="line"></span><br><span class="line">################################## INCLUDES ###################################</span><br><span class="line"></span><br><span class="line"># Include one or more other config files here.  This is useful if you</span><br><span class="line"># have a standard template that goes to all Redis servers but also need</span><br><span class="line"># to customize a few per-server settings.  Include files can include</span><br><span class="line"># other files, so use this wisely.</span><br><span class="line">#</span><br><span class="line"># Notice option "include" won't be rewritten by command "CONFIG REWRITE"</span><br><span class="line"># from admin or Redis Sentinel. Since Redis always uses the last processed</span><br><span class="line"># line as value of a configuration directive, you'd better put includes</span><br><span class="line"># at the beginning of this file to avoid overwriting config change at runtime.</span><br><span class="line">#</span><br><span class="line"># If instead you are interested in using includes to override configuration</span><br><span class="line"># options, it is better to use include as the last line.</span><br><span class="line">#</span><br><span class="line"># include /path/to/local.conf</span><br><span class="line"># include /path/to/other.conf</span><br><span class="line"></span><br><span class="line">################################## MODULES #####################################</span><br><span class="line"></span><br><span class="line"># Load modules at startup. If the server is not able to load modules</span><br><span class="line"># it will abort. It is possible to use multiple loadmodule directives.</span><br><span class="line">#</span><br><span class="line"># loadmodule /path/to/my_module.so</span><br><span class="line"># loadmodule /path/to/other_module.so</span><br><span class="line"></span><br><span class="line">################################## NETWORK #####################################</span><br><span class="line"></span><br><span class="line"># By default, if no "bind" configuration directive is specified, Redis listens</span><br><span class="line"># for connections from all the network interfaces available on the server.</span><br><span class="line"># It is possible to listen to just one or multiple selected interfaces using</span><br><span class="line"># the "bind" configuration directive, followed by one or more IP addresses.</span><br><span class="line">#</span><br><span class="line"># Examples:</span><br><span class="line">#</span><br><span class="line"># bind 192.168.1.100 10.0.0.1</span><br><span class="line"># bind 127.0.0.1 ::1</span><br><span class="line">#</span><br><span class="line"># ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the</span><br><span class="line"># internet, binding to all the interfaces is dangerous and will expose the</span><br><span class="line"># instance to everybody on the internet. So by default we uncomment the</span><br><span class="line"># following bind directive, that will force Redis to listen only into</span><br><span class="line"># the IPv4 loopback interface address (this means Redis will be able to</span><br><span class="line"># accept connections only from clients running into the same computer it</span><br><span class="line"># is running).</span><br><span class="line">#</span><br><span class="line"># IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES</span><br><span class="line"># JUST COMMENT THE FOLLOWING LINE.</span><br><span class="line"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">#bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># Protected mode is a layer of security protection, in order to avoid that</span><br><span class="line"># Redis instances left open on the internet are accessed and exploited.</span><br><span class="line">#</span><br><span class="line"># When protected mode is on and if:</span><br><span class="line">#</span><br><span class="line"># 1) The server is not binding explicitly to a set of addresses using the</span><br><span class="line">#    "bind" directive.</span><br><span class="line"># 2) No password is configured.</span><br><span class="line">#</span><br><span class="line"># The server only accepts connections from clients connecting from the</span><br><span class="line"># IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain</span><br><span class="line"># sockets.</span><br><span class="line">#</span><br><span class="line"># By default protected mode is enabled. You should disable it only if</span><br><span class="line"># you are sure you want clients from other hosts to connect to Redis</span><br><span class="line"># even if no authentication is configured, nor a specific set of interfaces</span><br><span class="line"># are explicitly listed using the "bind" directive.</span><br><span class="line"><span class="keyword">protected</span>-mode yes</span><br><span class="line"></span><br><span class="line"># Accept connections on the specified port, default is 6379 (IANA #815344).</span><br><span class="line"># If port 0 is specified Redis will not listen on a TCP socket.</span><br><span class="line">port <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"># TCP listen() backlog.</span><br><span class="line">#</span><br><span class="line"># In high requests-per-second environments you need an high backlog in order</span><br><span class="line"># to avoid slow clients connections issues. Note that the Linux kernel</span><br><span class="line"># will silently truncate it to the value of /proc/sys/net/core/somaxconn so</span><br><span class="line"># make sure to raise both the value of somaxconn and tcp_max_syn_backlog</span><br><span class="line"># in order to get the desired effect.</span><br><span class="line">tcp-backlog <span class="number">511</span></span><br><span class="line"></span><br><span class="line"># Unix socket.</span><br><span class="line">#</span><br><span class="line"># Specify the path for the Unix socket that will be used to listen for</span><br><span class="line"># incoming connections. There is no default, so Redis will not listen</span><br><span class="line"># on a unix socket when not specified.</span><br><span class="line">#</span><br><span class="line"># unixsocket /tmp/redis.sock</span><br><span class="line"># unixsocketperm 700</span><br><span class="line"></span><br><span class="line"># Close the connection after a client is idle for N seconds (0 to disable)</span><br><span class="line">timeout <span class="number">0</span></span><br><span class="line"></span><br><span class="line"># TCP keepalive.</span><br><span class="line">#</span><br><span class="line"># If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence</span><br><span class="line"># of communication. This is useful for two reasons:</span><br><span class="line">#</span><br><span class="line"># 1) Detect dead peers.</span><br><span class="line"># 2) Take the connection alive from the point of view of network</span><br><span class="line">#    equipment in the middle.</span><br><span class="line">#</span><br><span class="line"># On Linux, the specified value (in seconds) is the period used to send ACKs.</span><br><span class="line"># Note that to close the connection the double of the time is needed.</span><br><span class="line"># On other kernels the period depends on the kernel configuration.</span><br><span class="line">#</span><br><span class="line"># A reasonable value for this option is 300 seconds, which is the new</span><br><span class="line"># Redis default starting with Redis 3.2.1.</span><br><span class="line">tcp-keepalive <span class="number">300</span></span><br><span class="line"></span><br><span class="line">################################# TLS/SSL #####################################</span><br><span class="line"></span><br><span class="line"># By default, TLS/SSL is disabled. To enable it, the "tls-port" configuration</span><br><span class="line"># directive can be used to define TLS-listening ports. To enable TLS on the</span><br><span class="line"># default port, use:</span><br><span class="line">#</span><br><span class="line"># port 0</span><br><span class="line"># tls-port 6379</span><br><span class="line"></span><br><span class="line"># Configure a X.509 certificate and private key to use for authenticating the</span><br><span class="line"># server to connected clients, masters or cluster peers.  These files should be</span><br><span class="line"># PEM formatted.</span><br><span class="line">#</span><br><span class="line"># tls-cert-file redis.crt </span><br><span class="line"># tls-key-file redis.key</span><br><span class="line"></span><br><span class="line"># Configure a DH parameters file to enable Diffie-Hellman (DH) key exchange:</span><br><span class="line">#</span><br><span class="line"># tls-dh-params-file redis.dh</span><br><span class="line"></span><br><span class="line"># Configure a CA certificate(s) bundle or directory to authenticate TLS/SSL</span><br><span class="line"># clients and peers.  Redis requires an explicit configuration of at least one</span><br><span class="line"># of these, and will not implicitly use the system wide configuration.</span><br><span class="line">#</span><br><span class="line"># tls-ca-cert-file ca.crt</span><br><span class="line"># tls-ca-cert-dir /etc/ssl/certs</span><br><span class="line"></span><br><span class="line"># By default, clients (including replica servers) on a TLS port are required</span><br><span class="line"># to authenticate using valid client side certificates.</span><br><span class="line">#</span><br><span class="line"># If "no" is specified, client certificates are not required and not accepted.</span><br><span class="line"># If "optional" is specified, client certificates are accepted and must be</span><br><span class="line"># valid if provided, but are not required.</span><br><span class="line">#</span><br><span class="line"># tls-auth-clients no</span><br><span class="line"># tls-auth-clients optional</span><br><span class="line"></span><br><span class="line"># By default, a Redis replica does not attempt to establish a TLS connection</span><br><span class="line"># with its master.</span><br><span class="line">#</span><br><span class="line"># Use the following directive to enable TLS on replication links.</span><br><span class="line">#</span><br><span class="line"># tls-replication yes</span><br><span class="line"></span><br><span class="line"># By default, the Redis Cluster bus uses a plain TCP connection. To enable</span><br><span class="line"># TLS for the bus protocol, use the following directive:</span><br><span class="line">#</span><br><span class="line"># tls-cluster yes</span><br><span class="line"></span><br><span class="line"># Explicitly specify TLS versions to support. Allowed values are case insensitive</span><br><span class="line"># and include "TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3" (OpenSSL &gt;= 1.1.1) or</span><br><span class="line"># any combination. To enable only TLSv1.2 and TLSv1.3, use:</span><br><span class="line">#</span><br><span class="line"># tls-protocols "TLSv1.2 TLSv1.3"</span><br><span class="line"></span><br><span class="line"># Configure allowed ciphers.  See the ciphers(1ssl) manpage for more information</span><br><span class="line"># about the syntax of this string.</span><br><span class="line">#</span><br><span class="line"># Note: this configuration applies only to &lt;= TLSv1.2.</span><br><span class="line">#</span><br><span class="line"># tls-ciphers DEFAULT:!MEDIUM</span><br><span class="line"></span><br><span class="line"># Configure allowed TLSv1.3 ciphersuites.  See the ciphers(1ssl) manpage for more</span><br><span class="line"># information about the syntax of this string, and specifically for TLSv1.3</span><br><span class="line"># ciphersuites.</span><br><span class="line">#</span><br><span class="line"># tls-ciphersuites TLS_CHACHA20_POLY1305_SHA256</span><br><span class="line"></span><br><span class="line"># When choosing a cipher, use the server's preference instead of the client</span><br><span class="line"># preference. By default, the server follows the client's preference.</span><br><span class="line">#</span><br><span class="line"># tls-prefer-server-ciphers yes</span><br><span class="line"></span><br><span class="line"># By default, TLS session caching is enabled to allow faster and less expensive</span><br><span class="line"># reconnections by clients that support it. Use the following directive to disable</span><br><span class="line"># caching.</span><br><span class="line">#</span><br><span class="line"># tls-session-caching no</span><br><span class="line"></span><br><span class="line"># Change the default number of TLS sessions cached. A zero value sets the cache</span><br><span class="line"># to unlimited size. The default size is 20480.</span><br><span class="line">#</span><br><span class="line"># tls-session-cache-size 5000</span><br><span class="line"></span><br><span class="line"># Change the default timeout of cached TLS sessions. The default timeout is 300</span><br><span class="line"># seconds.</span><br><span class="line">#</span><br><span class="line"># tls-session-cache-timeout 60</span><br><span class="line"></span><br><span class="line">################################# GENERAL #####################################</span><br><span class="line"></span><br><span class="line"># By default Redis does not run as a daemon. Use 'yes' if you need it.</span><br><span class="line"># Note that Redis will write a pid file in /var/run/redis.pid when daemonized.</span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"># If you run Redis from upstart or systemd, Redis can interact with your</span><br><span class="line"># supervision tree. Options:</span><br><span class="line">#   supervised no      - no supervision interaction</span><br><span class="line">#   supervised upstart - signal upstart by putting Redis into SIGSTOP mode</span><br><span class="line">#   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET</span><br><span class="line">#   supervised auto    - detect upstart or systemd method based on</span><br><span class="line">#                        UPSTART_JOB or NOTIFY_SOCKET environment variables</span><br><span class="line"># Note: these supervision methods only signal "process is ready."</span><br><span class="line">#       They do not enable continuous liveness pings back to your supervisor.</span><br><span class="line">supervised no</span><br><span class="line"></span><br><span class="line"># If a pid file is specified, Redis writes it where specified at startup</span><br><span class="line"># and removes it at exit.</span><br><span class="line">#</span><br><span class="line"># When the server runs non daemonized, no pid file is created if none is</span><br><span class="line"># specified in the configuration. When the server is daemonized, the pid file</span><br><span class="line"># is used even if not specified, defaulting to "/var/run/redis.pid".</span><br><span class="line">#</span><br><span class="line"># Creating a pid file is best effort: if Redis is not able to create it</span><br><span class="line"># nothing bad happens, the server will start and run normally.</span><br><span class="line">pidfile /<span class="keyword">var</span>/run/redis_6379.pid</span><br><span class="line"></span><br><span class="line"># Specify the server verbosity level.</span><br><span class="line"># This can be one of:</span><br><span class="line"># debug (a lot of information, useful for development/testing)</span><br><span class="line"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="line"># notice (moderately verbose, what you want in production probably)</span><br><span class="line"># warning (only very important / critical messages are logged)</span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line"># Specify the log file name. Also the empty string can be used to force</span><br><span class="line"># Redis to log on the standard output. Note that if you use standard</span><br><span class="line"># output for logging but daemonize, logs will be sent to /dev/null</span><br><span class="line">logfile <span class="string">""</span></span><br><span class="line"></span><br><span class="line"># To enable logging to the system logger, just set 'syslog-enabled' to yes,</span><br><span class="line"># and optionally update the other syslog parameters to suit your needs.</span><br><span class="line"># syslog-enabled no</span><br><span class="line"></span><br><span class="line"># Specify the syslog identity.</span><br><span class="line"># syslog-ident redis</span><br><span class="line"></span><br><span class="line"># Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.</span><br><span class="line"># syslog-facility local0</span><br><span class="line"></span><br><span class="line"># Set the number of databases. The default database is DB 0, you can select</span><br><span class="line"># a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span><br><span class="line"># dbid is a number between 0 and 'databases'-1</span><br><span class="line">databases <span class="number">16</span></span><br><span class="line"></span><br><span class="line"># By default Redis shows an ASCII art logo only when started to log to the</span><br><span class="line"># standard output and if the standard output is a TTY. Basically this means</span><br><span class="line"># that normally a logo is displayed only in interactive sessions.</span><br><span class="line">#</span><br><span class="line"># However it is possible to force the pre-4.0 behavior and always show a</span><br><span class="line"># ASCII art logo in startup logs by setting the following option to yes.</span><br><span class="line">always-show-logo yes</span><br><span class="line"></span><br><span class="line">################################ SNAPSHOTTING  ################################</span><br><span class="line">#</span><br><span class="line"># Save the DB on disk:</span><br><span class="line">#</span><br><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#</span><br><span class="line">#   Will save the DB if both the given number of seconds and the given</span><br><span class="line">#   number of write operations against the DB occurred.</span><br><span class="line">#</span><br><span class="line">#   In the example below the behaviour will be to save:</span><br><span class="line">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">#   after 60 sec if at least 10000 keys changed</span><br><span class="line">#</span><br><span class="line">#   Note: you can disable saving completely by commenting out all "save" lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save ""</span><br><span class="line"></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"># By default Redis will stop accepting writes if RDB snapshots are enabled</span><br><span class="line"># (at least one save point) and the latest background save failed.</span><br><span class="line"># This will make the user aware (in a hard way) that data is not persisting</span><br><span class="line"># on disk properly, otherwise chances are that no one will notice and some</span><br><span class="line"># disaster will happen.</span><br><span class="line">#</span><br><span class="line"># If the background saving process will start working again Redis will</span><br><span class="line"># automatically allow writes again.</span><br><span class="line">#</span><br><span class="line"># However if you have setup your proper monitoring of the Redis server</span><br><span class="line"># and persistence, you may want to disable this feature so that Redis will</span><br><span class="line"># continue to work as usual even if there are problems with disk,</span><br><span class="line"># permissions, and so forth.</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># Compress string objects using LZF when dump .rdb databases?</span><br><span class="line"># For default that's set to 'yes' as it's almost always a win.</span><br><span class="line"># If you want to save some CPU in the saving child set it to 'no' but</span><br><span class="line"># the dataset will likely be bigger if you have compressible values or keys.</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span><br><span class="line"># This makes the format more resistant to corruption but there is a performance</span><br><span class="line"># hit to pay (around 10%) when saving and loading RDB files, so you can disable it</span><br><span class="line"># for maximum performances.</span><br><span class="line">#</span><br><span class="line"># RDB files created with checksum disabled have a checksum of zero that will</span><br><span class="line"># tell the loading code to skip the check.</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"># The filename where to dump the DB</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># Remove RDB files used by replication in instances without persistence</span><br><span class="line"># enabled. By default this option is disabled, however there are environments</span><br><span class="line"># where for regulations or other security concerns, RDB files persisted on</span><br><span class="line"># disk by masters in order to feed replicas, or stored on disk by replicas</span><br><span class="line"># in order to load them for the initial synchronization, should be deleted</span><br><span class="line"># ASAP. Note that this option ONLY WORKS in instances that have both AOF</span><br><span class="line"># and RDB persistence disabled, otherwise is completely ignored.</span><br><span class="line">#</span><br><span class="line"># An alternative (and sometimes better) way to obtain the same effect is</span><br><span class="line"># to use diskless replication on both master and replicas instances. However</span><br><span class="line"># in the case of replicas, diskless is not always an option.</span><br><span class="line">rdb-del-sync-files no</span><br><span class="line"></span><br><span class="line"># The working directory.</span><br><span class="line">#</span><br><span class="line"># The DB will be written inside this directory, with the filename specified</span><br><span class="line"># above using the 'dbfilename' configuration directive.</span><br><span class="line">#</span><br><span class="line"># The Append Only File will also be created inside this directory.</span><br><span class="line">#</span><br><span class="line"># Note that you must specify a directory here, not a file name.</span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line">################################# REPLICATION #################################</span><br><span class="line"></span><br><span class="line"># Master-Replica replication. Use replicaof to make a Redis instance a copy of</span><br><span class="line"># another Redis server. A few things to understand ASAP about Redis replication.</span><br><span class="line">#</span><br><span class="line">#   +------------------+      +---------------+</span><br><span class="line">#   |      Master      | ---&gt; |    Replica    |</span><br><span class="line">#   | (receive writes) |      |  (exact copy) |</span><br><span class="line">#   +------------------+      +---------------+</span><br><span class="line">#</span><br><span class="line"># 1) Redis replication is asynchronous, but you can configure a master to</span><br><span class="line">#    stop accepting writes if it appears to be not connected with at least</span><br><span class="line">#    a given number of replicas.</span><br><span class="line"># 2) Redis replicas are able to perform a partial resynchronization with the</span><br><span class="line">#    master if the replication link is lost for a relatively small amount of</span><br><span class="line">#    time. You may want to configure the replication backlog size (see the next</span><br><span class="line">#    sections of this file) with a sensible value depending on your needs.</span><br><span class="line"># 3) Replication is automatic and does not need user intervention. After a</span><br><span class="line">#    network partition replicas automatically try to reconnect to masters</span><br><span class="line">#    and resynchronize with them.</span><br><span class="line">#</span><br><span class="line"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line"># If the master is password protected (using the "requirepass" configuration</span><br><span class="line"># directive below) it is possible to tell the replica to authenticate before</span><br><span class="line"># starting the replication synchronization process, otherwise the master will</span><br><span class="line"># refuse the replica request.</span><br><span class="line">#</span><br><span class="line"># masterauth &lt;master-password&gt;</span><br><span class="line">#</span><br><span class="line"># However this is not enough if you are using Redis ACLs (for Redis version</span><br><span class="line"># 6 or greater), and the default user is not capable of running the PSYNC</span><br><span class="line"># command and/or other commands needed for replication. In this case it's</span><br><span class="line"># better to configure a special user to use with replication, and specify the</span><br><span class="line"># masteruser configuration as such:</span><br><span class="line">#</span><br><span class="line"># masteruser &lt;username&gt;</span><br><span class="line">#</span><br><span class="line"># When masteruser is specified, the replica will authenticate against its</span><br><span class="line"># master using the new AUTH form: AUTH &lt;username&gt; &lt;password&gt;.</span><br><span class="line"></span><br><span class="line"># When a replica loses its connection with the master, or when the replication</span><br><span class="line"># is still in progress, the replica can act in two different ways:</span><br><span class="line">#</span><br><span class="line"># 1) if replica-serve-stale-data is set to 'yes' (the default) the replica will</span><br><span class="line">#    still reply to client requests, possibly with out of date data, or the</span><br><span class="line">#    data set may just be empty if this is the first synchronization.</span><br><span class="line">#</span><br><span class="line"># 2) if replica-serve-stale-data is set to 'no' the replica will reply with</span><br><span class="line">#    an error "SYNC with master in progress" to all the kind of commands</span><br><span class="line">#    but to INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,</span><br><span class="line">#    SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,</span><br><span class="line">#    COMMAND, POST, HOST: and LATENCY.</span><br><span class="line">#</span><br><span class="line">replica-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"># You can configure a replica instance to accept writes or not. Writing against</span><br><span class="line"># a replica instance may be useful to store some ephemeral data (because data</span><br><span class="line"># written on a replica will be easily deleted after resync with the master) but</span><br><span class="line"># may also cause problems if clients are writing to it because of a</span><br><span class="line"># misconfiguration.</span><br><span class="line">#</span><br><span class="line"># Since Redis 2.6 by default replicas are read-only.</span><br><span class="line">#</span><br><span class="line"># Note: read only replicas are not designed to be exposed to untrusted clients</span><br><span class="line"># on the internet. It's just a protection layer against misuse of the instance.</span><br><span class="line"># Still a read only replica exports by default all the administrative commands</span><br><span class="line"># such as CONFIG, DEBUG, and so forth. To a limited extent you can improve</span><br><span class="line"># security of read only replicas using 'rename-command' to shadow all the</span><br><span class="line"># administrative / dangerous commands.</span><br><span class="line">replica-read-only yes</span><br><span class="line"></span><br><span class="line"># Replication SYNC strategy: disk or socket.</span><br><span class="line">#</span><br><span class="line"># New replicas and reconnecting replicas that are not able to continue the</span><br><span class="line"># replication process just receiving differences, need to do what is called a</span><br><span class="line"># "full synchronization". An RDB file is transmitted from the master to the</span><br><span class="line"># replicas.</span><br><span class="line">#</span><br><span class="line"># The transmission can happen in two different ways:</span><br><span class="line">#</span><br><span class="line"># 1) Disk-backed: The Redis master creates a new process that writes the RDB</span><br><span class="line">#                 file on disk. Later the file is transferred by the parent</span><br><span class="line">#                 process to the replicas incrementally.</span><br><span class="line"># 2) Diskless: The Redis master creates a new process that directly writes the</span><br><span class="line">#              RDB file to replica sockets, without touching the disk at all.</span><br><span class="line">#</span><br><span class="line"># With disk-backed replication, while the RDB file is generated, more replicas</span><br><span class="line"># can be queued and served with the RDB file as soon as the current child</span><br><span class="line"># producing the RDB file finishes its work. With diskless replication instead</span><br><span class="line"># once the transfer starts, new replicas arriving will be queued and a new</span><br><span class="line"># transfer will start when the current one terminates.</span><br><span class="line">#</span><br><span class="line"># When diskless replication is used, the master waits a configurable amount of</span><br><span class="line"># time (in seconds) before starting the transfer in the hope that multiple</span><br><span class="line"># replicas will arrive and the transfer can be parallelized.</span><br><span class="line">#</span><br><span class="line"># With slow disks and fast (large bandwidth) networks, diskless replication</span><br><span class="line"># works better.</span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"># When diskless replication is enabled, it is possible to configure the delay</span><br><span class="line"># the server waits in order to spawn the child that transfers the RDB via socket</span><br><span class="line"># to the replicas.</span><br><span class="line">#</span><br><span class="line"># This is important since once the transfer starts, it is not possible to serve</span><br><span class="line"># new replicas arriving, that will be queued for the next RDB transfer, so the</span><br><span class="line"># server waits a delay in order to let more replicas arrive.</span><br><span class="line">#</span><br><span class="line"># The delay is specified in seconds, and by default is 5 seconds. To disable</span><br><span class="line"># it entirely just set it to 0 seconds and the transfer will start ASAP.</span><br><span class="line">repl-diskless-sync-delay <span class="number">5</span></span><br><span class="line"></span><br><span class="line"># -----------------------------------------------------------------------------</span><br><span class="line"># WARNING: RDB diskless load is experimental. Since in this setup the replica</span><br><span class="line"># does not immediately store an RDB on disk, it may cause data loss during</span><br><span class="line"># failovers. RDB diskless load + Redis modules not handling I/O reads may also</span><br><span class="line"># cause Redis to abort in case of I/O errors during the initial synchronization</span><br><span class="line"># stage with the master. Use only if your do what you are doing.</span><br><span class="line"># -----------------------------------------------------------------------------</span><br><span class="line">#</span><br><span class="line"># Replica can load the RDB it reads from the replication link directly from the</span><br><span class="line"># socket, or store the RDB to a file and read that file after it was completely</span><br><span class="line"># recived from the master.</span><br><span class="line">#</span><br><span class="line"># In many cases the disk is slower than the network, and storing and loading</span><br><span class="line"># the RDB file may increase replication time (and even increase the master's</span><br><span class="line"># Copy on Write memory and salve buffers).</span><br><span class="line"># However, parsing the RDB file directly from the socket may mean that we have</span><br><span class="line"># to flush the contents of the current database before the full rdb was</span><br><span class="line"># received. For this reason we have the following options:</span><br><span class="line">#</span><br><span class="line"># "disabled"    - Don't use diskless load (store the rdb file to the disk first)</span><br><span class="line"># "on-empty-db" - Use diskless load only when it is completely safe.</span><br><span class="line"># "swapdb"      - Keep a copy of the current db contents in RAM while parsing</span><br><span class="line">#                 the data directly from the socket. note that this requires</span><br><span class="line">#                 sufficient memory, if you don't have it, you risk an OOM kill.</span><br><span class="line">repl-diskless-load disabled</span><br><span class="line"></span><br><span class="line"># Replicas send PINGs to server in a predefined interval. It's possible to</span><br><span class="line"># change this interval with the repl_ping_replica_period option. The default</span><br><span class="line"># value is 10 seconds.</span><br><span class="line">#</span><br><span class="line"># repl-ping-replica-period 10</span><br><span class="line"></span><br><span class="line"># The following option sets the replication timeout for:</span><br><span class="line">#</span><br><span class="line"># 1) Bulk transfer I/O during SYNC, from the point of view of replica.</span><br><span class="line"># 2) Master timeout from the point of view of replicas (data, pings).</span><br><span class="line"># 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).</span><br><span class="line">#</span><br><span class="line"># It is important to make sure that this value is greater than the value</span><br><span class="line"># specified for repl-ping-replica-period otherwise a timeout will be detected</span><br><span class="line"># every time there is low traffic between the master and the replica.</span><br><span class="line">#</span><br><span class="line"># repl-timeout 60</span><br><span class="line"></span><br><span class="line"># Disable TCP_NODELAY on the replica socket after SYNC?</span><br><span class="line">#</span><br><span class="line"># If you select "yes" Redis will use a smaller number of TCP packets and</span><br><span class="line"># less bandwidth to send data to replicas. But this can add a delay for</span><br><span class="line"># the data to appear on the replica side, up to 40 milliseconds with</span><br><span class="line"># Linux kernels using a default configuration.</span><br><span class="line">#</span><br><span class="line"># If you select "no" the delay for data to appear on the replica side will</span><br><span class="line"># be reduced but more bandwidth will be used for replication.</span><br><span class="line">#</span><br><span class="line"># By default we optimize for low latency, but in very high traffic conditions</span><br><span class="line"># or when the master and replicas are many hops away, turning this to "yes" may</span><br><span class="line"># be a good idea.</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"># Set the replication backlog size. The backlog is a buffer that accumulates</span><br><span class="line"># replica data when replicas are disconnected for some time, so that when a</span><br><span class="line"># replica wants to reconnect again, often a full resync is not needed, but a</span><br><span class="line"># partial resync is enough, just passing the portion of data the replica</span><br><span class="line"># missed while disconnected.</span><br><span class="line">#</span><br><span class="line"># The bigger the replication backlog, the longer the time the replica can be</span><br><span class="line"># disconnected and later be able to perform a partial resynchronization.</span><br><span class="line">#</span><br><span class="line"># The backlog is only allocated once there is at least a replica connected.</span><br><span class="line">#</span><br><span class="line"># repl-backlog-size 1mb</span><br><span class="line"></span><br><span class="line"># After a master has no longer connected replicas for some time, the backlog</span><br><span class="line"># will be freed. The following option configures the amount of seconds that</span><br><span class="line"># need to elapse, starting from the time the last replica disconnected, for</span><br><span class="line"># the backlog buffer to be freed.</span><br><span class="line">#</span><br><span class="line"># Note that replicas never free the backlog for timeout, since they may be</span><br><span class="line"># promoted to masters later, and should be able to correctly "partially</span><br><span class="line"># resynchronize" with the replicas: hence they should always accumulate backlog.</span><br><span class="line">#</span><br><span class="line"># A value of 0 means to never release the backlog.</span><br><span class="line">#</span><br><span class="line"># repl-backlog-ttl 3600</span><br><span class="line"></span><br><span class="line"># The replica priority is an integer number published by Redis in the INFO</span><br><span class="line"># output. It is used by Redis Sentinel in order to select a replica to promote</span><br><span class="line"># into a master if the master is no longer working correctly.</span><br><span class="line">#</span><br><span class="line"># A replica with a low priority number is considered better for promotion, so</span><br><span class="line"># for instance if there are three replicas with priority 10, 100, 25 Sentinel</span><br><span class="line"># will pick the one with priority 10, that is the lowest.</span><br><span class="line">#</span><br><span class="line"># However a special priority of 0 marks the replica as not able to perform the</span><br><span class="line"># role of master, so a replica with priority of 0 will never be selected by</span><br><span class="line"># Redis Sentinel for promotion.</span><br><span class="line">#</span><br><span class="line"># By default the priority is 100.</span><br><span class="line">replica-priority <span class="number">100</span></span><br><span class="line"></span><br><span class="line"># It is possible for a master to stop accepting writes if there are less than</span><br><span class="line"># N replicas connected, having a lag less or equal than M seconds.</span><br><span class="line">#</span><br><span class="line"># The N replicas need to be in "online" state.</span><br><span class="line">#</span><br><span class="line"># The lag in seconds, that must be &lt;= the specified value, is calculated from</span><br><span class="line"># the last ping received from the replica, that is usually sent every second.</span><br><span class="line">#</span><br><span class="line"># This option does not GUARANTEE that N replicas will accept the write, but</span><br><span class="line"># will limit the window of exposure for lost writes in case not enough replicas</span><br><span class="line"># are available, to the specified number of seconds.</span><br><span class="line">#</span><br><span class="line"># For example to require at least 3 replicas with a lag &lt;= 10 seconds use:</span><br><span class="line">#</span><br><span class="line"># min-replicas-to-write 3</span><br><span class="line"># min-replicas-max-lag 10</span><br><span class="line">#</span><br><span class="line"># Setting one or the other to 0 disables the feature.</span><br><span class="line">#</span><br><span class="line"># By default min-replicas-to-write is set to 0 (feature disabled) and</span><br><span class="line"># min-replicas-max-lag is set to 10.</span><br><span class="line"></span><br><span class="line"># A Redis master is able to list the address and port of the attached</span><br><span class="line"># replicas in different ways. For example the "INFO replication" section</span><br><span class="line"># offers this information, which is used, among other tools, by</span><br><span class="line"># Redis Sentinel in order to discover replica instances.</span><br><span class="line"># Another place where this info is available is in the output of the</span><br><span class="line"># "ROLE" command of a master.</span><br><span class="line">#</span><br><span class="line"># The listed IP and address normally reported by a replica is obtained</span><br><span class="line"># in the following way:</span><br><span class="line">#</span><br><span class="line">#   IP: The address is auto detected by checking the peer address</span><br><span class="line">#   of the socket used by the replica to connect with the master.</span><br><span class="line">#</span><br><span class="line">#   Port: The port is communicated by the replica during the replication</span><br><span class="line">#   handshake, and is normally the port that the replica is using to</span><br><span class="line">#   listen for connections.</span><br><span class="line">#</span><br><span class="line"># However when port forwarding or Network Address Translation (NAT) is</span><br><span class="line"># used, the replica may be actually reachable via different IP and port</span><br><span class="line"># pairs. The following two options can be used by a replica in order to</span><br><span class="line"># report to its master a specific set of IP and port, so that both INFO</span><br><span class="line"># and ROLE will report those values.</span><br><span class="line">#</span><br><span class="line"># There is no need to use both the options if you need to override just</span><br><span class="line"># the port or the IP address.</span><br><span class="line">#</span><br><span class="line"># replica-announce-ip 5.5.5.5</span><br><span class="line"># replica-announce-port 1234</span><br><span class="line"></span><br><span class="line">############################### KEYS TRACKING #################################</span><br><span class="line"></span><br><span class="line"># Redis implements server assisted support for client side caching of values.</span><br><span class="line"># This is implemented using an invalidation table that remembers, using</span><br><span class="line"># 16 millions of slots, what clients may have certain subsets of keys. In turn</span><br><span class="line"># this is used in order to send invalidation messages to clients. Please</span><br><span class="line"># to understand more about the feature check this page:</span><br><span class="line">#</span><br><span class="line">#   https://redis.io/topics/client-side-caching</span><br><span class="line">#</span><br><span class="line"># When tracking is enabled for a client, all the read only queries are assumed</span><br><span class="line"># to be cached: this will force Redis to store information in the invalidation</span><br><span class="line"># table. When keys are modified, such information is flushed away, and</span><br><span class="line"># invalidation messages are sent to the clients. However if the workload is</span><br><span class="line"># heavily dominated by reads, Redis could use more and more memory in order</span><br><span class="line"># to track the keys fetched by many clients.</span><br><span class="line">#</span><br><span class="line"># For this reason it is possible to configure a maximum fill value for the</span><br><span class="line"># invalidation table. By default it is set to 1M of keys, and once this limit</span><br><span class="line"># is reached, Redis will start to evict keys in the invalidation table</span><br><span class="line"># even if they were not modified, just to reclaim memory: this will in turn</span><br><span class="line"># force the clients to invalidate the cached values. Basically the table</span><br><span class="line"># maximum size is a trade off between the memory you want to spend server</span><br><span class="line"># side to track information about who cached what, and the ability of clients</span><br><span class="line"># to retain cached objects in memory.</span><br><span class="line">#</span><br><span class="line"># If you set the value to 0, it means there are no limits, and Redis will</span><br><span class="line"># retain as many keys as needed in the invalidation table.</span><br><span class="line"># In the "stats" INFO section, you can find information about the number of</span><br><span class="line"># keys in the invalidation table at every given moment.</span><br><span class="line">#</span><br><span class="line"># Note: when key tracking is used in broadcasting mode, no memory is used</span><br><span class="line"># in the server side so this setting is useless.</span><br><span class="line">#</span><br><span class="line"># tracking-table-max-keys 1000000</span><br><span class="line"></span><br><span class="line">################################## SECURITY ###################################</span><br><span class="line"></span><br><span class="line"># Warning: since Redis is pretty fast an outside user can try up to</span><br><span class="line"># 1 million passwords per second against a modern box. This means that you</span><br><span class="line"># should use very strong passwords, otherwise they will be very easy to break.</span><br><span class="line"># Note that because the password is really a shared secret between the client</span><br><span class="line"># and the server, and should not be memorized by any human, the password</span><br><span class="line"># can be easily a long string from /dev/urandom or whatever, so by using a</span><br><span class="line"># long and unguessable password no brute force attack will be possible.</span><br><span class="line"></span><br><span class="line"># Redis ACL users are defined in the following format:</span><br><span class="line">#</span><br><span class="line">#   user &lt;username&gt; ... acl rules ...</span><br><span class="line">#</span><br><span class="line"># For example:</span><br><span class="line">#</span><br><span class="line">#   user worker +@list +@connection ~jobs:* on &gt;ffa9203c493aa99</span><br><span class="line">#</span><br><span class="line"># The special username "default" is used for new connections. If this user</span><br><span class="line"># has the "nopass" rule, then new connections will be immediately authenticated</span><br><span class="line"># as the "default" user without the need of any password provided via the</span><br><span class="line"># AUTH command. Otherwise if the "default" user is not flagged with "nopass"</span><br><span class="line"># the connections will start in not authenticated state, and will require</span><br><span class="line"># AUTH (or the HELLO command AUTH option) in order to be authenticated and</span><br><span class="line"># start to work.</span><br><span class="line">#</span><br><span class="line"># The ACL rules that describe what an user can do are the following:</span><br><span class="line">#</span><br><span class="line">#  on           Enable the user: it is possible to authenticate as this user.</span><br><span class="line">#  off          Disable the user: it's no longer possible to authenticate</span><br><span class="line">#               with this user, however the already authenticated connections</span><br><span class="line">#               will still work.</span><br><span class="line">#  +&lt;command&gt;   Allow the execution of that command</span><br><span class="line">#  -&lt;command&gt;   Disallow the execution of that command</span><br><span class="line">#  +@&lt;category&gt; Allow the execution of all the commands in such category</span><br><span class="line">#               with valid categories are like @admin, @set, @sortedset, ...</span><br><span class="line">#               and so forth, see the full list in the server.c file where</span><br><span class="line">#               the Redis command table is described and defined.</span><br><span class="line">#               The special category @all means all the commands, but currently</span><br><span class="line">#               present in the server, and that will be loaded in the future</span><br><span class="line">#               via modules.</span><br><span class="line">#  +&lt;command&gt;|subcommand    Allow a specific subcommand of an otherwise</span><br><span class="line">#                           disabled command. Note that this form is not</span><br><span class="line">#                           allowed as negative like -DEBUG|SEGFAULT, but</span><br><span class="line">#                           only additive starting with "+".</span><br><span class="line">#  allcommands  Alias for +@all. Note that it implies the ability to execute</span><br><span class="line">#               all the future commands loaded via the modules system.</span><br><span class="line">#  nocommands   Alias for -@all.</span><br><span class="line">#  ~&lt;pattern&gt;   Add a pattern of keys that can be mentioned as part of</span><br><span class="line">#               commands. For instance ~* allows all the keys. The pattern</span><br><span class="line">#               is a glob-style pattern like the one of KEYS.</span><br><span class="line">#               It is possible to specify multiple patterns.</span><br><span class="line">#  allkeys      Alias for ~*</span><br><span class="line">#  resetkeys    Flush the list of allowed keys patterns.</span><br><span class="line">#  &gt;&lt;password&gt;  Add this passowrd to the list of valid password for the user.</span><br><span class="line">#               For example &gt;mypass will add "mypass" to the list.</span><br><span class="line">#               This directive clears the "nopass" flag (see later).</span><br><span class="line">#  &lt;&lt;password&gt;  Remove this password from the list of valid passwords.</span><br><span class="line">#  nopass       All the set passwords of the user are removed, and the user</span><br><span class="line">#               is flagged as requiring no password: it means that every</span><br><span class="line">#               password will work against this user. If this directive is</span><br><span class="line">#               used for the default user, every new connection will be</span><br><span class="line">#               immediately authenticated with the default user without</span><br><span class="line">#               any explicit AUTH command required. Note that the "resetpass"</span><br><span class="line">#               directive will clear this condition.</span><br><span class="line">#  resetpass    Flush the list of allowed passwords. Moreover removes the</span><br><span class="line">#               "nopass" status. After "resetpass" the user has no associated</span><br><span class="line">#               passwords and there is no way to authenticate without adding</span><br><span class="line">#               some password (or setting it as "nopass" later).</span><br><span class="line">#  reset        Performs the following actions: resetpass, resetkeys, off,</span><br><span class="line">#               -@all. The user returns to the same state it has immediately</span><br><span class="line">#               after its creation.</span><br><span class="line">#</span><br><span class="line"># ACL rules can be specified in any order: for instance you can start with</span><br><span class="line"># passwords, then flags, or key patterns. However note that the additive</span><br><span class="line"># and subtractive rules will CHANGE MEANING depending on the ordering.</span><br><span class="line"># For instance see the following example:</span><br><span class="line">#</span><br><span class="line">#   user alice on +@all -DEBUG ~* &gt;somepassword</span><br><span class="line">#</span><br><span class="line"># This will allow "alice" to use all the commands with the exception of the</span><br><span class="line"># DEBUG command, since +@all added all the commands to the set of the commands</span><br><span class="line"># alice can use, and later DEBUG was removed. However if we invert the order</span><br><span class="line"># of two ACL rules the result will be different:</span><br><span class="line">#</span><br><span class="line">#   user alice on -DEBUG +@all ~* &gt;somepassword</span><br><span class="line">#</span><br><span class="line"># Now DEBUG was removed when alice had yet no commands in the set of allowed</span><br><span class="line"># commands, later all the commands are added, so the user will be able to</span><br><span class="line"># execute everything.</span><br><span class="line">#</span><br><span class="line"># Basically ACL rules are processed left-to-right.</span><br><span class="line">#</span><br><span class="line"># For more information about ACL configuration please refer to</span><br><span class="line"># the Redis web site at https://redis.io/topics/acl</span><br><span class="line"></span><br><span class="line"># ACL LOG</span><br><span class="line">#</span><br><span class="line"># The ACL Log tracks failed commands and authentication events associated</span><br><span class="line"># with ACLs. The ACL Log is useful to troubleshoot failed commands blocked </span><br><span class="line"># by ACLs. The ACL Log is stored in memory. You can reclaim memory with </span><br><span class="line"># ACL LOG RESET. Define the maximum entry length of the ACL Log below.</span><br><span class="line">acllog-max-len <span class="number">128</span></span><br><span class="line"></span><br><span class="line"># Using an external ACL file</span><br><span class="line">#</span><br><span class="line"># Instead of configuring users here in this file, it is possible to use</span><br><span class="line"># a stand-alone file just listing users. The two methods cannot be mixed:</span><br><span class="line"># if you configure users here and at the same time you activate the exteranl</span><br><span class="line"># ACL file, the server will refuse to start.</span><br><span class="line">#</span><br><span class="line"># The format of the external ACL user file is exactly the same as the</span><br><span class="line"># format that is used inside redis.conf to describe users.</span><br><span class="line">#</span><br><span class="line"># aclfile /etc/redis/users.acl</span><br><span class="line"></span><br><span class="line"># IMPORTANT NOTE: starting with Redis 6 "requirepass" is just a compatiblity</span><br><span class="line"># layer on top of the new ACL system. The option effect will be just setting</span><br><span class="line"># the password for the default user. Clients will still authenticate using</span><br><span class="line"># AUTH &lt;password&gt; as usually, or more explicitly with AUTH default &lt;password&gt;</span><br><span class="line"># if they follow the new protocol: both will work.</span><br><span class="line">#</span><br><span class="line"># requirepass foobared</span><br><span class="line"></span><br><span class="line"># Command renaming (DEPRECATED).</span><br><span class="line">#</span><br><span class="line"># ------------------------------------------------------------------------</span><br><span class="line"># WARNING: avoid using this option if possible. Instead use ACLs to remove</span><br><span class="line"># commands from the default user, and put them only in some admin user you</span><br><span class="line"># create for administrative purposes.</span><br><span class="line"># ------------------------------------------------------------------------</span><br><span class="line">#</span><br><span class="line"># It is possible to change the name of dangerous commands in a shared</span><br><span class="line"># environment. For instance the CONFIG command may be renamed into something</span><br><span class="line"># hard to guess so that it will still be available for internal-use tools</span><br><span class="line"># but not available for general clients.</span><br><span class="line">#</span><br><span class="line"># Example:</span><br><span class="line">#</span><br><span class="line"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="line">#</span><br><span class="line"># It is also possible to completely kill a command by renaming it into</span><br><span class="line"># an empty string:</span><br><span class="line">#</span><br><span class="line"># rename-command CONFIG ""</span><br><span class="line">#</span><br><span class="line"># Please note that changing the name of commands that are logged into the</span><br><span class="line"># AOF file or transmitted to replicas may cause problems.</span><br><span class="line"></span><br><span class="line">################################### CLIENTS ####################################</span><br><span class="line"></span><br><span class="line"># Set the max number of connected clients at the same time. By default</span><br><span class="line"># this limit is set to 10000 clients, however if the Redis server is not</span><br><span class="line"># able to configure the process file limit to allow for the specified limit</span><br><span class="line"># the max number of allowed clients is set to the current file limit</span><br><span class="line"># minus 32 (as Redis reserves a few file descriptors for internal uses).</span><br><span class="line">#</span><br><span class="line"># Once the limit is reached Redis will close all the new connections sending</span><br><span class="line"># an error 'max number of clients reached'.</span><br><span class="line">#</span><br><span class="line"># IMPORTANT: When Redis Cluster is used, the max number of connections is also</span><br><span class="line"># shared with the cluster bus: every node in the cluster will use two</span><br><span class="line"># connections, one incoming and another outgoing. It is important to size the</span><br><span class="line"># limit accordingly in case of very large clusters.</span><br><span class="line">#</span><br><span class="line"># maxclients 10000</span><br><span class="line"></span><br><span class="line">############################## MEMORY MANAGEMENT ################################</span><br><span class="line"></span><br><span class="line"># Set a memory usage limit to the specified amount of bytes.</span><br><span class="line"># When the memory limit is reached Redis will try to remove keys</span><br><span class="line"># according to the eviction policy selected (see maxmemory-policy).</span><br><span class="line">#</span><br><span class="line"># If Redis can't remove keys according to the policy, or if the policy is</span><br><span class="line"># set to 'noeviction', Redis will start to reply with errors to commands</span><br><span class="line"># that would use more memory, like SET, LPUSH, and so on, and will continue</span><br><span class="line"># to reply to read-only commands like GET.</span><br><span class="line">#</span><br><span class="line"># This option is usually useful when using Redis as an LRU or LFU cache, or to</span><br><span class="line"># set a hard memory limit for an instance (using the 'noeviction' policy).</span><br><span class="line">#</span><br><span class="line"># WARNING: If you have replicas attached to an instance with maxmemory on,</span><br><span class="line"># the size of the output buffers needed to feed the replicas are subtracted</span><br><span class="line"># from the used memory count, so that network problems / resyncs will</span><br><span class="line"># not trigger a loop where keys are evicted, and in turn the output</span><br><span class="line"># buffer of replicas is full with DELs of keys evicted triggering the deletion</span><br><span class="line"># of more keys, and so forth until the database is completely emptied.</span><br><span class="line">#</span><br><span class="line"># In short... if you have replicas attached it is suggested that you set a lower</span><br><span class="line"># limit for maxmemory so that there is some free RAM on the system for replica</span><br><span class="line"># output buffers (but this is not needed if the policy is 'noeviction').</span><br><span class="line">#</span><br><span class="line"># maxmemory &lt;bytes&gt;</span><br><span class="line"></span><br><span class="line"># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span><br><span class="line"># is reached. You can select one from the following behaviors:</span><br><span class="line">#</span><br><span class="line"># volatile-lru -&gt; Evict using approximated LRU, only keys with an expire set.</span><br><span class="line"># allkeys-lru -&gt; Evict any key using approximated LRU.</span><br><span class="line"># volatile-lfu -&gt; Evict using approximated LFU, only keys with an expire set.</span><br><span class="line"># allkeys-lfu -&gt; Evict any key using approximated LFU.</span><br><span class="line"># volatile-random -&gt; Remove a random key having an expire set.</span><br><span class="line"># allkeys-random -&gt; Remove a random key, any key.</span><br><span class="line"># volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</span><br><span class="line"># noeviction -&gt; Don't evict anything, just return an error on write operations.</span><br><span class="line">#</span><br><span class="line"># LRU means Least Recently Used</span><br><span class="line"># LFU means Least Frequently Used</span><br><span class="line">#</span><br><span class="line"># Both LRU, LFU and volatile-ttl are implemented using approximated</span><br><span class="line"># randomized algorithms.</span><br><span class="line">#</span><br><span class="line"># Note: with any of the above policies, Redis will return an error on write</span><br><span class="line">#       operations, when there are no suitable keys for eviction.</span><br><span class="line">#</span><br><span class="line">#       At the date of writing these commands are: set setnx setex append</span><br><span class="line">#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span><br><span class="line">#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span><br><span class="line">#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span><br><span class="line">#       getset mset msetnx exec sort</span><br><span class="line">#</span><br><span class="line"># The default is:</span><br><span class="line">#</span><br><span class="line"># maxmemory-policy noeviction</span><br><span class="line"></span><br><span class="line"># LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated</span><br><span class="line"># algorithms (in order to save memory), so you can tune it for speed or</span><br><span class="line"># accuracy. For default Redis will check five keys and pick the one that was</span><br><span class="line"># used less recently, you can change the sample size using the following</span><br><span class="line"># configuration directive.</span><br><span class="line">#</span><br><span class="line"># The default of 5 produces good enough results. 10 Approximates very closely</span><br><span class="line"># true LRU but costs more CPU. 3 is faster but not very accurate.</span><br><span class="line">#</span><br><span class="line"># maxmemory-samples 5</span><br><span class="line"></span><br><span class="line"># Starting from Redis 5, by default a replica will ignore its maxmemory setting</span><br><span class="line"># (unless it is promoted to master after a failover or manually). It means</span><br><span class="line"># that the eviction of keys will be just handled by the master, sending the</span><br><span class="line"># DEL commands to the replica as keys evict in the master side.</span><br><span class="line">#</span><br><span class="line"># This behavior ensures that masters and replicas stay consistent, and is usually</span><br><span class="line"># what you want, however if your replica is writable, or you want the replica</span><br><span class="line"># to have a different memory setting, and you are sure all the writes performed</span><br><span class="line"># to the replica are idempotent, then you may change this default (but be sure</span><br><span class="line"># to understand what you are doing).</span><br><span class="line">#</span><br><span class="line"># Note that since the replica by default does not evict, it may end using more</span><br><span class="line"># memory than the one set via maxmemory (there are certain buffers that may</span><br><span class="line"># be larger on the replica, or data structures may sometimes take more memory</span><br><span class="line"># and so forth). So make sure you monitor your replicas and make sure they</span><br><span class="line"># have enough memory to never hit a real out-of-memory condition before the</span><br><span class="line"># master hits the configured maxmemory setting.</span><br><span class="line">#</span><br><span class="line"># replica-ignore-maxmemory yes</span><br><span class="line"></span><br><span class="line"># Redis reclaims expired keys in two ways: upon access when those keys are</span><br><span class="line"># found to be expired, and also in background, in what is called the</span><br><span class="line"># "active expire key". The key space is slowly and interactively scanned</span><br><span class="line"># looking for expired keys to reclaim, so that it is possible to free memory</span><br><span class="line"># of keys that are expired and will never be accessed again in a short time.</span><br><span class="line">#</span><br><span class="line"># The default effort of the expire cycle will try to avoid having more than</span><br><span class="line"># ten percent of expired keys still in memory, and will try to avoid consuming</span><br><span class="line"># more than 25% of total memory and to add latency to the system. However</span><br><span class="line"># it is possible to increase the expire "effort" that is normally set to</span><br><span class="line"># "1", to a greater value, up to the value "10". At its maximum value the</span><br><span class="line"># system will use more CPU, longer cycles (and technically may introduce</span><br><span class="line"># more latency), and will tollerate less already expired keys still present</span><br><span class="line"># in the system. It's a tradeoff betweeen memory, CPU and latecy.</span><br><span class="line">#</span><br><span class="line"># active-expire-effort 1</span><br><span class="line"></span><br><span class="line">############################# LAZY FREEING ####################################</span><br><span class="line"></span><br><span class="line"># Redis has two primitives to delete keys. One is called DEL and is a blocking</span><br><span class="line"># deletion of the object. It means that the server stops processing new commands</span><br><span class="line"># in order to reclaim all the memory associated with an object in a synchronous</span><br><span class="line"># way. If the key deleted is associated with a small object, the time needed</span><br><span class="line"># in order to execute the DEL command is very small and comparable to most other</span><br><span class="line"># O(1) or O(log_N) commands in Redis. However if the key is associated with an</span><br><span class="line"># aggregated value containing millions of elements, the server can block for</span><br><span class="line"># a long time (even seconds) in order to complete the operation.</span><br><span class="line">#</span><br><span class="line"># For the above reasons Redis also offers non blocking deletion primitives</span><br><span class="line"># such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and</span><br><span class="line"># FLUSHDB commands, in order to reclaim memory in background. Those commands</span><br><span class="line"># are executed in constant time. Another thread will incrementally free the</span><br><span class="line"># object in the background as fast as possible.</span><br><span class="line">#</span><br><span class="line"># DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.</span><br><span class="line"># It's up to the design of the application to understand when it is a good</span><br><span class="line"># idea to use one or the other. However the Redis server sometimes has to</span><br><span class="line"># delete keys or flush the whole database as a side effect of other operations.</span><br><span class="line"># Specifically Redis deletes objects independently of a user call in the</span><br><span class="line"># following scenarios:</span><br><span class="line">#</span><br><span class="line"># 1) On eviction, because of the maxmemory and maxmemory policy configurations,</span><br><span class="line">#    in order to make room for new data, without going over the specified</span><br><span class="line">#    memory limit.</span><br><span class="line"># 2) Because of expire: when a key with an associated time to live (see the</span><br><span class="line">#    EXPIRE command) must be deleted from memory.</span><br><span class="line"># 3) Because of a side effect of a command that stores data on a key that may</span><br><span class="line">#    already exist. For example the RENAME command may delete the old key</span><br><span class="line">#    content when it is replaced with another one. Similarly SUNIONSTORE</span><br><span class="line">#    or SORT with STORE option may delete existing keys. The SET command</span><br><span class="line">#    itself removes any old content of the specified key in order to replace</span><br><span class="line">#    it with the specified string.</span><br><span class="line"># 4) During replication, when a replica performs a full resynchronization with</span><br><span class="line">#    its master, the content of the whole database is removed in order to</span><br><span class="line">#    load the RDB file just transferred.</span><br><span class="line">#</span><br><span class="line"># In all the above cases the default is to delete objects in a blocking way,</span><br><span class="line"># like if DEL was called. However you can configure each case specifically</span><br><span class="line"># in order to instead release memory in a non-blocking way like if UNLINK</span><br><span class="line"># was called, using the following configuration directives.</span><br><span class="line"></span><br><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">replica-lazy-flush no</span><br><span class="line"></span><br><span class="line"># It is also possible, for the case when to replace the user code DEL calls</span><br><span class="line"># with UNLINK calls is not easy, to modify the default behavior of the DEL</span><br><span class="line"># command to act exactly like UNLINK, using the following configuration</span><br><span class="line"># directive:</span><br><span class="line"></span><br><span class="line">lazyfree-lazy-user-del no</span><br><span class="line"></span><br><span class="line">################################ THREADED I/O #################################</span><br><span class="line"></span><br><span class="line"># Redis is mostly single threaded, however there are certain threaded</span><br><span class="line"># operations such as UNLINK, slow I/O accesses and other things that are</span><br><span class="line"># performed on side threads.</span><br><span class="line">#</span><br><span class="line"># Now it is also possible to handle Redis clients socket reads and writes</span><br><span class="line"># in different I/O threads. Since especially writing is so slow, normally</span><br><span class="line"># Redis users use pipelining in order to speedup the Redis performances per</span><br><span class="line"># core, and spawn multiple instances in order to scale more. Using I/O</span><br><span class="line"># threads it is possible to easily speedup two times Redis without resorting</span><br><span class="line"># to pipelining nor sharding of the instance.</span><br><span class="line">#</span><br><span class="line"># By default threading is disabled, we suggest enabling it only in machines</span><br><span class="line"># that have at least 4 or more cores, leaving at least one spare core.</span><br><span class="line"># Using more than 8 threads is unlikely to help much. We also recommend using</span><br><span class="line"># threaded I/O only if you actually have performance problems, with Redis</span><br><span class="line"># instances being able to use a quite big percentage of CPU time, otherwise</span><br><span class="line"># there is no point in using this feature.</span><br><span class="line">#</span><br><span class="line"># So for instance if you have a four cores boxes, try to use 2 or 3 I/O</span><br><span class="line"># threads, if you have a 8 cores, try to use 6 threads. In order to</span><br><span class="line"># enable I/O threads use the following configuration directive:</span><br><span class="line">#</span><br><span class="line"># io-threads 4</span><br><span class="line">#</span><br><span class="line"># Setting io-threads to 1 will just use the main thread as usually.</span><br><span class="line"># When I/O threads are enabled, we only use threads for writes, that is</span><br><span class="line"># to thread the write(2) syscall and transfer the client buffers to the</span><br><span class="line"># socket. However it is also possible to enable threading of reads and</span><br><span class="line"># protocol parsing using the following configuration directive, by setting</span><br><span class="line"># it to yes:</span><br><span class="line">#</span><br><span class="line"># io-threads-do-reads no</span><br><span class="line">#</span><br><span class="line"># Usually threading reads doesn't help much.</span><br><span class="line">#</span><br><span class="line"># NOTE 1: This configuration directive cannot be changed at runtime via</span><br><span class="line"># CONFIG SET. Aso this feature currently does not work when SSL is</span><br><span class="line"># enabled.</span><br><span class="line">#</span><br><span class="line"># NOTE 2: If you want to test the Redis speedup using redis-benchmark, make</span><br><span class="line"># sure you also run the benchmark itself in threaded mode, using the</span><br><span class="line"># --threads option to match the number of Redis theads, otherwise you'll not</span><br><span class="line"># be able to notice the improvements.</span><br><span class="line"></span><br><span class="line">############################ KERNEL OOM CONTROL ##############################</span><br><span class="line"></span><br><span class="line"># On Linux, it is possible to hint the kernel OOM killer on what processes</span><br><span class="line"># should be killed first when out of memory.</span><br><span class="line">#</span><br><span class="line"># Enabling this feature makes Redis actively control the oom_score_adj value</span><br><span class="line"># for all its processes, depending on their role. The default scores will</span><br><span class="line"># attempt to have background child processes killed before all others, and</span><br><span class="line"># replicas killed before masters.</span><br><span class="line"></span><br><span class="line">oom-score-adj no</span><br><span class="line"></span><br><span class="line"># When oom-score-adj is used, this directive controls the specific values used</span><br><span class="line"># for master, replica and background child processes. Values range -1000 to</span><br><span class="line"># 1000 (higher means more likely to be killed).</span><br><span class="line">#</span><br><span class="line"># Unprivileged processes (not root, and without CAP_SYS_RESOURCE capabilities)</span><br><span class="line"># can freely increase their value, but not decrease it below its initial</span><br><span class="line"># settings.</span><br><span class="line">#</span><br><span class="line"># Values are used relative to the initial value of oom_score_adj when the server</span><br><span class="line"># starts. Because typically the initial value is 0, they will often match the</span><br><span class="line"># absolute values.</span><br><span class="line"></span><br><span class="line">oom-score-adj-values <span class="number">0</span> <span class="number">200</span> <span class="number">800</span></span><br><span class="line"></span><br><span class="line">############################## APPEND ONLY MODE ###############################</span><br><span class="line"></span><br><span class="line"># By default Redis asynchronously dumps the dataset on disk. This mode is</span><br><span class="line"># good enough in many applications, but an issue with the Redis process or</span><br><span class="line"># a power outage may result into a few minutes of writes lost (depending on</span><br><span class="line"># the configured save points).</span><br><span class="line">#</span><br><span class="line"># The Append Only File is an alternative persistence mode that provides</span><br><span class="line"># much better durability. For instance using the default data fsync policy</span><br><span class="line"># (see later in the config file) Redis can lose just one second of writes in a</span><br><span class="line"># dramatic event like a server power outage, or a single write if something</span><br><span class="line"># wrong with the Redis process itself happens, but the operating system is</span><br><span class="line"># still running correctly.</span><br><span class="line">#</span><br><span class="line"># AOF and RDB persistence can be enabled at the same time without problems.</span><br><span class="line"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span><br><span class="line"># with the better durability guarantees.</span><br><span class="line">#</span><br><span class="line"># Please check http://redis.io/topics/persistence for more information.</span><br><span class="line"></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># The name of the append only file (default: "appendonly.aof")</span><br><span class="line"></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br><span class="line"></span><br><span class="line"># The fsync() call tells the Operating System to actually write data on disk</span><br><span class="line"># instead of waiting for more data in the output buffer. Some OS will really flush</span><br><span class="line"># data on disk, some other OS will just try to do it ASAP.</span><br><span class="line">#</span><br><span class="line"># Redis supports three different modes:</span><br><span class="line">#</span><br><span class="line"># no: don't fsync, just let the OS flush the data when it wants. Faster.</span><br><span class="line"># always: fsync after every write to the append only log. Slow, Safest.</span><br><span class="line"># everysec: fsync only one time every second. Compromise.</span><br><span class="line">#</span><br><span class="line"># The default is "everysec", as that's usually the right compromise between</span><br><span class="line"># speed and data safety. It's up to you to understand if you can relax this to</span><br><span class="line"># "no" that will let the operating system flush the output buffer when</span><br><span class="line"># it wants, for better performances (but if you can live with the idea of</span><br><span class="line"># some data loss consider the default persistence mode that's snapshotting),</span><br><span class="line"># or on the contrary, use "always" that's very slow but a bit safer than</span><br><span class="line"># everysec.</span><br><span class="line">#</span><br><span class="line"># More details please check the following article:</span><br><span class="line"># http://antirez.com/post/redis-persistence-demystified.html</span><br><span class="line">#</span><br><span class="line"># If unsure, use "everysec".</span><br><span class="line"></span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"></span><br><span class="line"># When the AOF fsync policy is set to always or everysec, and a background</span><br><span class="line"># saving process (a background save or AOF log background rewriting) is</span><br><span class="line"># performing a lot of I/O against the disk, in some Linux configurations</span><br><span class="line"># Redis may block too long on the fsync() call. Note that there is no fix for</span><br><span class="line"># this currently, as even performing fsync in a different thread will block</span><br><span class="line"># our synchronous write(2) call.</span><br><span class="line">#</span><br><span class="line"># In order to mitigate this problem it's possible to use the following option</span><br><span class="line"># that will prevent fsync() from being called in the main process while a</span><br><span class="line"># BGSAVE or BGREWRITEAOF is in progress.</span><br><span class="line">#</span><br><span class="line"># This means that while another child is saving, the durability of Redis is</span><br><span class="line"># the same as "appendfsync none". In practical terms, this means that it is</span><br><span class="line"># possible to lose up to 30 seconds of log in the worst scenario (with the</span><br><span class="line"># default Linux settings).</span><br><span class="line">#</span><br><span class="line"># If you have latency problems turn this to "yes". Otherwise leave it as</span><br><span class="line"># "no" that is the safest pick from the point of view of durability.</span><br><span class="line"></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># Automatic rewrite of the append only file.</span><br><span class="line"># Redis is able to automatically rewrite the log file implicitly calling</span><br><span class="line"># BGREWRITEAOF when the AOF log size grows by the specified percentage.</span><br><span class="line">#</span><br><span class="line"># This is how it works: Redis remembers the size of the AOF file after the</span><br><span class="line"># latest rewrite (if no rewrite has happened since the restart, the size of</span><br><span class="line"># the AOF at startup is used).</span><br><span class="line">#</span><br><span class="line"># This base size is compared to the current size. If the current size is</span><br><span class="line"># bigger than the specified percentage, the rewrite is triggered. Also</span><br><span class="line"># you need to specify a minimal size for the AOF file to be rewritten, this</span><br><span class="line"># is useful to avoid rewriting the AOF file even if the percentage increase</span><br><span class="line"># is reached but it is still pretty small.</span><br><span class="line">#</span><br><span class="line"># Specify a percentage of zero in order to disable the automatic AOF</span><br><span class="line"># rewrite feature.</span><br><span class="line"></span><br><span class="line">auto-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line">auto-aof-rewrite-min-size <span class="number">64</span>mb</span><br><span class="line"></span><br><span class="line"># An AOF file may be found to be truncated at the end during the Redis</span><br><span class="line"># startup process, when the AOF data gets loaded back into memory.</span><br><span class="line"># This may happen when the system where Redis is running</span><br><span class="line"># crashes, especially when an ext4 filesystem is mounted without the</span><br><span class="line"># data=ordered option (however this can't happen when Redis itself</span><br><span class="line"># crashes or aborts but the operating system still works correctly).</span><br><span class="line">#</span><br><span class="line"># Redis can either exit with an error when this happens, or load as much</span><br><span class="line"># data as possible (the default now) and start if the AOF file is found</span><br><span class="line"># to be truncated at the end. The following option controls this behavior.</span><br><span class="line">#</span><br><span class="line"># If aof-load-truncated is set to yes, a truncated AOF file is loaded and</span><br><span class="line"># the Redis server starts emitting a log to inform the user of the event.</span><br><span class="line"># Otherwise if the option is set to no, the server aborts with an error</span><br><span class="line"># and refuses to start. When the option is set to no, the user requires</span><br><span class="line"># to fix the AOF file using the "redis-check-aof" utility before to restart</span><br><span class="line"># the server.</span><br><span class="line">#</span><br><span class="line"># Note that if the AOF file will be found to be corrupted in the middle</span><br><span class="line"># the server will still exit with an error. This option only applies when</span><br><span class="line"># Redis will try to read more data from the AOF file but not enough bytes</span><br><span class="line"># will be found.</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"># When rewriting the AOF file, Redis is able to use an RDB preamble in the</span><br><span class="line"># AOF file for faster rewrites and recoveries. When this option is turned</span><br><span class="line"># on the rewritten AOF file is composed of two different stanzas:</span><br><span class="line">#</span><br><span class="line">#   [RDB file][AOF tail]</span><br><span class="line">#</span><br><span class="line"># When loading Redis recognizes that the AOF file starts with the "REDIS"</span><br><span class="line"># string and loads the prefixed RDB file, and continues loading the AOF</span><br><span class="line"># tail.</span><br><span class="line">aof-use-rdb-preamble yes</span><br><span class="line"></span><br><span class="line">################################ LUA SCRIPTING  ###############################</span><br><span class="line"></span><br><span class="line"># Max execution time of a Lua script in milliseconds.</span><br><span class="line">#</span><br><span class="line"># If the maximum execution time is reached Redis will log that a script is</span><br><span class="line"># still in execution after the maximum allowed time and will start to</span><br><span class="line"># reply to queries with an error.</span><br><span class="line">#</span><br><span class="line"># When a long running script exceeds the maximum execution time only the</span><br><span class="line"># SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be</span><br><span class="line"># used to stop a script that did not yet called write commands. The second</span><br><span class="line"># is the only way to shut down the server in the case a write command was</span><br><span class="line"># already issued by the script but the user doesn't want to wait for the natural</span><br><span class="line"># termination of the script.</span><br><span class="line">#</span><br><span class="line"># Set it to 0 or a negative value for unlimited execution without warnings.</span><br><span class="line">lua-time-limit <span class="number">5000</span></span><br><span class="line"></span><br><span class="line">################################ REDIS CLUSTER  ###############################</span><br><span class="line"></span><br><span class="line"># Normal Redis instances can't be part of a Redis Cluster; only nodes that are</span><br><span class="line"># started as cluster nodes can. In order to start a Redis instance as a</span><br><span class="line"># cluster node enable the cluster support uncommenting the following:</span><br><span class="line">#</span><br><span class="line"># cluster-enabled yes</span><br><span class="line"></span><br><span class="line"># Every cluster node has a cluster configuration file. This file is not</span><br><span class="line"># intended to be edited by hand. It is created and updated by Redis nodes.</span><br><span class="line"># Every Redis Cluster node requires a different cluster configuration file.</span><br><span class="line"># Make sure that instances running in the same system do not have</span><br><span class="line"># overlapping cluster configuration file names.</span><br><span class="line">#</span><br><span class="line"># cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"># Cluster node timeout is the amount of milliseconds a node must be unreachable</span><br><span class="line"># for it to be considered in failure state.</span><br><span class="line"># Most other internal time limits are multiple of the node timeout.</span><br><span class="line">#</span><br><span class="line"># cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line"># A replica of a failing master will avoid to start a failover if its data</span><br><span class="line"># looks too old.</span><br><span class="line">#</span><br><span class="line"># There is no simple way for a replica to actually have an exact measure of</span><br><span class="line"># its "data age", so the following two checks are performed:</span><br><span class="line">#</span><br><span class="line"># 1) If there are multiple replicas able to failover, they exchange messages</span><br><span class="line">#    in order to try to give an advantage to the replica with the best</span><br><span class="line">#    replication offset (more data from the master processed).</span><br><span class="line">#    Replicas will try to get their rank by offset, and apply to the start</span><br><span class="line">#    of the failover a delay proportional to their rank.</span><br><span class="line">#</span><br><span class="line"># 2) Every single replica computes the time of the last interaction with</span><br><span class="line">#    its master. This can be the last ping or command received (if the master</span><br><span class="line">#    is still in the "connected" state), or the time that elapsed since the</span><br><span class="line">#    disconnection with the master (if the replication link is currently down).</span><br><span class="line">#    If the last interaction is too old, the replica will not try to failover</span><br><span class="line">#    at all.</span><br><span class="line">#</span><br><span class="line"># The point "2" can be tuned by user. Specifically a replica will not perform</span><br><span class="line"># the failover if, since the last interaction with the master, the time</span><br><span class="line"># elapsed is greater than:</span><br><span class="line">#</span><br><span class="line">#   (node-timeout * replica-validity-factor) + repl-ping-replica-period</span><br><span class="line">#</span><br><span class="line"># So for example if node-timeout is 30 seconds, and the replica-validity-factor</span><br><span class="line"># is 10, and assuming a default repl-ping-replica-period of 10 seconds, the</span><br><span class="line"># replica will not try to failover if it was not able to talk with the master</span><br><span class="line"># for longer than 310 seconds.</span><br><span class="line">#</span><br><span class="line"># A large replica-validity-factor may allow replicas with too old data to failover</span><br><span class="line"># a master, while a too small value may prevent the cluster from being able to</span><br><span class="line"># elect a replica at all.</span><br><span class="line">#</span><br><span class="line"># For maximum availability, it is possible to set the replica-validity-factor</span><br><span class="line"># to a value of 0, which means, that replicas will always try to failover the</span><br><span class="line"># master regardless of the last time they interacted with the master.</span><br><span class="line"># (However they'll always try to apply a delay proportional to their</span><br><span class="line"># offset rank).</span><br><span class="line">#</span><br><span class="line"># Zero is the only value able to guarantee that when all the partitions heal</span><br><span class="line"># the cluster will always be able to continue.</span><br><span class="line">#</span><br><span class="line"># cluster-replica-validity-factor 10</span><br><span class="line"></span><br><span class="line"># Cluster replicas are able to migrate to orphaned masters, that are masters</span><br><span class="line"># that are left without working replicas. This improves the cluster ability</span><br><span class="line"># to resist to failures as otherwise an orphaned master can't be failed over</span><br><span class="line"># in case of failure if it has no working replicas.</span><br><span class="line">#</span><br><span class="line"># Replicas migrate to orphaned masters only if there are still at least a</span><br><span class="line"># given number of other working replicas for their old master. This number</span><br><span class="line"># is the "migration barrier". A migration barrier of 1 means that a replica</span><br><span class="line"># will migrate only if there is at least 1 other working replica for its master</span><br><span class="line"># and so forth. It usually reflects the number of replicas you want for every</span><br><span class="line"># master in your cluster.</span><br><span class="line">#</span><br><span class="line"># Default is 1 (replicas migrate only if their masters remain with at least</span><br><span class="line"># one replica). To disable migration just set it to a very large value.</span><br><span class="line"># A value of 0 can be set but is useful only for debugging and dangerous</span><br><span class="line"># in production.</span><br><span class="line">#</span><br><span class="line"># cluster-migration-barrier 1</span><br><span class="line"></span><br><span class="line"># By default Redis Cluster nodes stop accepting queries if they detect there</span><br><span class="line"># is at least an hash slot uncovered (no available node is serving it).</span><br><span class="line"># This way if the cluster is partially down (for example a range of hash slots</span><br><span class="line"># are no longer covered) all the cluster becomes, eventually, unavailable.</span><br><span class="line"># It automatically returns available as soon as all the slots are covered again.</span><br><span class="line">#</span><br><span class="line"># However sometimes you want the subset of the cluster which is working,</span><br><span class="line"># to continue to accept queries for the part of the key space that is still</span><br><span class="line"># covered. In order to do so, just set the cluster-require-full-coverage</span><br><span class="line"># option to no.</span><br><span class="line">#</span><br><span class="line"># cluster-require-full-coverage yes</span><br><span class="line"></span><br><span class="line"># This option, when set to yes, prevents replicas from trying to failover its</span><br><span class="line"># master during master failures. However the master can still perform a</span><br><span class="line"># manual failover, if forced to do so.</span><br><span class="line">#</span><br><span class="line"># This is useful in different scenarios, especially in the case of multiple</span><br><span class="line"># data center operations, where we want one side to never be promoted if not</span><br><span class="line"># in the case of a total DC failure.</span><br><span class="line">#</span><br><span class="line"># cluster-replica-no-failover no</span><br><span class="line"></span><br><span class="line"># This option, when set to yes, allows nodes to serve read traffic while the</span><br><span class="line"># the cluster is in a down state, as long as it believes it owns the slots. </span><br><span class="line">#</span><br><span class="line"># This is useful for two cases.  The first case is for when an application </span><br><span class="line"># doesn't require consistency of data during node failures or network partitions.</span><br><span class="line"># One example of this is a cache, where as long as the node has the data it</span><br><span class="line"># should be able to serve it. </span><br><span class="line">#</span><br><span class="line"># The second use case is for configurations that don't meet the recommended  </span><br><span class="line"># three shards but want to enable cluster mode and scale later. A </span><br><span class="line"># master outage in a 1 or 2 shard configuration causes a read/write outage to the</span><br><span class="line"># entire cluster without this option set, with it set there is only a write outage.</span><br><span class="line"># Without a quorum of masters, slot ownership will not change automatically. </span><br><span class="line">#</span><br><span class="line"># cluster-allow-reads-when-down no</span><br><span class="line"></span><br><span class="line"># In order to setup your cluster make sure to read the documentation</span><br><span class="line"># available at http://redis.io web site.</span><br><span class="line"></span><br><span class="line">########################## CLUSTER DOCKER/NAT support  ########################</span><br><span class="line"></span><br><span class="line"># In certain deployments, Redis Cluster nodes address discovery fails, because</span><br><span class="line"># addresses are NAT-ted or because ports are forwarded (the typical case is</span><br><span class="line"># Docker and other containers).</span><br><span class="line">#</span><br><span class="line"># In order to make Redis Cluster working in such environments, a static</span><br><span class="line"># configuration where each node knows its public address is needed. The</span><br><span class="line"># following two options are used for this scope, and are:</span><br><span class="line">#</span><br><span class="line"># * cluster-announce-ip</span><br><span class="line"># * cluster-announce-port</span><br><span class="line"># * cluster-announce-bus-port</span><br><span class="line">#</span><br><span class="line"># Each instruct the node about its address, client port, and cluster message</span><br><span class="line"># bus port. The information is then published in the header of the bus packets</span><br><span class="line"># so that other nodes will be able to correctly map the address of the node</span><br><span class="line"># publishing the information.</span><br><span class="line">#</span><br><span class="line"># If the above options are not used, the normal Redis Cluster auto-detection</span><br><span class="line"># will be used instead.</span><br><span class="line">#</span><br><span class="line"># Note that when remapped, the bus port may not be at the fixed offset of</span><br><span class="line"># clients port + 10000, so you can specify any port and bus-port depending</span><br><span class="line"># on how they get remapped. If the bus-port is not set, a fixed offset of</span><br><span class="line"># 10000 will be used as usually.</span><br><span class="line">#</span><br><span class="line"># Example:</span><br><span class="line">#</span><br><span class="line"># cluster-announce-ip 10.1.1.5</span><br><span class="line"># cluster-announce-port 6379</span><br><span class="line"># cluster-announce-bus-port 6380</span><br><span class="line"></span><br><span class="line">################################## SLOW LOG ###################################</span><br><span class="line"></span><br><span class="line"># The Redis Slow Log is a system to log queries that exceeded a specified</span><br><span class="line"># execution time. The execution time does not include the I/O operations</span><br><span class="line"># like talking with the client, sending the reply and so forth,</span><br><span class="line"># but just the time needed to actually execute the command (this is the only</span><br><span class="line"># stage of command execution where the thread is blocked and can not serve</span><br><span class="line"># other requests in the meantime).</span><br><span class="line">#</span><br><span class="line"># You can configure the slow log with two parameters: one tells Redis</span><br><span class="line"># what is the execution time, in microseconds, to exceed in order for the</span><br><span class="line"># command to get logged, and the other parameter is the length of the</span><br><span class="line"># slow log. When a new command is logged the oldest one is removed from the</span><br><span class="line"># queue of logged commands.</span><br><span class="line"></span><br><span class="line"># The following time is expressed in microseconds, so 1000000 is equivalent</span><br><span class="line"># to one second. Note that a negative number disables the slow log, while</span><br><span class="line"># a value of zero forces the logging of every command.</span><br><span class="line">slowlog-log-slower-than <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"># There is no limit to this length. Just be aware that it will consume memory.</span><br><span class="line"># You can reclaim memory used by the slow log with SLOWLOG RESET.</span><br><span class="line">slowlog-max-len <span class="number">128</span></span><br><span class="line"></span><br><span class="line">################################ LATENCY MONITOR ##############################</span><br><span class="line"></span><br><span class="line"># The Redis latency monitoring subsystem samples different operations</span><br><span class="line"># at runtime in order to collect data related to possible sources of</span><br><span class="line"># latency of a Redis instance.</span><br><span class="line">#</span><br><span class="line"># Via the LATENCY command this information is available to the user that can</span><br><span class="line"># print graphs and obtain reports.</span><br><span class="line">#</span><br><span class="line"># The system only logs operations that were performed in a time equal or</span><br><span class="line"># greater than the amount of milliseconds specified via the</span><br><span class="line"># latency-monitor-threshold configuration directive. When its value is set</span><br><span class="line"># to zero, the latency monitor is turned off.</span><br><span class="line">#</span><br><span class="line"># By default latency monitoring is disabled since it is mostly not needed</span><br><span class="line"># if you don't have latency issues, and collecting data has a performance</span><br><span class="line"># impact, that while very small, can be measured under big load. Latency</span><br><span class="line"># monitoring can easily be enabled at runtime using the command</span><br><span class="line"># "CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;" if needed.</span><br><span class="line">latency-monitor-threshold <span class="number">0</span></span><br><span class="line"></span><br><span class="line">############################# EVENT NOTIFICATION ##############################</span><br><span class="line"></span><br><span class="line"># Redis can notify Pub/Sub clients about events happening in the key space.</span><br><span class="line"># This feature is documented at http://redis.io/topics/notifications</span><br><span class="line">#</span><br><span class="line"># For instance if keyspace events notification is enabled, and a client</span><br><span class="line"># performs a DEL operation on key "foo" stored in the Database 0, two</span><br><span class="line"># messages will be published via Pub/Sub:</span><br><span class="line">#</span><br><span class="line"># PUBLISH __keyspace@0__:foo del</span><br><span class="line"># PUBLISH __keyevent@0__:del foo</span><br><span class="line">#</span><br><span class="line"># It is possible to select the events that Redis will notify among a set</span><br><span class="line"># of classes. Every class is identified by a single character:</span><br><span class="line">#</span><br><span class="line">#  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.</span><br><span class="line">#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.</span><br><span class="line">#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</span><br><span class="line">#  $     String commands</span><br><span class="line">#  l     List commands</span><br><span class="line">#  s     Set commands</span><br><span class="line">#  h     Hash commands</span><br><span class="line">#  z     Sorted set commands</span><br><span class="line">#  x     Expired events (events generated every time a key expires)</span><br><span class="line">#  e     Evicted events (events generated when a key is evicted for maxmemory)</span><br><span class="line">#  t     Stream commands</span><br><span class="line">#  m     Key-miss events (Note: It is not included in the 'A' class)</span><br><span class="line">#  A     Alias for g$lshzxet, so that the "AKE" string means all the events</span><br><span class="line">#        (Except key-miss events which are excluded from 'A' due to their</span><br><span class="line">#         unique nature).</span><br><span class="line">#</span><br><span class="line">#  The "notify-keyspace-events" takes as argument a string that is composed</span><br><span class="line">#  of zero or multiple characters. The empty string means that notifications</span><br><span class="line">#  are disabled.</span><br><span class="line">#</span><br><span class="line">#  Example: to enable list and generic events, from the point of view of the</span><br><span class="line">#           event name, use:</span><br><span class="line">#</span><br><span class="line">#  notify-keyspace-events Elg</span><br><span class="line">#</span><br><span class="line">#  Example 2: to get the stream of the expired keys subscribing to channel</span><br><span class="line">#             name __keyevent@0__:expired use:</span><br><span class="line">#</span><br><span class="line">#  notify-keyspace-events Ex</span><br><span class="line">#</span><br><span class="line">#  By default all notifications are disabled because most users don't need</span><br><span class="line">#  this feature and the feature has some overhead. Note that if you don't</span><br><span class="line">#  specify at least one of K or E, no events will be delivered.</span><br><span class="line">notify-keyspace-events <span class="string">""</span></span><br><span class="line"></span><br><span class="line">############################### GOPHER SERVER #################################</span><br><span class="line"></span><br><span class="line"># Redis contains an implementation of the Gopher protocol, as specified in</span><br><span class="line"># the RFC 1436 (https://www.ietf.org/rfc/rfc1436.txt).</span><br><span class="line">#</span><br><span class="line"># The Gopher protocol was very popular in the late '90s. It is an alternative</span><br><span class="line"># to the web, and the implementation both server and client side is so simple</span><br><span class="line"># that the Redis server has just 100 lines of code in order to implement this</span><br><span class="line"># support.</span><br><span class="line">#</span><br><span class="line"># What do you do with Gopher nowadays? Well Gopher never *really* died, and</span><br><span class="line"># lately there is a movement in order for the Gopher more hierarchical content</span><br><span class="line"># composed of just plain text documents to be resurrected. Some want a simpler</span><br><span class="line"># internet, others believe that the mainstream internet became too much</span><br><span class="line"># controlled, and it's cool to create an alternative space for people that</span><br><span class="line"># want a bit of fresh air.</span><br><span class="line">#</span><br><span class="line"># Anyway for the 10nth birthday of the Redis, we gave it the Gopher protocol</span><br><span class="line"># as a gift.</span><br><span class="line">#</span><br><span class="line"># --- HOW IT WORKS? ---</span><br><span class="line">#</span><br><span class="line"># The Redis Gopher support uses the inline protocol of Redis, and specifically</span><br><span class="line"># two kind of inline requests that were anyway illegal: an empty request</span><br><span class="line"># or any request that starts with "/" (there are no Redis commands starting</span><br><span class="line"># with such a slash). Normal RESP2/RESP3 requests are completely out of the</span><br><span class="line"># path of the Gopher protocol implementation and are served as usually as well.</span><br><span class="line">#</span><br><span class="line"># If you open a connection to Redis when Gopher is enabled and send it</span><br><span class="line"># a string like "/foo", if there is a key named "/foo" it is served via the</span><br><span class="line"># Gopher protocol.</span><br><span class="line">#</span><br><span class="line"># In order to create a real Gopher "hole" (the name of a Gopher site in Gopher</span><br><span class="line"># talking), you likely need a script like the following:</span><br><span class="line">#</span><br><span class="line">#   https://github.com/antirez/gopher2redis</span><br><span class="line">#</span><br><span class="line"># --- SECURITY WARNING ---</span><br><span class="line">#</span><br><span class="line"># If you plan to put Redis on the internet in a publicly accessible address</span><br><span class="line"># to server Gopher pages MAKE SURE TO SET A PASSWORD to the instance.</span><br><span class="line"># Once a password is set:</span><br><span class="line">#</span><br><span class="line">#   1. The Gopher server (when enabled, not by default) will still serve</span><br><span class="line">#      content via Gopher.</span><br><span class="line">#   2. However other commands cannot be called before the client will</span><br><span class="line">#      authenticate.</span><br><span class="line">#</span><br><span class="line"># So use the 'requirepass' option to protect your instance.</span><br><span class="line">#</span><br><span class="line"># To enable Gopher support uncomment the following line and set</span><br><span class="line"># the option from no (the default) to yes.</span><br><span class="line">#</span><br><span class="line"># gopher-enabled no</span><br><span class="line"></span><br><span class="line">############################### ADVANCED CONFIG ###############################</span><br><span class="line"></span><br><span class="line"># Hashes are encoded using a memory efficient data structure when they have a</span><br><span class="line"># small number of entries, and the biggest entry does not exceed a given</span><br><span class="line"># threshold. These thresholds can be configured using the following directives.</span><br><span class="line">hash-max-ziplist-entries <span class="number">512</span></span><br><span class="line">hash-max-ziplist-value <span class="number">64</span></span><br><span class="line"></span><br><span class="line"># Lists are also encoded in a special way to save a lot of space.</span><br><span class="line"># The number of entries allowed per internal list node can be specified</span><br><span class="line"># as a fixed maximum size or a maximum number of elements.</span><br><span class="line"># For a fixed maximum size, use -5 through -1, meaning:</span><br><span class="line"># -5: max size: 64 Kb  &lt;-- not recommended for normal workloads</span><br><span class="line"># -4: max size: 32 Kb  &lt;-- not recommended</span><br><span class="line"># -3: max size: 16 Kb  &lt;-- probably not recommended</span><br><span class="line"># -2: max size: 8 Kb   &lt;-- good</span><br><span class="line"># -1: max size: 4 Kb   &lt;-- good</span><br><span class="line"># Positive numbers mean store up to _exactly_ that number of elements</span><br><span class="line"># per list node.</span><br><span class="line"># The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),</span><br><span class="line"># but if your use case is unique, adjust the settings as necessary.</span><br><span class="line">list-max-ziplist-size -<span class="number">2</span></span><br><span class="line"></span><br><span class="line"># Lists may also be compressed.</span><br><span class="line"># Compress depth is the number of quicklist ziplist nodes from *each* side of</span><br><span class="line"># the list to *exclude* from compression.  The head and tail of the list</span><br><span class="line"># are always uncompressed for fast push/pop operations.  Settings are:</span><br><span class="line"># 0: disable all list compression</span><br><span class="line"># 1: depth 1 means "don't start compressing until after 1 node into the list,</span><br><span class="line">#    going from either the head or tail"</span><br><span class="line">#    So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]</span><br><span class="line">#    [head], [tail] will always be uncompressed; inner nodes will compress.</span><br><span class="line"># 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]</span><br><span class="line">#    2 here means: don't compress head or head-&gt;next or tail-&gt;prev or tail,</span><br><span class="line">#    but compress all nodes between them.</span><br><span class="line"># 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]</span><br><span class="line"># etc.</span><br><span class="line">list-compress-depth <span class="number">0</span></span><br><span class="line"></span><br><span class="line"># Sets have a special encoding in just one case: when a set is composed</span><br><span class="line"># of just strings that happen to be integers in radix 10 in the range</span><br><span class="line"># of 64 bit signed integers.</span><br><span class="line"># The following configuration setting sets the limit in the size of the</span><br><span class="line"># set in order to use this special memory saving encoding.</span><br><span class="line">set-max-intset-entries <span class="number">512</span></span><br><span class="line"></span><br><span class="line"># Similarly to hashes and lists, sorted sets are also specially encoded in</span><br><span class="line"># order to save a lot of space. This encoding is only used when the length and</span><br><span class="line"># elements of a sorted set are below the following limits:</span><br><span class="line">zset-max-ziplist-entries <span class="number">128</span></span><br><span class="line">zset-max-ziplist-value <span class="number">64</span></span><br><span class="line"></span><br><span class="line"># HyperLogLog sparse representation bytes limit. The limit includes the</span><br><span class="line"># 16 bytes header. When an HyperLogLog using the sparse representation crosses</span><br><span class="line"># this limit, it is converted into the dense representation.</span><br><span class="line">#</span><br><span class="line"># A value greater than 16000 is totally useless, since at that point the</span><br><span class="line"># dense representation is more memory efficient.</span><br><span class="line">#</span><br><span class="line"># The suggested value is ~ 3000 in order to have the benefits of</span><br><span class="line"># the space efficient encoding without slowing down too much PFADD,</span><br><span class="line"># which is O(N) with the sparse encoding. The value can be raised to</span><br><span class="line"># ~ 10000 when CPU is not a concern, but space is, and the data set is</span><br><span class="line"># composed of many HyperLogLogs with cardinality in the 0 - 15000 range.</span><br><span class="line">hll-sparse-max-bytes <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"># Streams macro node max size / items. The stream data structure is a radix</span><br><span class="line"># tree of big nodes that encode multiple items inside. Using this configuration</span><br><span class="line"># it is possible to configure how big a single node can be in bytes, and the</span><br><span class="line"># maximum number of items it may contain before switching to a new node when</span><br><span class="line"># appending new stream entries. If any of the following settings are set to</span><br><span class="line"># zero, the limit is ignored, so for instance it is possible to set just a</span><br><span class="line"># max entires limit by setting max-bytes to 0 and max-entries to the desired</span><br><span class="line"># value.</span><br><span class="line">stream-node-max-bytes <span class="number">4096</span></span><br><span class="line">stream-node-max-entries <span class="number">100</span></span><br><span class="line"></span><br><span class="line"># Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in</span><br><span class="line"># order to help rehashing the main Redis hash table (the one mapping top-level</span><br><span class="line"># keys to values). The hash table implementation Redis uses (see dict.c)</span><br><span class="line"># performs a lazy rehashing: the more operation you run into a hash table</span><br><span class="line"># that is rehashing, the more rehashing "steps" are performed, so if the</span><br><span class="line"># server is idle the rehashing is never complete and some more memory is used</span><br><span class="line"># by the hash table.</span><br><span class="line">#</span><br><span class="line"># The default is to use this millisecond 10 times every second in order to</span><br><span class="line"># actively rehash the main dictionaries, freeing memory when possible.</span><br><span class="line">#</span><br><span class="line"># If unsure:</span><br><span class="line"># use "activerehashing no" if you have hard latency requirements and it is</span><br><span class="line"># not a good thing in your environment that Redis can reply from time to time</span><br><span class="line"># to queries with 2 milliseconds delay.</span><br><span class="line">#</span><br><span class="line"># use "activerehashing yes" if you don't have such hard requirements but</span><br><span class="line"># want to free memory asap when possible.</span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line"># The client output buffer limits can be used to force disconnection of clients</span><br><span class="line"># that are not reading data from the server fast enough for some reason (a</span><br><span class="line"># common reason is that a Pub/Sub client can't consume messages as fast as the</span><br><span class="line"># publisher can produce them).</span><br><span class="line">#</span><br><span class="line"># The limit can be set differently for the three different classes of clients:</span><br><span class="line">#</span><br><span class="line"># normal -&gt; normal clients including MONITOR clients</span><br><span class="line"># replica  -&gt; replica clients</span><br><span class="line"># pubsub -&gt; clients subscribed to at least one pubsub channel or pattern</span><br><span class="line">#</span><br><span class="line"># The syntax of every client-output-buffer-limit directive is the following:</span><br><span class="line">#</span><br><span class="line"># client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br><span class="line">#</span><br><span class="line"># A client is immediately disconnected once the hard limit is reached, or if</span><br><span class="line"># the soft limit is reached and remains reached for the specified number of</span><br><span class="line"># seconds (continuously).</span><br><span class="line"># So for instance if the hard limit is 32 megabytes and the soft limit is</span><br><span class="line"># 16 megabytes / 10 seconds, the client will get disconnected immediately</span><br><span class="line"># if the size of the output buffers reach 32 megabytes, but will also get</span><br><span class="line"># disconnected if the client reaches 16 megabytes and continuously overcomes</span><br><span class="line"># the limit for 10 seconds.</span><br><span class="line">#</span><br><span class="line"># By default normal clients are not limited because they don't receive data</span><br><span class="line"># without asking (in a push way), but just after a request, so only</span><br><span class="line"># asynchronous clients may create a scenario where data is requested faster</span><br><span class="line"># than it can read.</span><br><span class="line">#</span><br><span class="line"># Instead there is a default limit for pubsub and replica clients, since</span><br><span class="line"># subscribers and replicas receive data in a push fashion.</span><br><span class="line">#</span><br><span class="line"># Both the hard or the soft limit can be disabled by setting them to zero.</span><br><span class="line">client-output-buffer-limit normal <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">client-output-buffer-limit replica <span class="number">256</span>mb <span class="number">64</span>mb <span class="number">60</span></span><br><span class="line">client-output-buffer-limit pubsub <span class="number">32</span>mb <span class="number">8</span>mb <span class="number">60</span></span><br><span class="line"></span><br><span class="line"># Client query buffers accumulate new commands. They are limited to a fixed</span><br><span class="line"># amount by default in order to avoid that a protocol desynchronization (for</span><br><span class="line"># instance due to a bug in the client) will lead to unbound memory usage in</span><br><span class="line"># the query buffer. However you can configure it here if you have very special</span><br><span class="line"># needs, such us huge multi/exec requests or alike.</span><br><span class="line">#</span><br><span class="line"># client-query-buffer-limit 1gb</span><br><span class="line"></span><br><span class="line"># In the Redis protocol, bulk requests, that are, elements representing single</span><br><span class="line"># strings, are normally limited ot 512 mb. However you can change this limit</span><br><span class="line"># here, but must be 1mb or greater</span><br><span class="line">#</span><br><span class="line"># proto-max-bulk-len 512mb</span><br><span class="line"></span><br><span class="line"># Redis calls an internal function to perform many background tasks, like</span><br><span class="line"># closing connections of clients in timeout, purging expired keys that are</span><br><span class="line"># never requested, and so forth.</span><br><span class="line">#</span><br><span class="line"># Not all tasks are performed with the same frequency, but Redis checks for</span><br><span class="line"># tasks to perform according to the specified "hz" value.</span><br><span class="line">#</span><br><span class="line"># By default "hz" is set to 10. Raising the value will use more CPU when</span><br><span class="line"># Redis is idle, but at the same time will make Redis more responsive when</span><br><span class="line"># there are many keys expiring at the same time, and timeouts may be</span><br><span class="line"># handled with more precision.</span><br><span class="line">#</span><br><span class="line"># The range is between 1 and 500, however a value over 100 is usually not</span><br><span class="line"># a good idea. Most users should use the default of 10 and raise this up to</span><br><span class="line"># 100 only in environments where very low latency is required.</span><br><span class="line">hz <span class="number">10</span></span><br><span class="line"></span><br><span class="line"># Normally it is useful to have an HZ value which is proportional to the</span><br><span class="line"># number of clients connected. This is useful in order, for instance, to</span><br><span class="line"># avoid too many clients are processed for each background task invocation</span><br><span class="line"># in order to avoid latency spikes.</span><br><span class="line">#</span><br><span class="line"># Since the default HZ value by default is conservatively set to 10, Redis</span><br><span class="line"># offers, and enables by default, the ability to use an adaptive HZ value</span><br><span class="line"># which will temporary raise when there are many connected clients.</span><br><span class="line">#</span><br><span class="line"># When dynamic HZ is enabled, the actual configured HZ will be used</span><br><span class="line"># as a baseline, but multiples of the configured HZ value will be actually</span><br><span class="line"># used as needed once more clients are connected. In this way an idle</span><br><span class="line"># instance will use very little CPU time while a busy instance will be</span><br><span class="line"># more responsive.</span><br><span class="line">dynamic-hz yes</span><br><span class="line"></span><br><span class="line"># When a child rewrites the AOF file, if the following option is enabled</span><br><span class="line"># the file will be fsync-ed every 32 MB of data generated. This is useful</span><br><span class="line"># in order to commit the file to the disk more incrementally and avoid</span><br><span class="line"># big latency spikes.</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line"></span><br><span class="line"># When redis saves RDB file, if the following option is enabled</span><br><span class="line"># the file will be fsync-ed every 32 MB of data generated. This is useful</span><br><span class="line"># in order to commit the file to the disk more incrementally and avoid</span><br><span class="line"># big latency spikes.</span><br><span class="line">rdb-save-incremental-fsync yes</span><br><span class="line"></span><br><span class="line"># Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good</span><br><span class="line"># idea to start with the default settings and only change them after investigating</span><br><span class="line"># how to improve the performances and how the keys LFU change over time, which</span><br><span class="line"># is possible to inspect via the OBJECT FREQ command.</span><br><span class="line">#</span><br><span class="line"># There are two tunable parameters in the Redis LFU implementation: the</span><br><span class="line"># counter logarithm factor and the counter decay time. It is important to</span><br><span class="line"># understand what the two parameters mean before changing them.</span><br><span class="line">#</span><br><span class="line"># The LFU counter is just 8 bits per key, it's maximum value is 255, so Redis</span><br><span class="line"># uses a probabilistic increment with logarithmic behavior. Given the value</span><br><span class="line"># of the old counter, when a key is accessed, the counter is incremented in</span><br><span class="line"># this way:</span><br><span class="line">#</span><br><span class="line"># 1. A random number R between 0 and 1 is extracted.</span><br><span class="line"># 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).</span><br><span class="line"># 3. The counter is incremented only if R &lt; P.</span><br><span class="line">#</span><br><span class="line"># The default lfu-log-factor is 10. This is a table of how the frequency</span><br><span class="line"># counter changes with a different number of accesses with different</span><br><span class="line"># logarithmic factors:</span><br><span class="line">#</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line"># | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line"># | 0      | 104        | 255        | 255        | 255        | 255        |</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line"># | 1      | 18         | 49         | 255        | 255        | 255        |</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line"># | 10     | 10         | 18         | 142        | 255        | 255        |</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line"># | 100    | 8          | 11         | 49         | 143        | 255        |</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line">#</span><br><span class="line"># NOTE: The above table was obtained by running the following commands:</span><br><span class="line">#</span><br><span class="line">#   redis-benchmark -n 1000000 incr foo</span><br><span class="line">#   redis-cli object freq foo</span><br><span class="line">#</span><br><span class="line"># NOTE 2: The counter initial value is 5 in order to give new objects a chance</span><br><span class="line"># to accumulate hits.</span><br><span class="line">#</span><br><span class="line"># The counter decay time is the time, in minutes, that must elapse in order</span><br><span class="line"># for the key counter to be divided by two (or decremented if it has a value</span><br><span class="line"># less &lt;= 10).</span><br><span class="line">#</span><br><span class="line"># The default value for the lfu-decay-time is 1. A Special value of 0 means to</span><br><span class="line"># decay the counter every time it happens to be scanned.</span><br><span class="line">#</span><br><span class="line"># lfu-log-factor 10</span><br><span class="line"># lfu-decay-time 1</span><br><span class="line"></span><br><span class="line">########################### ACTIVE DEFRAGMENTATION #######################</span><br><span class="line">#</span><br><span class="line"># What is active defragmentation?</span><br><span class="line"># -------------------------------</span><br><span class="line">#</span><br><span class="line"># Active (online) defragmentation allows a Redis server to compact the</span><br><span class="line"># spaces left between small allocations and deallocations of data in memory,</span><br><span class="line"># thus allowing to reclaim back memory.</span><br><span class="line">#</span><br><span class="line"># Fragmentation is a natural process that happens with every allocator (but</span><br><span class="line"># less so with Jemalloc, fortunately) and certain workloads. Normally a server</span><br><span class="line"># restart is needed in order to lower the fragmentation, or at least to flush</span><br><span class="line"># away all the data and create it again. However thanks to this feature</span><br><span class="line"># implemented by Oran Agra for Redis 4.0 this process can happen at runtime</span><br><span class="line"># in an "hot" way, while the server is running.</span><br><span class="line">#</span><br><span class="line"># Basically when the fragmentation is over a certain level (see the</span><br><span class="line"># configuration options below) Redis will start to create new copies of the</span><br><span class="line"># values in contiguous memory regions by exploiting certain specific Jemalloc</span><br><span class="line"># features (in order to understand if an allocation is causing fragmentation</span><br><span class="line"># and to allocate it in a better place), and at the same time, will release the</span><br><span class="line"># old copies of the data. This process, repeated incrementally for all the keys</span><br><span class="line"># will cause the fragmentation to drop back to normal values.</span><br><span class="line">#</span><br><span class="line"># Important things to understand:</span><br><span class="line">#</span><br><span class="line"># 1. This feature is disabled by default, and only works if you compiled Redis</span><br><span class="line">#    to use the copy of Jemalloc we ship with the source code of Redis.</span><br><span class="line">#    This is the default with Linux builds.</span><br><span class="line">#</span><br><span class="line"># 2. You never need to enable this feature if you don't have fragmentation</span><br><span class="line">#    issues.</span><br><span class="line">#</span><br><span class="line"># 3. Once you experience fragmentation, you can enable this feature when</span><br><span class="line">#    needed with the command "CONFIG SET activedefrag yes".</span><br><span class="line">#</span><br><span class="line"># The configuration parameters are able to fine tune the behavior of the</span><br><span class="line"># defragmentation process. If you are not sure about what they mean it is</span><br><span class="line"># a good idea to leave the defaults untouched.</span><br><span class="line"></span><br><span class="line"># Enabled active defragmentation</span><br><span class="line"># activedefrag no</span><br><span class="line"></span><br><span class="line"># Minimum amount of fragmentation waste to start active defrag</span><br><span class="line"># active-defrag-ignore-bytes 100mb</span><br><span class="line"></span><br><span class="line"># Minimum percentage of fragmentation to start active defrag</span><br><span class="line"># active-defrag-threshold-lower 10</span><br><span class="line"></span><br><span class="line"># Maximum percentage of fragmentation at which we use maximum effort</span><br><span class="line"># active-defrag-threshold-upper 100</span><br><span class="line"></span><br><span class="line"># Minimal effort for defrag in CPU percentage, to be used when the lower</span><br><span class="line"># threshold is reached</span><br><span class="line"># active-defrag-cycle-min 1</span><br><span class="line"></span><br><span class="line"># Maximal effort for defrag in CPU percentage, to be used when the upper</span><br><span class="line"># threshold is reached</span><br><span class="line"># active-defrag-cycle-max 25</span><br><span class="line"></span><br><span class="line"># Maximum number of set/hash/zset/list fields that will be processed from</span><br><span class="line"># the main dictionary scan</span><br><span class="line"># active-defrag-max-scan-fields 1000</span><br><span class="line"></span><br><span class="line"># Jemalloc background thread for purging will be enabled by default</span><br><span class="line">jemalloc-bg-thread yes</span><br><span class="line"></span><br><span class="line"># It is possible to pin different threads and processes of Redis to specific</span><br><span class="line"># CPUs in your system, in order to maximize the performances of the server.</span><br><span class="line"># This is useful both in order to pin different Redis threads in different</span><br><span class="line"># CPUs, but also in order to make sure that multiple Redis instances running</span><br><span class="line"># in the same host will be pinned to different CPUs.</span><br><span class="line">#</span><br><span class="line"># Normally you can do this using the "taskset" command, however it is also</span><br><span class="line"># possible to this via Redis configuration directly, both in Linux and FreeBSD.</span><br><span class="line">#</span><br><span class="line"># You can pin the server/IO threads, bio threads, aof rewrite child process, and</span><br><span class="line"># the bgsave child process. The syntax to specify the cpu list is the same as</span><br><span class="line"># the taskset command:</span><br><span class="line">#</span><br><span class="line"># Set redis server/io threads to cpu affinity 0,2,4,6:</span><br><span class="line"># server_cpulist 0-7:2</span><br><span class="line">#</span><br><span class="line"># Set bio threads to cpu affinity 1,3:</span><br><span class="line"># bio_cpulist 1,3</span><br><span class="line">#</span><br><span class="line"># Set aof rewrite child process to cpu affinity 8,9,10,11:</span><br><span class="line"># aof_rewrite_cpulist 8-11</span><br><span class="line">#</span><br><span class="line"># Set bgsave child process to cpu affinity 1,10,11</span><br><span class="line"># bgsave_cpulist 1,10-11</span><br></pre></td></tr></table></figure>
<h3 id="测试-redis-cli连接上来"><a href="#测试-redis-cli连接上来" class="headerlink" title="测试 redis-cli连接上来"></a>测试 redis-cli连接上来</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 运行着redis服务容器的ID redis-cli</span><br></pre></td></tr></table></figure>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095817.png"></p>
<h3 id="测试持久化文件生成"><a href="#测试持久化文件生成" class="headerlink" title="测试持久化文件生成"></a>测试持久化文件生成</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095821.png"></p>
<h1 id="第-八-章-将镜像推送到阿里云"><a href="#第-八-章-将镜像推送到阿里云" class="headerlink" title="第 八 章 将镜像推送到阿里云"></a>第 八 章 将镜像推送到阿里云</h1><h2 id="本地镜像发布到阿里云流程"><a href="#本地镜像发布到阿里云流程" class="headerlink" title="本地镜像发布到阿里云流程"></a>本地镜像发布到阿里云流程</h2><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095826.png"></p>
<h2 id="镜像生成方法"><a href="#镜像生成方法" class="headerlink" title="镜像生成方法"></a>镜像生成方法</h2><p>1、前面的Dockerfile</p>
<p>2、从容器中创建一个新的镜像 </p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [OPTIONS] 容器ID [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095830.png"></p>
<h2 id="将本地镜像推送到阿里云"><a href="#将本地镜像推送到阿里云" class="headerlink" title="将本地镜像推送到阿里云"></a>将本地镜像推送到阿里云</h2><h3 id="1、本地镜像素材原型"><a href="#1、本地镜像素材原型" class="headerlink" title="1、本地镜像素材原型"></a>1、本地镜像素材原型</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095834.png"></p>
<p>2、阿里云开发者平台</p>
<p><a href="https://promotion.aliyun.com/ntms/act/kubernetes.html" target="_blank" rel="noopener">https://promotion.aliyun.com/ntms/act/kubernetes.html</a></p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095838.png"></p>
<h3 id="3、创建镜像仓库"><a href="#3、创建镜像仓库" class="headerlink" title="3、创建镜像仓库"></a>3、创建镜像仓库</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095842.png"></p>
<p>命名空间</p>
<p>仓库名称</p>
<h3 id="4、将镜像推送到registry"><a href="#4、将镜像推送到registry" class="headerlink" title="4、将镜像推送到registry"></a>4、将镜像推送到registry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker login --username=white3e registry.cn-shenzhen.aliyuncs.com</span><br><span class="line">$ sudo docker tag [ImageId] registry.cn-shenzhen.aliyuncs.com/ggccqq/mycentos:[镜像版本号]</span><br><span class="line">$ sudo docker push registry.cn-shenzhen.aliyuncs.com/ggccqq/mycentos:[镜像版本号]</span><br><span class="line">其中[ImageId][镜像版本]自己填写</span><br></pre></td></tr></table></figure>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095848.png"></p>
<h3 id="5、公有云可以查询得到"><a href="#5、公有云可以查询得到" class="headerlink" title="5、公有云可以查询得到"></a>5、公有云可以查询得到</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095852.png"></p>
<h3 id="6、查看详情"><a href="#6、查看详情" class="headerlink" title="6、查看详情"></a>6、查看详情</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095856.png"></p>
<h2 id="将阿里云上的镜像下载到本地"><a href="#将阿里云上的镜像下载到本地" class="headerlink" title="将阿里云上的镜像下载到本地"></a>将阿里云上的镜像下载到本地</h2><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095900.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210830082358.png"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://alexander-wd.github.io/alex-next/2021/08/12/面试题/RabbitMQ面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="alex">
      <meta itemprop="description" content="时光静好,与君语;细水流年,与君同;繁华落尽,与君老.">
      <meta itemprop="image" content="/alex-next/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="alex的博客 - github.com">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/alex-next/2021/08/12/面试题/RabbitMQ面试题/" class="post-title-link" itemprop="url">RabbitMQ学习记录</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2021-08-12 16:10:20" itemprop="dateCreated datePublished" datetime="2021-08-12T16:10:20+08:00">2021-08-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-13 18:03:04" itemprop="dateModified" datetime="2023-02-13T18:03:04+08:00">2023-02-13</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/alex-next/categories/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://alexander-wd.github.io/alex-next/2021/08/12/javaEE/RabbitMQ学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="alex">
      <meta itemprop="description" content="时光静好,与君语;细水流年,与君同;繁华落尽,与君老.">
      <meta itemprop="image" content="/alex-next/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="alex的博客 - github.com">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/alex-next/2021/08/12/javaEE/RabbitMQ学习笔记/" class="post-title-link" itemprop="url">RabbitMQ学习记录</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2021-08-12 16:10:20" itemprop="dateCreated datePublished" datetime="2021-08-12T16:10:20+08:00">2021-08-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-13 17:50:36" itemprop="dateModified" datetime="2023-02-13T17:50:36+08:00">2023-02-13</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/alex-next/categories/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><h2 id="1-Rabbitmq基本概念"><a href="#1-Rabbitmq基本概念" class="headerlink" title="1.Rabbitmq基本概念"></a>1.Rabbitmq基本概念</h2><h3 id="MQ概述"><a href="#MQ概述" class="headerlink" title="MQ概述"></a>MQ概述</h3><ul>
<li>全称 Message Queue（消息队列），是在消息的传输过程中保存消息的容器。多用于分布式系统之间进行通信。</li>
</ul>
<h3 id="MQ优势"><a href="#MQ优势" class="headerlink" title="MQ优势"></a>MQ优势</h3><ul>
<li>应用解耦</li>
<li>异步提速</li>
<li>削峰填谷</li>
</ul>
<h3 id="常见的MQ比较"><a href="#常见的MQ比较" class="headerlink" title="常见的MQ比较"></a>常见的MQ比较</h3><h3 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h3><h3 id="几种工作模式"><a href="#几种工作模式" class="headerlink" title="几种工作模式"></a>几种工作模式</h3><ul>
<li>最简单的</li>
<li><p>工作队列</p>
<ul>
<li>就是有多个消费者</li>
</ul>
</li>
<li><p>发布/订阅</p>
<ul>
<li><p>应用场景</p>
<ul>
<li>关注博主之后，主动推送(广播)</li>
</ul>
</li>
</ul>
</li>
<li><p>路由模式</p>
<ul>
<li>能匹配上路由key就发送</li>
</ul>
</li>
<li><p>Topics 主题模式(通配符模式)</p>
<ul>
<li><p>通配符规则</p>
<ul>
<li><h1 id="可以匹配多个词"><a href="#可以匹配多个词" class="headerlink" title="可以匹配多个词"></a>可以匹配多个词</h1></li>
<li>*只能匹配正好一个词</li>
</ul>
</li>
</ul>
</li>
<li><p>tips</p>
<ul>
<li>要自己手动创建交换机</li>
</ul>
</li>
</ul>
<h3 id="消息确认机制"><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h3><ul>
<li>RabbitMq充当了代理人(broker)的角色</li>
<li>ack表示消息已被Broker接收</li>
<li>nack表示Broker拒收消息(队列已满，限流)</li>
</ul>
<h3 id="spring整合rabbitMQ"><a href="#spring整合rabbitMQ" class="headerlink" title="spring整合rabbitMQ"></a>spring整合rabbitMQ</h3><ul>
<li>有参考代码</li>
</ul>
<h2 id="2-RabbitMq如何可靠性消息传递"><a href="#2-RabbitMq如何可靠性消息传递" class="headerlink" title="2.RabbitMq如何可靠性消息传递"></a>2.RabbitMq如何可靠性消息传递</h2><h3 id="springboot整合rabbitmq"><a href="#springboot整合rabbitmq" class="headerlink" title="springboot整合rabbitmq"></a>springboot整合rabbitmq</h3><ul>
<li><p>生产者</p>
<ul>
<li>1.导入依赖，编写配置类</li>
<li>2.定义交换机、队列、绑定关系的配置类</li>
<li>3.注入RabbitTemplate，调用方法，完成消息发送</li>
</ul>
</li>
<li><p>消费者</p>
<ul>
<li>1.导入依赖，编写配置类</li>
<li>2.定义监听类，使用@RabbitListener完成队列监听</li>
</ul>
</li>
</ul>
<h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><ul>
<li><p>消息确认机制</p>
<ul>
<li><p>生产者</p>
<ul>
<li><p>confirm确认模式</p>
<ul>
<li>消息从 producer 到 exchange 则会返回一个 confirmCallback</li>
<li><p>tips</p>
<ul>
<li>成功和失败的时候都能处理</li>
</ul>
</li>
</ul>
</li>
<li><p>return 回退模式</p>
<ul>
<li>消息从 exchange—&gt;queue 投递失败则会返回一个 returnCallback</li>
<li><p>tips</p>
<ul>
<li>要设置rabbitTemplate.setMandatory(true);</li>
<li>exchange到queue失败才会调用回调函数</li>
<li>失败的时候处理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>消费者</p>
<ul>
<li>自动确认模式</li>
<li><p>手动确认模式</p>
<ul>
<li>如果消费者出现了异常，会一直刷屏</li>
</ul>
</li>
<li><p>根据异常情况确认模式</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>消费端限流</p>
<ul>
<li>如果没接收，就表示堵住了，会被限流</li>
</ul>
</li>
<li><p>TTL</p>
<ul>
<li><p>含义</p>
<ul>
<li>Time to live(存活时间)</li>
</ul>
</li>
<li><p>当消息到达存活时间后，还没有被消费，会被自动清除。</p>
</li>
</ul>
</li>
<li><p>死信队列(DLX)</p>
<ul>
<li>又称为死信交换机(DLX)</li>
<li>若一个消息在TTL的时间内没有被消费，会被重新发送给另一个交换机，这个交换机就是DLX</li>
<li><p>步骤</p>
<ul>
<li>1.声明正常的队列(test_queue_dlx)和交换机(test_exchange_dlx)</li>
<li>2.声明死信队列(queue_dlx)和死信交换机(exchange_dlx)</li>
<li>3.正常队列绑定死信交换机</li>
</ul>
</li>
<li><p>死信的情况</p>
<ul>
<li>1.队列消息长度到达限制</li>
<li>2.消费者拒接消费消息</li>
<li>3.原队列存在消息过期设置，消息到达超时时间未被消费</li>
</ul>
</li>
</ul>
</li>
<li><p>延时队列</p>
<ul>
<li>死信队列+TTL</li>
<li>配置消费者的时候记得有个死信消费者绑定到死信队列上</li>
<li><p>应用</p>
<ul>
<li>在规定时间内，没有接受，就回滚库存</li>
</ul>
</li>
</ul>
</li>
<li><p>消息积压</p>
<ul>
<li><p>产生原因</p>
<ul>
<li>消费者宕机积压</li>
<li>消费者消费能力不足积压</li>
<li>生产者流量太大</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li>上线更多消费者</li>
<li><p>上线专门的队列消费服务</p>
<ul>
<li>将消息先批量取出来，记录到数据库中，再慢慢处理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>消息幂等性</p>
<ul>
<li><p>幂等性</p>
<ul>
<li>一次和多次请求某一个资源对于资源本身应该具有同样的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。</li>
</ul>
</li>
<li><p>产生原因</p>
<ul>
<li>生产者发送信息给消费者，消费者很久没消费，MQ重新发送了，这时候消费者可能会多次消费</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li>使用乐观锁，加版本号</li>
</ul>
</li>
</ul>
</li>
<li><p>事务</p>
<ul>
<li>不推荐重量级事务，吞吐量会下降250倍</li>
</ul>
</li>
</ul>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><ul>
<li>架构图</li>
</ul>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><blockquote>
<p>docker pull rabbitmq:managment</p>
<p>启动</p>
<p>docker run -d —name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management</p>
<p>tip:没有的话，docker run 会先安装在启动</p>
<p>解释</p>
<blockquote>
<p>4369, 25672 (Erlang发现&amp;集群端口)</p>
<p>5672, 5671 (AMQP端口)</p>
<p>15672 (web管理后台端口)</p>
<p>61613, 61614 (STOMP协议端口)</p>
<p>1883, 8883 (MQTT协议端口)</p>
<p><a href="https://www.rabbitmq.com/networking.html" target="_blank" rel="noopener">https://www.rabbitmq.com/networking.html</a></p>
</blockquote>
<p>默认账号  guest/guest</p>
</blockquote>
<h4 id="MQ优势-1"><a href="#MQ优势-1" class="headerlink" title="MQ优势"></a>MQ优势</h4><pre><code>应用解耦
</code></pre><blockquote>
<p>如若订单系统调用库存系统的接口改了，那么订单系统也要跟着改，不方便维护</p>
</blockquote>
<p><img alt="1" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208203444.png"></p>
<pre><code>异步提速
</code></pre><p><img alt="2" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208203447.png"></p>
<pre><code>削峰填谷
</code></pre><p><img alt="3" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208203450.png"></p>
<h4 id="消息队列两大规范"><a href="#消息队列两大规范" class="headerlink" title="消息队列两大规范"></a>消息队列两大规范</h4><p>JMS，ActiveMQ实现</p>
<p>AMQP，RabbitMQ实现</p>
<p><img alt="30" data-src="E:\desktop\自学\MyNote\项目\谷粒商城\images\30.png"></p>
<h4 id="基本组件图-概念图"><a href="#基本组件图-概念图" class="headerlink" title="基本组件图(概念图)"></a>基本组件图(概念图)</h4><blockquote>
<p>这是比较整体的图，具体的来说有好几种模式(工作模式，路由模式(Direct：定向)，发布/订阅模式(Fanout：广播)，Topics主题模式(Topic：通配符))</p>
</blockquote>
<p><img alt="img" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208210335.png"></p>
<p>其中MQ就充当了Broker消息代理的角色</p>
<p>route-key路由键结合交换机的类型(direct,fanout,topic)决定消息发给哪些队列，==注意和队列名称和交换机名称没有关系==</p>
<p>VHost</p>
<blockquote>
<p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</p>
<p>比如java和PHP可以隔离出两个VHost，一个崩溃了不会影响另一个；或者生产和测试可以隔离出两个VHost </p>
</blockquote>
<h4 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h4><h5 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="AmqpAdmin用于增删改查队列、交换机及其绑定关系等"><a href="#AmqpAdmin用于增删改查队列、交换机及其绑定关系等" class="headerlink" title="AmqpAdmin用于增删改查队列、交换机及其绑定关系等"></a>AmqpAdmin用于增删改查队列、交换机及其绑定关系等</h5><blockquote>
<p>结合web图形界面更直观</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DirectExchange(String name, boolean durable, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">    <span class="comment">// 名称,持久化,是否自动删除,额外参数</span></span><br><span class="line">    admin.declareExchange(<span class="keyword">new</span> DirectExchange(<span class="string">"hello-java-exchange"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>));</span><br><span class="line">    log.info(<span class="string">"Exchange:&#123;&#125;创建成功"</span>,<span class="string">"hello-java-exchange"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Queue(String name, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">    <span class="comment">// 名称,是否持久化,是否排他(只能被一个人连接),是否自动删除,额外参数</span></span><br><span class="line">    admin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">"hello-java-queue"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>));</span><br><span class="line">    log.info(<span class="string">"Queue:&#123;&#125;创建成功"</span>,<span class="string">"hello-java-queue"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Binding(String destination, Binding.DestinationType destinationType, String exchange, String routingKey,</span></span><br><span class="line"><span class="comment">//                Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">    <span class="comment">// 目的地，目的地类型(交换机或队列)，交换机，路由键</span></span><br><span class="line">    admin.declareBinding(<span class="keyword">new</span> Binding(<span class="string">"hello-java-queue"</span>,Binding.DestinationType.QUEUE,</span><br><span class="line">            <span class="string">"hello-java-exchange"</span>,</span><br><span class="line">            <span class="string">"hello.java"</span>,<span class="keyword">null</span>));</span><br><span class="line">    log.info(<span class="string">"Binding:&#123;&#125;创建成功"</span>,<span class="string">"hello-java-binding"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RabbitTemplate用于发送消息"><a href="#RabbitTemplate用于发送消息" class="headerlink" title="RabbitTemplate用于发送消息"></a>RabbitTemplate用于发送消息</h5><p>如果要发送对象，就必须实现序列化接口</p>
<p>或者转为json发送(需要往容器中注入rabbitmq的json转换器 Jackson2JsonMessageConverter)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    OrderReturnReasonEntity reasonEntity = <span class="keyword">new</span> OrderReturnReasonEntity();</span><br><span class="line">    reasonEntity.setId(<span class="number">1L</span>);</span><br><span class="line">    reasonEntity.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">    reasonEntity.setName(<span class="string">"reason"</span>);</span><br><span class="line">    reasonEntity.setStatus(<span class="number">1</span>);</span><br><span class="line">    reasonEntity.setSort(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 如果要发送对象，就必须实现序列化接口或者转为json发送</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"hello-java-exchange"</span>,<span class="string">"hello.java"</span>,reasonEntity);</span><br><span class="line">    log.info(<span class="string">"消息:&#123;&#125;发送完成"</span>,<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RabbitListner用于监听信息"><a href="#RabbitListner用于监听信息" class="headerlink" title="@RabbitListner用于监听信息"></a>@RabbitListner用于监听信息</h5><blockquote>
<p>例如接收如上RabbitTemplate发送的信息</p>
<p>@RabbitHandler也常用，不过只能用于方法；@RabbitListner可以用于方法和类。但是@RabbitHandler标注能够方便标注重载方法(区分不同的消息)，@RabbitListner此时就用来标注到类上，表示接收哪个队列的消息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"orderItemService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderItemServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">OrderItemDao</span>, <span class="title">OrderItemEntity</span>&gt; <span class="keyword">implements</span> <span class="title">OrderItemService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = &#123;<span class="string">"hello-java-queue"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revieveMessage</span><span class="params">(Message message,</span></span></span><br><span class="line"><span class="function"><span class="params">                               OrderReturnReasonEntity content,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//拿到主体内容</span></span><br><span class="line">        <span class="keyword">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="comment">//拿到的消息头属性信息</span></span><br><span class="line">        MessageProperties messageProperties = message.getMessageProperties();</span><br><span class="line">        System.out.println(<span class="string">"接受到的消息...内容"</span> + message + <span class="string">"===内容："</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消息确认机制-1"><a href="#消息确认机制-1" class="headerlink" title="消息确认机制"></a>消息确认机制</h4><blockquote>
<p>==保证消息不丢失，可靠抵达，虽然可以使用事务消息，但是性能下降250倍，为此引入确认机制==</p>
</blockquote>
<p>==分别从服务端和消费端实现确认机制==</p>
<p><img alt="32" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230210170128.png"></p>
<h5 id="ConfirmCallback"><a href="#ConfirmCallback" class="headerlink" title="ConfirmCallback"></a>ConfirmCallback</h5><p>只要消息抵达Broker就ack=true</p>
<p><img alt="33" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230210170520.png"></p>
<h5 id="ReturnCallback"><a href="#ReturnCallback" class="headerlink" title="ReturnCallback"></a>ReturnCallback</h5><p>==只要消息没有投递给指定的队列，就触发这个失败回调==</p>
<p><img alt="34" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230210170517.png"></p>
<h5 id="Ack消息确认机制"><a href="#Ack消息确认机制" class="headerlink" title="==Ack消息确认机制=="></a>==Ack消息确认机制==</h5><p><img alt="35" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230210170513.png"></p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>yml</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    rabbitmq:</span></span><br><span class="line"><span class="attr">        host:</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.108</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">        virtual-host:</span> <span class="string">/</span></span><br><span class="line">        <span class="comment"># 开启发送端消息抵达Broker确认</span></span><br><span class="line"><span class="attr">        publisher-confirms:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 开启发送端消息抵达Queue确认</span></span><br><span class="line"><span class="attr">        publisher-returns:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 只要消息抵达Queue，就会异步发送优先回调returnfirm</span></span><br><span class="line"><span class="attr">        template:</span></span><br><span class="line"><span class="attr">          mandatory:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 手动ack消息，不使用默认的消费端确认</span></span><br><span class="line"><span class="attr">        listener:</span></span><br><span class="line"><span class="attr">          simple:</span></span><br><span class="line"><span class="attr">            acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure>
<p>服务端确认需要的配置config.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageConverter <span class="title">messageConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制RabbitTemplate</span></span><br><span class="line"><span class="comment">     * 1、服务收到消息就会回调</span></span><br><span class="line"><span class="comment">     *      1、spring.rabbitmq.publisher-confirms: true</span></span><br><span class="line"><span class="comment">     *      2、设置确认回调</span></span><br><span class="line"><span class="comment">     * 2、消息正确抵达队列就会进行回调</span></span><br><span class="line"><span class="comment">     *      1、spring.rabbitmq.publisher-returns: true</span></span><br><span class="line"><span class="comment">     *         spring.rabbitmq.template.mandatory: true</span></span><br><span class="line"><span class="comment">     *      2、设置确认回调ReturnCallback</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3、消费端确认(保证每个消息都被正确消费，此时才可以broker删除这个消息)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// @PostConstruct  //MyRabbitConfig对象创建完成以后，执行这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initRabbitTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1、只要消息抵达Broker就ack=true</span></span><br><span class="line"><span class="comment">         * correlationData：当前消息的唯一关联数据(这个是消息的唯一id)</span></span><br><span class="line"><span class="comment">         * ack：消息是否成功收到</span></span><br><span class="line"><span class="comment">         * cause：失败的原因</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//设置确认回调</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback((correlationData,ack,cause) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"confirm...correlationData["</span>+correlationData+<span class="string">"]==&gt;ack:["</span>+ack+<span class="string">"]==&gt;cause:["</span>+cause+<span class="string">"]"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 只要消息没有投递给指定的队列，就触发这个失败回调</span></span><br><span class="line"><span class="comment">         * message：投递失败的消息详细信息</span></span><br><span class="line"><span class="comment">         * replyCode：回复的状态码</span></span><br><span class="line"><span class="comment">         * replyText：回复的文本内容</span></span><br><span class="line"><span class="comment">         * exchange：当时这个消息发给哪个交换机</span></span><br><span class="line"><span class="comment">         * routingKey：当时这个消息用哪个路邮键</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setReturnCallback((message,replyCode,replyText,exchange,routingKey) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"Fail Message["</span>+message+<span class="string">"]==&gt;replyCode["</span>+replyCode+<span class="string">"]"</span> +</span><br><span class="line">                    <span class="string">"==&gt;replyText["</span>+replyText+<span class="string">"]==&gt;exchange["</span>+exchange+<span class="string">"]==&gt;routingKey["</span>+routingKey+<span class="string">"]"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ack消费者确认机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revieveMessage</span><span class="params">(Message message,</span></span></span><br><span class="line"><span class="function"><span class="params">                           OrderReturnReasonEntity content,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Channel channel)</span></span>&#123;</span><br><span class="line">    <span class="comment">//拿到主体内容</span></span><br><span class="line">    <span class="keyword">byte</span>[] body = message.getBody();</span><br><span class="line">    <span class="comment">//拿到的消息头属性信息</span></span><br><span class="line">    MessageProperties messageProperties = message.getMessageProperties();</span><br><span class="line">    System.out.println(<span class="string">"接受到的消息...内容"</span> + <span class="keyword">new</span> String(body) + <span class="string">"===内容："</span> + content);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deliveryTag在该通道内从1开始计数   表示消息唯一标识</span></span><br><span class="line">    <span class="keyword">long</span> deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">    <span class="comment">// 签收消息</span></span><br><span class="line">    <span class="comment">// multiple=false(挨个签收)</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.basicAck(deliveryTag,<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 表示消息唯一标识,是否批量,拒绝后是否发挥服务器重新入队</span></span><br><span class="line">        <span class="comment">// channel.basicNack(deliveryTag,false,true);</span></span><br><span class="line">        <span class="comment">//            // 表示消息唯一标识,拒绝后是否发挥服务器重新入队</span></span><br><span class="line">        <span class="comment">// channel.basicReject(deliveryTag,true);</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 网络中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h4><h5 id="死信路由-DLX"><a href="#死信路由-DLX" class="headerlink" title="死信路由(DLX)"></a>死信路由(DLX)</h5><p>一个消息在满足如下条件下，会进死信路由，记住这里是路由而不是队列， 一个路由可以对应很多队列。（什么是死信）</p>
<p>成为死信的情况：</p>
<pre><code>    1.一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不会被再次放在队列里，被其他消费者使用。（basic.reject/ basic.nack）requeue=false
    2.上面的消息的TTL到了，消息过期了。
    3.队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上
</code></pre><p>Dead Letter Exchange其实就是一种普通的exchange，和创建其他exchange没有两样。只是在某一个设置Dead Letter Exchange的队列中有 消息过期了，会自动触发消息的转发，发送到Dead Letter Exchange中去。</p>
<p>我们既可以控制消息在一段时间后变成死信，又可以控制变成死信的消息 被路由到某一个指定的交换机，结合二者，其实就可以实现一个延时队列</p>
<p>手动ack&amp;异常消息统一放在一个队列处理建议的两种方式<br>        catch异常后，手动发送到指定队列，然后使用channel给rabbitmq确认消息已消费<br>        给Queue绑定死信队列，使用nack（requque为false）确认消息消费失败</p>
<h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><p><img alt="39" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/39.png"></p>
<h5 id="定时任务时效性"><a href="#定时任务时效性" class="headerlink" title="定时任务时效性"></a>定时任务时效性</h5><p><img alt="40" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/40.png"></p>
<h4 id="使用MQ实现最终一致性的分布式事务"><a href="#使用MQ实现最终一致性的分布式事务" class="headerlink" title="==使用MQ实现最终一致性的分布式事务=="></a>==使用MQ实现最终一致性的分布式事务==</h4><p>==遵循一个服务一个交换机的原则==，延时队列设计如下图。</p>
<p><img alt="41" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/41.png"></p>
<h5 id="整体消息队列架构"><a href="#整体消息队列架构" class="headerlink" title="整体消息队列架构"></a>整体消息队列架构</h5><p><img alt="消息队列流程" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/消息队列流程.jpg"></p>
<h5 id="创建延时队列"><a href="#创建延时队列" class="headerlink" title="创建延时队列"></a>创建延时队列</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">orderDelayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Queue(String name,  队列名字</span></span><br><span class="line"><span class="comment">        boolean durable,  是否持久化</span></span><br><span class="line"><span class="comment">        boolean exclusive,  是否排他</span></span><br><span class="line"><span class="comment">        boolean autoDelete, 是否自动删除</span></span><br><span class="line"><span class="comment">        Map&lt;String, Object&gt; arguments) 属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HashMap&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    arguments.put(<span class="string">"x-dead-letter-exchange"</span>, <span class="string">"order-event-exchange"</span>);<span class="comment">// 死信之后发给那个交换机</span></span><br><span class="line">    arguments.put(<span class="string">"x-dead-letter-routing-key"</span>, <span class="string">"order.release.order"</span>);<span class="comment">// 死信之后的routing-key</span></span><br><span class="line">    arguments.put(<span class="string">"x-message-ttl"</span>, <span class="number">60000</span>); <span class="comment">// 消息过期时间 1分钟</span></span><br><span class="line">    Queue queue = <span class="keyword">new</span> Queue(<span class="string">"order.delay.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建死信交换机"><a href="#创建死信交换机" class="headerlink" title="创建死信交换机"></a>创建死信交换机</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TopicExchange</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Exchange <span class="title">orderEventExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *   String name,</span></span><br><span class="line"><span class="comment">     *   boolean durable,</span></span><br><span class="line"><span class="comment">     *   boolean autoDelete,</span></span><br><span class="line"><span class="comment">     *   Map&lt;String, Object&gt; arguments</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"order-event-exchange"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建目的地交换机"><a href="#创建目的地交换机" class="headerlink" title="创建目的地交换机"></a>创建目的地交换机</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">orderReleaseQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue queue = <span class="keyword">new</span> Queue(<span class="string">"order.release.order.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="绑定关系"><a href="#绑定关系" class="headerlink" title="绑定关系"></a>绑定关系</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">orderCreateBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * String destination, 目的地（队列名或者交换机名字）</span></span><br><span class="line"><span class="comment">     * DestinationType destinationType, 目的地类型（Queue、Exhcange）</span></span><br><span class="line"><span class="comment">     * String exchange,</span></span><br><span class="line"><span class="comment">     * String routingKey,</span></span><br><span class="line"><span class="comment">     * Map&lt;String, Object&gt; arguments</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Binding(<span class="string">"order.delay.queue"</span>,</span><br><span class="line">            Binding.DestinationType.QUEUE,</span><br><span class="line">            <span class="string">"order-event-exchange"</span>,</span><br><span class="line">            <span class="string">"order.create.order"</span>,</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">orderReleaseBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Binding(<span class="string">"order.release.order.queue"</span>,</span><br><span class="line">            Binding.DestinationType.QUEUE,</span><br><span class="line">            <span class="string">"order-event-exchange"</span>,</span><br><span class="line">            <span class="string">"order.release.order"</span>,</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="发消息"><a href="#发消息" class="headerlink" title="发消息"></a>发消息</h5><p>订单创建成功往延时队列中发</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 订单创建成功，发送消息给MQ</span></span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">"order-event-exchange"</span>,<span class="string">"order.create.order"</span>,order.getOrder());</span><br><span class="line"><span class="comment">// 这里不需要有消费者,过期之后让消费者取消订单就行</span></span><br></pre></td></tr></table></figure>
<h5 id="监听过期消息"><a href="#监听过期消息" class="headerlink" title="监听过期消息"></a>监听过期消息</h5><p>在延迟队列中的消息，相当于有个定时器，到期之后，能够监听到，就可以调用方法来取消订单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"order.release.order.queue"</span>)</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderCloseListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listener</span><span class="params">(OrderEntity orderEntity, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到过期的订单信息，准备关闭订单"</span> + orderEntity.getOrderSn());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            orderService.closeOrder(orderEntity);</span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            channel.basicReject(message.getMessageProperties().getDeliveryTag(),<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MQ的几个可靠性问题"><a href="#MQ的几个可靠性问题" class="headerlink" title="MQ的几个可靠性问题"></a>MQ的几个可靠性问题</h4><h5 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h5><p>没抵达broker(MQ服务器)：保证每个消息一定会发出去，做好日志(存到mysql中)。定期扫描数据库，重新发送失败的消息</p>
<p>抵达了broker(MQ服务器)：使用publisher的消息确认机制</p>
<p><img alt="42" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/42.png"></p>
<h5 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h5><p><img alt="43" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/43.png"></p>
<h5 id="消息积压"><a href="#消息积压" class="headerlink" title="消息积压"></a>消息积压</h5><p><img alt="44" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/44.png"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://alexander-wd.github.io/alex-next/2021/07/31/javaEE/redis学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="alex">
      <meta itemprop="description" content="时光静好,与君语;细水流年,与君同;繁华落尽,与君老.">
      <meta itemprop="image" content="/alex-next/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="alex的博客 - github.com">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/alex-next/2021/07/31/javaEE/redis学习笔记/" class="post-title-link" itemprop="url">redis学习笔记</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2021-07-31 16:03:12" itemprop="dateCreated datePublished" datetime="2021-07-31T16:03:12+08:00">2021-07-31</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-13 17:44:08" itemprop="dateModified" datetime="2023-02-13T17:44:08+08:00">2023-02-13</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/alex-next/categories/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1-入门"><a href="#1-入门" class="headerlink" title="1.入门"></a>1.入门</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h3 id="五种数据结构"><a href="#五种数据结构" class="headerlink" title="五种数据结构"></a>五种数据结构</h3><ul>
<li><p>字符串</p>
<ul>
<li><p>常用操作</p>
<ul>
<li><p>set key value</p>
<ul>
<li>存入键值对</li>
</ul>
</li>
<li><p>mset key value [key value…]</p>
<ul>
<li>批量存储键值对</li>
</ul>
</li>
<li><p>setnx key value</p>
<ul>
<li>分布式锁，获取锁成功返回1，否则返回0</li>
</ul>
</li>
<li><p>get key</p>
<ul>
<li>获取value</li>
</ul>
</li>
<li><p>mget key [key…]</p>
<ul>
<li>批量获取value</li>
</ul>
</li>
<li><p>del key </p>
<ul>
<li>删除key</li>
</ul>
</li>
</ul>
</li>
<li><p>原子加减</p>
<ul>
<li><p>incr key</p>
<ul>
<li>key中存储的数字值加1</li>
</ul>
</li>
<li><p>decr key</p>
<ul>
<li>key中存储的数字值减1</li>
</ul>
</li>
<li><p>incrby key increment</p>
<ul>
<li>将key所储存的值加上increment</li>
</ul>
</li>
<li><p>decrby key increment</p>
<ul>
<li>将key所储存的值减去increment</li>
</ul>
</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li>文章阅读量</li>
<li>web集群session共享</li>
<li>分布式系统全局序列号</li>
</ul>
</li>
</ul>
</li>
<li><p>哈希</p>
<ul>
<li><p>记忆</p>
<ul>
<li>key类似对象，field类似属性，value类似属性值</li>
</ul>
</li>
<li><p>常用操作</p>
<ul>
<li><p>hset key field value</p>
<ul>
<li>存储一个哈希表的键值</li>
</ul>
</li>
<li><p>HSETNX  key  field  value</p>
<ul>
<li>分布式锁</li>
</ul>
</li>
<li><p>HMSET  key  field  value [field value …]</p>
<ul>
<li>批量存储</li>
</ul>
</li>
<li><p>HGET  key  field</p>
<ul>
<li>获取哈希表key对应的field键值</li>
</ul>
</li>
<li><p>HMGET  key  field  [field …]</p>
<ul>
<li>批量获取</li>
</ul>
</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li><p>电商购物车</p>
<ul>
<li><p>存储</p>
<ul>
<li>1）以用户id为key</li>
<li>2）商品id为field</li>
<li>3）商品数量为value</li>
</ul>
</li>
<li><p>操作</p>
<ul>
<li>添加商品：hset cart:1001 10088 1</li>
<li>增加数量：hincrby cart:1001 10088 1</li>
<li>商品总数：hlen cart:1001</li>
<li>删除商品：hdel cart:1001 10088</li>
<li>获取购物车所有商品：hgetall cart:1001</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>优缺点</p>
<ul>
<li><p>优点</p>
<ul>
<li>同类数据归类整合储存，方便数据管理</li>
<li>相比string操作消耗内存与cpu更小</li>
<li>相比string储存更节省空间</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>过期功能不能使用在field上，只能用在key上</li>
<li>Redis集群架构下不适合大规模使用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>列表</p>
<ul>
<li><p>常用操作</p>
<ul>
<li><p>LPUSH  key  value [value …]</p>
<ul>
<li>将一个或多个值value插入到key列表的表头(最左边)</li>
</ul>
</li>
<li><p>RPUSH  key  value [value …]</p>
<ul>
<li>将一个或多个值value插入到key列表的表尾(最右边)</li>
</ul>
</li>
<li><p>LPOP  key</p>
<ul>
<li>移除并返回key列表的头元素</li>
</ul>
</li>
<li><p>RPOP  key</p>
<ul>
<li>移除并返回key列表的尾元素</li>
</ul>
</li>
<li><p>LRANGE  key  start  stop</p>
<ul>
<li>返回列表key中指定区间内的元素，区间以偏移量start和stop指定</li>
</ul>
</li>
<li><p>BLPOP  key  [key …]  timeout</p>
<ul>
<li>从key列表表头弹出一个元素，若列表中没有元素，阻塞等待timeout秒,如果timeout=0,一直阻塞等待</li>
</ul>
</li>
<li><p>BRPOP  key  [key …]  timeout</p>
<ul>
<li>从key列表表尾弹出一个元素，若列表中没有元素，阻塞等待timeout秒,如果timeout=0,一直阻塞等待</li>
</ul>
</li>
</ul>
</li>
<li><p>常用数据结构</p>
<ul>
<li>Stack(栈) = LPUSH + LPOP</li>
<li>Queue(队列）= LPUSH + RPOP</li>
<li>Blocking MQ(阻塞队列）= LPUSH + BRPOP</li>
</ul>
</li>
<li><p>和Java的区别</p>
<ul>
<li>分布式多台电脑访问</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li><p>微信公众号推送消息流</p>
<ul>
<li>使用栈结构后进先出</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>集合</p>
<ul>
<li><p>常用操作</p>
<ul>
<li><p>SADD  key  member  [member …]</p>
<ul>
<li>往集合key中存入元素，元素存在则忽略，若key不存在则新建</li>
</ul>
</li>
<li><p>SREM  key  member  [member …]</p>
<ul>
<li>从集合key中删除元素</li>
</ul>
</li>
<li><p>SMEMBERS  key</p>
<ul>
<li>获取集合key中所有元素</li>
</ul>
</li>
<li><p>SCARD  key</p>
<ul>
<li>获取集合key的元素个数</li>
</ul>
</li>
<li><p>SISMEMBER  key  member</p>
<ul>
<li>判断member元素是否存在于集合key中</li>
</ul>
</li>
<li><p>SRANDMEMBER  key  [count]</p>
<ul>
<li>从集合key中选出count个元素，元素不从key中删除</li>
</ul>
</li>
<li><p>SPOP  key  [count]</p>
<ul>
<li>从集合key中选出count个元素，元素从key中删除</li>
</ul>
</li>
</ul>
</li>
<li><p>集合运算操作</p>
<ul>
<li><p>SINTER  key  [key …]</p>
<ul>
<li>交集运算</li>
</ul>
</li>
<li><p>SUNION  key  [key ..]</p>
<ul>
<li>并集运算</li>
</ul>
</li>
<li><p>SDIFF  key  [key …]</p>
<ul>
<li><p>差集运算</p>
<ul>
<li>集合A在集合B,C…中都没有的元素</li>
</ul>
</li>
</ul>
</li>
<li><p>SINTERSTORE  destination  key  [key ..]</p>
<ul>
<li>将交集结果存入新集合destination中</li>
</ul>
</li>
<li><p>SUNIONSTORE  destination  key  [key …]</p>
<ul>
<li>将并集结果存入新集合destination中</li>
</ul>
</li>
<li><p>SDIFFSTORE  destination  key  [key …]</p>
<ul>
<li>将差集结果存入新集合destination中</li>
</ul>
</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li><p>微信抽奖</p>
<ul>
<li><p>参加过得不能参加，适合不重复抽奖</p>
<ul>
<li>SADD key {userlD}</li>
</ul>
</li>
<li><p>抽取count名中奖者，适合重复抽奖</p>
<ul>
<li>SRANDMEMBER key [count] / SPOP key [count]</li>
</ul>
</li>
</ul>
</li>
<li><p>微信朋友圈点赞</p>
<ul>
<li>点赞过不能在点赞</li>
<li>取消点赞</li>
</ul>
</li>
<li><p>微博微信关注模型</p>
<ul>
<li><p>1) 诸葛老师关注的人: </p>
<ul>
<li>zhugeSet-&gt; {guojia, xushu}</li>
</ul>
</li>
<li><p>2) 杨过老师关注的人:</p>
<ul>
<li>yangguoSet—&gt; {zhuge, baiqi, guojia, xushu}</li>
</ul>
</li>
<li><p>3) 郭嘉老师关注的人: </p>
<ul>
<li>guojiaSet-&gt; {zhuge, yangguo, baiqi, xushu, xunyu)</li>
</ul>
</li>
<li><p>4) 我和杨过老师共同关注: </p>
<ul>
<li>SINTER zhugeSet yangguoSet—&gt; {guojia, xushu}</li>
</ul>
</li>
<li><p>5) 我关注的人也关注他(杨过老师): </p>
<ul>
<li>SISMEMBER guojiaSet yangguo </li>
<li>SISMEMBER xushuSet yangguo</li>
</ul>
</li>
<li><p>6) 我可能认识的人: </p>
<ul>
<li>SDIFF yangguoSet zhugeSet-&gt;(zhuge, baiqi}</li>
</ul>
</li>
</ul>
</li>
<li><p>集合操作实现电商商品筛选</p>
<ul>
<li><p>存储</p>
<ul>
<li>SADD  brand:huawei  P40</li>
<li>SADD  brand:xiaomi  mi-10</li>
<li>SADD  brand:iPhone iphone12</li>
<li>SADD os:android  P40  mi-10</li>
<li>SADD cpu:brand:intel  P40  mi-10</li>
<li>SADD ram:8G  P40  mi-10  iphone12</li>
</ul>
</li>
<li><p>操作</p>
<ul>
<li>SINTER  os:android  cpu:brand:intel  ram:8G -&gt;{P40，mi-10}</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>有序集合</p>
<ul>
<li><p>常用操作</p>
<ul>
<li><p>ZADD key score member [[score member]…]</p>
<ul>
<li>往有序集合key中加入带分值元素</li>
</ul>
</li>
<li><p>ZREM key member [member …]</p>
<ul>
<li>从有序集合key中删除元素</li>
</ul>
</li>
<li><p>ZSCORE key member</p>
<ul>
<li>返回有序集合key中元素member的分值</li>
</ul>
</li>
<li><p>ZINCRBY key increment member</p>
<ul>
<li>为有序集合key中元素member的分值加上increment </li>
</ul>
</li>
<li><p>ZCARD key</p>
<ul>
<li>返回有序集合key中元素个数</li>
</ul>
</li>
<li><p>ZRANGE key start stop [WITHSCORES]</p>
<ul>
<li>正序获取有序集合key从start下标到stop下标的元素</li>
</ul>
</li>
<li><p>ZREVRANGE key start stop [WITHSCORES]</p>
<ul>
<li>倒序获取有序集合key从start下标到stop下标的元素</li>
</ul>
</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li><p>排行榜</p>
<ul>
<li><p>1）点击新闻</p>
<ul>
<li>ZINCRBY  hotNews:20190819  1  守护香港</li>
</ul>
</li>
<li><p>2）展示当日排行前十</p>
<ul>
<li>ZREVRANGE  hotNews:20190819  0  9  WITHSCORES </li>
</ul>
</li>
<li><p>3）七日搜索榜单计算</p>
<ul>
<li>ZUNIONSTORE  hotNews:20190813-20190819  7 hotNews:20190813  hotNews:20190814… hotNews:20190819</li>
</ul>
</li>
<li><p>4）展示七日排行前十</p>
<ul>
<li>ZREVRANGE hotNews:20190813-20190819  0  9  WITHSCORES</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="其他高级命令"><a href="#其他高级命令" class="headerlink" title="其他高级命令"></a>其他高级命令</h3><ul>
<li><p>keys</p>
<ul>
<li>全量遍历键，效率低</li>
</ul>
</li>
<li><p>scan</p>
<ul>
<li>SCAN cursor [MATCH pattern] [COUNT count]</li>
<li><p>例子</p>
<ul>
<li>scan 0 match zhuge* count 3</li>
</ul>
</li>
<li><p>上述例子，是指从全量键中获取，并不一定是3个，可能比3个多，而且还要考虑多线程下增删改操作</p>
</li>
</ul>
</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p>Redis是单线程吗</p>
<ul>
<li>Redis 的单线程主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外 提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</li>
</ul>
</li>
<li><p>Redis不是单线程为什么还能这么快</p>
<ul>
<li>因为它所有数据都在内存中，所有的运算都是内存级别的运算</li>
</ul>
</li>
<li><p>Redis 单线程如何处理那么多的并发客户端连接</p>
<ul>
<li><p>NIO多路复用</p>
<ul>
<li>redis利用epoll来实现IO多路复用，将连接信息和事件放到队列中，依次放到 文件事件分派器，事件分派器将事件分发给事件处理器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-持久化、主从与哨兵集群架构"><a href="#2-持久化、主从与哨兵集群架构" class="headerlink" title="2.持久化、主从与哨兵集群架构"></a>2.持久化、主从与哨兵集群架构</h2><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><ul>
<li><p>RDB快照</p>
<ul>
<li>在默认情况下， Redis 将内存数据库快照保存在名字为 dump.rdb 的二进制文件中，也可以手动执行save或bgsave</li>
<li><p>save</p>
<ul>
<li>save是同步的，会阻塞客户端命令，影响Redis性能</li>
</ul>
</li>
<li><p>bgsave</p>
<ul>
<li>bgsave是异步的，使用copyonwrite机制</li>
</ul>
</li>
<li><p>save与bgsave对比</p>
</li>
<li><p>关闭RDB</p>
<ul>
<li>只需要把所有save 60 10000(60s内有10000个键被改动)注释掉</li>
</ul>
</li>
</ul>
</li>
<li><p>AOF</p>
<ul>
<li><p>AOF默认关闭，修改配置文件打开AOF</p>
<ul>
<li>appendonly yes</li>
</ul>
</li>
<li><p>可以配置多久将数据fsync到磁盘</p>
<ul>
<li><p>appendfsync always</p>
<ul>
<li>每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全。</li>
</ul>
</li>
<li><p>appendfsync everysec </p>
<ul>
<li>每秒 fsync 一次，足够快，并且在故障时只会丢失 1 秒钟的数据。</li>
</ul>
</li>
<li><p>appendfsync no</p>
<ul>
<li>从不 fsync ，将数据交给操作系统来处理。更快，也更不安全的选择。</li>
</ul>
</li>
<li><p>推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>RDB和AOF对比</p>
<ul>
<li>RDB更快是因为RDB是二进制存储的</li>
</ul>
</li>
<li><p>混合持久化</p>
<ul>
<li><p>redis4.0之后，其实就是AOF使用二进制存储</p>
</li>
<li><p>开启</p>
<ul>
<li><h1 id="aof‐use‐rdb‐preamble-yes"><a href="#aof‐use‐rdb‐preamble-yes" class="headerlink" title="aof‐use‐rdb‐preamble yes"></a>aof‐use‐rdb‐preamble yes</h1></li>
</ul>
</li>
</ul>
</li>
<li><p>Redis数据备份策略</p>
<ul>
<li><ol>
<li>写crontab定时调度脚本，每小时都copy一份rdb或aof的备份到一个目录中去，仅仅保留最近48 小时的备份 </li>
</ol>
</li>
<li><ol>
<li>每天都保留一份当日的数据备份到一个目录中去，可以保留最近1个月的备份</li>
</ol>
</li>
<li><ol>
<li>每次copy备份的时候，都把太旧的备份给删了 </li>
</ol>
</li>
<li><ol>
<li>每天晚上将当前机器上的备份复制一份到其他机器上，以防机器损坏</li>
</ol>
</li>
</ul>
</li>
<li><p>细节</p>
<ul>
<li>RDB和AOF若同时开启，RDB和AOF只要满足相应条件，都会各自备份</li>
</ul>
</li>
</ul>
<h3 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h3><ul>
<li><p>工作原理</p>
<ul>
<li><p>全量复制</p>
<ul>
<li>1.slave发送psync同步数据与master建立socket连接</li>
<li>2.master收到psync执行bgsave生成最新rdb数据</li>
<li>2.2做rdb之后缓存写命令</li>
<li>3.master发送给slave  rdb数据</li>
<li>4.slave清空老数据并加载rdb文件(会在slave生成一份rdb文件)</li>
<li>5.master发给slave做rdb之后repl buffer中的写命令</li>
<li>6.slave将执行buffer中的写命令</li>
<li>7.master通过socket长连接持续给从节点发送写命令</li>
</ul>
</li>
<li><p>部分复制(断点续传)</p>
<ul>
<li>1.slave断开连接(故障)</li>
<li>2.master会在repl backlog buffer中缓存最近的写命令和slave的复制数据下标offset</li>
<li>3.之后slave和master在此建立socket连接</li>
<li>4.slave发送psync</li>
<li>5.slave的offset若在repl backlog buffer中，从缓存中取offset之后的数据一次性同步给slave，否则会全量更新</li>
<li>6.master通过socket长连接持续吧写命令发给从节点</li>
</ul>
</li>
<li><p>细节</p>
<ul>
<li>如果master收到了多 个slave并发连接请求，它只会进行一次持久化，而不是一个连接一次，然后再把这一份持久化的数据发送 给多个并发连接的slave</li>
<li><p>主从复制风暴(多个从节点同时复制主节点导致主节点压力过大)</p>
<ul>
<li>解决方案：让部分从节点与从节点(与主节点同步)同步数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>操作</p>
<ul>
<li><p>master结点配置文件不变</p>
</li>
<li><p>slave结点配置文件</p>
<ul>
<li><p>1.复制一份redis.conf文件(修改初始配置)</p>
</li>
<li><p>2.修改基本配置</p>
<ul>
<li><p>端口号</p>
<ul>
<li>port 6380</li>
</ul>
</li>
<li><p>pidfile文件</p>
<ul>
<li>只有linux有</li>
<li>pidfile /var/run/redis_6380.pid # 把pid进程号写入pidfile配置的文件</li>
</ul>
</li>
<li><p>日志文件</p>
<ul>
<li>logfile “6380.log”</li>
</ul>
</li>
<li><p>修改工作目录</p>
<ul>
<li>windows从cmd出来默认把用户目录当做工作目录</li>
<li>dir ./data</li>
</ul>
</li>
<li><p>注释bind</p>
<ul>
<li><p>windows试过不用注释掉(因为这次是在一台电脑上测试的，若是多台机器上测试要注释掉)</p>
</li>
<li><h1 id="bind-127-0-0-1"><a href="#bind-127-0-0-1" class="headerlink" title="bind 127.0.0.1"></a>bind 127.0.0.1</h1><ul>
<li>若是在一台机器上，这样配置没有问题；若主从结点在不同机器上用127.0.0.1访问不了其他节点，必须要用对外的ip地址</li>
</ul>
</li>
</ul>
</li>
<li><p>修改dbfilename或工作目录都行</p>
<ul>
<li>dbfilename dump-6380.rdb</li>
</ul>
</li>
</ul>
</li>
<li><p>3.配置主从复制</p>
<ul>
<li><p>replicaof 127.0.0.1 6379</p>
<ul>
<li>从本机6379的redis实例复制数据，Redis 5.0之前使用slaveof</li>
</ul>
</li>
<li><p>replica‐read‐only yes</p>
<ul>
<li>配置从节点只读</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>启动从结点</p>
<ul>
<li>redis-server ./conf/redis-6380.conf</li>
</ul>
</li>
<li><p>连接从节点</p>
<ul>
<li>redis‐cli ‐p 6380</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="哨兵高可用架构"><a href="#哨兵高可用架构" class="headerlink" title="哨兵高可用架构"></a>哨兵高可用架构</h3><ul>
<li><p>原理</p>
<ul>
<li><p>sentinel哨兵权限</p>
<ul>
<li>sentinel哨兵是特殊的redis服务，不提供读写服务，主要用来监控redis实例节点</li>
</ul>
</li>
<li><p>访问数据步骤</p>
<ul>
<li>哨兵架构下client端第一次从哨兵找出redis的主节点，后续就直接访问redis的主节点，不会每次都通过 sentinel代理访问redis的主节点</li>
<li>当redis的主节点发生变化，哨兵会第一时间感知到，并且将新的redis 主节点通知给client端(这里面redis的client端一般都实现了订阅功能，订阅sentinel发布的节点变动消息)</li>
</ul>
</li>
</ul>
</li>
<li><p>实验操作</p>
<ul>
<li><p>sentinel结点配置文件</p>
<ul>
<li><p>windows配置</p>
<ul>
<li>复制一份redis.conf文件(修改初始配置)</li>
<li><p>端口号</p>
<ul>
<li>port 26380</li>
</ul>
</li>
<li><p>pidfile文件</p>
<ul>
<li>只有linux有</li>
<li>pidfile /var/run/redis_6380.pid # 把pid进程号写入pidfile配置的文件</li>
</ul>
</li>
<li><p>daemonize yes</p>
<ul>
<li>只有linux有</li>
<li>用来指定redis是否要用守护线程的方式启动</li>
</ul>
</li>
<li><p>日志文件</p>
<ul>
<li>logfile “6380.log”</li>
</ul>
</li>
<li><p>修改工作目录</p>
<ul>
<li>windows从cmd出来默认把用户目录当做工作目录</li>
<li>dir ./data</li>
</ul>
</li>
<li><p>修改sentinel monitor</p>
<ul>
<li>sentinel monitor mymaster 192.168.0.60 6379 2</li>
</ul>
</li>
</ul>
</li>
<li><p>windows配置</p>
<ul>
<li><p>新建sentinel.conf文件</p>
</li>
<li><p>port 26379</p>
<ul>
<li><h1 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h1></li>
</ul>
</li>
<li><p>sentinel monitor mymaster 127.0.0.1 6379 2</p>
<ul>
<li><h1 id="哨兵监听的主服务器-后面的2表示主机挂掉以后进行投票，只需要2票就可以从机编程主机"><a href="#哨兵监听的主服务器-后面的2表示主机挂掉以后进行投票，只需要2票就可以从机编程主机" class="headerlink" title="哨兵监听的主服务器    后面的2表示主机挂掉以后进行投票，只需要2票就可以从机编程主机"></a>哨兵监听的主服务器 <master名称> <master的ip> <master端口号> 后面的2表示主机挂掉以后进行投票，只需要2票就可以从机编程主机</master端口号></master的ip></master名称></h1></li>
</ul>
</li>
<li><p>sentinel down-after-milliseconds mymaster 5000</p>
<ul>
<li><h1 id="指定了Sentinel认为Redis实例已经失效所需的毫秒数。"><a href="#指定了Sentinel认为Redis实例已经失效所需的毫秒数。" class="headerlink" title="指定了Sentinel认为Redis实例已经失效所需的毫秒数。"></a>指定了Sentinel认为Redis实例已经失效所需的毫秒数。</h1></li>
</ul>
</li>
<li><h1 id="sentinel-failover-timeout-mymaster-18000"><a href="#sentinel-failover-timeout-mymaster-18000" class="headerlink" title="sentinel failover-timeout mymaster 18000"></a>sentinel failover-timeout mymaster 18000</h1><ul>
<li><h1 id="如果在该时间（ms）内未能完成failover操作，则认为该failover失败"><a href="#如果在该时间（ms）内未能完成failover操作，则认为该failover失败" class="headerlink" title="如果在该时间（ms）内未能完成failover操作，则认为该failover失败"></a>如果在该时间（ms）内未能完成failover操作，则认为该failover失败</h1></li>
</ul>
</li>
<li><h1 id="sentinel-notification-script"><a href="#sentinel-notification-script" class="headerlink" title="sentinel notification-script  "></a>sentinel notification-script <master-name> <script-path></script-path></master-name></h1><ul>
<li><h1 id="指定sentinel检测到该监控的redis实例指向的实例异常时，调用的报警脚本。该配置项可选，但是很常用"><a href="#指定sentinel检测到该监控的redis实例指向的实例异常时，调用的报警脚本。该配置项可选，但是很常用" class="headerlink" title="指定sentinel检测到该监控的redis实例指向的实例异常时，调用的报警脚本。该配置项可选，但是很常用"></a>指定sentinel检测到该监控的redis实例指向的实例异常时，调用的报警脚本。该配置项可选，但是很常用</h1></li>
</ul>
</li>
<li><p>dir ./data/s26380</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>启动</p>
<ul>
<li><p>redis</p>
<ul>
<li>src/redis‐sentinel sentinel‐26379.conf</li>
</ul>
</li>
<li><p>windows</p>
<ul>
<li>redis-server ./conf/sentinel-26379.conf —sentinel</li>
</ul>
</li>
</ul>
</li>
<li><p>实验结果</p>
<ul>
<li>启动一个循环往主结点中丢数据的程序，然后，将主节点手动关闭，可以观察到在报错过了3-5s后，又开始往redis中放数据(sentinel选举出了新的master结点)</li>
<li><p>主节点挂掉的话</p>
<ul>
<li>会修改相应sentinel的conf文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Jedis-RedisTemplate"><a href="#Jedis-RedisTemplate" class="headerlink" title="Jedis/RedisTemplate"></a>Jedis/RedisTemplate</h3><ul>
<li><p>lua脚本事务</p>
<ul>
<li><p>减少网络开销</p>
<ul>
<li>本来5次网络请求的操作，可以用一个请求完成，原先5次请求的逻辑放在redis服务器 上完成。使用脚本，减少了网络往返时延。这点跟管道类似</li>
</ul>
</li>
<li><p>原子操作</p>
<ul>
<li>Redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。管道不是原子的，不过 redis的批量操作命令(类似mset)是原子的</li>
</ul>
</li>
<li><p>替代redis的事务功能</p>
</li>
</ul>
</li>
<li><p>管道</p>
<ul>
<li>客户端可以一次性发送多个请求而不用等待服务器的响应(不然每条命令都需要连接(比较耗时))</li>
<li>管道中前面命令失败，后面命令 不会有影响，继续执行</li>
</ul>
</li>
<li><p>RedisTemplate</p>
<ul>
<li>StringRedisTemplate继承自RedisTemplate，在redis命令窗口查看不会是/xx,/xx的形式</li>
<li>RedisTemplate与Redis命令对应参考</li>
</ul>
</li>
</ul>
<h3 id="实验注意"><a href="#实验注意" class="headerlink" title="实验注意"></a>实验注意</h3><ul>
<li>redis-server要在安装目录下执行，否则用的不是安装目录下的配置文件，直接win+R运行，当前的工作目录就是用户文件夹</li>
<li>windows实验的时候点击开启redis的黑窗口可能阻塞该进程</li>
</ul>
<h2 id="3-Redis-Cluster集群、原理"><a href="#3-Redis-Cluster集群、原理" class="headerlink" title="3.Redis Cluster集群、原理"></a>3.Redis Cluster集群、原理</h2><h3 id="集群实验"><a href="#集群实验" class="headerlink" title="集群实验"></a>集群实验</h3><ul>
<li><p>集群配置</p>
<ul>
<li><p>1.复制redis.conf</p>
</li>
<li><p>2.修改配置文件</p>
<ul>
<li><p>daemonize yes</p>
<ul>
<li>windows无</li>
</ul>
</li>
<li><p>port 8001</p>
</li>
<li><p>pidfile /var/run/redis_8001.pid</p>
<ul>
<li>windows无</li>
</ul>
</li>
<li><p>dir /usr/local/redis‐cluster/8001/</p>
</li>
<li><p>cluster‐enabled yes</p>
</li>
<li><p>cluster‐config‐file nodes‐8001.conf</p>
<ul>
<li>集群节点信息文件，这里800x最好和port对应上</li>
</ul>
</li>
<li><p>cluster‐node‐timeout 10000</p>
</li>
<li><h1 id="bind-127-0-0-1-1"><a href="#bind-127-0-0-1-1" class="headerlink" title="bind 127.0.0.1"></a>bind 127.0.0.1</h1><ul>
<li>bind绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip，代表允许客户端通 过机器的哪些网卡ip去访问，内网一般可以不配置bind，注释掉即可</li>
<li>若是在一台机器上，这样配置没有问题；若主从结点在不同机器上用127.0.0.1访问不了其他节点，必须要用对外的ip地址</li>
</ul>
</li>
<li><p>protected‐mode no</p>
<ul>
<li>关闭保护模式</li>
</ul>
</li>
<li><p>appendonly yes</p>
</li>
<li><p>设置密码</p>
<ul>
<li>requirepass zhuge</li>
<li>masterauth zhuge</li>
</ul>
</li>
</ul>
</li>
<li><p>开启结点</p>
<ul>
<li>redis-server ./cluster_conf/8001/redis-8001.conf</li>
</ul>
</li>
<li><p>3.创建集群</p>
<ul>
<li><p>细节</p>
<ul>
<li>在创建集群之前，要先把所有节点启动起来</li>
<li>不创建集群的话，所有节点只是独立的</li>
</ul>
</li>
<li><p>windows</p>
<ul>
<li>redis-cli —cluster create —cluster-replicas 1 127.0.0.1:8001 127.0.0.1:8002 127.0.0.1:8003 127.0.0.1:8004 127.0.0.1:8005 127.0.0.1:8006</li>
<li>‐‐cluster‐replicas后的1表示为每个master配置1个从节点</li>
</ul>
</li>
<li><p>linux</p>
<ul>
<li>/usr/local/redis‐5.0.3/src/redis-cli -a zhuge —cluster create —cluster-replicas 1 192.168.0.61:8001 192.168.0.62:8002 192.168.0.63:8003 192.168.0.61:8004 192.168.0.62:8005 192. 168.0.63:8006</li>
</ul>
</li>
</ul>
</li>
<li><p>4.验证</p>
<ul>
<li>redis-cli -c -p 8001</li>
<li>cluster nodes</li>
<li>cluster info</li>
</ul>
</li>
</ul>
</li>
<li><p>水平扩展</p>
<ul>
<li><p>水平扩展</p>
<ul>
<li>不关闭集群的情况下增加结点</li>
</ul>
</li>
<li><p>步骤</p>
<ul>
<li>复制修改redis.conf同集群配置</li>
<li><p>开启结点(8007,8008)</p>
<ul>
<li>redis-server ./cluster_conf/8007/redis-8007.conf</li>
</ul>
</li>
<li><p>配置水平扩展的集群主节点</p>
<ul>
<li>redis-cli —cluster add-node 127.0.0.1:8007 127.0.0.1:8001</li>
<li>add-node第一个是要添加的，第二个是已知的结点(要连上这个网络分区，随便选一个此网络分区的结点即可)</li>
</ul>
</li>
<li><p>给新的集群主节点分配槽位</p>
<ul>
<li>redis-cli —cluster reshard 127.0.0.1:8007(任意改网络分区的节点)</li>
<li>细节</li>
</ul>
</li>
<li><p>添加从节点8008</p>
<ul>
<li><p>redis-cli —cluster add-node 127.0.0.1:8008 127.0.0.1:8001</p>
<ul>
<li>加入该网络分区</li>
</ul>
</li>
<li><p>redis-cli进入8008</p>
<ul>
<li>cluster replicate 2728a594a0498e98e4b83a537e19f9a0a3790f38 #后面这串id为8007的节点id</li>
</ul>
</li>
</ul>
</li>
<li><p>删除结点参考文件</p>
</li>
</ul>
</li>
<li><p>图解</p>
</li>
</ul>
</li>
<li><p>细节</p>
<ul>
<li>集群信息都保存在了nodes-8002.conf中，关闭之后重新启动，不需要再创建集群</li>
</ul>
</li>
</ul>
<h3 id="集群原理"><a href="#集群原理" class="headerlink" title="集群原理"></a>集群原理</h3><ul>
<li><p>槽位定位</p>
<ul>
<li>Redis Cluster 将所有数据划分为 16384 个 slots(槽位)，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中。</li>
<li>Cluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384 进行取模 来得到具体槽位。</li>
</ul>
</li>
<li><p>集群结点通信机制</p>
<ul>
<li>redis cluster节点间采取gossip协议进行通信</li>
<li><p>gossip通知</p>
<ul>
<li>meet </li>
<li>ping</li>
<li>pong</li>
<li>fail</li>
</ul>
</li>
</ul>
</li>
<li><p>redis集群选举原理</p>
<ul>
<li>1.slave发现自己的master变为FAIL </li>
<li>2.将自己记录的集群currentEpoch加1，并广播FAILOVER_AUTH_REQUEST 信息</li>
<li>3.其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个 epoch只发送一次ack </li>
<li>4.尝试failover的slave收集master返回的FAILOVER_AUTH_ACK </li>
<li>5.slave收到超过半数master的ack后变成新Master(这里解释了集群为什么至少需要三个主节点，如果只有两个，当其中一个挂了，只剩一个主节点是不能选举成功的)</li>
<li>6.slave广播Pong消息通知其他集群节点</li>
<li><p>细节</p>
<ul>
<li><p>从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟</p>
<ul>
<li>DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms</li>
<li>SLAVE_RANK表示此slave已经从master复制数据的总量的rank</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>集群相关问题</p>
<ul>
<li><p>网络抖动</p>
<ul>
<li>突然之间部分连接变得不可访问，然后很快又恢复正常</li>
<li><p>为解决这种问题，Redis Cluster 提供了一种选项cluster­node­timeout，表示当某个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切换。</p>
<ul>
<li>如果没有这个选项，网络抖动会导致主从频 繁切换 (数据的重新复制</li>
</ul>
</li>
</ul>
</li>
<li><p>脑裂问题</p>
<ul>
<li>redis集群没有过半同意机制会有脑裂问题</li>
<li><p>产生结果</p>
<ul>
<li>网络分区导致脑裂后多个主节点对外提供写服务(人话：主节点一开始挂了，之后选举出了新主节点，然后老主节点(没有过半机制可能会被选上)恢复了，就发生脑裂现象)，一旦网络分区恢复， 会将其中一个主节点变为从节点，这时会有大量数据丢失</li>
</ul>
</li>
<li><p>解决方法</p>
<ul>
<li><p>min‐replicas‐to‐write 1</p>
<ul>
<li>写数据成功最少同步的slave数量，这个数量可以模仿大于半数机制配置，比如 集群总共三个节点可以配置1，加上leader就是2，超过了半数</li>
<li>会影响CAP中的可用性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>集群是否完整才能对外提供服务</p>
<ul>
<li>当redis.conf的配置cluster-require-full-coverage为no时，表示当负责一个插槽的主库下线且没有相应的从 库进行故障恢复时，集群仍然可用，如果为yes则集群不可用</li>
</ul>
</li>
<li><p>Redis集群为什么至少需要三个master节点，并且推荐节点数为奇数？</p>
<ul>
<li><p>至少需要三个master</p>
<ul>
<li>因为新master的选举需要大于半数的集群master节点同意才能选举成功，如果只有两个master节点，当其中一个挂了，是达不到选举新master的条件的</li>
</ul>
</li>
<li><p>节点数(master)为什么推荐奇数</p>
<ul>
<li>4个和3个master节点，都至多只能挂一个(3/4或2/3，因为要半数以上)，从资源利用上来说奇数个master更优</li>
</ul>
</li>
</ul>
</li>
<li><p>Redis集群对批量操作命令的支持</p>
<ul>
<li>redis集群只支持所有key落在同一slot的情况，如果有多个key一定要用mset命令在redis集群上操作，则可以在key的前面加上{XX}，这样参数数据分片hash计 算的只会是大括号里的值，这样能确保不同的key能落到同一slot里去</li>
<li><p>示例</p>
<ul>
<li>mset {user1}:1:name zhuge {user1}:1:age 18</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-C源码解读"><a href="#4-C源码解读" class="headerlink" title="4.C源码解读(*)"></a>4.C源码解读(*)</h2><h2 id="5-redis-6新特性"><a href="#5-redis-6新特性" class="headerlink" title="5.redis 6新特性(*)"></a>5.redis 6新特性(*)</h2><h2 id="6-缓存设计与性能优化"><a href="#6-缓存设计与性能优化" class="headerlink" title="6.缓存设计与性能优化"></a>6.缓存设计与性能优化</h2><h3 id="缓存设计的问题"><a href="#缓存设计的问题" class="headerlink" title="缓存设计的问题"></a>缓存设计的问题</h3><ul>
<li><p>缓存穿透</p>
<ul>
<li><p>含义</p>
<ul>
<li>大量请求的 key 是不合理的，根本不存在于缓存中，也不存在于数据库中 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</li>
</ul>
</li>
<li><p>产生原因</p>
<ul>
<li>自身业务代码或者数据出现问题。</li>
<li>一些恶意攻击、 爬虫等造成大量空命中</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li>1.缓存空对象</li>
<li>2.布隆过滤器</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存失效(击穿)</p>
<ul>
<li><p>含义</p>
<ul>
<li>请求的 key 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</li>
</ul>
</li>
<li><p>产生原因</p>
</li>
<li><p>解决方案</p>
<ul>
<li>设置热点数据永不过期或者过期时间比较长。</li>
<li>针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>
<li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存雪崩</p>
<ul>
<li><p>含义</p>
<ul>
<li>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</li>
</ul>
</li>
<li><p>产生原因</p>
</li>
<li><p>解决方案</p>
<ul>
<li><p>针对 Redis 服务不可用的情况</p>
<ul>
<li>1.采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>2.限流，避免同时处理大量的请求。</li>
</ul>
</li>
<li><p>针对热点缓存失效的情况</p>
<ul>
<li>1.设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>2.缓存永不失效（不太推荐，实用性太差）。</li>
<li>3.设置二级缓存。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>热点缓存key</p>
<ul>
<li><p>含义</p>
<ul>
<li>在缓存失效的瞬间， 有大量线程来重建缓存， 造成后端负载加大， 甚至可能会让应用崩溃。</li>
</ul>
</li>
<li><p>产生原因</p>
<ul>
<li>当前key是一个热点key（例如一个热门的娱乐新闻），并发量非常大。重建缓存不能在短时间完成， 可能是一个复杂计算， 例如复杂的SQL、 多次IO、 多个依赖等。</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li>利用互斥锁来解决，此方法只允许一个线程重建缓存， 其他线程等待重建缓存的线程执行完， 重新从缓存获取数据即可。</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存与数据库双写不一致</p>
<ul>
<li><p>含义</p>
<ul>
<li>缓存与数据库存在数据不一致问题</li>
</ul>
</li>
<li><p>产生原因</p>
<ul>
<li>大并发导致。。</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li>1、对于并发几率很小的数据(如个人维度的订单数据、用户数据等)，这种几乎不用考虑这个问题，很少会发生缓存不一致，可以给缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。</li>
<li>2、就算并发很高，如果业务上能容忍短时间的缓存数据不一致(如商品名称，商品分类菜单等)，缓存加上过期时间依然可以解决大部分业务对于缓存的要求。</li>
<li>3、如果不能容忍缓存数据不一致，可以通过加读写锁保证并发读写或写写的时候按顺序排好队，读读的时候相当于无锁。</li>
<li>4、也可以用阿里开源的canal通过监听数据库的binlog日志及时的去修改缓存，但是引入了新的中间件，增加了系统的复杂度。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="开发规范与性能优化"><a href="#开发规范与性能优化" class="headerlink" title="开发规范与性能优化"></a>开发规范与性能优化</h3>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://alexander-wd.github.io/alex-next/2021/05/29/算法/数据结构/数组模拟/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="alex">
      <meta itemprop="description" content="时光静好,与君语;细水流年,与君同;繁华落尽,与君老.">
      <meta itemprop="image" content="/alex-next/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="alex的博客 - github.com">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/alex-next/2021/05/29/算法/数据结构/数组模拟/" class="post-title-link" itemprop="url">数组模拟</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2021-05-29 10:53:20" itemprop="dateCreated datePublished" datetime="2021-05-29T10:53:20+08:00">2021-05-29</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-09 19:42:32" itemprop="dateModified" datetime="2021-06-09T19:42:32+08:00">2021-06-09</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/alex-next/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>为什么使用数组模拟单链表、双链表、栈、队列？</p>
<p>如果数据规模很大，一个一个new 速度太慢了，使用数组会大大加快速度。</p>
<h2 id="1-数组模拟单链表"><a href="#1-数组模拟单链表" class="headerlink" title="1.数组模拟单链表"></a>1.数组模拟单链表</h2><p><img alt="10048_8b47069add-数组表示单链表" data-src="https://gitee.com/alexander1/pic/raw/master/acwing/20210609111200.png"></p>
<p>在头部插入一个元素<code>x</code>：</p>
<p>先把值放到数据域中，让当前结点<code>next</code>指针指向<code>head</code>所指向的元素，让<code>head</code>指向当前元素，<code>idx</code>下移一位。<code>(idx</code>相当于元素的地址，<code>head</code>的值为第一个元素的地址<code>)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_head</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第<code>k</code>个输入的数后面插入一个元素<code>x</code>：</p>
<p>先把值放到数据域中，让当前结点<code>next</code>指针指向<code>k</code>的<code>next</code>域所指向的元素，让<code>k</code>的<code>next</code>指向当前元素，<code>idx</code>下移一位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除第k个输入的数后面的数：</p>
<p>让<code>k</code>的<code>next</code>指向<code>k</code>的<code>next</code>的<code>next</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>C++代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> idx,head = <span class="number">-1</span>,e[N],ne[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示向链表头插入一个数x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_head</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示在第k个输入的数后面插入一个数x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示删除第k个输入的数后面的数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        <span class="keyword">int</span> k,x;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">'D'</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">            <span class="keyword">if</span>(!k)head = ne[head];</span><br><span class="line">            remove(k<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">'H'</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            add_head(x);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">'I'</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            add(k<span class="number">-1</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head;i!=<span class="number">-1</span>;i=ne[i])<span class="built_in">printf</span>(<span class="string">"%d "</span>,e[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-数组模拟双链表"><a href="#2-数组模拟双链表" class="headerlink" title="2.数组模拟双链表"></a>2.数组模拟双链表</h2><p>初始化左指针域和右指针域</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>,l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第<code>k</code>个结点右边插入一个元素：</p>
<p>与单链表类似，但要注意先让<code>k</code>的右节点的左指针指向<code>idx</code>，在让<code>k</code>的右指针指向<code>idx</code>。否则，<code>l[r[k]]</code>中的<code>r[k]</code>已经不是原来的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    l[r[k]] = idx;</span><br><span class="line">    r[k] = idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将第<code>k</code> 个插入的数删除<code>(</code>序号<code>1,2,...n)</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>C++代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> e[N],l[N],r[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>,l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第k个结点右边插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    l[r[k]] = idx;</span><br><span class="line">    r[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示将第 k 个插入的数删除(序号1,2,...n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="keyword">int</span> k,x;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">"L"</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            add(<span class="number">0</span>,x);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">"R"</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            add(l[<span class="number">1</span>],x);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">"D"</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">            remove(k+<span class="number">1</span>);    </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">"IL"</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            add(l[k+<span class="number">1</span>],x);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            add(k+<span class="number">1</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r[<span class="number">0</span>];i!=<span class="number">1</span>;i=r[i])<span class="built_in">printf</span>(<span class="string">"%d "</span>,e[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-数组模拟队列"><a href="#3-数组模拟队列" class="headerlink" title="3.数组模拟队列"></a>3.数组模拟队列</h2><p>当<code>tt&lt;hh</code>时，队列为空</p>
<p>队头为<code>q[hh]</code>，出队列<code>hh++</code></p>
<p><strong>c++代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N],hh,tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">"push"</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            q[++tt] = x;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">"pop"</span>)&#123;</span><br><span class="line">            hh++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">"empty"</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hh&lt;=tt)<span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;q[hh]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-数组模拟栈"><a href="#4-数组模拟栈" class="headerlink" title="4.数组模拟栈"></a>4.数组模拟栈</h2><p>当<code>tt=-1</code>时，栈为空</p>
<p>出栈<code>tt--</code></p>
<p><strong>c++代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[N],tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">"push"</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">            stk[++tt] = a;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"pop"</span>)&#123;</span><br><span class="line">            tt--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"query"</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,stk[tt]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"empty"</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;(tt==<span class="number">-1</span>?<span class="string">"YES"</span>:<span class="string">"NO"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/alex-next/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/alex-next/">1</a><a class="page-number" href="/alex-next/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/alex-next/page/4/">4</a><a class="page-number" href="/alex-next/page/5/">5</a><a class="extend next" rel="next" href="/alex-next/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/alex-next/images/avatar.jpg"
      alt="alex">
  <p class="site-author-name" itemprop="name">alex</p>
  <div class="site-description" itemprop="description">时光静好,与君语;细水流年,与君同;繁华落尽,与君老.</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/alex-next/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/alex-next/categories/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/alex-next/tags/">
          
        
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/alex-next/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">alex</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/alex-next/lib/anime.min.js?v=3.1.0"></script>
  <script src="/alex-next/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/alex-next/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script src="/alex-next/lib/pjax/pjax.min.js?v=0.2.8"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
<script src="/alex-next/js/utils.js?v=7.4.0"></script><script src="/alex-next/js/motion.js?v=7.4.0"></script>
<script src="/alex-next/js/schemes/pisces.js?v=7.4.0"></script>
<script src="/alex-next/js/next-boot.js?v=7.4.0"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var id = element.id || '';
    var src = element.src || '';
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (id !=='') {
      script.id = element.id;
    }
    if (src !== '') {
      script.src = src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  








  <script src="/alex-next/js/local-search.js?v=7.4.0"></script>













    <div id="pjax">

  

  
    
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    
  

  

  


    </div>
</body>
</html>
