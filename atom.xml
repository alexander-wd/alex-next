<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>alex的博客 - github.com</title>
  
  
  <link href="/alex-next/atom.xml" rel="self"/>
  
  <link href="https://alexander-wd.github.io/"/>
  <updated>2023-02-13T10:41:14.331Z</updated>
  <id>https://alexander-wd.github.io/</id>
  
  <author>
    <name>alex</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis面试题</title>
    <link href="https://alexander-wd.github.io/2023/01/13/%E9%9D%A2%E8%AF%95%E9%A2%98/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://alexander-wd.github.io/2023/01/13/%E9%9D%A2%E8%AF%95%E9%A2%98/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-01-13T09:10:20.000Z</published>
    <updated>2023-02-13T10:41:14.331Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="1-为什么要用-Redis-为什么要用缓存？"><a href="#1-为什么要用-Redis-为什么要用缓存？" class="headerlink" title="1.为什么要用 Redis/为什么要用缓存？"></a>1.为什么要用 Redis/为什么要用缓存？</h4><p><strong>高性能</strong></p><p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。</p><p><strong>这样有什么好处呢？</strong> 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p><p><strong>高并发</strong></p><p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。</p><h4 id="2-Redis-除了做缓存，还能做什么？"><a href="#2-Redis-除了做缓存，还能做什么？" class="headerlink" title="2.Redis 除了做缓存，还能做什么？"></a>2.Redis 除了做缓存，还能做什么？</h4><p><strong>分布式锁</strong> ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：<a href="https://javaguide.cn/distributed-system/distributed-lock.html" target="_blank" rel="noopener">分布式锁详解open in new window</a> 。</p><p><strong>限流</strong> ：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：<a href="https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA" target="_blank" rel="noopener">《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》open in new window</a>。</p><p><strong>消息队列</strong> ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</p><p><strong>复杂业务场景</strong> ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="1-Redis-常用的数据结构有哪些？"><a href="#1-Redis-常用的数据结构有哪些？" class="headerlink" title="1.Redis 常用的数据结构有哪些？"></a>1.Redis 常用的数据结构有哪些？</h4><ul><li><strong>5 种基础数据结构</strong> ：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li><li><strong>3 种特殊数据结构</strong> ：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</li></ul><h4 id="2-String-的应用场景有哪些？"><a href="#2-String-的应用场景有哪些？" class="headerlink" title="2.String 的应用场景有哪些？"></a>2.String 的应用场景有哪些？</h4><ul><li>常规数据（比如 session、token、、序列化后的对象）的缓存；</li><li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li><li>分布式锁(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)；</li></ul><h4 id="3-String-还是-Hash-存储对象数据更好呢？"><a href="#3-String-还是-Hash-存储对象数据更好呢？" class="headerlink" title="3.String 还是 Hash 存储对象数据更好呢？"></a>3.String 还是 Hash 存储对象数据更好呢？</h4><ul><li>String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</li><li>String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</li></ul><p>在绝大部分情况，我们建议使用 String 来存储对象数据即可！</p><h4 id="4-购物车信息用-String-还是-Hash-存储更好呢"><a href="#4-购物车信息用-String-还是-Hash-存储更好呢" class="headerlink" title="4.购物车信息用 String 还是 Hash 存储更好呢?"></a>4.购物车信息用 String 还是 Hash 存储更好呢?</h4><p>由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：</p><ul><li>用户 id 为 key</li><li>商品 id 为 field，商品数量为 value</li></ul><p><img alt="3" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Redis/20230131143501.png"><br>操作<br>    添加商品：hset cart:1001 10088 1<br>    增加数量：hincrby cart:1001 10088 1<br>    商品总数：hlen cart:1001<br>    删除商品：hdel cart:1001 10088<br>    获取购物车所有商品：hgetall cart:1001</p><h4 id="5-使用-Redis-实现一个排行榜怎么做？"><a href="#5-使用-Redis-实现一个排行榜怎么做？" class="headerlink" title="5.使用 Redis 实现一个排行榜怎么做？"></a>5.使用 Redis 实现一个排行榜怎么做？</h4><p>Redis 中有一个叫做 <code>sorted set</code> 的数据结构经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</p><p>相关的一些 Redis 命令: <code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</p><p><img alt="8" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Redis/20230131143757.png"></p><h4 id="6-使用-Set-实现抽奖系统需要用到什么命令？"><a href="#6-使用-Set-实现抽奖系统需要用到什么命令？" class="headerlink" title="6.使用 Set 实现抽奖系统需要用到什么命令？"></a>6.使用 Set 实现抽奖系统需要用到什么命令？</h4><ul><li><code>SPOP key count</code> ： 随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li><li><code>SRANDMEMBER key count</code> : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li></ul><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><h4 id="1-Redis是单线程吗"><a href="#1-Redis是单线程吗" class="headerlink" title="1.Redis是单线程吗"></a>1.Redis是单线程吗</h4><p>​    Redis 的单线程主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外 提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</p><h4 id="2-Redis不是单线程为什么还能这么快"><a href="#2-Redis不是单线程为什么还能这么快" class="headerlink" title="2.Redis不是单线程为什么还能这么快"></a>2.Redis不是单线程为什么还能这么快</h4><p>​    因为它所有数据都在内存中，所有的运算都是内存级别的运算</p><h4 id="3-Redis-单线程如何处理那么多的并发客户端连接"><a href="#3-Redis-单线程如何处理那么多的并发客户端连接" class="headerlink" title="3.Redis 单线程如何处理那么多的并发客户端连接"></a>3.Redis 单线程如何处理那么多的并发客户端连接</h4><p>​    NIO多路复用<br>​        redis利用epoll来实现IO多路复用，将连接信息和事件放到队列中，依次放到 文件事件分派器，事件分派器将事件分发给事件处理器</p><p><img alt="10" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Redis/20230131144326.png"></p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="1-Redis-给缓存数据设置过期时间有啥用？"><a href="#1-Redis-给缓存数据设置过期时间有啥用？" class="headerlink" title="1.Redis 给缓存数据设置过期时间有啥用？"></a>1.Redis 给缓存数据设置过期时间有啥用？</h4><p>1.<strong>有助于缓解内存的消耗</strong></p><p>2.自动判断过期数据并删除，比传统数据库要方便</p><h4 id="2-过期的数据的删除策略了解么？"><a href="#2-过期的数据的删除策略了解么？" class="headerlink" title="2.过期的数据的删除策略了解么？"></a>2.过期的数据的删除策略了解么？</h4><p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p><p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p><ol><li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li><li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li></ol><p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p><p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p><p>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制。</strong></p><h4 id="3-Redis-内存淘汰机制了解么？"><a href="#3-Redis-内存淘汰机制了解么？" class="headerlink" title="3.Redis 内存淘汰机制了解么？"></a>3.Redis 内存淘汰机制了解么？</h4><blockquote><p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p></blockquote><p>Redis 提供 6 种数据淘汰策略：</p><p><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p><p><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p><p><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p><p><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</p><p><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</p><p><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</p><p>4.0 版本后增加以下两种：</p><p><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</p><p><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</p><h3 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h3><h4 id="1-怎么保证-Redis-挂掉之后再重启数据可以进行恢复"><a href="#1-怎么保证-Redis-挂掉之后再重启数据可以进行恢复" class="headerlink" title="1.怎么保证 Redis 挂掉之后再重启数据可以进行恢复"></a>1.怎么保证 Redis 挂掉之后再重启数据可以进行恢复</h4><h4 id="2-什么是-RDB-持久化？"><a href="#2-什么是-RDB-持久化？" class="headerlink" title="2.什么是 RDB 持久化？"></a>2.什么是 RDB 持久化？</h4><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p><p>快照持久化是 Redis 默认采用的持久化方式，在 <code>redis.conf</code> 配置文件中默认有此下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br></pre></td></tr></table></figure><h4 id="3-RDB-创建快照时会阻塞主线程吗？"><a href="#3-RDB-创建快照时会阻塞主线程吗？" class="headerlink" title="3.RDB 创建快照时会阻塞主线程吗？"></a>3.RDB 创建快照时会阻塞主线程吗？</h4><p>Redis 提供了两个命令来生成 RDB 快照文件：</p><ul><li><code>save</code> : 主线程执行，会阻塞主线程；</li><li><code>bgsave</code> : 子线程执行，不会阻塞主线程，默认选项。</li></ul><h4 id="4-什么是-AOF-持久化？"><a href="#4-什么是-AOF-持久化？" class="headerlink" title="4.什么是 AOF 持久化？"></a>4.什么是 AOF 持久化？</h4><p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p><p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code></p><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    <span class="comment">#每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span></span><br><span class="line">appendfsync everysec  <span class="comment">#每秒钟同步一次，显式地将多个写命令同步到硬盘</span></span><br><span class="line">appendfsync no        <span class="comment">#让操作系统决定何时进行同步</span></span><br></pre></td></tr></table></figure><p>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p><h4 id="5-AOF-日志是如何实现的？"><a href="#5-AOF-日志是如何实现的？" class="headerlink" title="5.AOF 日志是如何实现的？"></a>5.AOF 日志是如何实现的？</h4><p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。</p><p><img alt="AOF 记录日志过程" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Redis/20230131155723.png"></p><p><strong>为什么是在执行完命令之后记录日志呢？</strong></p><ul><li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li><li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li></ul><p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p><ul><li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li><li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li></ul><h4 id="6-如何选择-RDB-和-AOF？"><a href="#6-如何选择-RDB-和-AOF？" class="headerlink" title="6.如何选择 RDB 和 AOF？"></a>6.如何选择 RDB 和 AOF？</h4><p>关于 RDB 和 AOF 的优缺点，官网上面也给了比较详细的说明<a href="https://redis.io/docs/manual/persistence/" target="_blank" rel="noopener">Redis persistenceopen in new window</a>，这里结合自己的理解简单总结一下。</p><p><strong>RDB 比 AOF 优秀的地方</strong> ：</p><ul><li>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会必 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</li><li>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。</li></ul><p><strong>AOF 比 RDB 优秀的地方</strong> ：</p><ul><li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li><li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。</li><li>AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li></ul><h4 id="7-AOF-重写了解吗？"><a href="#7-AOF-重写了解吗？" class="headerlink" title="7.AOF 重写了解吗？"></a>7.AOF 重写了解吗？</h4><p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p><p>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p><p>在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p><p>Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="1-什么是-bigkey？有什么危害？怎么发现？如何解决？"><a href="#1-什么是-bigkey？有什么危害？怎么发现？如何解决？" class="headerlink" title="1.什么是 bigkey？有什么危害？怎么发现？如何解决？"></a>1.什么是 bigkey？有什么危害？怎么发现？如何解决？</h4><p><strong>是什么</strong>：简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。：</p><p><strong>危害</strong>：除了会消耗更多的内存空间，bigkey 对性能也会有比较大的影响。因此，我们应该尽量避免写入 bigkey！</p><p><strong>发现</strong>：</p><blockquote><p> <strong>1、使用 Redis 自带的 <code>--bigkeys</code> 参数来查找。</strong></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;  C:\Users\alex&gt;redis-cli --bigkeys</span><br><span class="line">&gt;  </span><br><span class="line">&gt;  <span class="comment"># Scanning the entire keyspace to find biggest keys as well as</span></span><br><span class="line">&gt;  <span class="comment"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span></span><br><span class="line">&gt;  <span class="comment"># per 100 SCAN commands (not usually needed).</span></span><br><span class="line">&gt;  </span><br><span class="line">&gt;  [00.00%] Biggest string found so far <span class="string">'zhuge10'</span> with 2 bytes</span><br><span class="line">&gt;  [00.00%] Biggest string found so far <span class="string">'groupLeapfrog'</span> with 478 bytes</span><br><span class="line">&gt;  [62.50%] Biggest string found so far <span class="string">'storeLeapfrog'</span> with 555 bytes</span><br><span class="line">&gt;  </span><br><span class="line">&gt;  -------- summary -------</span><br><span class="line">&gt;  </span><br><span class="line">&gt;  Sampled 16 keys <span class="keyword">in</span> the keyspace!</span><br><span class="line">&gt;  Total key length <span class="keyword">in</span> bytes is 120 (avg len 7.50)</span><br><span class="line">&gt;  </span><br><span class="line">&gt;  Biggest string found <span class="string">'storeLeapfrog'</span> has 555 bytes</span><br><span class="line">&gt;  </span><br><span class="line">&gt;  0 lists with 0 items (00.00% of keys, avg size 0.00)</span><br><span class="line">&gt;  0 hashs with 0 fields (00.00% of keys, avg size 0.00)</span><br><span class="line">&gt;  16 strings with 1053 bytes (100.00% of keys, avg size 65.81)</span><br><span class="line">&gt;  0 streams with 0 entries (00.00% of keys, avg size 0.00)</span><br><span class="line">&gt;  0 sets with 0 members (00.00% of keys, avg size 0.00)</span><br><span class="line">&gt;  0 zsets with 0 members (00.00% of keys, avg size 0.00)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p> 从这个命令的运行结果，我们可以看出：这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构 top 1 bigkey（占用内存最大的 string 数据类型，包含元素最多的复合数据类型）。</p><p> <strong>2、分析 RDB 文件</strong></p><p> 通过分析 RDB 文件来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。</p><p> 网上有现成的代码/工具可以直接拿来使用：</p><ul><li><a href="https://github.com/sripathikrishnan/redis-rdb-tools" target="_blank" rel="noopener">redis-rdb-toolsopen in new window</a> ：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li><li><a href="https://github.com/weiyanwei412/rdb_bigkeys" target="_blank" rel="noopener">rdb_bigkeysopen in new window</a> : Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li></ul></blockquote><h4 id="2-大量-key-集中过期问题"><a href="#2-大量-key-集中过期问题" class="headerlink" title="2.大量 key 集中过期问题"></a>2.大量 key 集中过期问题</h4><p>我在上面提到过：对于过期 key，Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 策略。</p><p>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</p><p>如何解决呢？下面是两种常见的方法：</p><p>1.给 key 设置随机过期时间。</p><p>2.开启 lazy-free（惰性删除/延迟释放）。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</p><p>个人建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间。</p><h3 id="生产问题"><a href="#生产问题" class="headerlink" title="生产问题"></a>生产问题</h3><h4 id="1-什么是缓存穿透？解决方法？"><a href="#1-什么是缓存穿透？解决方法？" class="headerlink" title="1.什么是缓存穿透？解决方法？"></a>1.什么是缓存穿透？解决方法？</h4><p>含义：缓存穿透说简单点就是大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p>示意图：</p><p><img alt="缓存穿透" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Redis/20230131225232.png"></p><p>产生原因：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p><p>解决方法：最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p><p><strong>1）缓存无效 key</strong></p><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p><p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p><p>如果用 Java 代码展示的话，差不多是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInclNullById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    Object cacheValue = cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        Object storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）布隆过滤器</strong></p><blockquote><p>对于恶意攻击，向服务器请求大量不存在的数据造成的缓存穿透，还可以用布隆过滤器先做一次过滤，对于不</p><p>存在的数据布隆过滤器一般都能够过滤掉，不让请求再往后端发送。当布隆过滤器说<strong>某个值存在时，这个值可</strong></p><p><strong>能不存在；当它说不存在时，那就肯定不存在。</strong></p></blockquote><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p><p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><p>加入布隆过滤器之后的缓存处理流程图如下。</p><p><img alt="加入布隆过滤器之后的缓存处理流程图" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Redis/20230201110610.png"></p><p><strong>布隆过滤器的原理</strong>：</p><p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p><p>1.使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</p><p>2.根据得到的哈希值，在位数组中把对应下标的值置为 1。</p><p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p><p>1.对给定元素再次进行相同的哈希计算；</p><p>2.得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p><p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率。</p><h4 id="2-什么是缓存击穿？怎么解决？"><a href="#2-什么是缓存击穿？怎么解决？" class="headerlink" title="2.什么是缓存击穿？怎么解决？"></a>2.什么是缓存击穿？怎么解决？</h4><p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p><img alt="缓存击穿" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Redis/20230201142053.png"></p><p>举个例子 ：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p><h5 id="有哪些解决办法？"><a href="#有哪些解决办法？" class="headerlink" title="有哪些解决办法？"></a>有哪些解决办法？</h5><ul><li>设置热点数据永不过期或者过期时间比较长。</li><li>针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li><li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。</li></ul><h4 id="3-缓存穿透和缓存击穿有什么区别？"><a href="#3-缓存穿透和缓存击穿有什么区别？" class="headerlink" title="3.缓存穿透和缓存击穿有什么区别？"></a>3.缓存穿透和缓存击穿有什么区别？</h4><p>缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。</p><p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。</p><h4 id="4-什么是缓存雪崩？解决方法？"><a href="#4-什么是缓存雪崩？解决方法？" class="headerlink" title="4.什么是缓存雪崩？解决方法？"></a>4.什么是缓存雪崩？解决方法？</h4><p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p><p>另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p><p><img alt="缓存雪崩" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Redis/20230201142448.png"></p><p>举个例子 ：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p><h5 id="有哪些解决办法？-1"><a href="#有哪些解决办法？-1" class="headerlink" title="有哪些解决办法？"></a>有哪些解决办法？</h5><p><strong>针对 Redis 服务不可用的情况：</strong></p><p>1.采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</p><p>2.限流，避免同时处理大量的请求。</p><p><strong>针对热点缓存失效的情况：</strong></p><p>==1.设置不同的失效时间比如随机设置缓存的失效时间。==</p><p>2.缓存永不失效（不太推荐，实用性太差）。</p><p>3.设置二级缓存。</p><h4 id="5-缓存雪崩和缓存击穿有什么区别？"><a href="#5-缓存雪崩和缓存击穿有什么区别？" class="headerlink" title="5.缓存雪崩和缓存击穿有什么区别？"></a>5.缓存雪崩和缓存击穿有什么区别？</h4><p>缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期）。</p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><h4 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis Sentinel"></a><strong>Redis Sentinel</strong></h4><h5 id="什么是-Sentinel？-有什么用？"><a href="#什么是-Sentinel？-有什么用？" class="headerlink" title="什么是 Sentinel？ 有什么用？"></a>什么是 Sentinel？ 有什么用？</h5><h5 id="Sentinel-如何检测节点是否下线？主观下线与客观下线的区别"><a href="#Sentinel-如何检测节点是否下线？主观下线与客观下线的区别" class="headerlink" title="Sentinel 如何检测节点是否下线？主观下线与客观下线的区别?"></a>Sentinel 如何检测节点是否下线？主观下线与客观下线的区别?</h5><h5 id="Sentinel-是如何实现故障转移的？"><a href="#Sentinel-是如何实现故障转移的？" class="headerlink" title="Sentinel 是如何实现故障转移的？"></a>Sentinel 是如何实现故障转移的？</h5><h5 id="为什么建议部署多个-sentinel-节点（哨兵集群）？"><a href="#为什么建议部署多个-sentinel-节点（哨兵集群）？" class="headerlink" title="为什么建议部署多个 sentinel 节点（哨兵集群）？"></a>为什么建议部署多个 sentinel 节点（哨兵集群）？</h5><h5 id="Sentinel-如何选择出新的-master（选举机制）"><a href="#Sentinel-如何选择出新的-master（选举机制）" class="headerlink" title="Sentinel 如何选择出新的 master（选举机制）?"></a>Sentinel 如何选择出新的 master（选举机制）?</h5><h5 id="如何从-Sentinel-集群中选择出-Leader-？"><a href="#如何从-Sentinel-集群中选择出-Leader-？" class="headerlink" title="如何从 Sentinel 集群中选择出 Leader ？"></a>如何从 Sentinel 集群中选择出 Leader ？</h5><h5 id="Sentinel-可以防止脑裂吗？"><a href="#Sentinel-可以防止脑裂吗？" class="headerlink" title="Sentinel 可以防止脑裂吗？"></a>Sentinel 可以防止脑裂吗？</h5><h4 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a><strong>Redis Cluster</strong></h4><h5 id="为什么需要-Redis-Cluster？解决了什么问题？有什么优势？"><a href="#为什么需要-Redis-Cluster？解决了什么问题？有什么优势？" class="headerlink" title="为什么需要 Redis Cluster？解决了什么问题？有什么优势？"></a>为什么需要 Redis Cluster？解决了什么问题？有什么优势？</h5><h5 id="Redis-Cluster-是如何分片的？"><a href="#Redis-Cluster-是如何分片的？" class="headerlink" title="Redis Cluster 是如何分片的？"></a>Redis Cluster 是如何分片的？</h5><h5 id="为什么-Redis-Cluster-的哈希槽是-16384-个"><a href="#为什么-Redis-Cluster-的哈希槽是-16384-个" class="headerlink" title="为什么 Redis Cluster 的哈希槽是 16384 个?"></a>为什么 Redis Cluster 的哈希槽是 16384 个?</h5><h5 id="如何确定给定-key-的应该分布到哪个哈希槽中？"><a href="#如何确定给定-key-的应该分布到哪个哈希槽中？" class="headerlink" title="如何确定给定 key 的应该分布到哪个哈希槽中？"></a>如何确定给定 key 的应该分布到哪个哈希槽中？</h5><h5 id="Redis-Cluster-支持重新分配哈希槽吗？"><a href="#Redis-Cluster-支持重新分配哈希槽吗？" class="headerlink" title="Redis Cluster 支持重新分配哈希槽吗？"></a>Redis Cluster 支持重新分配哈希槽吗？</h5><h5 id="Redis-Cluster-扩容缩容期间可以提供服务吗？"><a href="#Redis-Cluster-扩容缩容期间可以提供服务吗？" class="headerlink" title="Redis Cluster 扩容缩容期间可以提供服务吗？"></a>Redis Cluster 扩容缩容期间可以提供服务吗？</h5><h5 id="Redis-Cluster-中的节点是怎么进行通信的？"><a href="#Redis-Cluster-中的节点是怎么进行通信的？" class="headerlink" title="Redis Cluster 中的节点是怎么进行通信的？"></a>Redis Cluster 中的节点是怎么进行通信的？</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;h4 id=&quot;1-为什么要用-Redis-为什么要用缓存？&quot;&gt;&lt;a href=&quot;#1-为什么要用-Redis-为什么要用缓存？&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="面试题" scheme="https://alexander-wd.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="redis" scheme="https://alexander-wd.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础面试题</title>
    <link href="https://alexander-wd.github.io/2022/12/24/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://alexander-wd.github.io/2022/12/24/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-12-24T08:10:20.000Z</published>
    <updated>2023-02-13T10:07:15.615Z</updated>
    
    <content type="html"><![CDATA[<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h4 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a>操作系统基础</h4><h5 id="1-什么是操作系统"><a href="#1-什么是操作系统" class="headerlink" title="1.什么是操作系统"></a>1.什么是操作系统</h5><p>操作系统是管理计算机硬件和软件资源的程序，是计算机的基石<br>操作系统本质上是一个运行在计算机上的软件程序，用于管理计算机硬件和软件资源<br>操作系统存在屏蔽了硬件层的复杂性<br>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性</p><h5 id="2-什么是系统调用呢"><a href="#2-什么是系统调用呢" class="headerlink" title="==2.什么是系统调用呢=="></a>==2.什么是系统调用呢==</h5><p>用户态和系统态<br>    用户态<br>        用户态运行的进程可以直接读取用户程序的数据<br>    系统态<br>        可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制<br>系统调用<br>    我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了<br>系统调用按功能分类<br>    设备管理<br>        完成设备的请求或释放，以及设备启动等功能。<br>    文件管理<br>        完成文件的读、写、创建及删除等功能。<br>    进程控制<br>        完成进程的创建、撤销、阻塞及唤醒等功能。<br>    进程通信<br>        完成进程之间的消息传递或信号传递等功能。<br>    内存管理<br>        完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</p><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><h5 id="1-进程和线程的区别"><a href="#1-进程和线程的区别" class="headerlink" title="1.进程和线程的区别"></a>1.进程和线程的区别</h5><p>进程是资源分配的最小单位<br>    线程是 CPU 调度的最小单位<br>创建进程或撤销进程，系统都要为之分配或回收资源，操作系统开销远大于创建或撤销线程时的开销<br>不同进程地址空间相互独立，同一进程内的线程共享同一地址空间。一个进程的线程在另一个进程内是不可见的<br>进程间不会相互影响，而一个线程挂掉将可能导致整个进程挂掉<br>以JVM为例分析<br>    一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈</p><h5 id="2-进程有哪几种状态"><a href="#2-进程有哪几种状态" class="headerlink" title="2.进程有哪几种状态"></a>2.进程有哪几种状态</h5><p>创建<br>    进程正在被创建，尚未到就绪状态<br>就绪<br>    进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行<br>运行<br>    进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)<br>阻塞<br>    又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行<br>结束<br>    进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行<br>进程状态转换图</p><p><img alt="7" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/计算机基础/20230118163100.png"></p><h5 id="3-进程间的通信方式"><a href="#3-进程间的通信方式" class="headerlink" title="3.进程间的通信方式"></a>3.进程间的通信方式</h5><p>管道/匿名管道(Pipes)<br>    用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。<br>有名管道(Names Pipes)<br>    匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</p><p>信号(Signal)<br>    信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</p><p>==消息队列(Message Queuing)==<br>    消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。<br>==信号量(Semaphores)==<br>    信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。<br>    类比，Semaphore(AQS)<br>==共享内存(Shared memory)==<br>    使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。<br>    类比volatile<br>==套接字(Sockets)==<br>    此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。<br>信号(Signal)<br>    信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</p><h5 id="4-线程间的同步的方式"><a href="#4-线程间的同步的方式" class="headerlink" title="4.线程间的同步的方式"></a>4.线程间的同步的方式</h5><p>互斥量<br>    采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限<br>    同步锁(synchronized，ReentrantLock)<br>信号量<br>    它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量<br>    Semaphore(AQS)<br>事件<br>    通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作<br>    wait/notify<br>共享内存<br>    volatile关键字</p><h5 id="5-进程的调度算法"><a href="#5-进程的调度算法" class="headerlink" title="5.进程的调度算法"></a>5.进程的调度算法</h5><p>短作业优先(SJF)的调度算法<br>    从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。<br>时间片轮转调度算法<br>    时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。<br>多级反馈队列调度算法<br>    前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。<br>    短进程执行优先级最高，时间片小；长进程执行优先级低，时间片长。<br>    一个新进程进来先进入序数最小的队列(优先级最高，时间片最小)，拿到CPU时间片执行，时间皮用完，移到序数较大的队列中；以此类推<br>优先级调度<br>    为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。<br>先到先服务(FCFS)调度算法<br>    从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</p><h5 id="6-什么是死锁"><a href="#6-什么是死锁" class="headerlink" title="==6.什么是死锁=="></a>==6.什么是死锁==</h5><p>多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止</p><h5 id="7-死锁的四个必要条件是什么"><a href="#7-死锁的四个必要条件是什么" class="headerlink" title="==7.死锁的四个必要条件是什么=="></a>==7.死锁的四个必要条件是什么==</h5><p>互斥<br>    资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。<br>占有并等待<br>    一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。<br>非抢占<br>    资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。<br>循环等待<br>    有一组等待进程 {P0, P1,…, Pn}， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，……，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有<br>例：A有R1，等待R2;B有R2，等待R1</p><h5 id="8-解决死锁的方法"><a href="#8-解决死锁的方法" class="headerlink" title="==8.解决死锁的方法=="></a>==8.解决死锁的方法==</h5><p>预防<br>    概念<br>        采用某种策略，限制并发进程对资源的请求，从而使得死锁的必要条件在系统执行的任何时间上都不满足<br>    破坏互斥条件<br>        很多资源往往是不能同时访问的，不靠谱<br>    破坏非抢占条件<br>        会导致资源利用率下降，不靠谱<br>    破坏占有并等待条件<br>        静态分配策略<br>            在一开始就给线程分配执行所需要的所有资源<br>            可能有些资源要在执行比较靠后的时间采用，会严重降低资源利用率，不靠谱<br>    破坏循环等待条件<br>        层次分配策略<br>            在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源<br>            A有R1，等待R2;B有R2，等待R1，加入R2&gt;R1，那么B会先释放R2<br>避免<br>    概念<br>        系统在分配资源时，根据资源的使用情况提前做出预测，从而避免死锁的发生(允许存在四个必要条件)<br>    <a href="https://blog.csdn.net/qq_33414271/article/details/80245715" target="_blank" rel="noopener">银行家算法</a><br>        先 试探 分配给该进程资源<br>        然后通过 安全性算法 判断分配后系统是否处于安全状态<br>            若不安全则试探分配作废，让该进程继续等待<br>            若能够进入到安全的状态，则就 真的分配资源给该进程。<br>        缺点：需要不断做安全性检查，时间开销大<br>检测<br>    概念<br>        系统设有专门的机构，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。<br>    进程-资源分配图<br>        如果进程-资源分配图中无环路，则此时系统没有发生死锁<br>        如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁<br>        如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁<br>            如果能在进程-资源分配图中找出一个 既不阻塞又非独立的进程 ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 消除所有的边 ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 拓扑排序)<br>解除<br>    概念<br>        解除 是与检测相配套的一种措施，用于将进程从死锁状态下解脱出来<br>    立即结束所有进程的执行，重新启动操作系统<br>        这种方法简单，但以前所在的工作全部作废，损失很大。<br>    撤销涉及死锁的所有进程，解除死锁后继续运行<br>        这种方法能彻底打破死锁的循环等待条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。<br>    逐个撤销涉及死锁的进程，回收其资源直至死锁解除。<br>    抢占资源<br>        从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。<br>总结<br>    预防和避免像悲观锁，检测和解除像乐观锁</p><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><h5 id="1-操作系统的内存管理主要是做什么"><a href="#1-操作系统的内存管理主要是做什么" class="headerlink" title="1.操作系统的内存管理主要是做什么"></a>1.操作系统的内存管理主要是做什么</h5><p>主要负责内存的分配与回收<br>地址转换也就是将逻辑地址转换成相应的物理地址等功能</p><h5 id="2-常见的几种内存管理机制"><a href="#2-常见的几种内存管理机制" class="headerlink" title="2.常见的几种内存管理机制"></a>2.常见的几种内存管理机制</h5><p>连续分配管理方式<br>    为一个用户程序分配一个连续的内存空间<br>    块式管理<br>        将内存分为几个固定大小的块，每个块中只包含一个进程。<br>        如果程序运行需要内存的话，操作系统就分配给它一块，<br>        如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片<br>非连续分配管理方式<br>    允许一个程序使用的内存分布在离散或者说不相邻的内存中<br>    页式管理<br>        把主存分为大小相等且固定的一页一页的形式，页较小，相比于块式管理的划分粒度更小，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。<br>    段式管理<br>        页式管理虽然提高了内存利用率，但是页式管理其中的页并无任何实际意义。<br>        段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。<br>    段页式管理机制<br>        结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 段页式管理机制 中段与段之间以及段的内部的都是离散的。<br>    总结<br>        页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求</p><h5 id="3-快表和多级页表"><a href="#3-快表和多级页表" class="headerlink" title="3.快表和多级页表"></a>3.快表和多级页表</h5><p>快表<br>    在 页表方案 基础之上引入了 快表 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器<br>    步骤<br>        加入快表后,在地址转换时，首先在快表中查找，若找到就直接进行地址转换；<br>        未找到，则在主存页表继续查找，并把查到的页号和块号放入联想存储器中。<br>        快表的命中率很高，有效地提高了地址转换的速度。<br>    <a href="https://blog.csdn.net/SJ_Sniper/article/details/122838711" target="_blank" rel="noopener">参考</a><br>    快表命中率</p><p>​    <img alt="8" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/计算机基础/20230118180157.jpg"></p><p>多级页表<br>    为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。<br>    多级页表属于时间换空间的典型场景<br>    <a href="https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html" target="_blank" rel="noopener">参考</a><br>利用了程序的局部性原理</p><h5 id="4-分页机制和分段机制的共同点和区别"><a href="#4-分页机制和分段机制的共同点和区别" class="headerlink" title="4.分页机制和分段机制的共同点和区别"></a>4.分页机制和分段机制的共同点和区别</h5><p>共同点<br>    分页机制和分段机制都是为了提高内存利用率，减少内存碎片。<br>    页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。<br>区别<br>    页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。<br>    分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</p><h5 id="5-逻辑-虚拟-地址和物理地址"><a href="#5-逻辑-虚拟-地址和物理地址" class="headerlink" title="5.逻辑(虚拟)地址和物理地址"></a>5.逻辑(虚拟)地址和物理地址</h5><p>编程一般只有可能和逻辑地址打交道<br>逻辑地址<br>    在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定<br>物理地址<br>    物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址</p><h5 id="6-CPU-寻址了解吗-为什么需要虚拟地址空间"><a href="#6-CPU-寻址了解吗-为什么需要虚拟地址空间" class="headerlink" title="==6.CPU 寻址了解吗?为什么需要虚拟地址空间=="></a>==6.CPU 寻址了解吗?为什么需要虚拟地址空间==</h5><p>CPU寻址<br>    使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存<br>==为什么要有虚拟地址空间呢==<br>    没有虚拟地址空间的时候，程序直接访问和操作的都是物理内存，会有几个问题<br>        用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。<br>        想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃<br>        总结<br>            如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难</p><p>​    优势<br>​        程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。<br>​        程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。<br>​        不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><h5 id="1-什么是虚拟内存"><a href="#1-什么是虚拟内存" class="headerlink" title="1.什么是虚拟内存"></a>1.什么是虚拟内存</h5><p>概念<br>    虚拟内存是计算机系统内存管理的一种技术<br>    虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间<br>优势<br>    通过 虚拟内存 可以让程序可以拥有超过系统物理内存大小的可用内存空间。<br>    虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。</p><h5 id="2-局部性原理"><a href="#2-局部性原理" class="headerlink" title="==2.局部性原理=="></a>==2.局部性原理==</h5><p>局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。<br>时间局部性<br>    如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。<br>    产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。<br>    实现<br>        将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现</p><p>空间局部性<br>    一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。<br>    如数组<br>    实现<br>        使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现</p><h5 id="3-虚拟存储器"><a href="#3-虚拟存储器" class="headerlink" title="3.虚拟存储器"></a>3.虚拟存储器</h5><p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。<br>在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大得多的存储器</p><h5 id="4-虚拟内存的技术实现"><a href="#4-虚拟内存的技术实现" class="headerlink" title="==4.虚拟内存的技术实现=="></a>==4.虚拟内存的技术实现==</h5><p>请求分页存储管理<br>    ==建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能==<br>    步骤<br>        请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。<br>        假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中<br>请求分段存储管理<br>    建立在分段存储管理之上，增加了请求调段功能、分段置换功能。<br>请求段页式存储管理<br>要点<br>    一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；<br>    ==缺页中断==<br>        如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序；<br>    虚拟地址空间<br>        逻辑地址到物理地址的变换</p><h5 id="5-页面置换算法"><a href="#5-页面置换算法" class="headerlink" title="==5.页面置换算法=="></a>==5.页面置换算法==</h5><p>==为什么需要页面置换算法==<br>    地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断，若此时内存中没有空闲的页面，就会使用页面置换算法淘汰页面<br>OPT 页面置换算法（最佳页面置换算法）<br>    最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率<br>    但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法<br>FIFO页面置换算法（先进先出页面置换算法）<br>    总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。<br>LRU页面置换算法（最近最久未使用页面置换算法）<br>    LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。<br>LFU页面置换算法（最少使用页面置换算法）<br>    该置换算法选择在之前时期使用最少的页面作为淘汰页。</p><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h5 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1.OSI七层模型"></a>1.OSI七层模型</h5><p><img alt="1" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/计算机基础/20230118183256.png"></p><h5 id="2-TCP-IP四层模型"><a href="#2-TCP-IP四层模型" class="headerlink" title="2.TCP/IP四层模型"></a>2.TCP/IP四层模型</h5><p>应用层<br>    定义了信息交换的格式<br>传输层<br>    提供通用的数据传输服务<br>网络层<br>    提供通信服务<br>网络接口层<br>    封装成桢，无差别传输</p><h5 id="3-参考"><a href="#3-参考" class="headerlink" title="3.参考"></a>3.<a href="https://www.iamshuaidi.com/747.html" target="_blank" rel="noopener">参考</a></h5><h4 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h4><h5 id="1-TCP-三次握手"><a href="#1-TCP-三次握手" class="headerlink" title="==1.TCP 三次握手=="></a>==1.TCP 三次握手==</h5><p>详解</p><blockquote><p>​    人话概述<br>​        首先，我让信使运输一份信件给对方，对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。<br>​        于是他给我回信，我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以。<br>​        然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次，他若收到了，他便清楚了他的发件能力和我的收件能力是可以的。<br>​    第一次握手<br>​        客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。<br>​        人话<br>​            发送SYN，请求连接<br>​    第二次握手<br>​        服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。<br>​        人话<br>​            发送SYN和ACK，确认请求连接<br>​    第三次握手<br>​        客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。<br>​        人话<br>​            发送ACK，确认服务器的确认(主要让服务器明白)</p></blockquote><p>核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求</p><p>==追问==</p><blockquote><p>==为什么TCP连接的时候是3次？2次或4次不可以吗==<br>    2次不可以？<br>        2次的话服务器并不知道客户端是否已经收到自己的同步信号，可能这个同步信号会丢失(客户端接收有问题)，导致服务器和客户端的初始序号无法达成一致<br>    4次不可以？<br>        3次已经能满足可靠传输和传输效率了，4次多余<br>==第2次握手传回了ACK，为什么还要传回SYN==<br>    服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信。<br>==如果已经建立了连接，但是客户端突然出现故障了怎么办==<br>    TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。<br>==如果第1次握手中，客户端发给服务端的SYN丢了，怎么办==<br>    客户端会周期性超时重传，直到收到服务器的确认<br>==如果第2次握手中，服务器发给客户端的SYN+ACK丢了，怎么办==<br>    服务端会周期性超时重传SYN+ACK，直到收到客户端的确认<br>==如果第3次握手中，服务器发给客户端的确认(ACK)丢了，怎么办==<br>    首先，客户端不会为没有数据的ACK超时重传<br>    A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态<br>    这时，分三种情况<br>        双方都没数据，服务端会周期性超时重传SYN+ACK，直到收到客户端的确认<br>        若客户端有数据，服务端收到客户端的数据+ACK，自然会切换为Established状态<br>        若服务器有数据，发送不了，会周期性超时重传SYN+ACK，直到收到客户端的确认</p></blockquote><p>图解</p><p><img alt="2" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/计算机基础/20230118184004.png"></p><h5 id="2-TCP四次挥手"><a href="#2-TCP四次挥手" class="headerlink" title="==2.TCP四次挥手=="></a>==2.TCP四次挥手==</h5><p>详解</p><blockquote><p>人话概述<br>    第一次挥手 ： A 说“我没啥要说的了”<br>    第二次挥手 ：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话<br>    第三次挥手 ：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”<br>    第四次挥手 ：A 回答“知道了”，这样通话才算结束。<br>第一次挥手<br>    当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。<br>第二次挥手<br>    服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。<br>第三次挥手<br>    服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。<br>第四次挥手<br>    客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。</p></blockquote><p>追问</p><blockquote><p>==为什么TCP连接的时候是3次，关闭的时候却是4次==<br>    因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)<br>==为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手==<br>    因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。<br>==如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样==<br>    客户端没有收到 ACK 确认，服务器会重新发送 FIN 请求<br>==为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接==<br>    第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端没有因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN<br>    类比第三次握手时丢失ACK</p></blockquote><p>图解</p><p><img alt="3" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/计算机基础/20230118184012.png"></p><h5 id="3-TCP-与-UDP-的区别"><a href="#3-TCP-与-UDP-的区别" class="headerlink" title="==3.TCP 与 UDP 的区别=="></a>==3.TCP 与 UDP 的区别==</h5><p>是否面向连接<br>    UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。<br>是否是可靠传输<br>    远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。<br>是否有状态<br>    这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（这很渣男！）。<br>传输效率<br>    由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。<br>传输形式<br>    TCP 是面向字节流的，UDP 是面向报文的。<br>首部开销<br>    TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。<br>是否提供广播或多播服务<br>    TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</p><p>图解</p><p><img alt="4" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/计算机基础/20230118190231.png"></p><h5 id="4-什么时候选择-TCP-什么时候选-UDP"><a href="#4-什么时候选择-TCP-什么时候选-UDP" class="headerlink" title="4.什么时候选择 TCP,什么时候选 UDP"></a>4.什么时候选择 TCP,什么时候选 UDP</h5><p>UDP<br>    一般用于即时通信<br>        语音、 视频 、直播<br>TCP<br>    用于对传输准确性要求特别高的场景<br>        文件传输、发送和接收邮件、远程登录</p><h5 id="5-使用-TCP-的协议有哪些-使用-UDP-的协议有哪些"><a href="#5-使用-TCP-的协议有哪些-使用-UDP-的协议有哪些" class="headerlink" title="5.使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?"></a>5.使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?</h5><p>==TCP==<br>    HTTP 协议<br>        超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。<br>    HTTPS 协议<br>        更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议<br>    FTP 协议<br>        文件传输协议 FTP（File Transfer Protocol），提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。<br>    SMTP 协议<br>        简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，基于 TCP 协议，用来发送电子邮件。注意 ⚠️：接受邮件的协议不是 SMTP 而是 POP3 协议。<br>    POP3/IMAP 协议<br>        POP3 和 IMAP 两者都是负责邮件接收的协议。<br>    Telent 协议<br>        远程登陆协议，通过一个终端登陆到其他服务器。被一种称为 SSH 的非常安全的协议所取代。<br>    SSH 协议<br>        SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。<br>==UDP==<br>    DNS<br>        域名系统（DNS，Domain Name System）将人类可读的域名 (例如，www.baidu.com) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议。<br>    DHCP 协议<br>        动态主机配置协议，动态配置 IP 地址</p><h5 id="6-TCP-协议如何保证可靠传输"><a href="#6-TCP-协议如何保证可靠传输" class="headerlink" title="==6.TCP 协议如何保证可靠传输=="></a>==6.TCP 协议如何保证可靠传输==</h5><p>==基于数据块传输==<br>    应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。<br>对失序数据包重新排序以及去重<br>    TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。<br>校验和<br>    TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。<br>==超时重传==<br>    当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为已丢失并进行重传。<br>==流量控制==<br>    TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。<br>==拥塞控制==<br>    当网络拥塞时，减少数据的发送。</p><h5 id="7-TCP-如何实现流量控制"><a href="#7-TCP-如何实现流量控制" class="headerlink" title="7.TCP 如何实现流量控制"></a>7.TCP 如何实现流量控制</h5><p>TCP 利用滑动窗口实现流量控制<br>追问<br>    ==为什么需要流量控制==<br>        因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等<br>        如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 接收缓冲区(Receiving Buffers) 里（失序的数据包也会被存放在缓存区里）。<br>        如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。</p><h5 id="8-TCP-的拥塞控制是怎么实现的"><a href="#8-TCP-的拥塞控制是怎么实现的" class="headerlink" title="8.TCP 的拥塞控制是怎么实现的"></a>8.TCP 的拥塞控制是怎么实现的</h5><p>总结<br>    维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化，根据网络的拥塞程度使用四种不同的算法(慢开始、拥塞避免、快重传、快恢复)<br>追问<br>    ==拥塞控制和流量控制区别==<br>        拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。<br>        相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收</p><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h5 id="1-在浏览器中输入-url-地址-gt-gt-显示主页的过程"><a href="#1-在浏览器中输入-url-地址-gt-gt-显示主页的过程" class="headerlink" title="==1.在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程=="></a>==1.在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程==</h5><blockquote><p>1.使用DNS解析域名为IP地址<br>2.浏览器向web服务器发送HTTP请求<br>    若是HTTPS，还要使用SSL/TLS协议(握手)<br>3.与服务器建立TCP连接<br>    IP协议，OSPF协议(路由器间)<br>    ARP协议(IP地址转为MAC地址)<br>4.服务器发回HTML响应<br>5.浏览器开始显示HTML</p><p><img alt="5" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/计算机基础/20230118191216.jpg"></p></blockquote><p><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">参考</a></p><h5 id="2-HTTP-是不保存状态的协议-如何保存用户状态"><a href="#2-HTTP-是不保存状态的协议-如何保存用户状态" class="headerlink" title="2.HTTP 是不保存状态的协议, 如何保存用户状态"></a>2.HTTP 是不保存状态的协议, 如何保存用户状态</h5><p>Session + Cookie<br>token和session的区别<br>    <a href="https://blog.csdn.net/sinat_34191046/article/details/88740880" target="_blank" rel="noopener">token易扩展，session存在服务器中，但每台服务器session可能不同</a><br>    <a href="https://blog.csdn.net/u013451157/article/details/98478484" target="_blank" rel="noopener">token可以防止CSRF跨站请求伪造，因为浏览器访问默认不会带</a><br>    <a href="https://blog.csdn.net/weixin_44052462/article/details/122988438" target="_blank" rel="noopener">csrf原理</a></p><h5 id="3-HTTP-和-HTTPS-有什么区别"><a href="#3-HTTP-和-HTTPS-有什么区别" class="headerlink" title="==3.HTTP 和 HTTPS 有什么区别=="></a>==3.HTTP 和 HTTPS 有什么区别==</h5><p>端口号<br>    HTTP 默认是 80，HTTPS 默认是 443。<br>URL 前缀<br>    HTTP 的 URL 前缀是 <a href="http://，HTTPS" target="_blank" rel="noopener">http://，HTTPS</a> 的 URL 前缀是 https://。<br>安全性和资源消耗<br>     HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p><h5 id="4-HTTP1-0，1-1，2-0-的版本区别"><a href="#4-HTTP1-0，1-1，2-0-的版本区别" class="headerlink" title="4.HTTP1.0，1.1，2.0 的版本区别"></a>4.HTTP1.0，1.1，2.0 的版本区别</h5><p>1.0<br>    无状态(不记录请求记录)<br>    无连接(处理完之后立即断开TCP协议)<br>1.1<br>    开始默认使用Connection: keep-alive<br>        可以被多个请求复用<br>    管道机制<br>        在同一个TCP连接里面，客户端可以同时发送多个请求<br>2.0<br>    多路复用<br>        前提<br>            HTTP/2进行了二进制分帧<br>        在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应<br>    头部压缩<br>        使用encoder来减少需要传输的header大小</p><h5 id="5-token和session的区别"><a href="#5-token和session的区别" class="headerlink" title="==5.token和session的区别=="></a>==5.token和session的区别==</h5><p><a href="https://blog.csdn.net/sinat_34191046/article/details/88740880" target="_blank" rel="noopener">token易扩展，session存在服务器中，但每台服务器session可能不同</a><br><a href="https://blog.csdn.net/u013451157/article/details/98478484" target="_blank" rel="noopener">token可以防止CSRF跨站请求伪造，因为浏览器访问默认不会带</a><br>[csrf原理](</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h3&gt;&lt;h4 id=&quot;操作系统基础&quot;&gt;&lt;a href=&quot;#操作系统基础&quot; class=&quot;headerlink&quot; title=&quot;操作系统基
      
    
    </summary>
    
    
      <category term="面试题" scheme="https://alexander-wd.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="计算机基础" scheme="https://alexander-wd.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC面试题</title>
    <link href="https://alexander-wd.github.io/2022/12/05/%E9%9D%A2%E8%AF%95%E9%A2%98/SpringMVC%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://alexander-wd.github.io/2022/12/05/%E9%9D%A2%E8%AF%95%E9%A2%98/SpringMVC%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-12-05T08:10:20.000Z</published>
    <updated>2023-02-13T10:44:09.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="67-如何解决get-post乱码问题"><a href="#67-如何解决get-post乱码问题" class="headerlink" title="67.如何解决get/post乱码问题"></a>67.如何解决get/post乱码问题</h3><p>​    确保前端没问题<br>​    post请求乱码问题<br>​        配置CharacterEncodingFilter过滤器</p><p><img alt="43" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125203418.png"></p><p>​    get中文乱码</p><p><img alt="44" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125203426.png"></p><h3 id="68-SpringMVC的控制器是不是单例模式，如果是，有什么问题，怎么解决"><a href="#68-SpringMVC的控制器是不是单例模式，如果是，有什么问题，怎么解决" class="headerlink" title="68.SpringMVC的控制器是不是单例模式，如果是，有什么问题，怎么解决"></a>68.SpringMVC的控制器是不是单例模式，如果是，有什么问题，怎么解决</h3><p>​    Q.17,18<br>​    默认单例<br>​    如果声明在类成员变量中<br>​        如果在类中声明成员变量，并且有读写操作(有状态)，线程不安全，但是成员变量声明在方法中(无状态)，单例bean是安全的<br>​    解决<br>​        1.设置为多例<br>​            每个线程都会创建不同的对象<br>​        2.成员变量放到ThreadLocal中<br>​            成员变量会绑定在各自的线程上，不共享<br>​        3.同步锁synchronized<br>​            并行变成了串行，会影响系统吞吐量<br>​    题外话<br>​        HttpServletRequest HttpSession  Spring底层已经放到IOC容器里了，可以直接自动注入</p><h3 id="69-描述SpringMVC的工作流程-DispatcherServlet的工作流程"><a href="#69-描述SpringMVC的工作流程-DispatcherServlet的工作流程" class="headerlink" title="==69.描述SpringMVC的工作流程(DispatcherServlet的工作流程)=="></a>==69.描述SpringMVC的工作流程(DispatcherServlet的工作流程)==</h3><p>​    1.请求到DispatcherServlet<br>​    2.请求处理器映射器HandlerMapping<br>​        返回映射器执行链(包含拦截器)<br>​    3.HandlerAdapter<br>​        因为controller多种实现方式<br>​    4.handler真正调用后端方法<br>​        返回ModelAndView<br>​    5.请求视图解析器ViewReslover，动态拼接.html，.jsp等<br>​        返回view<br>​    6.解析视图(jsp，thymeleaf)<br>​    7.响应给用户<br>​    参考</p><p><img alt="46" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125203651.png"></p><p>​    图解</p><p><img alt="45" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125204154.png"></p><h3 id="70-SpringMVC中处理ajax请求原理"><a href="#70-SpringMVC中处理ajax请求原理" class="headerlink" title="==70.SpringMVC中处理ajax请求原理=="></a>==70.SpringMVC中处理ajax请求原理==</h3><p>​    1.加入Jackson.jar<br>​    2.配置json的消息转换器HttpMessageConverter接口<br>​    3.接收ajax方法上加@ResponseBody<br>​    图解</p><p><img alt="47" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125203654.png"></p><p>​        请求的是json，就直接返回了，viewReslover和解析视图都没有<br>​    参考</p><p><img alt="48" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125204206.png"></p><h3 id="71-Spring和SpringMVC为什么需要父子容器"><a href="#71-Spring和SpringMVC为什么需要父子容器" class="headerlink" title="==71.Spring和SpringMVC为什么需要父子容器=="></a>==71.Spring和SpringMVC为什么需要父子容器==</h3><p>​    划分框架边界<br>​    规范整体架构(SSM)<br>​    方便子容器的切换<br>​    为了节省重复bean创建<br>​        两个子容器依赖父容器，bean创建到父容器<br>​    参考</p><p><img alt="49" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125204428.png"></p><h3 id="72-是否可以把SpringMVC所有Bean交给Spring容器管理"><a href="#72-是否可以把SpringMVC所有Bean交给Spring容器管理" class="headerlink" title="72.是否可以把SpringMVC所有Bean交给Spring容器管理"></a>72.是否可以把SpringMVC所有Bean交给Spring容器管理</h3><p>​    如果交给父容器管理，处理器映射器HandlerMapping初始化时候会根据beanDefinition解析@RequestMapping，并没有调用父容器的getBean，就找不到对应的HandlerMethod<br>​    参考</p><p><img alt="50" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125204549.png"></p><h3 id="73-是否可以吧Spring的Bean都交给SpringMVC管理"><a href="#73-是否可以吧Spring的Bean都交给SpringMVC管理" class="headerlink" title="73.是否可以吧Spring的Bean都交给SpringMVC管理"></a>73.是否可以吧Spring的Bean都交给SpringMVC管理</h3><p>​    可以，因为子容器可以获取父容器，而父容器拿不到子容器的bean<br>​    参考</p><p><img alt="51" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125204617.png"></p><h3 id="74-如何实现零配置的SpringMVC，原理是什么"><a href="#74-如何实现零配置的SpringMVC，原理是什么" class="headerlink" title="==74.如何实现零配置的SpringMVC，原理是什么=="></a>==74.如何实现零配置的SpringMVC，原理是什么==</h3><p>​    零配置<br>​        无web.xml，spring.xml，spring-mvc.xml<br>​    实现<br>​        省略web.xml<br>​            1.Servlet3.0后<br>​                @WebServlet<br>​                @WebListener<br>​                @WebFilter<br>​            ==2.使用SPI==<br>​        省略spring.xml和springmvc.xml<br>​            自定义一个类实现AbstractAnnotationConfigDispatcherServletInitializer，此类实现了WebApplicationInitializer，在里面配置spring和springmvc配置类的位置<br>​    参考代码<br>​        spring-tuling-webmvc<br>​        spring-web<br>​    参考</p><p><img alt="52" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125204646.png"></p><h3 id="75-SpringMVC的拦截器和过滤器有什么区别，执行顺序"><a href="#75-SpringMVC的拦截器和过滤器有什么区别，执行顺序" class="headerlink" title="==75.SpringMVC的拦截器和过滤器有什么区别，执行顺序=="></a>==75.SpringMVC的拦截器和过滤器有什么区别，执行顺序==</h3><p>​    区别</p><p><img alt="53" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125204950.png"></p><p>​    执行顺序<br>​        filter<br>​        servlet<br>​        interceptor<br>​        controller<br>​        依次进来，依次出去</p><p><img alt="54" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125205001.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;67-如何解决get-post乱码问题&quot;&gt;&lt;a href=&quot;#67-如何解决get-post乱码问题&quot; class=&quot;headerlink&quot; title=&quot;67.如何解决get/post乱码问题&quot;&gt;&lt;/a&gt;67.如何解决get/post乱码问题&lt;/h3&gt;&lt;p&gt;​ 
      
    
    </summary>
    
    
      <category term="面试题" scheme="https://alexander-wd.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="springmvc" scheme="https://alexander-wd.github.io/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>spring面试题</title>
    <link href="https://alexander-wd.github.io/2022/11/28/%E9%9D%A2%E8%AF%95%E9%A2%98/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://alexander-wd.github.io/2022/11/28/%E9%9D%A2%E8%AF%95%E9%A2%98/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-11-28T15:10:22.000Z</published>
    <updated>2023-02-13T10:16:39.519Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.processon.com/view/link/5f5075c763768959e2d109df" target="_blank" rel="noopener">spring笔记整体脑图</a></p><p><a href="https://www.processon.com/view/link/5f18298a7d9c0835d38a57c0" target="_blank" rel="noopener">bean定义注册流程</a></p><p><a href="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124162059.jpg" target="_blank" rel="noopener">springioc加载整体流程图</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="1-谈谈你理解的Spring是什么"><a href="#1-谈谈你理解的Spring是什么" class="headerlink" title="1.谈谈你理解的Spring是什么"></a>1.谈谈你理解的Spring是什么</h4><p>​    不止是IOC和AOP的容器框架，Spring还是一个生态圈<br>​        生态圈<br>​            springboot<br>​            spring集成的各种框架<br>​        <a href="https://blog.csdn.net/weixin_37711738/article/details/90020123" target="_blank" rel="noopener">IOC</a><br>​            控制反转：将对象的控制权交给spring，把应用从复杂的对象依赖关系管理中解放出来<br>​        AOP<br>​            无缝地给方法增强<br>​    标准答案</p><p><img alt="1" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124155639.png"></p><h4 id="2-Spring的优缺点是什么"><a href="#2-Spring的优缺点是什么" class="headerlink" title="2.Spring的优缺点是什么"></a>2.Spring的优缺点是什么</h4><p>​    思路<br>​        先总结Spring的特性：IOC、AOP、声明式事务、集成框架、JDBCTemplate、restTemplate(远程调用)、邮件(JavaMail)、异步调用<br>​    优点<br>​        IOC<br>​            集中管理了对象，是对象和对象之间的耦合性降低，更方便地维护对象(如：以前单例需要使用设计模式、懒加载)<br>​        AOP<br>​            不修改代码的情况下，对业务代码进行增强，减少重复代码，提高开发效率，维护方便<br>​        声明式事务<br>​            只需要@Transactional，提高开发效率<br>​        方便程序测试<br>​            结合junit非常方便测试<br>​        方便集成各种框架<br>​            拥有非常强大的粘合度、集成能力非常强，只需要简单配置就可以集成第三方框架<br>​        降低JAVAEE API使用难度<br>​            简化开发，封装了很多代码<br>​        java源码学习范例<br>​            Spring底层实现：反射、设计模式值得学习<br>​    缺点<br>​        应用层面没有缺点<br>​        简化开发，如果想深入底层了解非常困难<br>​        源码缺点：由于spring大而全，代码量非常庞大，一百多万行，想深入源码带来一定困难</p><h4 id="3-什么是SpringIOC容器，有什么用，优点是什么"><a href="#3-什么是SpringIOC容器，有什么用，优点是什么" class="headerlink" title="3.什么是SpringIOC容器，有什么用，优点是什么"></a>3.什么是SpringIOC容器，有什么用，优点是什么</h4><p>​    IOC<br>​        控制反转：原来需要new，耦合度高，不方便维护，引入IOC将创建对象的控制权交给Spring<br>​        现在如果要使用，只需要DI(依赖注入)@Autowired就可以使用对象了<br>​    优点<br>​        集中管理了对象，方便维护。降低耦合度</p><h4 id="4-IOC的实现机制是什么"><a href="#4-IOC的实现机制是什么" class="headerlink" title="==4.IOC的实现机制是什么=="></a>==4.IOC的实现机制是什么==</h4><p>​    工厂+反射<br>​        简单工厂：beanFactory.getBean，只有简单工厂需要一个一个if</p><p><img alt="2" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124155946.png">            </p><p>​        反射的方式</p><p><img alt="3" data-src="E:\desktop\自学\MyNote\面试题\spring图\3.png"></p><h4 id="5-IOC和DI的区别是什么"><a href="#5-IOC和DI的区别是什么" class="headerlink" title="5.IOC和DI的区别是什么"></a>5.IOC和DI的区别是什么</h4><p>​    IOC<br>​        控制反转：原来需要new，耦合度高，不方便维护，引入IOC将创建对象的控制权交给Spring<br>​        现在如果要使用，只需要DI(依赖注入)@Autowired就可以使用对象了<br>​        是一种设计思想<br>​    DI<br>​        DI是实现IOC的重要一环<br>​    bean和对象<br>​        对象是自己new的，bean是IOC里的</p><h4 id="6-紧耦合和松耦合有什么区别？如何编写松耦合代码"><a href="#6-紧耦合和松耦合有什么区别？如何编写松耦合代码" class="headerlink" title="6.紧耦合和松耦合有什么区别？如何编写松耦合代码"></a>6.紧耦合和松耦合有什么区别？如何编写松耦合代码</h4><p>​    紧耦合<br>​        类之间高度依赖<br>​    松耦合<br>​        松耦合是通过促进单一职责和接口分离、依赖倒置的设计原则来实现<br>​        单一职责</p><p><img alt="4" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124162413.png">        接口分离</p><p><img alt="5" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124162418.png">        </p><p>​    依赖倒置</p><p><img alt="6" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124162407.png"></p><h4 id="9-BeanFactory和ApplicationContext有什么区别"><a href="#9-BeanFactory和ApplicationContext有什么区别" class="headerlink" title="==9.BeanFactory和ApplicationContext有什么区别=="></a>==9.BeanFactory和ApplicationContext有什么区别==</h4><p>​    共同点<br>​        都可以作为容器，管理bean的生命周期<br>​    不同点<br>​        ApplicationContext相当于是4s店，不生产bean，而BeanFactory是工厂<br>​        ApplicationContext做的事情更多<br>​            会帮我们配置的bean注册进来<br>​            加载环境变量<br>​            支持国际化<br>​            事件监听<br>​            注册对外扩展点</p><h4 id="10-BeanFactory和FactoryBean有什么区别"><a href="#10-BeanFactory和FactoryBean有什么区别" class="headerlink" title="==10.BeanFactory和FactoryBean有什么区别=="></a>==10.BeanFactory和FactoryBean有什么区别==</h4><p>​    beanFactory是一个工厂，bean容器，管理bean的生命周期<br>​    FactoryBean是一个bean，由beanFactory生产管理<br>​        它是一个特殊的bean，是一个接口<br>​        使用FactoryBean#getObject()获取FactoryBean产生的对象，相当于工厂设计模式<br>​        细节<br>​            想要获取原本的实例，可以加上“&amp;”<br>​            被FactoryBean修饰后，会变成懒加载</p><h4 id="13-什么是Spring-Bean，JavaBean和SpringBean和对象的区别"><a href="#13-什么是Spring-Bean，JavaBean和SpringBean和对象的区别" class="headerlink" title="13.什么是Spring Bean，JavaBean和SpringBean和对象的区别"></a>13.什么是Spring Bean，JavaBean和SpringBean和对象的区别</h4><p>​    SpringBean<br>​        被Spring管理的对象<br>​    JavaBean<br>​        java的实体类</p><h4 id="14-配置Bean有哪几种方式"><a href="#14-配置Bean有哪几种方式" class="headerlink" title="14.配置Bean有哪几种方式"></a>14.配置Bean有哪几种方式</h4><p>​    xml<br>​    @Component(@Controller,@Service,@Repository)<br>​        前提：配置@Component-scan<br>​        Spring帮我们使用反射调用构造方法<br>​    @Bean<br>​        可以自己控制实例化过程<br>​    @Import<br>​        三种方式<br>​            ImportSelector接口<br>​            ImportBeanDefinitionRegistrar接口<br>​            @ImportResource<br>​        ==可以批量导入，可以导入不在扫描范围内的Bean==</p><h4 id="15-Spring支持的Bean的作用域"><a href="#15-Spring支持的Bean的作用域" class="headerlink" title="15.Spring支持的Bean的作用域"></a>15.Spring支持的Bean的作用域</h4><p>​    @Scope<br>​        单例<br>​        多例<br>​        request<br>​            一个请求创建一个bean<br>​        session<br>​            一次会话创建一个bean<br>​        application<br>​            一个全局应用共享一个bean<br>​        request、session和application在web应用才有<br>​    类比<a href="https://blog.csdn.net/ning_576555615/article/details/48494785" target="_blank" rel="noopener">JavaWeb四大作用域</a></p><h4 id="16-单例Bean的优势"><a href="#16-单例Bean的优势" class="headerlink" title="16.单例Bean的优势"></a>16.单例Bean的优势</h4><p>​    单例设计模式优势同<br>​    性能优势<br>​        减少生成实例消耗<br>​            spring通过反射或cglib生成bean<br>​            分配对象内存<br>​        减少jvm垃圾<br>​        能够快速从缓存中获取bean<br>​    参考答案</p><p><img alt="12" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124193641.png"></p><h4 id="17-Spring的bean是线程安全吗"><a href="#17-Spring的bean是线程安全吗" class="headerlink" title="==17.Spring的bean是线程安全吗=="></a>==17.Spring的bean是线程安全吗==</h4><p>​    单例bean的情况<br>​        如果在类中声明成员变量，并且有读写操作(有状态)，线程不安全，但是成员变量声明在方法中(无状态)，单例bean是安全的</p><h4 id="18-Spring如何处理线程并发问题"><a href="#18-Spring如何处理线程并发问题" class="headerlink" title="==18.Spring如何处理线程并发问题=="></a>==18.Spring如何处理线程并发问题==</h4><p>​    接Q.17<br>​    1.设置为多例<br>​        每个线程都会创建不同的对象<br>​    2.成员变量放到ThreadLocal中<br>​        成员变量会绑定在各自的线程上，不共享<br>​    3.同步锁synchronized<br>​        并行变成了串行，会影响系统吞吐量</p><h4 id="33-Spring有哪几种配置方式"><a href="#33-Spring有哪几种配置方式" class="headerlink" title="33.Spring有哪几种配置方式"></a>33.Spring有哪几种配置方式</h4><p>​    1.xml<br>​        spring诞生就有的<br>​        spring-xml  <bean><br>​    2.注解<br>​        Spring2.5<br>​        spring.xml  <component-scan>  @Component  @Autowired<br>​    3.java配置<br>​        javaConfig  Spring3.0+<br>​        @Configuration  @Bean</component-scan></bean></p><h4 id="34-JavaConfig是如何替代spring-xml的"><a href="#34-JavaConfig是如何替代spring-xml的" class="headerlink" title="==34.JavaConfig是如何替代spring.xml的=="></a>==34.JavaConfig是如何替代spring.xml的==</h4><p>​    应用<br>​        xml<br>​            ClassPathXmlApplicationContext<br>​            spring.xml<br>​            <bean scope lazy><br>​            <component-scan><br>​            引入外部属性配置文件<br>​                <contetx:property-placeholder location="db.properties"><br>​            <property value="${password}"><br>​            <import>指定其他配置文件<br>​        javaconfig<br>​            AnnotationConfigApplicationContext<br>​            @Configuration<br>​            @Bean @Scope @Lazy<br>​            @ComponentScan<br>​            @PropertySource(“classpath:db.properties”)<br>​            @Value(“${password}”)<br>​            @Import比较灵活<br>​    源码<br>​        Q.28<br>​        BeanFactory.getBean是一样的<br>​        参考</import></property></contetx:property-placeholder></component-scan></bean></p><p><img alt="25" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124194042.png"></p><h4 id="42-Configuration的作用及解析原理"><a href="#42-Configuration的作用及解析原理" class="headerlink" title="==42.@Configuration的作用及解析原理=="></a>==42.@Configuration的作用及解析原理==</h4><p>​    1.代替spring.xml配置文件<br>​    2.没有@Configuration也可以配置@Bean<br>​    ==3.@Configuration加与不加有什么区别==<br>​        加了@Configuration会为配置类创建Cglib代理，保证配置类@Bean方法调用Bean的单例，@Bean方法的调用就会通过getBean获取    </p><p>​    <img alt="28" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124210616.png"></p><p>​    原理<br>​        1.创建Spring上下文会注册ConfigurationClassPostProcessor<br>​        2.调用invokeBeanFactoryPostProcessors,就会调用ConfigurationClassPostProcessor就会解析各种注解(@Component，@Bean)<br>​        3.ConfigurationClassPostProcessor#postProcessBeanFactory会给配置类创建cglib动态代理</p><p><img alt="6" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124211115.png"></p><h4 id="64-Spring事件监听机制"><a href="#64-Spring事件监听机制" class="headerlink" title="64.Spring事件监听机制"></a>64.Spring事件监听机制</h4><p>​    观察者模式<br>​        事件<br>​        监听器<br>​        多播器<br>​    异步事件<br>​        多线程</p><h4 id="65-Spring中都用到了哪些设计模式"><a href="#65-Spring中都用到了哪些设计模式" class="headerlink" title="==65.Spring中都用到了哪些设计模式=="></a>==65.Spring中都用到了哪些设计模式==</h4><p>​    简单工厂<br>​        Beanfactory.getBean<br>​    工厂方法<br>​        FactoryBean.getObject<br>​    单例模式<br>​        Bean实例<br>​    适配器模式<br>​        SpringMVC的HandlerAdapter<br>​    装饰器模式<br>​        BeanWrapper<br>​    代理模式<br>​        AOP、事务<br>​    观察者模式<br>​        事件监听<br>​    策略模式<br>​        excludeFilters、includeFilters    @ComponentScan<br>​    模板方法模式<br>​        Spring几乎所有外接扩展(beanPostProcessor)<br>​    责任链模式<br>​        AOP、事务调用</p><h4 id="66-Spring是如何整合Mybatis管理Mapper接口的"><a href="#66-Spring是如何整合Mybatis管理Mapper接口的" class="headerlink" title="66.Spring是如何整合Mybatis管理Mapper接口的"></a>66.Spring是如何整合Mybatis管理Mapper接口的</h4><p>​    ==难点：给Mapper接口加上@Component由于注册BeanDefinition时不会注册接口类(参考解析@Component)且生产bean的时候也不会去生产接口的实例==<br>​    1.Mybatis提供mapper的jdk动态代理<br>​        注册BeanDefinition时不会注册接口类<br>​    2.实现BeanDefinitionRegistryPostProcessor动态注册BeanDefinition<br>​    3.实现自定义扫描器，重写ClassPathBeanDefinitionScanner排除接口的方法(isCandidateComponent)<br>​        批量扫描BeanDefinition<br>​    4.修改BeanDefinition的BeanClass替换为JDK动态代理实例(FactoryBean);偷天换日<br>​        生产bean的时候也不会去生产接口的实例<br>​    5.通过FactoryBean的工厂方法设计模式自由控制bean的实例化过程(getObject)<br>​<br>​    ==Spring注册BeanDefinition时不会注册接口类==</p><p>​    参考</p><p>​    <img alt="42" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124201403.png"></p><h3 id="IOC加载流程"><a href="#IOC加载流程" class="headerlink" title="IOC加载流程"></a>IOC加载流程</h3><h4 id="11-SpringIOC容器的加载过程"><a href="#11-SpringIOC容器的加载过程" class="headerlink" title="==11.SpringIOC容器的加载过程=="></a>==11.SpringIOC容器的加载过程==</h4><p>​    其实就是Bean的创建过程<br>​    new ApplicationContext()<br>​    invokeBeanFactoryPostProcessors<br>​        扫描包(@Component,@Import,@ComponentScan)，解析类信息，使用BeanDefinition存储类信息，注册为bean定义<br>​        使用beanDefinitionMap缓存起来<br>​    国际化、扩展点、监听器<br>​    finishBeanFactoryInitialization<br>​        判断是否符合生产标准<br>​            是单例<br>​            不是懒加载<br>​            不是抽象类<br>​        推断构造方法(spring通过构造方法反射)<br>​        通过反射实例化对象(纯静态)<br>​        需要属性赋值，则注入属性(@Autowired,@ByName…)<br>​        初始化<br>​            生命周期方法回调<br>​            需要动态代理，则创建动态代理<br>​        加入一级缓存<br>​    参考答案<br>​    <img alt="8" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124201613.png"></p><p><img alt="9" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124201616.png"></p><h4 id="12-SpringIOC有哪些扩展点，在什么时候调用"><a href="#12-SpringIOC有哪些扩展点，在什么时候调用" class="headerlink" title="==12.SpringIOC有哪些扩展点，在什么时候调用=="></a>==12.SpringIOC有哪些扩展点，在什么时候调用==</h4><p>​    1.实现BeanFactoryPostProcessor<br>​    2.实现BeanDefinitionRegistryPostProcessor</p><p>​    <img alt="10" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124204411.png"></p><p>​    3.BeanPostProcessor：bean的生命周期调用9次<br>​    4.初始化调用</p><p>​    <img alt="11" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124204415.png"></p><p>​    5.FactoryBean</p><h4 id="24-Spring在加载过程中Bean哪有几种形态"><a href="#24-Spring在加载过程中Bean哪有几种形态" class="headerlink" title="==24.Spring在加载过程中Bean哪有几种形态=="></a>==24.Spring在加载过程中Bean哪有几种形态==</h4><p>​    概念态<br>​    定义态<br>​    纯静态<br>​    成熟态<br>​    参考</p><p><img alt="17" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124204510.png"></p><h4 id="注册BeanDefinition"><a href="#注册BeanDefinition" class="headerlink" title="注册BeanDefinition"></a>注册BeanDefinition</h4><h5 id="8-BeanDefinition的作用"><a href="#8-BeanDefinition的作用" class="headerlink" title="==8.BeanDefinition的作用=="></a>==8.BeanDefinition的作用==</h5><p>​    主要负责存储bean的定义信息：决定Bean的生产方式<br>​        如对象的路径名、懒加载、单例、自动装配方式<br>​    先根据用户配置生成BeanDefinition，然后生成Bean</p><h5 id="28-描述BeanDefinition的加载过程"><a href="#28-描述BeanDefinition的加载过程" class="headerlink" title="28.描述BeanDefinition的加载过程"></a>28.描述BeanDefinition的加载过程</h5><p>​    BeanDefinitionReader读取配置文件<br>​    ConfigurationClassParser解析加了@Configuation的配置文件<br>​        解析@Component等注解<br>​    @ComponentScan为例ClassPathBeanDefinitionScanner#doScan<br>​        扫描包路径下的所有.class文件，扫描是否包含@Service,@Component注解<br>​    注册beanDefinition</p><h5 id="31-spring启动时，为什么先加载BeanFactoryPostProcessor"><a href="#31-spring启动时，为什么先加载BeanFactoryPostProcessor" class="headerlink" title="31.spring启动时，为什么先加载BeanFactoryPostProcessor"></a>31.spring启动时，为什么先加载BeanFactoryPostProcessor</h5><p>​    1.因为BeanDefinition会在IOC容器加载的时候先注册，而BeanFactoryPostProcessor就是在beanDefinition注册完后做扩展的<br>​    2.解析配置类的组件(生成BeanDefinition)ConfigurationClassPostProcessor实现了BeanFactoryPostProcessor(准确的来说是BeanDefinitionRegistryPostProcessor)，所以要先去加载BeanFactoryPostProcessor</p><h5 id="解析注解-系统的BeanDefinitionRegistryPostProcessor"><a href="#解析注解-系统的BeanDefinitionRegistryPostProcessor" class="headerlink" title="解析注解(系统的BeanDefinitionRegistryPostProcessor)"></a>解析注解(系统的BeanDefinitionRegistryPostProcessor)</h5><h6 id="45-为什么-ComponentScan不设置basePackage也会扫描"><a href="#45-为什么-ComponentScan不设置basePackage也会扫描" class="headerlink" title="45.为什么@ComponentScan不设置basePackage也会扫描"></a>45.为什么@ComponentScan不设置basePackage也会扫描</h6><p>​    因为Spring在解析@ComponentScan的时候，如果没设置basePackage，会将当前配置类所在包作为扫描路径</p><h6 id="35-Controller-Component-Repository-Service有什么区别"><a href="#35-Controller-Component-Repository-Service有什么区别" class="headerlink" title="35.@Controller,@Component,@Repository,@Service有什么区别"></a>35.@Controller,@Component,@Repository,@Service有什么区别</h6><p>​    元注解都是@Component<br>​    三层分别使用三个注解，代码阅读性更强，每个注解职责更清晰</p><h6 id="36-Import可以有几种用法"><a href="#36-Import可以有几种用法" class="headerlink" title="36.@Import可以有几种用法"></a>36.@Import可以有几种用法</h6><p>​    Q.14<br>​    @Import直接指定类<br>​        配置类按配置类解析，普通类解析为bean<br>​    ImportSelector.class<br>​        看一次性注册多个，返回一个String[]{}类的完整类路径，但不能干预实例化过程<br>​        DeferredImportSelector<br>​            延迟加载<br>​    ImportBeanDefinitionRegistrar<br>​        可以一次性注册多个<br>​        需要自己去创建注册beanDefinition，可以使用BeanDefinitionRegistry动态注册</p><h6 id="43-Bean的方法调用怎么保证单例"><a href="#43-Bean的方法调用怎么保证单例" class="headerlink" title="==43.@Bean的方法调用怎么保证单例=="></a>==43.@Bean的方法调用怎么保证单例==</h6><p>​    同@Configuration加与不加有什么区别<br>​        加了@Configuration会为配置类创建Cglib代理，保证配置类@Bean方法调用Bean的单例，@Bean方法的调用就会通过getBean获取<br>​    原理<br>​        1.创建Spring上下文会注册ConfigurationClassPostProcessor<br>​        2.调用invokeBeanFactoryPostProcessors,就会调用ConfigurationClassPostProcessor就会解析各种注解(@Component，@Bean)<br>​        3.ConfigurationClassPostProcessor#postProcessBeanFactory会给配置类创建cglib动态代理<br>​    参考</p><p><img alt="29" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124212108.png"></p><h6 id="32-Bean的生产顺序-BeanDefinition的注册顺序-是由什么决定的"><a href="#32-Bean的生产顺序-BeanDefinition的注册顺序-是由什么决定的" class="headerlink" title="==32.Bean的生产顺序(BeanDefinition的注册顺序)是由什么决定的=="></a>==32.Bean的生产顺序(BeanDefinition的注册顺序)是由什么决定的==</h6><p>​    bean的创建顺序由BeanDefinition的注册顺序来决定的，当然依赖关系也会影响Bean的创建顺序<br>​    ==追问：BeanDefinition的注册顺序是由什么决定的==<br>​        主要由注解的解析顺序决定<br>​            @Configuration<br>​            @Import导入的@Configuration<br>​            @Component<br>​            @Import—-class<br>​            @Import—-@Configuration—-@Bean<br>​            @Bean<br>​            @Import—-ImportBeanDefinitionRegistrar<br>​            自己实现的BeanDefinitionRegistryPostProcessor<br>​            后加载的会覆盖前面的<br>​        细节(@Order)</p><h6 id="44-将第三方的类配置成bean有哪些方式"><a href="#44-将第三方的类配置成bean有哪些方式" class="headerlink" title="==44.将第三方的类配置成bean有哪些方式=="></a>==44.将第三方的类配置成bean有哪些方式==</h6><p>​    Q.32<br>​    @Bean<br>​    @Import<br>​        Q.36<br>​        @Import直接导入类<br>​        ImportSelector<br>​        ImportBeanDefinitionRegistrar<br>​            可以自定义BeanDefinition<br>​    自己实现的BeanDefinitionRegistryPostProcessor</p><h5 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h5><h6 id="29-如何在所有BeanDefinition注册完后做扩展"><a href="#29-如何在所有BeanDefinition注册完后做扩展" class="headerlink" title="29.如何在所有BeanDefinition注册完后做扩展"></a>29.如何在所有BeanDefinition注册完后做扩展</h6><p>​        Q.12<br>​        BeanFactoryPostProcessor可以</p><h4 id="创建Bean"><a href="#创建Bean" class="headerlink" title="创建Bean"></a>创建Bean</h4><h5 id="7-BeanFactory的作用"><a href="#7-BeanFactory的作用" class="headerlink" title="==7.BeanFactory的作用=="></a>==7.BeanFactory的作用==</h5><p>​    Spring非常核心的一个顶层接口<br>​    主要职责：生产Bean<br>​    Spring容器(管理着Bean的生命周期 )<br>​    答案</p><p><img alt="7" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124212501.png"></p><h5 id="25-解释Spring框架中Bean的生命周期"><a href="#25-解释Spring框架中Bean的生命周期" class="headerlink" title="==25.解释Spring框架中Bean的生命周期=="></a>==25.解释Spring框架中Bean的生命周期==</h5><p>​    Bean的生命周期<br>​        从创建到销毁的过程<br>​    四大步<br>​        实例化<br>​            Q.19<br>​            推断构造函数，通过反射实例化<br>​            静态工厂、实例工厂<br>​        属性赋值<br>​            Q.22<br>​            解析自动装配(byName,byType)：DI体现<br>​            会出现循环依赖<br>​        初始化<br>​            调用XXXAware回调<br>​            调用初始化生命周期回调<br>​                Q.23<br>​            如果bean实现了AOP，创建动态代理<br>​        销毁<br>​            在spring容器关闭的时候进行调用<br>​            调用销毁生命周期回调<br>​    参考</p><p><img alt="18" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124212912.png"></p><h5 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h5><h6 id="19-Spring实例化Bean有几种方式"><a href="#19-Spring实例化Bean有几种方式" class="headerlink" title="19.Spring实例化Bean有几种方式"></a>19.Spring实例化Bean有几种方式</h6><p>​        1.构造器(反射)<br>​            存到BeanDefinition.beanClass<br>​            然后反射<br>​        2.静态工厂<br>​            factory-method指定的静态方法</p><p><img alt="13" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124213008.png"></p><p>​        3.实例工厂方式<br>​            factory-bean+factory-method<br>​            @Bean底层用的就是此方式</p><p><img alt="14" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124213016.png"></p><p>​        4.FactoryBean<br>​            getObject()</p><h5 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h5><h6 id="20-什么是bean的自动装配-装配"><a href="#20-什么是bean的自动装配-装配" class="headerlink" title="20.什么是bean的自动装配(装配)"></a>20.什么是bean的自动装配(装配)</h6><p>​    手动装配<br>​        <property></property>一个一个指定<br>​    自动装配<br>​        根据@Autowired、@Resource注入</p><h6 id="21-自动注入有什么限制-需要注意"><a href="#21-自动注入有什么限制-需要注意" class="headerlink" title="21.自动注入有什么限制(需要注意)"></a>21.自动注入有什么限制(需要注意)</h6><p>​    一定要声明set方法<br>​    可以使用<property><constructor>覆盖<br>​    不能自动装配简单的属性，如基本数据类型、字符串和类。但是手动注入(&lt;property&gt;,@Value)可以注入基本数据类型<br>​    模糊特性：自动装配不如显示装配精确</constructor></property></p><h6 id="22-自动装配方式有几种"><a href="#22-自动装配方式有几种" class="headerlink" title="22.自动装配方式有几种"></a>22.自动装配方式有几种</h6><p>​    no<br>​        默认<br>​        需要自己在xml里面配置<property ref><br>​    byName<br>​        根据setXXX的名字，不是属性名<br>​    byType<br>​        根据set方法传入的类型<br>​    constructor<br>​    autodetect<br>​        spring3.0后弃用<br>​    参考答案</property></p><p><img alt="15" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124213249.png"></p><h6 id="26-Spring如何解决bean的循环依赖"><a href="#26-Spring如何解决bean的循环依赖" class="headerlink" title="==26.Spring如何解决bean的循环依赖(*)=="></a>==26.Spring如何解决bean的循环依赖(<em>*</em>)==</h6><p>采用了三级缓存<br>    一级缓存<br>        存储完整的bean<br>        方便以后直接getBean获取对象<br>    二级缓存<br>        存储纯静态的bean<br>        ==避免多重循环依赖(b和c都依赖a),重复创建动态代理==<br>        ==保证多线程下bean的完整性==<br>    三级缓存<br>        存储了bean动态代理的一个函数接口<br>        ==不会立即调用：如果立即调用，不管bean是否是循环依赖，都会在实例化后创建proxy，但是正常bean，spring还是希望遵循生命周期在初始化创建动态代理；只有循环依赖，才会在实例化后创建动态代理==<br>        延时获取：提高性能，因为并不是所有的Bean都存在循环引用，所以当真正调用时再缓存该单例到二级缓存<br>        提高扩展性：采用bean的后置处理器方式可以提高扩展性<br>夺命连环问<br>    1.二级缓存能不能解决循环依赖<br>        a.如果只想解决循环依赖死循环：一级缓存就可以解决，但并发情况下会获取到不完整的bean<br>        b.二级缓存也可以解决循环依赖：可以避免重复循环依赖多次创建aop动态代理<br>    <a href="https://blog.csdn.net/weixin_48777366/article/details/123645686" target="_blank" rel="noopener">2.spring有没有解决多例bean的循环依赖</a><br>        没有解决，会报错BeanCurrentlyInCreationException<br>        a.多例bean不会使用缓存进行存储(多例bean 每次使用都需要重新创建)<br>        b.不缓存早期对象就无法解决循环依赖<br>    <a href="https://baijiahao.baidu.com/s?id=1676046519501587416&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">3.Spring有没有解决构造函数参数bean的循环依赖</a><br>        没有解决，beforeSingletonCreation报错？<br>            构造器会在实例化时候调用，一二三级缓存还没有<br>        可以通过@Lazy解决<br>            不会立即创建Bean，等到用到的时候才会创建<br>    参考答案</p><p>​    <img alt="21" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124214018.png"></p><p>参考</p><p><img alt="19" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124214141.png"></p><p>循环依赖图解</p><p><img alt="循环依赖课上图" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124214138.png"></p><h6 id="27-Spring如何在并发下避免获取不完整的Bean"><a href="#27-Spring如何在并发下避免获取不完整的Bean" class="headerlink" title="==27.Spring如何在并发下避免获取不完整的Bean=="></a>==27.Spring如何在并发下避免获取不完整的Bean==</h6><p>​    双重检查锁：2个同步锁(锁对象都是一级缓存)<br>​        1.getSingleton(A,boolean)</p><p>​        <img alt="23" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124214314.png"></p><p>​        2.getSingleton(A,objectFactory)</p><p>​    <img alt="22" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124214324.png"></p><p>​    追问<br>​        一级缓存为什么不加入锁<br>​            性能问题，其他线程可能要从一级缓存中获取bean<br>​    循环依赖图解(同Q.26)</p><h6 id="37-如何让自动注入没有找到依赖Bean时不会报错"><a href="#37-如何让自动注入没有找到依赖Bean时不会报错" class="headerlink" title="37.如何让自动注入没有找到依赖Bean时不会报错"></a>37.如何让自动注入没有找到依赖Bean时不会报错</h6><p>​    @Autowired(required = false)</p><h6 id="38-如何让自动注入找到多个依赖Bean不会报错"><a href="#38-如何让自动注入找到多个依赖Bean不会报错" class="headerlink" title="38.如何让自动注入找到多个依赖Bean不会报错"></a>38.如何让自动注入找到多个依赖Bean不会报错</h6><p>​    @Primary<br>​        设置此bean时主要的，优先级最高</p><h6 id="39-Autowired有什么作用"><a href="#39-Autowired有什么作用" class="headerlink" title="39.@Autowired有什么作用"></a>39.@Autowired有什么作用</h6><p>​    @Autowired对比byName,byType能更细粒度的注入属性(byName,byType会给所有set方法注入)<br>​    ==@Autowired默认按类型，按类型找到多个再按照名称，并且不需要提供get/set方法==</p><h6 id="属性注入方式"><a href="#属性注入方式" class="headerlink" title="属性注入方式"></a>属性注入方式</h6><p>​    set注入<br>​        在pupulateBean注入<br>​    构造器注入<br>​        在实例化的时候就实现了注入<br>​    @Autowired注入<br>​        @Autowired对比byName,byType能更细粒度的注入属性(byName,byType会给所有set方法注入)<br>​        @Autowired默认按类型，按类型找到多个再按照名称，并且不需要提供get/set方法</p><h6 id="40-Autowired和-Resource的区别"><a href="#40-Autowired和-Resource的区别" class="headerlink" title="40.@Autowired和@Resource的区别"></a>40.@Autowired和@Resource的区别</h6><p>​    @Autowired<br>​        是spring提供的<br>​        @Autowired默认按类型，按类型找到多个再按照名称，并且不需要提供get/set方法<br>​    @Resource<br>​        jdk提供<br>​        @esource默认按名字，按名字找到多个再按照类型</p><h6 id="41-Autowired注解自动装配底层原理"><a href="#41-Autowired注解自动装配底层原理" class="headerlink" title="==41.@Autowired注解自动装配底层原理=="></a>==41.@Autowired注解自动装配底层原理==</h6><p>​    通过BeanPostProcessor进行解析的<br>​        1.创建spring上下文时候注册AutowiredAnnotationBeanPostProcessor<br>​        2.实例化后预解析@Autowired类型、名称、属性等信息；在属性注入时，去IOC根据缓存的元数据信息返回注入bean<br>​    参考</p><p>​    <img alt="26" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124214837.png"></p><p>​    图解</p><p><img alt="27" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124214846.png"></p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><h6 id="23-Bean有哪些生命周期回调方法，有哪几种实现方式"><a href="#23-Bean有哪些生命周期回调方法，有哪几种实现方式" class="headerlink" title="==23.Bean有哪些生命周期回调方法，有哪几种实现方式=="></a>==23.Bean有哪些生命周期回调方法，有哪几种实现方式==</h6><p>​    初始化(从前到后)<br>​        @PostConstruct<br>​        InitializingBean接口<br>​        @Bean的init-method<br>​    销毁(从前到后)<br>​        @PreDestroy<br>​        DisposableBean接口<br>​        @Bean的destroy-method<br>​    参考</p><p><img alt="16" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124215050.png"></p><h5 id="30-如何在所有bean创建完后做扩展"><a href="#30-如何在所有bean创建完后做扩展" class="headerlink" title="==30.如何在所有bean创建完后做扩展=="></a>==30.如何在所有bean创建完后做扩展==</h5><p>​    哪里才算所有的Bean创建完<br>​        循环所有BeanDefinition执行getBean之后，所有bean就创建完了<br>​    1.SmartInitializingSingleton<br>​        finishBeanFactoryInitialization<br>​            preInstantiateSingletons<br>​                遍历完所有BeanDefinition之后<br>​    2.监听ContextRefreshedEvent事件<br>​        finishRefresh<br>​        注：注解形式解析类其实实现了SmartInitializingSingleton</p><p><img alt="24" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124215207.png"></p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="46-什么是AOP，能做什么"><a href="#46-什么是AOP，能做什么" class="headerlink" title="46.什么是AOP，能做什么"></a>46.什么是AOP，能做什么</h4><p>​    面向切面编程<br>​        用于与业务无关，但对多个对象产生影响的公共行为和逻辑。减少系统中的重复代码，降低了模块间的耦合度，提高了系统的可维护性<br>​        可用于权限认证、日志、事务</p><h4 id="47-解释Spring-AOP常见的概念名词"><a href="#47-解释Spring-AOP常见的概念名词" class="headerlink" title="47.解释Spring AOP常见的概念名词"></a>47.解释Spring AOP常见的概念名词</h4><p>​    切面Aspect<br>​        自己定义的切面类(@Aspectj)，管理了切点和通知<br>​    连接点Join point<br>​        指的就是被增强的业务方法(自己写的业务逻辑)<br>​    通知advice<br>​        就是需要增强到业务方法中的公共代码<br>​            前置通知<br>​            后置通知<br>​            环绕通知<br>​            异常通知<br>​            返回通知<br>​    切点Pointcut<br>​        通过切点表达式决定哪些方法需要被增强<br>​    目标对象<br>​        增强的对象，业务逻辑类的对象<br>​    顾问(Advisor)<br>​        Pointcut和Advice的一个结合<br>​        应用层面无需关心<br>​    织入Weaving<br>​        Aspectj独有<br>​        Spring aop织入方式：动态代理</p><h4 id="48-Spring通知有哪些类型"><a href="#48-Spring通知有哪些类型" class="headerlink" title="48.Spring通知有哪些类型"></a>48.Spring通知有哪些类型</h4><p>​    类型<br>​        前置通知<br>​        后置通知<br>​        环绕通知<br>​        异常通知<br>​        返回通知<br>​    执行顺序<br>​        spring5.2.7之前<br>​            后置通知在返回通知和异常通知之前<br>​        spring5.2.7之后<br>​            正常:around(before)-&gt; before -&gt; around(proceed方法体执行) -&gt; afterReturning -&gt; after -&gt; around(after)<br>​            异常:around(before)-&gt; before -&gt; around(proceed方法体执行) -&gt; AfterThrowing -&gt; after</p><h4 id="49-Spring-AOP和Aspectj-AOP有什么区别"><a href="#49-Spring-AOP和Aspectj-AOP有什么区别" class="headerlink" title="49.Spring AOP和Aspectj AOP有什么区别"></a>49.Spring AOP和Aspectj AOP有什么区别</h4><p>​    联系<br>​        Spring AOP提供了AspectJ的支持，但只能用到AspectJ的切点解析和匹配(@Aspect、@Before)<br>​        @Aspect、@Before等都是AspectJ发明的<br>​    区别<br>​        Spring<br>​            动态代理<br>​                使用接口：jdk<br>​                没有接口：cglib<br>​            在容器启动的时候生成代理实例<br>​                方法调用上也会增加栈的深度<br>​        AspectJ<br>​            静态代理<br>​                编译的时候动态修改.class文件<br>​            实际代码运行前(编译时)完成织入</p><p><img alt="30" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125160735.png"></p><h4 id="50-JDK动态代理和CGLIB动态代理"><a href="#50-JDK动态代理和CGLIB动态代理" class="headerlink" title="50.JDK动态代理和CGLIB动态代理"></a>50.JDK动态代理和CGLIB动态代理</h4><p>​    JDK动态代理<br>​        实现了接口<br>​        JDK在运行时为目标类生成一个动态代理类$proxy*.class<br>​        该代理类会实现目标类接口，并且代理类会实现接口所有的方法增强代码。<br>​        ==调用时，通过代理类先去  调用  处理类进行增强，在通过反射方式进行调用目标方法==<br>​    CGLIB动态代理<br>​        没有实现接口<br>​        使用ASM在运行时动态生成目标类的子类。会生成多个<br>​        会重写父类所有的方法增强代码<br>​        调用时，通过代理类进行增强，再  直接调用  父类对应的方法进行调用目标方法<br>​            如果某个类被标记为final，不能被继承，也无法做CGLIB动态代理<br>​            ==除了生成目标子类代理类，还有一个FastClass(路由类)，可以让(不是必须，Spring没使用)本类方法调用重复增强，不像jdk代理只能增强一次==<br>​    jdk生成动态代理快，调用慢(反射)，cglib生成慢(ASM多个类)，调用快<br>​        老版本cglib快，目前jdk快<br>​    参考</p><p><img alt="31" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125162016.png"></p><h4 id="51-JavaConfig如何启用AOP，如何强制使用cglib"><a href="#51-JavaConfig如何启用AOP，如何强制使用cglib" class="headerlink" title="51.JavaConfig如何启用AOP，如何强制使用cglib"></a>51.JavaConfig如何启用AOP，如何强制使用cglib</h4><p>​    启用AOP<br>​        @EnableAspectJAutoProxy<br>​            强制CGLIB<br>​                proxyTargetClass = true<br>​            在线程中暴露代理对象<br>​                exposeProxy = true<br>​                底层就会把代理对象存到ThreadLocal(绑定到当前线程上)中</p><h4 id="52-介绍AOP有几种实现方式"><a href="#52-介绍AOP有几种实现方式" class="headerlink" title="52.介绍AOP有几种实现方式"></a>52.介绍AOP有几种实现方式</h4><p>​    spring1.2<br>​        基于接口<br>​    spring2.0<br>​        xml<br>​    spring2.0<br>​        注解<br>​    AspectJ</p><h4 id="53-什么情况下AOP会失效，怎么解决"><a href="#53-什么情况下AOP会失效，怎么解决" class="headerlink" title="53.什么情况下AOP会失效，怎么解决"></a>53.什么情况下AOP会失效，怎么解决</h4><p>​    Q.51<br>​    失效原因<br>​        内部调用(方法内部调用另一个方法，事务相关!!!)不会触发AOP，必须走代理<br>​        方法是private，必须是public<br>​        目标类没有配置为bean<br>​        切点表达式不正确<br>​        Q.73<br>​    解决<br>​        从本类中自动注入当前bean(IOC存的就是代理类)<br>​        在线程中暴露代理对象<br>​            exposeProxy = true<br>​            底层就会把代理对象存到ThreadLocal(绑定到当前线程上)中</p><h4 id="54-Spring-AOP在哪里创建的动态代理"><a href="#54-Spring-AOP在哪里创建的动态代理" class="headerlink" title="==54.Spring AOP在哪里创建的动态代理=="></a>==54.Spring AOP在哪里创建的动态代理==</h4><p>​    1.普通bean<br>​        初始化后，使用beanPostProcessor创建<br>​    2.循环依赖<br>​        在属性注入的时候<br>​    参考</p><p><img alt="32" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125200212.png"></p><h4 id="55-描述AOP的完整实现流程"><a href="#55-描述AOP的完整实现流程" class="headerlink" title="==55.描述AOP的完整实现流程=="></a>==55.描述AOP的完整实现流程==</h4><p>​    @EnableAspectJAutoProxy会通过@Import注册一个BeanPostProcessor处理AOP<br>​    1.解析切面<br>​        实例化之前第一个BeanPostProcessor<br>​    2.创建代理<br>​        初始化后调用BeanPostProcessor拿到之前缓存的advisor，根据advisor的pointcut匹配当前bean是否命中<br>​    3.调用代理<br>​        拿到动态代理对象，判断是否是需要增强的方法<br>​        如果是需要增强的方法，就拿到所有的advisors<br>​        转换为Interceptor，通过责任链调用<br>​    参考</p><p><img alt="33" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125200314.png"></p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="56-事务四大特性"><a href="#56-事务四大特性" class="headerlink" title="56.事务四大特性"></a>56.事务四大特性</h4><p>​    原子性<br>​        要么都成功要么都失败<br>​    一致性<br>​        A转账给B，执行前执行后数据一致<br>​    隔离性<br>​        事务执行时，不被其他事务操作干扰<br>​    持久性<br>​        事务一旦提交，改变就是永久性的；遇到故障，也不会丢失提交事务的操作<br>​    参考</p><p><img alt="34" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125201452.png"></p><h4 id="57-Spring支持的事务管理类型，Spring事务实现方式有哪些"><a href="#57-Spring支持的事务管理类型，Spring事务实现方式有哪些" class="headerlink" title="57.Spring支持的事务管理类型，Spring事务实现方式有哪些"></a>57.Spring支持的事务管理类型，Spring事务实现方式有哪些</h4><p>​    事务管理类型<br>​        编程式事务<br>​        声明式事务<br>​    实现方式<br>​        基于接口<br>​            基于TransactionInterceptor的声明式事务<br>​            基于TransactionProxyFactoryBean的声明式事务<br>​        基于<tx>和<aop>命名空间的声明式事务<br>​        基于@Transactional全注解方式<br>​        参考</aop></tx></p><p><img alt="35" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125201634.png"></p><h4 id="58-说一下Spring的事务传播行为"><a href="#58-说一下Spring的事务传播行为" class="headerlink" title="==58.说一下Spring的事务传播行为=="></a>==58.说一下Spring的事务传播行为==</h4><p>​    ==事务的传播行为指的是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行==<br>​    事务传播行为</p><p><img alt="36" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125201859.png"></p><h4 id="59-说一下Spring的事务隔离级别"><a href="#59-说一下Spring的事务隔离级别" class="headerlink" title="==59.说一下Spring的事务隔离级别=="></a>==59.说一下Spring的事务隔离级别==</h4><p>​    并发产生的问题<br>​        脏读<br>​            事务A读取了事务B未提交的数据<br>​        不可重复读<br>​            事务A两次读取数据(一条数据)不一致<br>​        幻读<br>​            事务A两次统计数据条数(针对整张表)不一致<br>​    隔离级别<br>​        读未提交<br>​        读已提交<br>​        可重复读<br>​            行锁<br>​        串行化<br>​            表锁</p><h4 id="60-Spring事务实现原理"><a href="#60-Spring事务实现原理" class="headerlink" title="==60.Spring事务实现原理=="></a>==60.Spring事务实现原理==</h4><p>​    基于AOP，和AOP相似<br>​    @EnableTransactionManagement<br>​    1.解析切面<br>​        实例化之前第一个beanPostProcessor解析Spring事务自定义的advisor信息<br>​    2.创建代理<br>​        bean的初始化后beanPostProcessor，匹配(方法、类上、接口或父类上有没有@Transactional)<br>​    3.调用代理<br>​        创建数据库连接Connection，修改数据库连接属性autoCommit=false！！！<br>​        执行目标方法，执行sql<br>​        执行完后，有异常回滚，没异常提交</p><h4 id="61-Spring事务传播行为实现原理"><a href="#61-Spring事务传播行为实现原理" class="headerlink" title="==61.Spring事务传播行为实现原理=="></a>==61.Spring事务传播行为实现原理==</h4><p>​    源码在调用事务中<br>​    思路：connection存在ThreadLocal中，事务进来会判断是否已经有connection，有说明是内嵌事务；之后判断事务隔离级别<br>​        TransactionInfo.newTransaction用于判断融入(内嵌事务不提交)还是创建新事务(内嵌事务提交)<br>​        融入:TransactionInfo.newTransaction=false<br>​            无需暂存，直接用外部事务ThreadLocal中的信息<br>​        创建新事务:TransactionInfo.newTransaction=false<br>​            执行前暂存外部事务connection，隔离级别等各种事务信息<br>​            执行后把事务信息存到ThreadLocal中<br>​        细节<br>​            根据TransactionInfo.newTransaction判断是否要提交<br>​            当前执行的事务都有一个connection存到了ThreadLocal中<br>​    参考</p><p><img alt="37" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125202657.png"></p><p>​    融入</p><p><img alt="38" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125202700.png"></p><p>​    创建新事务</p><p><img alt="39" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125202703.png"></p><h4 id="62-Spring多线程事务能否保证事务的一致性"><a href="#62-Spring多线程事务能否保证事务的一致性" class="headerlink" title="==62.Spring多线程事务能否保证事务的一致性=="></a>==62.Spring多线程事务能否保证事务的一致性==</h4><p>​    事务信息存在ThreadLocal中，多个线程是存在多个ThreadLocal中，所以一个线程永远只能有一个事务；因此不能保证多线程事务一致性<br>​    解决<br>​        编程式事务<br>​        分布式事务<br>​    参考</p><p><img alt="40" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125203043.png"></p><h4 id="63-Spring事务的失效原因"><a href="#63-Spring事务的失效原因" class="headerlink" title="63.Spring事务的失效原因"></a>63.Spring事务的失效原因</h4><p>​    Q.53<br>​<br>​    自己捕获了异常<br>​    Q.73<br>​    内部调用</p><p>参考</p><p><img alt="41" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125203228.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.processon.com/view/link/5f5075c763768959e2d109df&quot;
      
    
    </summary>
    
    
      <category term="面试题" scheme="https://alexander-wd.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="spring" scheme="https://alexander-wd.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>halo博客</title>
    <link href="https://alexander-wd.github.io/2022/11/18/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/docker%E9%83%A8%E7%BD%B2halo%E5%8D%9A%E5%AE%A2/"/>
    <id>https://alexander-wd.github.io/2022/11/18/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/docker%E9%83%A8%E7%BD%B2halo%E5%8D%9A%E5%AE%A2/</id>
    <published>2022-11-18T05:03:12.000Z</published>
    <updated>2023-02-13T10:02:07.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拉取halo"><a href="#拉取halo" class="headerlink" title="拉取halo"></a>拉取halo</h2><p>docker pull halohub/halo:1.5.2</p><p>docker pull halohub/halo</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>mkdir ~/.halo2</p><p>vim application.yaml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8090</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Response data gzip.</span></span><br><span class="line"><span class="attr">  compression:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># H2 database configuration.</span></span><br><span class="line">    <span class="comment">#driver-class-name: org.h2.Driver</span></span><br><span class="line">    <span class="comment">#url: jdbc:h2:file:~/.halo/db/halo</span></span><br><span class="line">    <span class="comment">#username: admin</span></span><br><span class="line">    <span class="comment">#password: 123456</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># MySQL database configuration.</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://127.0.0.1:3306/blog?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># H2 database console configuration.</span></span><br><span class="line">  <span class="comment">#h2:</span></span><br><span class="line">    <span class="comment">#console:</span></span><br><span class="line">    <span class="comment">#  settings:</span></span><br><span class="line">     <span class="comment">#   web-allow-others: false</span></span><br><span class="line">    <span class="comment">#  path: /h2-console</span></span><br><span class="line">    <span class="comment">#  enabled: false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">halo:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Your admin client path is https://your-domain/&#123;admin-path&#125;</span></span><br><span class="line"><span class="attr">  admin-path:</span> <span class="string">admin</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># memory or level</span></span><br><span class="line"><span class="attr">  cache:</span> <span class="string">memory</span></span><br></pre></td></tr></table></figure><p>要事先安装好mysql</p><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>docker pull mysql:5.6</p><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \   </span><br><span class="line">-d mysql:5.6</span><br><span class="line"></span><br><span class="line">密码用户名都是root</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  -it -d \</span><br><span class="line">  --name halo \</span><br><span class="line">  -p 8090:8090 \</span><br><span class="line">  -v ~/.halo2:/root/.halo2 \</span><br><span class="line">  halohub/halo:latest \</span><br><span class="line">  --halo.external-url=http://localhost:8090/ \</span><br><span class="line">  --halo.security.initializer.superadminuser=admin \</span><br><span class="line">  --halo.security.initializer.superadminpassword=admin</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_33411202/article/details/124670673" target="_blank" rel="noopener">docker安装halo</a></p><p><a href="https://blog.csdn.net/qq_25482375/article/details/126250746" target="_blank" rel="noopener">docker安装mysql</a></p><p><a href="https://docs.halo.run/getting-started/install/docker" target="_blank" rel="noopener">官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;拉取halo&quot;&gt;&lt;a href=&quot;#拉取halo&quot; class=&quot;headerlink&quot; title=&quot;拉取halo&quot;&gt;&lt;/a&gt;拉取halo&lt;/h2&gt;&lt;p&gt;docker pull halohub/halo:1.5.2&lt;/p&gt;
&lt;p&gt;docker pull halo
      
    
    </summary>
    
    
      <category term="工具配置" scheme="https://alexander-wd.github.io/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>JUC面试题</title>
    <link href="https://alexander-wd.github.io/2022/11/16/%E9%9D%A2%E8%AF%95%E9%A2%98/JUC%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://alexander-wd.github.io/2022/11/16/%E9%9D%A2%E8%AF%95%E9%A2%98/JUC%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-11-16T08:10:20.000Z</published>
    <updated>2023-02-13T10:08:49.794Z</updated>
    
    <content type="html"><![CDATA[<h3 id="并发基础-理论"><a href="#并发基础-理论" class="headerlink" title="并发基础/理论"></a>并发基础/理论</h3><h4 id="1-并发编程的优缺点"><a href="#1-并发编程的优缺点" class="headerlink" title="1.并发编程的优缺点"></a>1.并发编程的优缺点</h4><p>优点<br>    充分利用多核CPU的计算能力<br>    方便进行业务拆分，提升系统并发能力和性能<br>缺点<br>    内存泄漏<br>    上下文切换<br>    线程安全<br>    死锁</p><h4 id="2-并发编程三要素是什么"><a href="#2-并发编程三要素是什么" class="headerlink" title="2.并发编程三要素是什么"></a>2.并发编程三要素是什么</h4><p>原子性<br>    线程切换带来的原子性问题<br>可见性<br>    线程缓存导致的可见性问题<br>有序性<br>    编译优化带来的有序性问题    </p><h4 id="3-并行和并发有什么区别"><a href="#3-并行和并发有什么区别" class="headerlink" title="3.并行和并发有什么区别"></a>3.并行和并发有什么区别</h4><p>并发<br>    多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行<br>并行<br>    单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”</p><h4 id="4-进程与线程的区别"><a href="#4-进程与线程的区别" class="headerlink" title="4.进程与线程的区别"></a>4.进程与线程的区别</h4><p>进程<br>    操作系统资源分配的基本单位<br>    有独立的代码和数据空间（程序上下文）<br>        程序之间的切换会有较大的开销<br>    每个独立的进程有程序运行的入口、顺序执行序列和程序出口<br>线程<br>    处理器任务调度和执行的基本单位<br>    同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC）<br>        线程之间切换的开销小<br>    但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行<br>同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的<br>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉</p><h5 id="4-1什么是上下文切换"><a href="#4-1什么是上下文切换" class="headerlink" title="4.1什么是上下文切换"></a>4.1什么是上下文切换</h5><p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换</p><h4 id="5-守护线程和用户线程有什么区别"><a href="#5-守护线程和用户线程有什么区别" class="headerlink" title="5.守护线程和用户线程有什么区别"></a>5.守护线程和用户线程有什么区别</h4><p>用户线程<br>    运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程<br>守护线程<br>    运行在后台，为其他前台线程服务。也可以说守护线程是 JVM 中非守护线程的 “佣人”。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作</p><h4 id="6-创建线程有哪几种方式"><a href="#6-创建线程有哪几种方式" class="headerlink" title="==6.创建线程有哪几种方式=="></a>==6.创建线程有哪几种方式==</h4><p>继承 Thread 类；<br>实现 Runnable 接口；<br>实现 Callable 接口；<br>使用 Executors 工具类创建线程池</p><h4 id="7-runnable-和-callable-有什么异同"><a href="#7-runnable-和-callable-有什么异同" class="headerlink" title="7.runnable 和 callable 有什么异同"></a>7.runnable 和 callable 有什么异同</h4><p>相同点<br>    都是接口<br>    都可以编写多线程程序<br>    都采用Thread.start()启动线程<br>不同点<br>    Runnable<br>        Runnable 接口 run 方法无返回值<br>        Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理<br>    Callable<br>        Callable 接口 call 方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果<br>        Callable 接口 call 方法允许抛出异常，可以获取异常信息</p><h4 id="8-线程的-run-和-start-有什么区别"><a href="#8-线程的-run-和-start-有什么区别" class="headerlink" title="8.线程的 run()和 start()有什么区别"></a>8.线程的 run()和 start()有什么区别</h4><p>start<br>    start() 方法用于启动线程<br>    而 start() 只能调用一次<br>    start()方法来启动一个线程，真正实现了多线程运行。调用start()方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， run()方法运行结束， 此线程终止。然后CPU再调度其它线程。<br>run<br>    run() 方法用于执行线程的运行时代码<br>    run() 可以重复调用<br>    run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p><h4 id="9-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法"><a href="#9-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法" class="headerlink" title="==9.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法=="></a>==9.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法==</h4><p>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。<br>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。<br>==总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。==</p><h4 id="10-sleep-和-wait-有什么区别"><a href="#10-sleep-和-wait-有什么区别" class="headerlink" title="10.sleep() 和 wait() 有什么区别"></a>10.sleep() 和 wait() 有什么区别</h4><p>两者都可以暂停线程的执行<br>区别<br>    类的不同：sleep() 是 Thread线程类的静态方法，wait() 是 Object类的方法。<br>    是否释放锁：sleep() 不释放锁；wait() 释放锁。<br>    用途不同：Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。<br>    用法不同：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。</p><h4 id="11-Thread-类中的-yield-方法有什么作用"><a href="#11-Thread-类中的-yield-方法有什么作用" class="headerlink" title="11.Thread 类中的 yield 方法有什么作用"></a>11.Thread 类中的 yield 方法有什么作用</h4><p>使当前线程从执行状态（运行状态）变为可执行态（就绪状态）<br>当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。 </p><h4 id="12-线程的-sleep-方法和-yield-方法有什么区别"><a href="#12-线程的-sleep-方法和-yield-方法有什么区别" class="headerlink" title="12.线程的 sleep()方法和 yield()方法有什么区别"></a>12.线程的 sleep()方法和 yield()方法有什么区别</h4><p>（1） sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；<br>（2） 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；<br>（3）sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；<br>（4）sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。</p><h4 id="13-如何停止一个正在运行的线程"><a href="#13-如何停止一个正在运行的线程" class="headerlink" title="13.如何停止一个正在运行的线程"></a>13.如何停止一个正在运行的线程</h4><p>1.使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。<br>2.使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。<br>3.使用interrupt方法中断线程。</p><h4 id="14-Java-中-interrupted-和-isInterrupted-方法的区别"><a href="#14-Java-中-interrupted-和-isInterrupted-方法的区别" class="headerlink" title="14.Java 中 interrupted 和 isInterrupted 方法的区别"></a>14.Java 中 interrupted 和 isInterrupted 方法的区别</h4><p>interrupt：用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。<br>    会在Thread.cpp底层执行LockSupport.unpark(t)，唤醒当前线程<br>interrupted：是静态方法，查看当前中断信号是true还是false并且清除中断信号。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了。<br>isInterrupted：查看当前中断信号是true还是false</p><h4 id="15-Java-如何实现多线程之间的通讯和协作"><a href="#15-Java-如何实现多线程之间的通讯和协作" class="headerlink" title="15.Java 如何实现多线程之间的通讯和协作"></a>15.Java 如何实现多线程之间的通讯和协作</h4><p>1.syncrhoized加锁的线程的Object类的wait()/notify()/notifyAll()<br>2.ReentrantLock类加锁的线程的Condition类的await()/signal()/signalAll()</p><h4 id="16-park-unpark和-wait-notify区别"><a href="#16-park-unpark和-wait-notify区别" class="headerlink" title="16.park/unpark和 wait/notify区别"></a>16.park/unpark和 wait/notify区别</h4><p>wait和notify方法必须和同步锁 synchronized一块使用。而park/unpark使用就比较灵活了，没有这个限制，可以在任何地方使用。<br>park/unpark 使用时没有先后顺序，都可以使线程不阻塞（前面代码已验证）。而wait必须在notify前先使用，如果先notify，再wait，则线程会一直等待。<br>notify只能随机释放一个线程，并不能指定某个特定线程，notifyAll是释放锁对象中的所有线程。而unpark方法可以唤醒指定的线程。<br>调用wait方法会使当前线程释放锁资源，但使用的前提是必须已经获得了锁。而park不会释放锁资源。</p><p><a href="https://blog.csdn.net/yemuxiaweiliang/article/details/120987740" target="_blank" rel="noopener">参考</a></p><h3 id="并发关键字"><a href="#并发关键字" class="headerlink" title="并发关键字"></a>并发关键字</h3><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><h5 id="1-synchronized-的作用"><a href="#1-synchronized-的作用" class="headerlink" title="1.synchronized 的作用"></a>1.synchronized 的作用</h5><p>在多线程的环境下，控制 synchronized     代码段不被多个线程同时执行<br>早期<br>    在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁是依赖于底层的操作系统的 Mutex Lock 来实现的，需要挂起或环形线程，线程间的切换涉及到从用户态转换为内核态，成本高，这是早期synchronized效率低下的原因<br>优化<br>    自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁</p><h5 id="2-说一下-synchronized-底层实现原理"><a href="#2-说一下-synchronized-底层实现原理" class="headerlink" title="==2.说一下 synchronized 底层实现原理=="></a>==2.说一下 synchronized 底层实现原理==</h5><p>首先要获取锁，而获取锁的过程就是monitorenter ，在执行完代码块之后，要释放锁，释放锁就是执行monitorexit指令。<br>Monitor在C++层面维护了ObjectMonitor的变量，有count计数器表示是否有线程竞争锁<br>==追问==<br>    ==为什么会有两个monitorexit呢==<br>        这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。<br>        因此最后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁<br>    ==synchronized可重入的原理==<br>        底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</p><h5 id="3-多线程中-synchronized-锁升级的原理是什么"><a href="#3-多线程中-synchronized-锁升级的原理是什么" class="headerlink" title="3.多线程中 synchronized 锁升级的原理是什么"></a>3.多线程中 synchronized 锁升级的原理是什么</h5><p>1.在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id<br>2.再次进入的时候会先判断 threadid 是否与其线程 id 一致<br>    如果一致则可以直接使用此对象<br>    如果不一致，则升级偏向锁为轻量级锁<br>3.通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁</p><p>不同线程竞争</p><p><img alt="JVM锁的膨胀升级" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JUC/20230119213935.jpg"></p><p>锁升级流程图</p><p><img alt="synchronized锁实现与升级过程" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JUC/20230119213956.png"></p><h5 id="4-synchronized怎么保证可见性、有序性、原子性"><a href="#4-synchronized怎么保证可见性、有序性、原子性" class="headerlink" title="==4.synchronized怎么保证可见性、有序性、原子性=="></a>==4.synchronized怎么保证可见性、有序性、原子性==</h5><p>原子性<br>可见性<br>    通过monitorenter/monitorexit的jvm字节码指令，在底层调用lock前缀指令开启内存屏障<br>有序性<br>    依然会发生重排序，只不过我们有同步代码块，可以保证只有一个线程执行同步代码中的代码。保证有序性</p><p><a href="https://blog.csdn.net/chenzengnian123/article/details/122686371" target="_blank" rel="noopener">参考</a></p><h5 id="5-synchronized-和-Lock-有什么区别"><a href="#5-synchronized-和-Lock-有什么区别" class="headerlink" title="5.synchronized 和 Lock 有什么区别"></a>5.synchronized 和 Lock 有什么区别</h5><p>首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类；<br>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。<br>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。<br>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p><h5 id="6-synchronized-和-ReentrantLock-的区别"><a href="#6-synchronized-和-ReentrantLock-的区别" class="headerlink" title="==6.synchronized 和 ReentrantLock 的区别=="></a>==6.synchronized 和 ReentrantLock 的区别==</h5><p><strong>都是可重入锁</strong><br><strong>区别</strong><br>    ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；<br>    ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；<br>    ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。<br>    二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的park 方法加锁，synchronized 操作的应该是对象头中 mark word<br>==ReentrantLock的新功能==<br>    等待可中断<br>        ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。<br>    可实现公平锁<br>        ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。<br>    可实现选择性通知（锁可以绑定多个条件）<br>        synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。</p><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><h5 id="1-volatile-关键字的作用"><a href="#1-volatile-关键字的作用" class="headerlink" title="1.volatile 关键字的作用"></a>1.volatile 关键字的作用</h5><p>保证可见性和有序性(禁止指令重排)<br>和Atomic(CAS)结合保证原子性</p><h5 id="2-Java-中能创建-volatile-数组吗"><a href="#2-Java-中能创建-volatile-数组吗" class="headerlink" title="2.Java 中能创建 volatile 数组吗"></a>2.Java 中能创建 volatile 数组吗</h5><p>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了</p><h5 id="3-synchronized-和-volatile-的区别是什么"><a href="#3-synchronized-和-volatile-的区别是什么" class="headerlink" title="3.synchronized 和 volatile 的区别是什么"></a>3.synchronized 和 volatile 的区别是什么</h5><p>volatile 是变量修饰符；synchronized 可以修饰类、方法、变量。<br>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。==对于可见性来说，在JAVA底层都是调用了内存屏障，在硬件底层都是调用了Lock前缀指令从而触发了MESI协议保证了可见性。==</p><p><a href="https://blog.csdn.net/weixin_35688354/article/details/113452096" target="_blank" rel="noopener">参考</a></p><p>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。<br>volatile 标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化(指令重排)。</p><h5 id="4-volatile实现内存可见性、有序性原理"><a href="#4-volatile实现内存可见性、有序性原理" class="headerlink" title="==4.volatile实现内存可见性、有序性原理=="></a>==4.volatile实现内存可见性、有序性原理==</h5><p><a href="https://blog.csdn.net/it_lihongmin/article/details/109169260" target="_blank" rel="noopener">可见性</a><br>    硬件层面<br>        底层汇编会生成lock前缀指令，从而触发MESI缓存一致性协议，通过总线嗅探机制监听每个线程(工作内存)的变量是否改变<br>    JAVA层面<br>        内存屏障<br>有序性<br>    内存屏障(禁止指令重排)</p><h4 id="final"><a href="#final" class="headerlink" title="final"></a><a href="https://cloud.tencent.com/developer/article/1379380" target="_blank" rel="noopener">final</a></h4><h3 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h3><h4 id="1-什么是-CAS"><a href="#1-什么是-CAS" class="headerlink" title="1.什么是 CAS"></a>1.什么是 CAS</h4><p>CAS 操作包含三个操作数 —— 内存位置(V)、预期原值(A)和新值(B)。<br>    如果内存地址里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。<br>    CAS是通过无限循环来获取数据的，如果在第一轮循环中，a 线程获取地址里面的值被b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执行。</p><h4 id="2-CAS-的会产生什么问题"><a href="#2-CAS-的会产生什么问题" class="headerlink" title="2.CAS 的会产生什么问题"></a>2.CAS 的会产生什么问题</h4><p>==ABA问题==<br>    描述<br>        比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。<br>    解决<br>        AtomicStampedReference每次更新加版本<br>==循环时间长开销大==<br>    描述<br>        对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized<br>    解决<br>        <a href="https://blog.csdn.net/qq_29373285/article/details/88566435" target="_blank" rel="noopener">LongAdder</a>：分段CAS操作<br>            默认一开始使用CAS单个cell作为base，当线程多了之后，开启多个cell单元，用于分担base的压力，之后需要值的时候返回base+所有cell的值<br>        示意图</p><p><img alt="img" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JUC/20230120163139"></p><h3 id="Lock基础-AQS"><a href="#Lock基础-AQS" class="headerlink" title="Lock基础(AQS)"></a>Lock基础(AQS)</h3><h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><h5 id="1-说下对同步器-AQS-的理解"><a href="#1-说下对同步器-AQS-的理解" class="headerlink" title="1.说下对同步器 AQS 的理解"></a>1.说下对同步器 AQS 的理解</h5><p>​    AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。<br>​    AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，BlockingQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。</p><h5 id="2-AQS-的原理是什么"><a href="#2-AQS-的原理是什么" class="headerlink" title="2.AQS 的原理是什么"></a>2.AQS 的原理是什么</h5><p>​    核心思想<br>​        如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。<br>​        如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中<br>​    AQS 使用一个 int 成员变量 (state) 来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS (unsafe类)对该同步状态进行原子操作实现对其值的修改<br>​    CLH中每个结点还有一个waitSatus用于表示下一个结点中的线程的声明状态</p><h5 id="3-AQS-对资源的共享模式有哪些"><a href="#3-AQS-对资源的共享模式有哪些" class="headerlink" title="3.AQS 对资源的共享模式有哪些"></a>3.AQS 对资源的共享模式有哪些</h5><p>​    Exclusive（独占）<br>​        ReentrantLock，又可分为公平锁和非公平锁<br>​    Share（共享）<br>​        多个线程可同时执行，如：CountDownLatch、Semaphore、 CyclicBarrier、ReadWriteLock</p><h5 id="4-AQS-底层使用了模板方法模式，你能说出几个需要重写的方法吗"><a href="#4-AQS-底层使用了模板方法模式，你能说出几个需要重写的方法吗" class="headerlink" title="4.AQS 底层使用了模板方法模式，你能说出几个需要重写的方法吗"></a>4.AQS 底层使用了模板方法模式，你能说出几个需要重写的方法吗</h5><p>​    tryAcquire(int)<br>​        独占方式。尝试获取资源，成功则返回 true，失败则返回 false。<br>​    tryRelease(int)<br>​        独占方式。尝试释放资源，成功则返回 true，失败则返回 false。<br>​    tryAcquireShared(int)<br>​        共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br>​    tryReleaseShared(int)<br>​        共享方式。尝试释放资源，成功则返回 true，失败则返回 false。                     </p><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><h5 id="1-CountDownLatch-怎么用？应用场景是什么？"><a href="#1-CountDownLatch-怎么用？应用场景是什么？" class="headerlink" title="1.CountDownLatch 怎么用？应用场景是什么？"></a>1.CountDownLatch 怎么用？应用场景是什么？</h5><p>​    核心API<br>​        countDown<br>​            计数器减一<br>​        await<br>​            等到计数器为0再唤醒当前线程<br>​    应用场景<br>​        当所有的数据处理完成后，再去执行后面的操作<br>​        多个线程需要等待其他线程的工作之后，再进行其后续工作。</p><h5 id="2-CountDownLatch-和-CyclicBarrier-的不同之处？"><a href="#2-CountDownLatch-和-CyclicBarrier-的不同之处？" class="headerlink" title="2.CountDownLatch 和 CyclicBarrier 的不同之处？"></a>2.CountDownLatch 和 CyclicBarrier 的不同之处？</h5><p>​    CountDownLatch 是计数器，只能使用一次，而 CyclicBarrier 的计数器提供 reset 功能，可以多次使用<br>​    含义不同<br>​        CountDownLatch: 一个或者多个线程(主线程)，等待其他多个线程完成某件事情之后才能执行<br>​        CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。<br>​    <a href="https://blog.csdn.net/liangyihuai/article/details/83106584" target="_blank" rel="noopener">参考</a></p><h5 id="3-CountDownLatch-类中主要的方法？"><a href="#3-CountDownLatch-类中主要的方法？" class="headerlink" title="3.CountDownLatch 类中主要的方法？"></a>3.CountDownLatch 类中主要的方法？</h5><p>​    countDown<br>​        计数器减一，如果计数达到零，释放所有等待的线程。<br>​    await<br>​        等到计数器为0再唤醒当前线程<br>​    getCount<br>​        返回当前计数</p><h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><h5 id="1-谈谈对-BlockingQueue-的理解？分别有哪些实现类"><a href="#1-谈谈对-BlockingQueue-的理解？分别有哪些实现类" class="headerlink" title="1.谈谈对 BlockingQueue 的理解？分别有哪些实现类"></a>1.谈谈对 BlockingQueue 的理解？分别有哪些实现类</h5><p>​    阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。<br>​    实现类<br>​        ArrayBlockingQueue 由数组支持的有界队列<br>​        LinkedBlockingQueue 由链接节点支持的可选有界队列<br>​        PriorityBlockingQueue 由优先级堆支持的无界优先级队列<br>​        DelayQueue 由优先级堆支持的、基于时间的调度队列</p><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><h5 id="1-什么是ConcurrentHashMap"><a href="#1-什么是ConcurrentHashMap" class="headerlink" title="1.什么是ConcurrentHashMap"></a>1.什么是ConcurrentHashMap</h5><p>​    ConcurrentHashMap是Java中的一个线程安全且高效的HashMap实现<br>​    JDK1.8后，ConcurrentHashMap抛弃了原有的Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。</p><h5 id="2-Java-中-ConcurrentHashMap-的并发度是什么"><a href="#2-Java-中-ConcurrentHashMap-的并发度是什么" class="headerlink" title="2.Java 中 ConcurrentHashMap 的并发度是什么"></a>2.Java 中 ConcurrentHashMap 的并发度是什么</h5><p>​    ConcurrentHashMap 把实际 map 划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是 ConcurrentHashMap 类构造函数的一个可选参数，默认值为 16，这样在多线程情况下就能避免争用</p><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><h5 id="1-谈谈对-CopyOnWriteArrayList-的理解"><a href="#1-谈谈对-CopyOnWriteArrayList-的理解" class="headerlink" title="1.谈谈对 CopyOnWriteArrayList 的理解"></a>1.谈谈对 CopyOnWriteArrayList 的理解</h5><p>​    特性<br>​        适用场景为读多写少<br>​        不能读取实时性的数据，但能保证最终数据一致性<br>​        空间换时间<br>​    原理<br>​        内部维护了一个Object[]数组，通过getArray/setArray来获取/赋值<br>​        修改<br>​            如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。</p><h5 id="2-CopyOnWriteArrayList-是什么，可以用于什么应用场景"><a href="#2-CopyOnWriteArrayList-是什么，可以用于什么应用场景" class="headerlink" title="2.CopyOnWriteArrayList 是什么，可以用于什么应用场景"></a>2.CopyOnWriteArrayList 是什么，可以用于什么应用场景</h5><p>​    读多写少</p><h5 id="3-CopyOnWriteArrayList有哪些优缺点"><a href="#3-CopyOnWriteArrayList有哪些优缺点" class="headerlink" title="3.CopyOnWriteArrayList有哪些优缺点"></a>3.CopyOnWriteArrayList有哪些优缺点</h5><p>​    缺点<br>​        1. 由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。<br>​        2. 不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的，虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。<br>​        3. 由于实际使用中可能没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次 add/set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。<br>​    优点<br>​        读写分离，读和写分开<br>​        适合读多写少</p><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><h5 id="1-谈谈对ConcurrentLinkedQueue理解"><a href="#1-谈谈对ConcurrentLinkedQueue理解" class="headerlink" title="1.谈谈对ConcurrentLinkedQueue理解"></a>1.谈谈对ConcurrentLinkedQueue理解</h5><p>​    高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列</p><h4 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h4><h5 id="1-谈谈对-ConcurrentSkipListMap-的理解"><a href="#1-谈谈对-ConcurrentSkipListMap-的理解" class="headerlink" title="1.谈谈对 ConcurrentSkipListMap 的理解"></a>1.谈谈对 ConcurrentSkipListMap 的理解</h5><p><a href="https://blog.csdn.net/hbtj_1216/article/details/114228578" target="_blank" rel="noopener">参考</a></p><p>​    特点<br>​        高并发场景<br>​        key是有序的<br>​        添加、删除、查找操作都是基于跳表结构（Skip List）实现的<br>​        key和value都不能为null<br>​    跳表<br>​        跳表由很多层组成；<br>​        每一层都是一个有序的链表；<br>​        最底层的链表包含所有元素；<br>​        对于每一层的任意一个节点，不仅有指向其下一个节点的指针，也有指向其下一层的指针；<br>​        如果一个元素出现在Level n层的链表中，则它在Level n层以下的链表也都会出现。</p><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h5 id="1-ThreadLocal-是什么？有哪些使用场景"><a href="#1-ThreadLocal-是什么？有哪些使用场景" class="headerlink" title="1.ThreadLocal 是什么？有哪些使用场景"></a>1.ThreadLocal 是什么？有哪些使用场景</h5><p>​    ThreadLocal 是一个本地线程副本变量工具类，在每个线程中都创建了一个 ThreadLocalMap 对象<br>​    使用场景<br>​        为每个线程分配一个 JDBC 连接 Connection。这样就可以保证每个线程的都在各自的 Connection 上进行数据库的操作，不会出现 A 线程关了 B线程正在使用的 Connection</p><h5 id="2-什么是线程局部变量"><a href="#2-什么是线程局部变量" class="headerlink" title="2.什么是线程局部变量"></a>2.什么是线程局部变量</h5><p>​    线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。</p><h5 id="3-ThreadLocal造成内存泄漏的原因"><a href="#3-ThreadLocal造成内存泄漏的原因" class="headerlink" title="3.ThreadLocal造成内存泄漏的原因"></a>3.ThreadLocal造成内存泄漏的原因</h5><p>​    ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。<br>​    所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。<br>​    这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露</p><h5 id="4-ThreadLocal内存泄漏解决方案"><a href="#4-ThreadLocal内存泄漏解决方案" class="headerlink" title="4.ThreadLocal内存泄漏解决方案"></a>4.ThreadLocal内存泄漏解决方案</h5><p>​    每次使用完ThreadLocal，都调用它的remove()方法，清除数据</p><h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h5><p>​    ThreadLocal的 key 是弱引用，那么在 ThreadLocal.get()的时候，发生GC之后，key 是否为null？<br>​    ThreadLocal中ThreadLocalMap的数据结构？<br>​    ThreadLocalMap的Hash 算法？<br>​    ThreadLocalMap中Hash 冲突如何解决？<br>​    ThreadLocalMap的扩容机制？<br>​    ThreadLocalMap中过期 key 的清理机制？探测式清理和启发式清理流程？<br>​    ThreadLocalMap.set()方法实现原理？<br>​    ThreadLocalMap.get()方法实现原理？<br>​    项目中ThreadLocal使用情况？遇到的坑？</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="1-什么是线程池？有哪几种创建方式"><a href="#1-什么是线程池？有哪几种创建方式" class="headerlink" title="1.什么是线程池？有哪几种创建方式"></a>1.什么是线程池？有哪几种创建方式</h4><p>​    线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。<br>​    Executors<br>​        newSingleThreadExecutor：创建一个单线程的线程池。<br>​        newFixedThreadPool：创建固定大小的线程池。<br>​        newCachedThreadPool：创建一个可缓存的线程池。<br>​        newScheduledThreadPool：创建一个大小无限的线程池。<br>​    new ThreadPoolExecutor</p><h4 id="2-线程池有什么优点"><a href="#2-线程池有什么优点" class="headerlink" title="2.线程池有什么优点"></a>2.线程池有什么优点</h4><p>​    降低资源消耗<br>​        重用存在的线程，减少对象创建销毁的开销<br>​    提高响应速度<br>​        可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要等到线程创建就能立即执行<br>​    提高线程的可管理性<br>​        线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控<br>​    附加功能<br>​        提供定时执行、定期执行、单线程、并发数控制等功能</p><h4 id="3-线程池都有哪些状态"><a href="#3-线程池都有哪些状态" class="headerlink" title="3.线程池都有哪些状态"></a>3.线程池都有哪些状态</h4><p><img alt="1" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JUC/20230120182934.png"></p><p>​    RUNNING<br>​        这是最正常的状态，接受新的任务，处理等待队列中的任务<br>​    SHUTDOWN<br>​        不接受新的任务提交，但是会继续处理等待队列中的任务<br>​    STOP<br>​        不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程<br>​    TIDYING<br>​        所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()<br>​    TERMINATED<br>​        terminated()方法结束后，线程池的状态就会变成这个</p><h4 id="4-在-Java-中-Executor-和-Executors-的区别"><a href="#4-在-Java-中-Executor-和-Executors-的区别" class="headerlink" title="4.在 Java 中 Executor 和 Executors 的区别"></a>4.在 Java 中 Executor 和 Executors 的区别</h4><p>​    Executor是线程池的顶层接口<br>​    Executors定义了一堆用户可以直接使用的线程池，但不推荐</p><h4 id="5-线程池中-submit-和-execute-方法有什么区别"><a href="#5-线程池中-submit-和-execute-方法有什么区别" class="headerlink" title="==5.线程池中 submit() 和 execute() 方法有什么区别=="></a>==5.线程池中 submit() 和 execute() 方法有什么区别==</h4><p>​    接收参数<br>​        execute()只能执行 Runnable 类型的任务。submit()可以执行 Runnable 和 Callable 类型的任务<br>​    返回值<br>​        submit()方法可以返回持有计算结果的 Future 对象，而execute()没有<br>​    异常处理<br>​        submit()方便Exception处理</p><h4 id="6-Executors和ThreaPoolExecutor创建线程池的区别-为什么不推荐Executors"><a href="#6-Executors和ThreaPoolExecutor创建线程池的区别-为什么不推荐Executors" class="headerlink" title="6.Executors和ThreaPoolExecutor创建线程池的区别(为什么不推荐Executors)"></a>6.Executors和ThreaPoolExecutor创建线程池的区别(为什么不推荐Executors)</h4><p>​    Executors 各个方法的弊端<br>​        newFixedThreadPool 和 newSingleThreadExecutor:<br>​            ==主要问题是允许请求的队列长度为 Integer.MAX_VALUE，堆积的请求处理队列可能会耗费非常大的内存==，甚至 OOM<br>​        newCachedThreadPool 和 newScheduledThreadPool:<br>​            主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM<br>​    ThreaPoolExecutor创建线程池方式只有一种，就是走它的构造函数，参数自己指定</p><h4 id="7-ThreadPoolExecutor构造函数重要参数分析"><a href="#7-ThreadPoolExecutor构造函数重要参数分析" class="headerlink" title="==7.ThreadPoolExecutor构造函数重要参数分析=="></a>==7.ThreadPoolExecutor构造函数重要参数分析==</h4><p>​    corePoolSize<br>​        核心线程数，线程数定义了最小可以同时运行的线程数量。<br>​    maximumPoolSize<br>​        线程池中允许存在的工作线程的最大数量<br>​    workQueue<br>​        当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在队列中<br>​    keepAliveTime<br>​        线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；<br>​    unit<br>​        keepAliveTime 参数的时间单位。<br>​    threadFactory<br>​        为线程池提供创建新线程的线程工厂<br>​    handler<br>​        线程池任务队列超过 maxinumPoolSize 之后的拒绝策略</p><h4 id="建议不同类别的业务用不同的线程池"><a href="#建议不同类别的业务用不同的线程池" class="headerlink" title="建议不同类别的业务用不同的线程池"></a>建议不同类别的业务用不同的线程池</h4><p>​    一般建议是不同的业务使用不同的线程池，配置线程池的时候根据当前业务的情况对当前线程池进行配置，因为不同的业务的并发以及对资源的使用情况都不同，重心优化系统性能瓶颈相关的业务。<br>​    否则，父子线程可能会互相死锁</p><h4 id="线程池架构-原理-流程"><a href="#线程池架构-原理-流程" class="headerlink" title="线程池架构(原理/流程)"></a>线程池架构(原理/流程)</h4><p><img alt="4" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JUC/20230120183334.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;并发基础-理论&quot;&gt;&lt;a href=&quot;#并发基础-理论&quot; class=&quot;headerlink&quot; title=&quot;并发基础/理论&quot;&gt;&lt;/a&gt;并发基础/理论&lt;/h3&gt;&lt;h4 id=&quot;1-并发编程的优缺点&quot;&gt;&lt;a href=&quot;#1-并发编程的优缺点&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="面试题" scheme="https://alexander-wd.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="JUC" scheme="https://alexander-wd.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JVM面试题</title>
    <link href="https://alexander-wd.github.io/2022/10/30/%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://alexander-wd.github.io/2022/10/30/%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-10-30T10:18:20.000Z</published>
    <updated>2023-02-13T10:14:16.505Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><h4 id="1-简述java类加载机制"><a href="#1-简述java类加载机制" class="headerlink" title="1.简述java类加载机制"></a>1.简述java类加载机制</h4><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，准备，解析和初始化，最终形成可以被虚拟机直接使用的java类型</p><p><img alt="2" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109171002.png"></p><h4 id="2-描述一下JVM加载Class文件的原理机制"><a href="#2-描述一下JVM加载Class文件的原理机制" class="headerlink" title="2.描述一下JVM加载Class文件的原理机制"></a>2.描述一下JVM加载Class文件的原理机制</h4><p>默认隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中<br>        显式装载， 通过class.forname()等方法，显式加载需要的类<br>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p><h4 id="3-什么是类加载器，类加载器有哪些"><a href="#3-什么是类加载器，类加载器有哪些" class="headerlink" title="3.什么是类加载器，类加载器有哪些"></a>3.什么是类加载器，类加载器有哪些</h4><p>类加载器负责动态加载Java类到Java虚拟机的内存空间中</p><p>类加载器有：</p><p>启动类加载器<br>    用来加载java核心类库，无法被java程序直接引用<br>扩展类加载器<br>    它用来加载 Java 的扩展库<br>系统类加载器<br>    它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类<br>用户自定义类加载器<br>    通过继承 java.lang.ClassLoader类的方式实现</p><h4 id="4-说一下类装载的执行过程"><a href="#4-说一下类装载的执行过程" class="headerlink" title="==4.说一下类装载的执行过程=="></a>==4.说一下类装载的执行过程==</h4><p>加载：根据查找路径找到相应的 class 文件然后导入<br>    双亲委派<br>验证：检查加载的 class 文件的正确性，如开头CAFEBABE<br>准备：给类中的静态变量分配内存空间，赋予默认值<br>解析：虚拟机将常量池中的符号引用替换成直接引用的过程(也就是得到类或者字段、方法在内存中的指针或者偏移量)<br>初始化：对静态变量和静态代码块执行初始化工作(初始化为用户自定义的值)</p><h4 id="5-什么是双亲委派模型"><a href="#5-什么是双亲委派模型" class="headerlink" title="==5.什么是双亲委派模型=="></a>==5.什么是双亲委派模型==</h4><p><strong>步骤</strong><br>    1.首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接 返回。<br>     2.如果此类没有加载过(在内存中)，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用parent.loadClass(name, false);）(扩展类加载器再向上委托便是bootstrap类加载器来加载)。<br>    3.如果父加载器及bootstrap类加载器都没有找到指定的类，那么向下委托看当前加载器的路径下有没有改class文件(一般都会回到当前类加载器的 findClass方法来完成类加载)。<br>        注意AppClassLoader和ExtClassLoader的findClass方法均在URLClassLoader中实现<br>细节</p><blockquote><p>双亲委派机制</p><p>向上委托主要是判断要加载的类有没有被加载到内存，如果已被加载到内存，就没必要继续向上委托。</p><p>而父类向下委托则是判断自己的类路径中有没有该类，有的话直接加载进内存。</p></blockquote><p>==为什么要设计双亲委派机制==<br>    1.沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心API库被随意篡改<br>    2.避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证被加载类的唯一性<br>模型图参考</p><p><img alt="2" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109175409.png"></p><h4 id="6-如何判断两个class对象是否相同？"><a href="#6-如何判断两个class对象是否相同？" class="headerlink" title="6.如何判断两个class对象是否相同？"></a>6.如何判断两个class对象是否相同？</h4><p>1.类的完整类名必须一致，包括包名<br>2.加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</p><h4 id="7-怎么实现一个自定义的类加载器"><a href="#7-怎么实现一个自定义的类加载器" class="headerlink" title="7.怎么实现一个自定义的类加载器"></a>7.怎么实现一个自定义的类加载器</h4><p>自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，<br>        一个是 loadClass(String, boolean)，实现了双亲委派机制<br>        还有一个方法是findClass，默认实现是空 方法，所以我们自定义类加载器主要是重写findClass方法<br>                重写findClass方法实际上就是为了实现defineClass方法，将类路径的类加载进来。</p><h4 id="8-怎么打破双亲委派模型"><a href="#8-怎么打破双亲委派模型" class="headerlink" title="8.怎么打破双亲委派模型"></a>8.怎么打破双亲委派模型</h4><p>自己写一个类加载器继承ClassLoader<br>主要重写 loadClass() 方法，把原来双亲委派的部分去掉<br>重写 findClass() 方法</p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><h4 id="自增-操作数栈"><a href="#自增-操作数栈" class="headerlink" title="==自增/操作数栈=="></a>==自增/操作数栈==</h4><p><img alt="1" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109195634.png"></p><p>结果<br>    i=4,j=1,k=11<br>分析<br>    1.i=i++<br>        将i=1读入操作数栈，i自增(此时i=2)存在局部变量表，接着赋值，将操作数栈的i覆盖局部变量表的i，最后i=1<br>    2.j = i++<br>        将i=1读入操作数栈，i自增(操作之后i=2)存在局部变量表，接着赋值，将操作数栈的i覆盖局部变量表的j，最后j=1,i=2<br>    3.k=i+ ++i <em> i++<br>        将i=2读入操作数栈，++i(操作之后i=3)存在局部变量表，将i=3(乘号前的)压入栈中，紧接着将i=3(乘号后的)压入栈中，i++(操作之后i=4)存在局部变量表；计算乘法操作(3</em>3=9)后，与一开始的入栈的2相加得11，赋值给局部变量表的k。最后k=11，i=4</p><p>总结<br>    赋值运算，最后计算；赋值运算就是将对应操作数栈的数，移到局部变量表中<br>    i++和++i的区别就是<br>        压入操作数栈和修改局部变量表中的值(+1操作)顺序的区别(无论如何这两步操作是紧接在一起的)<br>        i++自增直接修改局部变量表中的值，不经过操作数栈；++i自增直接修改局部变量表中的值，之后再把局部变量表的i放入操作数栈<br><a href="https://www.bilibili.com/video/BV1Eb411P7bP/?vd_source=3c18550954067ac625f4410f0e243609" target="_blank" rel="noopener">来源</a></p><h4 id="1-介绍下-Java-内存区域（运行时数据区）"><a href="#1-介绍下-Java-内存区域（运行时数据区）" class="headerlink" title="==1.介绍下 Java 内存区域（运行时数据区）=="></a>==1.介绍下 Java 内存区域（运行时数据区）==</h4><p>运行时数据区<br>    Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域<br>==五大区域==<br>    程序计数器<br>        当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成<br>    虚拟机栈(线程栈)<br>        用于存储局部变量表、操作数栈、动态链接、方法出口等信息<br>    本地方法栈<br>        与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的<br>        局部变量表<br>            存基本数据类型和对象引用<br>        操作数栈<br>            方法调用的中转站<br>        动态链接<br>            动态链接的作用就是为了将符号引用转换为调用方法的直接引用(与类装载解析阶段是将静态方法的符号引用转换为直接引用不同)<br>        方法出口<br>            return 或异常<br>    堆<br>        Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存<br>    方法区<br>        用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据<br>线程共享<br>    堆<br>    方法区<br>线程私有<br>    程序计数器<br>    虚拟机栈<br>    本地方法栈<br>参考</p><p><img alt="3" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109200014.png"></p><h4 id="2-Java-对象的创建过程"><a href="#2-Java-对象的创建过程" class="headerlink" title="==2.Java 对象的创建过程=="></a>==2.Java 对象的创建过程==</h4><p>1.类加载检查<br>    虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个 符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程<br>2.分配内存</p><p>​    参考图</p><p>​    <img alt="4" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109200515.png"></p><p>​    内存分配方式<br>​        指针碰撞：类比顺序链表，依次分配内存<br>​        空闲链表：类比单链表，哪有空间就存哪<br>​        用哪种方式取决于Java 堆内存是否规整，而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”(不规整)，还是”标记-整理”(规整)或复制算法(规整)<br>​    创建对象可能频繁，产生并发问题<br>​        CAS<br>​            因为冲突失败就重试，直到成功为止<br>​        TLAB(本地线程分配缓冲)<br>​            为每一个线程预先在 Eden 区分配一块内存(这样就不会冲突)，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配<br>3.初始化<br>​    将分配到的内存空间都初始化为零值<br>​    这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用<br>4.设置对象头<br>​    mark word</p><p>​    <img alt="5" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109200437.png"></p><p>​        主要存的是自身运行时数据<br>​            对象的哈希码<br>​            对象的GC分代年龄<br>​            锁状态信息等<br>​    Klass Pointer类型指针：对象指向它的类元数据的指针<br>​        对象是哪个类的实例<br>​        如何才能找到类的元数据信息<br>​    数组长度(4字节，只有数组对象才有)<br>5.执行<init>方法<br>​    对象按照程序员的意愿对属性进行赋值</init></p><h4 id="3-对象的访问定位的两种方式"><a href="#3-对象的访问定位的两种方式" class="headerlink" title="3.对象的访问定位的两种方式"></a>3.对象的访问定位的两种方式</h4><p>​    对象的访问定位方式由虚拟机实现而定<br>​    句柄访问<br>​        引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。<br>​    直接指针<br>​        速度更快，节省了一次指针定位的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。</p><h4 id="4-说一下-JVM-的主要组成部分及其作用"><a href="#4-说一下-JVM-的主要组成部分及其作用" class="headerlink" title="4.说一下 JVM 的主要组成部分及其作用"></a>4.说一下 JVM 的主要组成部分及其作用</h4><p><img alt="6" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109204100.png"></p><p>类加载子系统<br>    步骤<br>        加载<br>        验证<br>        准备<br>        解析<br>        初始化<br>    类加载器（ClassLoader）再把字节码加载到内存中(JVM可以直接使用的java类)<br>运行时数据区<br>    Q.1<br>执行引擎<br>    即时编译器JIT</p><p>​        <img alt="7" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109204230.png"></p><p>​        前端编译(javac命令)为.class文件<br>​        解释执行，运行到不同平台上<br>​    垃圾回收器<br>本地库接口<br>本地方法库</p><h4 id="5-说一下堆栈的区别"><a href="#5-说一下堆栈的区别" class="headerlink" title="5.说一下堆栈的区别"></a>5.说一下堆栈的区别</h4><div class="table-container"><table><thead><tr><th></th><th>==存储内容==</th><th>==程序可见度==</th><th>作用</th><th>存储结构</th><th>内存大小</th></tr></thead><tbody><tr><td>堆</td><td>主要存放对象实例</td><td>线程共享</td><td>主要用于存储对象信息</td><td>物理地址分配对象不连续，速度慢</td><td>分配不连续，在运行期确认，大小不固定，大小远远大于栈</td></tr><tr><td>栈</td><td>存放基本数据类型和对象的引用</td><td>线程私有</td><td>运行时的单位，解决程序运行时的问题</td><td>使用数据结构—栈，物理地址分配连续，速度快</td><td>分配连续，在编译期确认，大小固定</td></tr></tbody></table></div><h4 id="6-深拷贝和浅拷贝"><a href="#6-深拷贝和浅拷贝" class="headerlink" title="6.深拷贝和浅拷贝"></a>6.深拷贝和浅拷贝</h4><p>浅拷贝<br>    引用数据类型在堆中是同一个<br>深拷贝<br>    引用数据类型会创建一个新的对象放到堆中<br>对于基本数据类型都一样，因为基本数据类型存在虚拟机栈中</p><h4 id="7-谈谈你对内存分配的理解？大对象怎么分配？"><a href="#7-谈谈你对内存分配的理解？大对象怎么分配？" class="headerlink" title="==7.谈谈你对内存分配的理解？大对象怎么分配？=="></a>==7.谈谈你对内存分配的理解？大对象怎么分配？==</h4><p>1.根据逃逸分析，判断对象不会逃逸，就在栈上分配<br>2.判断如果是大对象，直接进老年代<br>3.判断TLAB(本地线程分配缓存)是否满了<br>细节</p><p>​    1.大对象直接进老年代</p><p>​    2.Eden区满了(事实上有个阈值)，就会回收(99%的对象都会变成垃圾)，存活的放到幸存区<br>​        若幸存区存不下，直接进老年代<br>​    3.长期存活的对象进老年代<br>​        分代年龄阈值可以通过-XX:MaxTenuringThreshold 来设置<br>​    4.对象动态年龄判断<br>​        例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会 把年龄n(含)以上的对象都放入老年代。<br>​        -XX:TargetSurvivorRatio可以指定<br>​    5.老年代空间担保机制</p><p>​        <img alt="7" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109211752.png"></p><p>​        ==确保minorGC之后，老年代能够装下年轻代中的所有对象==<br>内存分配流程图</p><p><img alt="6" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109211655.png"></p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h4 id="1-如何判断对象是否死亡（两种方法）"><a href="#1-如何判断对象是否死亡（两种方法）" class="headerlink" title="1.如何判断对象是否死亡（两种方法）"></a>1.如何判断对象是否死亡（两种方法）</h4><p>引用计数法<br>    有一个地方引用它，计数器+1；引用失效，计数器-1；计数器为0<br>    问题<br>        不能解决循环引用的问题，引发内存泄漏<br>==可达性分析算法==<br>    以GCRoot为起点，向下搜索标记引用链，最后未标记的就是垃圾<br>    GCRoot<br>        虚拟机栈(栈帧中的本地变量表)中引用的对象<br>        本地方法栈(Native 方法)中引用的对象<br>        方法区中类静态属性引用的对象<br>        方法区中常量引用的对象<br>        所有被同步锁持有的对象</p><h4 id="2-简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。-很少见"><a href="#2-简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。-很少见" class="headerlink" title="2.简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。(很少见)"></a>2.简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。(很少见)</h4><p>强引用<br>    编程中一般对象所使用的引用<br>软引用<br>    软引用可用来实现内存敏感的高速缓存<br>弱引用<br>虚引用<br>    虚引用主要用来跟踪对象被垃圾回收的活动<br>虚引用与软引用和弱引用的区别<br>    虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><h4 id="3-如何判断一个常量是废弃常量"><a href="#3-如何判断一个常量是废弃常量" class="headerlink" title="3.如何判断一个常量是废弃常量"></a>3.如何判断一个常量是废弃常量</h4><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量</p><h4 id="4-如何判断一个类是无用的类"><a href="#4-如何判断一个类是无用的类" class="headerlink" title="4.如何判断一个类是无用的类"></a>4.如何判断一个类是无用的类</h4><p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。<br>加载该类的 ClassLoader 已经被回收。<br>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p><h4 id="5-垃圾收集有哪些算法，各自的特点？"><a href="#5-垃圾收集有哪些算法，各自的特点？" class="headerlink" title="==5.垃圾收集有哪些算法，各自的特点？=="></a>==5.垃圾收集有哪些算法，各自的特点？==</h4><p>1.复制算法</p><p><img alt="2" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230111215622.png"></p><p>2.标记清除算法</p><p><img alt="3" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230111215624.png"></p><p>3.标记整理算法</p><p><img alt="4" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230111215626.png"></p><h4 id="6-HotSpot-为什么要分为新生代和老年代？"><a href="#6-HotSpot-为什么要分为新生代和老年代？" class="headerlink" title="==6.HotSpot 为什么要分为新生代和老年代？=="></a>==6.HotSpot 为什么要分为新生代和老年代？==</h4><p>将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>​    新生代<br>​            每次收集都会有大量对象(近99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可 以完成每次垃圾收集<br>​    老年代<br>​            对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集</p><h4 id="7-常见的垃圾回收器有哪些？"><a href="#7-常见的垃圾回收器有哪些？" class="headerlink" title="==7.常见的垃圾回收器有哪些？=="></a>==7.常见的垃圾回收器有哪些？==</h4><p><img alt="1" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230111211416.png"></p><h5 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1.Serial 收集器"></a>1.Serial 收集器</h5><p>​    单线程，串行<br>​    新生代采用标记-复制算法，老年代采用标记-整理算法</p><h5 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2.ParNew 收集器"></a>2.ParNew 收集器</h5><p>​    Serial 收集器的多线程版本，其他和Serial一样<br>​    只能用于新生代，采用标记-复制算法<br>​    可以和CMS收集器配合使用</p><h5 id="3-Parallel-收集器"><a href="#3-Parallel-收集器" class="headerlink" title="3.Parallel 收集器"></a>3.Parallel 收集器</h5><p>​    新生代采用复制算法，老年代采用标记-整理算法<br>​    关注点是吞吐量（高效率的利用CPU）</p><h5 id="4-CMS收集器"><a href="#4-CMS收集器" class="headerlink" title="4.CMS收集器"></a>4.CMS收集器</h5><p>​    只能用于老年代，使用标记清除算法<br>​    步骤<br>​        初始标记<br>​            STW<br>​            记录gc roots直接能引用的对象，很快<br>​        并发标记<br>​            三色标记算法<br>​        重新标记<br>​            STW<br>​            主要使用三色标记中的增量更新做重新标记<br>​        并发清理<br>​            开启用户线程，同时GC线程开始对未标记的区域做清扫<br>​        并发重置<br>​            重置本次GC过程中的标记数据<br>​    并发标记时漏标使用增量更新</p><h5 id="5-G1"><a href="#5-G1" class="headerlink" title="5.G1"></a>5.G1</h5><h6 id="并发标记时漏标使用原始快照-SATB"><a href="#并发标记时漏标使用原始快照-SATB" class="headerlink" title="并发标记时漏标使用原始快照(SATB)"></a>并发标记时漏标使用原始快照(SATB)</h6><h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6><p>​        可预测的停顿<br>​            这是 G1 相对于 CMS 的一个大优势<br>​        空间整合<br>​            与 CMS 的“标记-清理”算法不同<br>​            G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。<br>​        分代收集<br>​            虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念<br>​        并行与并发<br>​            G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。<br>​            部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。<br>​        有优先级的回收策略<br>​            在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字 Garbage-First的由来)<br>​                比如一个Region花200ms能回收10M垃圾，另外一个Region花50ms能回收20M垃圾，在回收时间有限情况下，G1当然会优先选择后面这个Region回收。</p><h6 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h6><p>​        初始标记<br>​            同CMS<br>​        并发标记<br>​            同CMS<br>​        最终标记<br>​            同CMS重新标记<br>​        筛选回收<br>​            会STW<br>​            首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划<br>​                例：老年代此时有1000个 Region都满了，但是因为根据预期停顿时间，本次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得 知，可能回收其中800个Region刚好需要200ms，那么就只会回收800个Region(Collection Set，要回收的集合)，尽量把GC导致的停顿时间控制在我们指定的范围内。<br>​                可以用JVM参数 -XX:MaxGCPauseMillis指定GC停顿时间<br>​            不管是年轻代或是老 年代，回收算法主要用的是复制算法<br>​                将一个region中的存活对象复制到另一个region中，这种不会像CMS那样 回收完因为有很多内存碎片还需要整理一次，G1采用复制算法回收几乎不会有太多内存碎片</p><h6 id="G1-垃圾收集分类"><a href="#G1-垃圾收集分类" class="headerlink" title="G1 垃圾收集分类"></a>G1 垃圾收集分类</h6><p>​        Young GC<br>​            YoungGC并不是说现有的Eden区放满了就会马上触发，而是接近参数 -XX:MaxGCPauseMills 设定的值<br>​        Mixed GC<br>​            老年代的堆占有率达到参数(-XX:InitiatingHeapOccupancyPercent)设定的值则触发<br>​            回收所有的 Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区<br>​        Full GC<br>​            Mixed GC使用复制算法发现没有足够的空region就会触发<br>​            STW，使用Serial单线程<br>​    回收流程图</p><p><img alt="9" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109220816.png"></p><h6 id="JDK8默认"><a href="#JDK8默认" class="headerlink" title="JDK8默认"></a>JDK8默认</h6><p>​    Parallel Scavenge收集器(新生代)和Parallel Old收集器(老年代)</p><h4 id="8-介绍一下-CMS-G1-收集器。"><a href="#8-介绍一下-CMS-G1-收集器。" class="headerlink" title="==8.介绍一下 CMS,G1 收集器。=="></a>==8.介绍一下 CMS,G1 收集器。==</h4><p>参考Q.7</p><h4 id="9-Minor-Gc-和-Full-GC-有什么不同呢？"><a href="#9-Minor-Gc-和-Full-GC-有什么不同呢？" class="headerlink" title="==9.Minor Gc 和 Full GC 有什么不同呢？=="></a>==9.Minor Gc 和 Full GC 有什么不同呢？==</h4><p>Minor GC<br>    指发生在新生代的垃圾收集<br>    采用复制算法<br>    频繁<br>Full GC<br>    指发生在老年代的垃圾收集<br>    “标记-清除”或“标记-整理”算法<br>    相比Minor GC没那么频繁</p><h4 id="10-Java会存在内存泄漏吗？请简单描述"><a href="#10-Java会存在内存泄漏吗？请简单描述" class="headerlink" title="10.Java会存在内存泄漏吗？请简单描述"></a>10.Java会存在内存泄漏吗？请简单描述</h4><p>简单使用一个hashmap，于是不断往里面放缓存数据，但是很少考虑这个map的容量问题，结果这个缓存map越来越大，一直占用着老年代的很多空间，时间长了就会导致full gc非常频繁，这就是一种内存泄漏<br>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收</p><h4 id="11-简述Java垃圾回收机制"><a href="#11-简述Java垃圾回收机制" class="headerlink" title="11.简述Java垃圾回收机制"></a>11.简述Java垃圾回收机制</h4><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。<br>在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p><h4 id="12-什么是浮动垃圾"><a href="#12-什么是浮动垃圾" class="headerlink" title="12.什么是浮动垃圾"></a>12.什么是浮动垃圾</h4><p>产生时机<br>    并发标记时，三色算法多标<br>    并发清理时，有对象变成垃圾<br>    这两个时机异曲同工</p><h4 id="13-什么是内存碎片？如何解决"><a href="#13-什么是内存碎片？如何解决" class="headerlink" title="13.什么是内存碎片？如何解决"></a>13.什么是内存碎片？如何解决</h4><p>概念<br>    由于不同 Java 对象存活时间是不一定的，因此，在程序运行一段时间以后，如果不进行内存整理，就会出现零散的内存碎片。<br>产生的问题<br>    会导致无法分配大块的内存空间<br>    程序运行效率降低<br>解决<br>    “复制”算法<br>    “标记-整理”算法</p><h4 id="14-为什么G1用SATB？CMS用增量更新？"><a href="#14-为什么G1用SATB？CMS用增量更新？" class="headerlink" title="14.为什么G1用SATB？CMS用增量更新？"></a>14.为什么G1用SATB？CMS用增量更新？</h4><p>SATB相对增量更新效率会高(当然SATB可能造成更多的浮动垃圾)，因为不需要在重新标记阶段再次深度扫描 被删除引用对象<br>而CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的region，CMS就一块老年代区域，重新深度扫描对象的话G1的代价会比CMS高<br>所以G1选择SATB不深度扫描对象，只是简单标记，等到下一轮GC 再深度扫描。</p><h4 id="15-如何选择垃圾收集器"><a href="#15-如何选择垃圾收集器" class="headerlink" title="==15.如何选择垃圾收集器=="></a>==15.如何选择垃圾收集器==</h4><ol><li>优先调整堆的大小让服务器自己来选择 </li><li>如果内存小于100M，使用串行收集器 </li><li>如果是单核，并且没有停顿时间的要求，串行或JVM自己选择 </li><li>如果允许停顿时间超过1秒，选择并行或者JVM自己选 </li><li>如果响应时间最重要，并且不能超过1秒，使用并发收集器 </li><li>4G以下可以用parallel，4-8G可以用ParNew+CMS，8G以上可以用G1，几百G以上用ZGC</li></ol><h4 id="16-尽量避免内存泄漏的方法"><a href="#16-尽量避免内存泄漏的方法" class="headerlink" title="16.尽量避免内存泄漏的方法"></a>16.尽量避免内存泄漏的方法</h4><p>1.尽量不要使用 static 成员变量，减少生命周期；<br>2.及时关闭资源；<br>3.不用的对象，可以手动设置为 null。</p><h4 id="17-新生代和老年代分别采用什么垃圾回收算法，为什么"><a href="#17-新生代和老年代分别采用什么垃圾回收算法，为什么" class="headerlink" title="==17.新生代和老年代分别采用什么垃圾回收算法，为什么=="></a>==17.新生代和老年代分别采用什么垃圾回收算法，为什么==</h4><p>新生代<br>    复制算法<br>    每次收集都会有大量对象(近99%)死去，只需要付出少量对象的复制成本就可 以完成每次垃圾收集。<br>老年代<br>    “标记-清除”或“标记-整理”算法<br>    老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以不能使用复制算法</p><h3 id="调优实战"><a href="#调优实战" class="headerlink" title="调优实战"></a>调优实战</h3><h3 id="真实面试题"><a href="#真实面试题" class="headerlink" title="真实面试题"></a>真实面试题</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/414173543" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/414173543</a></p></blockquote><h4 id="头条一面-GC"><a href="#头条一面-GC" class="headerlink" title="头条一面(GC)"></a>头条一面(GC)</h4><h5 id="JVM-从-GC-角度看，堆的分区情况"><a href="#JVM-从-GC-角度看，堆的分区情况" class="headerlink" title="JVM 从 GC 角度看，堆的分区情况"></a><strong>JVM 从 GC 角度看，堆的分区情况</strong></h5><h5 id="为什么要将堆内存分为两块而不是直接一个老年代就行？"><a href="#为什么要将堆内存分为两块而不是直接一个老年代就行？" class="headerlink" title="为什么要将堆内存分为两块而不是直接一个老年代就行？"></a><strong>为什么要将堆内存分为两块而不是直接一个老年代就行？</strong></h5><h5 id="那为什么新生代还需要继续细分"><a href="#那为什么新生代还需要继续细分" class="headerlink" title="那为什么新生代还需要继续细分?"></a><strong>那为什么新生代还需要继续细分?</strong></h5><h5 id="Survivor-区会进行垃圾回收吗？"><a href="#Survivor-区会进行垃圾回收吗？" class="headerlink" title="Survivor 区会进行垃圾回收吗？"></a><strong>Survivor 区会进行垃圾回收吗？</strong></h5><h5 id="直接分成1块Eden区和1块s区不行吗？"><a href="#直接分成1块Eden区和1块s区不行吗？" class="headerlink" title="直接分成1块Eden区和1块s区不行吗？"></a><strong>直接分成1块Eden区和1块s区不行吗？</strong></h5><h4 id="美团一面-GC"><a href="#美团一面-GC" class="headerlink" title="美团一面(GC)"></a><strong>美团一面</strong>(GC)</h4><h5 id="说下JVM的垃圾回收算法"><a href="#说下JVM的垃圾回收算法" class="headerlink" title="说下JVM的垃圾回收算法"></a><strong>说下JVM的垃圾回收算法</strong></h5><h4 id="滴滴一面-GC"><a href="#滴滴一面-GC" class="headerlink" title="滴滴一面(GC)"></a><strong>滴滴一面</strong>(GC)</h4><h5 id="你知道哪几种垃圾回收器，各自的优缺点"><a href="#你知道哪几种垃圾回收器，各自的优缺点" class="headerlink" title="你知道哪几种垃圾回收器，各自的优缺点"></a><strong>你知道哪几种垃圾回收器，各自的优缺点</strong></h5><h4 id="字节一面-GC"><a href="#字节一面-GC" class="headerlink" title="字节一面(GC)"></a><strong>字节一面</strong>(GC)</h4><h5 id="CMS回收停顿了几次，为什么要停顿两次"><a href="#CMS回收停顿了几次，为什么要停顿两次" class="headerlink" title="CMS回收停顿了几次，为什么要停顿两次"></a><strong>CMS回收停顿了几次，为什么要停顿两次</strong></h5><h5 id="为什么要STW"><a href="#为什么要STW" class="headerlink" title="为什么要STW"></a><strong>为什么要STW</strong></h5><h5 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a><strong>三色标记算法</strong></h5><h5 id="cms-清理步骤"><a href="#cms-清理步骤" class="headerlink" title="cms 清理步骤"></a><strong>cms 清理步骤</strong></h5><h5 id="cms-为什么要停顿两次"><a href="#cms-为什么要停顿两次" class="headerlink" title="cms 为什么要停顿两次"></a><strong>cms 为什么要停顿两次</strong></h5><h4 id="字节二面-other"><a href="#字节二面-other" class="headerlink" title="字节二面(other)"></a><strong>字节二面</strong>(other)</h4><h5 id="JVM各区域间是如何协同工作的"><a href="#JVM各区域间是如何协同工作的" class="headerlink" title="JVM各区域间是如何协同工作的"></a><strong>JVM各区域间是如何协同工作的</strong></h5><h5 id="堆、栈、方法区之间数据存储怎么协调的"><a href="#堆、栈、方法区之间数据存储怎么协调的" class="headerlink" title="堆、栈、方法区之间数据存储怎么协调的"></a><strong>堆、栈、方法区之间数据存储怎么协调的</strong></h5><h5 id="双亲委派机制了解吗"><a href="#双亲委派机制了解吗" class="headerlink" title="双亲委派机制了解吗"></a><strong>双亲委派机制了解吗</strong></h5><h5 id="内存分配策略了解吗"><a href="#内存分配策略了解吗" class="headerlink" title="内存分配策略了解吗"></a><strong>内存分配策略了解吗</strong></h5><h5 id="为什么要引入元空间"><a href="#为什么要引入元空间" class="headerlink" title="为什么要引入元空间"></a><strong>为什么要引入元空间</strong></h5><h5 id="方法区，元空间，永久代之间关系"><a href="#方法区，元空间，永久代之间关系" class="headerlink" title="方法区，元空间，永久代之间关系"></a><strong>方法区，元空间，永久代之间关系</strong></h5><h5 id="System-gc-和-Runtime-getRuntime-gc-会做什么事情"><a href="#System-gc-和-Runtime-getRuntime-gc-会做什么事情" class="headerlink" title="System.gc() 和 Runtime. getRuntime(). gc()会做什么事情"></a><strong>System.gc() 和 Runtime. getRuntime(). gc()会做什么事情</strong></h5><h4 id="蚂蚁金服一面-GC"><a href="#蚂蚁金服一面-GC" class="headerlink" title="蚂蚁金服一面(GC)"></a><strong>蚂蚁金服一面</strong>(GC)</h4><h5 id="说下G1-收集器"><a href="#说下G1-收集器" class="headerlink" title="说下G1 收集器"></a><strong>说下G1 收集器</strong></h5><h4 id="京东二面-调优"><a href="#京东二面-调优" class="headerlink" title="京东二面(调优)"></a><strong>京东二面</strong>(调优)</h4><h5 id="讲下-jvm-调优思路"><a href="#讲下-jvm-调优思路" class="headerlink" title="讲下 jvm 调优思路"></a><strong>讲下 jvm 调优思路</strong></h5><h4 id="阿里一面-GC"><a href="#阿里一面-GC" class="headerlink" title="阿里一面(GC)"></a><strong>阿里一面</strong>(GC)</h4><h5 id="什么情况下触发垃圾回收"><a href="#什么情况下触发垃圾回收" class="headerlink" title="什么情况下触发垃圾回收"></a><strong>什么情况下触发垃圾回收</strong></h5><h4 id="美团一面-调优"><a href="#美团一面-调优" class="headerlink" title="美团一面(调优)"></a><strong>美团一面</strong>(调优)</h4><h5 id="有在⼯作时间中使⽤过-jstat-jmap-mat⼯具吗？能给⼀个实际的例⼦说明⼀下吗"><a href="#有在⼯作时间中使⽤过-jstat-jmap-mat⼯具吗？能给⼀个实际的例⼦说明⼀下吗" class="headerlink" title="有在⼯作时间中使⽤过 jstat, jmap, mat⼯具吗？能给⼀个实际的例⼦说明⼀下吗"></a><strong>有在⼯作时间中使⽤过 jstat, jmap, mat⼯具吗？能给⼀个实际的例⼦说明⼀下吗</strong></h5><h4 id="问题-GC"><a href="#问题-GC" class="headerlink" title="问题(GC)"></a>问题(GC)</h4><h5 id="增加-Eden-区，Minor-GC-的间隔变长了，会不会导致-Minor-GC-的时间增加"><a href="#增加-Eden-区，Minor-GC-的间隔变长了，会不会导致-Minor-GC-的时间增加" class="headerlink" title="增加 Eden 区，Minor GC 的间隔变长了，会不会导致 Minor GC 的时间增加"></a><strong>增加 Eden 区，Minor GC 的间隔变长了，会不会导致 Minor GC 的时间增加</strong></h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;类加载机制&quot;&gt;&lt;a href=&quot;#类加载机制&quot; class=&quot;headerlink&quot; title=&quot;类加载机制&quot;&gt;&lt;/a&gt;类加载机制&lt;/h3&gt;&lt;h4 id=&quot;1-简述java类加载机制&quot;&gt;&lt;a href=&quot;#1-简述java类加载机制&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="面试题" scheme="https://alexander-wd.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="JVM" scheme="https://alexander-wd.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>商城项目记录</title>
    <link href="https://alexander-wd.github.io/2022/10/27/javaEE/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    <id>https://alexander-wd.github.io/2022/10/27/javaEE/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/</id>
    <published>2022-10-27T08:10:20.000Z</published>
    <updated>2023-02-13T10:37:43.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p>微服务架构图</p><p><img alt="谷粒商城-微服务架构图" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230108213105.jpg"></p><h3 id="分布式基础概念"><a href="#分布式基础概念" class="headerlink" title="分布式基础概念"></a>分布式基础概念</h3><h4 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h4><h4 id="集群-分布式-节点"><a href="#集群-分布式-节点" class="headerlink" title="集群-分布式-节点"></a>集群-分布式-节点</h4><h4 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h4><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><h4 id="服务注册-发现-amp-注册中心"><a href="#服务注册-发现-amp-注册中心" class="headerlink" title="服务注册/发现&amp;注册中心"></a>服务注册/发现&amp;注册中心</h4><h4 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h4><h4 id="服务熔断-amp-降级"><a href="#服务熔断-amp-降级" class="headerlink" title="服务熔断&amp;降级"></a>服务熔断&amp;降级</h4><h4 id="API网关l"><a href="#API网关l" class="headerlink" title="API网关l"></a>API网关l</h4><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="1-搭建linux虚拟机"><a href="#1-搭建linux虚拟机" class="headerlink" title="1.搭建linux虚拟机"></a>1.搭建linux虚拟机</h4><h5 id="vagrant安装"><a href="#vagrant安装" class="headerlink" title="vagrant安装"></a>vagrant安装</h5><blockquote><p>网络设置-不要端口转发</p><p>端口转发示意图：</p><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230108213058.png"></p></blockquote><h5 id="自己使用的virtualbox安装"><a href="#自己使用的virtualbox安装" class="headerlink" title="自己使用的virtualbox安装"></a>自己使用的virtualbox安装</h5><blockquote><p>sudo -i进入root权限</p></blockquote><p>安装过程中页面小：使用</p><p>sudo xrandr和xrandr -s 1920x1080进行设置</p><p>1.安装成功后记得找上面设备-&gt;安装增强功能</p><p>2.安装成功后使用xshell连接ubuntu</p><p>2.1 安装软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br><span class="line">#开启防火墙端口</span><br><span class="line">firewall-cmd --zone=public --add-port=22/tcp --permanent</span><br></pre></td></tr></table></figure><p>2.2 设置网卡</p><p>解释：</p><p>NAT模式是最简单的实现虚拟机上网的方式，你可以这样理解：Vhost访问网络的所有数据都是由主机提供的，vhost并不真实存在于网络中，主机与网络中的任何机器都不能查看和访问到Vhost的存在。<br>虚拟机与主机关系：<br>只能单向访问，虚拟机可以通过网络访问到主机，主机无法通过网络访问到虚拟机。</p><p><img alt="img" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230115231221.png"></p><p><img alt="12" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230115231222.png"></p><p>2.3 然后使用ifconfig查看ubuntu的ip地址，然后使用xshell连接</p><h5 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h5><blockquote><p><a href="https://blog.csdn.net/ningmengzhihe/article/details/127295333" target="_blank" rel="noopener">https://blog.csdn.net/ningmengzhihe/article/details/127295333</a></p></blockquote><h4 id="2-安装docker"><a href="#2-安装docker" class="headerlink" title="2.安装docker"></a>2.安装docker</h4><blockquote><p>docker镜像去dockerhub</p><p>docker本身去docker官网找文档</p></blockquote><h4 id="3-docker安装mysql"><a href="#3-docker安装mysql" class="headerlink" title="3.docker安装mysql"></a>3.docker安装mysql</h4><blockquote><p>挂载文件，方便修改文件</p><p>开机自启动：sudo docker update mysql —restart=always</p></blockquote><p>==mysql(5.7)闪退解决方案，但是下载mysql5.6没有问题==</p><p><a href="https://www.zhangshengrong.com/p/QrXebV9p1d/" target="_blank" rel="noopener">https://www.zhangshengrong.com/p/QrXebV9p1d/</a></p><p>镜像中apt-update太慢(使用cat &gt;&gt; 加入)</p><p><a href="https://blog.csdn.net/yjk13703623757/article/details/113194891" target="_blank" rel="noopener">https://blog.csdn.net/yjk13703623757/article/details/113194891</a></p><blockquote><p>创建容器并启动</p><p>docker run -p 3306:3306 —name mysql \</p><p>-v /mydata/mysql/log:/var/log/mysql \</p><p>-v /mydata/mysql/data:/var/lib/mysql \</p><p>-v /mydata/mysql/conf:/etc/mysql \</p><p>-e MYSQL_ROOT_PASSWORD=root \</p><p>-d mysql:5.7</p></blockquote><h4 id="4-docker安装redis"><a href="#4-docker安装redis" class="headerlink" title="4.docker安装redis"></a>4.docker安装redis</h4><blockquote><p>开启持久化 appendonly yes</p><p>开机自启动：sudo docker update redis —restart=always</p></blockquote><h4 id="5-安装开发环境"><a href="#5-安装开发环境" class="headerlink" title="5.安装开发环境"></a>5.安装开发环境</h4><p>git </p><blockquote><p>配置ssh免密登陆</p></blockquote><h4 id="6-逆向生成代码"><a href="#6-逆向生成代码" class="headerlink" title="6.逆向生成代码"></a>6.逆向生成代码</h4><p>使用人人开源生成器生成</p><h3 id="前端开发基础知识"><a href="#前端开发基础知识" class="headerlink" title="前端开发基础知识"></a>前端开发基础知识</h3><blockquote><p>==请参考课件==</p></blockquote><p>前后端技术类比图</p><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230108213052.png"></p><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><blockquote><p>js是它的一个实现</p></blockquote><h5 id="map-reduce"><a href="#map-reduce" class="headerlink" title="==map== ==reduce=="></a>==map== ==reduce==</h5><h5 id="promise"><a href="#promise" class="headerlink" title="==promise=="></a>==promise==</h5><p>&gt;</p><blockquote><p>解决异步嵌套</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;     $.ajax(&#123;</span><br><span class="line">&gt;         url: <span class="string">"mock/user.json"</span>,</span><br><span class="line">&gt;         success(data) &#123;</span><br><span class="line">&gt;             <span class="built_in">console</span>.log(<span class="string">"查询用户："</span>, data);</span><br><span class="line">&gt;             resolve(data.id);</span><br><span class="line">&gt;         &#125;,</span><br><span class="line">&gt;         error(error) &#123;</span><br><span class="line">&gt;             <span class="built_in">console</span>.log(<span class="string">"出现异常了："</span> + error);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;);</span><br><span class="line">&gt; &#125;).then(<span class="function">(<span class="params">userId</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;         $.ajax(&#123;</span><br><span class="line">&gt;             url: <span class="string">`mock/user_corse_<span class="subst">$&#123;userId&#125;</span>.json`</span>,</span><br><span class="line">&gt;             success(data) &#123;</span><br><span class="line">&gt;                 <span class="built_in">console</span>.log(<span class="string">"查询到课程："</span>, data);</span><br><span class="line">&gt;                 resolve(data.id);</span><br><span class="line">&gt;             &#125;,</span><br><span class="line">&gt;             error(error) &#123;</span><br><span class="line">&gt;             <span class="built_in">console</span>.log(<span class="string">"出现异常了："</span> + error);</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;);</span><br><span class="line">&gt;     &#125;);</span><br><span class="line">&gt; &#125;).then(<span class="function">(<span class="params">corseId</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;     <span class="built_in">console</span>.log(corseId);</span><br><span class="line">&gt;     $.ajax(&#123;</span><br><span class="line">&gt;         url: <span class="string">`mock/corse_score_<span class="subst">$&#123;corseId&#125;</span>.json`</span>,</span><br><span class="line">&gt;         success(data) &#123;</span><br><span class="line">&gt;             <span class="built_in">console</span>.log(<span class="string">"查询到分数："</span>, data);</span><br><span class="line">&gt;         &#125;,</span><br><span class="line">&gt;         error(error) &#123;</span><br><span class="line">&gt;             <span class="built_in">console</span>.log(<span class="string">"出现异常了："</span> + error);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;);</span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>优化：将promise封装为一个方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> <span class="keyword">get</span> = function (url, data) &#123; <span class="comment">// 实际开发中会单独放到 common.js 中</span></span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;         $.ajax(&#123;</span><br><span class="line">&gt;             url: url,</span><br><span class="line">&gt;             type: <span class="string">"GET"</span>,</span><br><span class="line">&gt;             data: data,</span><br><span class="line">&gt;             success(result) &#123;</span><br><span class="line">&gt;             resolve(result);</span><br><span class="line">&gt;             &#125;,</span><br><span class="line">&gt;             error(error) &#123;</span><br><span class="line">&gt;             reject(error);</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;);</span><br><span class="line">&gt;     &#125;)</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">get</span>("mock/user.json").then((result) =&gt; &#123;</span><br><span class="line">&gt;     <span class="built_in">console</span>.log(<span class="string">"查询用户："</span>, result);</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">get</span>(`mock/user_corse_$&#123;result.id&#125;.json<span class="string">`);</span></span><br><span class="line"><span class="string">&gt; &#125;).then((result) =&gt; &#123;</span></span><br><span class="line"><span class="string">&gt;     console.log("查询到课程：", result);</span></span><br><span class="line"><span class="string">&gt;     return get(`</span>mock/corse_score_$&#123;result.id&#125;.json<span class="string">`)</span></span><br><span class="line"><span class="string">&gt; &#125;).then((result) =&gt; &#123;</span></span><br><span class="line"><span class="string">&gt; console.log("查询到分数：", result);</span></span><br><span class="line"><span class="string">&gt; &#125;).catch(() =&gt; &#123;</span></span><br><span class="line"><span class="string">&gt; console.log("出现异常了：" + error);</span></span><br><span class="line"><span class="string">&gt; &#125;);</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h5><blockquote><p>是vue模块化的基础</p><p>导出</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> util = &#123;</span><br><span class="line">    sum(a,b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"jack"</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">21</span></span><br><span class="line"><span class="keyword">export</span> &#123;util,name,age&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>可以自己起名</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    sum(a,b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>导入</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> util <span class="keyword">from</span> <span class="string">'hello.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;age,name&#125; <span class="keyword">from</span> <span class="string">'user.js'</span></span><br></pre></td></tr></table></figure><h5 id="json-的key和value相同可以省略key"><a href="#json-的key和value相同可以省略key" class="headerlink" title="json 的key和value相同可以省略key"></a>json 的key和value相同可以省略key</h5><h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><p>主要用到其中的npm，相当于java的maven</p><p>每次开启vue项目使用npm install根据package.json安装依赖包</p><h4 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h4><h5 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h5><blockquote><p>1.npm init -y生成package.json</p><p>2.npm install vue</p><p>调试工具vue-devtools</p></blockquote><h5 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h5><blockquote><p>数据与页面元素绑定上了，只需要把关注点放到model上，不需要繁琐的操作DOM</p></blockquote><h5 id="指令总结"><a href="#指令总结" class="headerlink" title="指令总结"></a>指令总结</h5><blockquote><p><strong>v-text、v-html和双大括号:给标签内容绑定值          双大括号就是直接从data中取出数据</strong></p><p><strong>v-bind:给标签属性绑定值</strong>  可以缩写，只留冒号</p><p><strong>以上都是单向绑定数据(页面值变了，data中不会变)</strong></p><p><strong>v-model可以实现双向绑定(页面值变了，data中会变)</strong></p><p><strong>v-model可以绑定的元素有input、select、textarea、checkbox、radio、components(vue组件)</strong></p><p><strong>v-on:给标签绑定事件</strong></p><p>​    事件修饰符</p><p>​    按键修饰符</p><p>​    组合按钮</p><p>v-for  写上:key渲染效率更高</p><p>v-if (直接html消失)</p><p>v-show(display:none)</p><p><strong>以上绑定的值都是从data中取出</strong></p><p>==最最最核心的就是data，页面的动态绑定的状态值都是在这里==</p></blockquote><h5 id="计算属性"><a href="#计算属性" class="headerlink" title="==计算属性=="></a>==计算属性==</h5><blockquote><p>computed：动态计算</p><p>应用：某个变量发生变化时，其他变量根据这个变量变化</p></blockquote><h5 id="监听器"><a href="#监听器" class="headerlink" title="==监听器=="></a>==监听器==</h5><blockquote><p>watch：监听某个方法的变化</p><p>应用：某个变量变化时，做出相应的反应(函数)</p></blockquote><h5 id="过滤器"><a href="#过滤器" class="headerlink" title="==过滤器=="></a>==过滤器==</h5><blockquote><p>filters：定义一些函数进行转换</p><p>应用：(0,1)-&gt;(男，女)</p><p>全局过滤器：Vue.filter({})</p></blockquote><h5 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h5><blockquote><p>复用重复的组件</p><p>tips</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; data()&#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> &#123;</span><br><span class="line">&gt;         count:<span class="number">1</span></span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; 组件中返回了一个新对象，而不是</span><br><span class="line">&gt; data()&#123;</span><br><span class="line">&gt;     count:<span class="number">1</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; 这样可以防止动一个组件，其他跟着一起动</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h5 id="父子组件传值"><a href="#父子组件传值" class="headerlink" title="==父子组件传值=="></a>==父子组件传值==</h5><blockquote><p>参考</p><p><a href="https://www.jianshu.com/p/1e91be0d280d" target="_blank" rel="noopener">https://www.jianshu.com/p/1e91be0d280d</a> 父子组件的通信</p><p><a href="https://www.jianshu.com/p/3ab0b823d5b0" target="_blank" rel="noopener">https://www.jianshu.com/p/3ab0b823d5b0</a> 非父子组件的通信、插槽Slot</p><p><a href="https://www.jianshu.com/p/7a972277dd0d" target="_blank" rel="noopener">https://www.jianshu.com/p/7a972277dd0d</a> 动态组件、异步组件、生命周期、组件的v-model、Mixin</p></blockquote><h6 id="使用了-emit向父组件中返回值"><a href="#使用了-emit向父组件中返回值" class="headerlink" title="==使用了$emit向父组件中返回值=="></a>==使用了$emit向父组件中返回值==</h6><p>父组件(brand-add-or-update.vue)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">single-upload</span> <span class="attr">v-model</span>=<span class="string">"dataForm.logo"</span>&gt;</span><span class="tag">&lt;/<span class="name">single-upload</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件(singleUpload.vue)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">emitInput(val) &#123;</span><br><span class="line">    参考  https:<span class="comment">//www.h5w3.com/81714.html</span></span><br><span class="line">    在这里返回给父组件 </span><br><span class="line">    <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, val)<span class="comment">// 触发输入行为,v-model 绑定的是 input 事件</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">handleUploadSuccess(res, file) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"上传成功..."</span>)</span><br><span class="line">        <span class="keyword">this</span>.showFileList = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.fileList.pop();</span><br><span class="line">        <span class="keyword">this</span>.fileList.push(&#123;<span class="attr">name</span>: file.name, <span class="attr">url</span>: <span class="keyword">this</span>.dataObj.host + <span class="string">'/'</span> + <span class="keyword">this</span>.dataObj.key.replace(<span class="string">"$&#123;filename&#125;"</span>,file.name)&#125;);</span><br><span class="line">        <span class="comment">// 在这里返回给父组件logo的地址</span></span><br><span class="line">        <span class="keyword">this</span>.emitInput(<span class="keyword">this</span>.fileList[<span class="number">0</span>].url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="父组件可以使用-props-把数据传给子组件"><a href="#父组件可以使用-props-把数据传给子组件" class="headerlink" title="==父组件可以使用 props 把数据传给子组件=="></a>==父组件可以使用 props 把数据传给子组件==</h6><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//直接绑定 :title=v-bind:title</span><br><span class="line"><span class="tag">&lt;<span class="name">show-message</span> <span class="attr">:title</span>=<span class="string">"title"</span> <span class="attr">:content</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">show-message</span>&gt;</span></span><br><span class="line">//绑定对象的属性</span><br><span class="line"><span class="tag">&lt;<span class="name">show-message</span> <span class="attr">:title</span>=<span class="string">"message.title"</span> <span class="attr">:content</span>=<span class="string">"message.content"</span>&gt;</span><span class="tag">&lt;/<span class="name">show-message</span>&gt;</span></span><br><span class="line">//绑定对象，就会把对象的所有属性绑定到组件上，这种写法和上一行效果一样</span><br><span class="line"><span class="tag">&lt;<span class="name">show-message</span> <span class="attr">v-bind</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">show-message</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//数据</span><br><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    title: "嘻嘻嘻",</span><br><span class="line">    content: "我是嘻嘻嘻嘻",</span><br><span class="line">    message: &#123;</span><br><span class="line">      title: "嘿嘿嘿",</span><br><span class="line">      content: "我是嘿嘿嘿"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子组件  </p><blockquote><p>子组件使用props指定要什么值</p><p>父组件调用子组件时也要指定传什么值</p></blockquote><p><img alt="img" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230108230519"></p><h5 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h5><blockquote><p>Vue在生命周期的每个状态都设置了监听函数，我们可以根据业务需求在Vue的各个生命周期设置各种函数执行相应的功能 </p><p>有点像Spring的AOP？？</p></blockquote><h5 id="使用脚手架快速开发"><a href="#使用脚手架快速开发" class="headerlink" title="使用脚手架快速开发"></a>使用脚手架快速开发</h5><blockquote><p>1.<strong>npm install webpack -g</strong></p><p>2.<strong>npm install -g @vue/cli-init</strong></p><p>​    安装vue脚手架</p><p>3.vue init webpack appname</p><p>​    初始化</p><p>==初始化的Vue项目详解看P43==</p><p>@是src根目录</p><p>==vscode可以自定义代码模板     ctrl+shift+f快速整理==</p></blockquote><h4 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h4><blockquote><p>老浏览器不支持ES6语法，Babel可以转成它们支持的老js语法</p></blockquote><h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><blockquote><p>打包工具，gulp是同类产品</p></blockquote><h3 id="SpringCloud-amp-SpringCloud-Alibaba组件"><a href="#SpringCloud-amp-SpringCloud-Alibaba组件" class="headerlink" title="==SpringCloud &amp; SpringCloud Alibaba组件=="></a>==SpringCloud &amp; SpringCloud Alibaba组件==</h3><blockquote><p>==SpringCloud Alibaba组件请参考github项目==</p><p><strong>SpringCloud</strong> <strong>的几大痛点</strong></p><p>SpringCloud 部分组件停止维护和更新，给开发带来不便；</p><p>SpringCloud 部分环境搭建复杂，没有完善的可视化界面，我们需要大量的二次开发和定制</p><p>SpringCloud 配置复杂，难以上手，部分配置差别难以区分和合理应用</p><p><strong>SpringCloud Alibaba</strong> <strong>的优势：</strong></p><p>阿里使用过的组件经历了考验，性能强悍，设计合理，现在开源出来大家用</p><p>成套的产品搭配完善的可视化界面给开发运维带来极大的便利</p><p>搭建简单，学习曲线低。</p></blockquote><p><strong>结合</strong> <strong>SpringCloud Alibaba</strong> <strong>我们最终的技术搭配方案：</strong></p><h5 id="SpringCloud-Alibaba-Nacos：注册中心（服务发现注册）"><a href="#SpringCloud-Alibaba-Nacos：注册中心（服务发现注册）" class="headerlink" title="SpringCloud Alibaba - Nacos：注册中心（服务发现注册）"></a><strong>SpringCloud Alibaba - Nacos</strong>：注册中心（服务发现注册）</h5><blockquote><p>对比Eureka</p><p>1.先在github上下载nacos文件包</p><p>2.引入pom依赖</p><p>3.配置application.yml的nacos地址</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&gt; spring:</span></span><br><span class="line"><span class="string">&gt;   application:</span></span><br><span class="line"><span class="string">&gt;     name: gulimall-coupon</span></span><br><span class="line"><span class="string">&gt;   cloud:</span></span><br><span class="line"><span class="string">&gt;     nacos:</span></span><br><span class="line"><span class="string">&gt;       discovery:</span></span><br><span class="line"><span class="string">&gt;         server-addr: localhost:8848</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>4.开启@EnableDiscoveryClient注解</p></blockquote><h5 id="SpringCloud-Alibaba-Nacos：配置中心-（动态配置管理）"><a href="#SpringCloud-Alibaba-Nacos：配置中心-（动态配置管理）" class="headerlink" title="==SpringCloud Alibaba - Nacos：配置中心==（动态配置管理）"></a><strong>==SpringCloud Alibaba - Nacos：配置中心==（动态配置管理）</strong></h5><h6 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h6><blockquote><p>1.先在github上下载nacos文件包</p><p>2.引入pom依赖</p><p>3.配置bootstrap.yml的nacos地址</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&gt; spring:</span></span><br><span class="line"><span class="string">&gt;   application:</span></span><br><span class="line"><span class="string">&gt;     name: gulimall-coupon</span></span><br><span class="line"><span class="string">&gt;   cloud:</span></span><br><span class="line"><span class="string">&gt;     nacos:</span></span><br><span class="line"><span class="string">&gt;       config:</span></span><br><span class="line"><span class="string">&gt;         server-addr: localhost:8848</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>==4.在需要刷新属性值的类上加上@RefreshScope==+ 属性名上加@Value</p><p>5.在nacos界面添加配置，配置的id是springboot启动界面出现的properties名称(项目名.properties)</p><p>tips：优先使用配置中心的配置，再使用项目中的配置</p><p>==作用：可以实时，不下线应用的前提下修改application.properties配置文件中的值==</p></blockquote><h6 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h6><blockquote><p><strong>1.命名空间:</strong></p><p>配置隔离：</p><p>1.1默认的命名空间是public，通过命名空间区分测试、开发、生产环境</p><blockquote><p>在bootstrap中配置命名空间的空间id—namespace</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&gt; &gt; spring:</span></span><br><span class="line"><span class="string">&gt; &gt;   application:</span></span><br><span class="line"><span class="string">&gt; &gt;     name: gulimall-coupon</span></span><br><span class="line"><span class="string">&gt; &gt;   cloud:</span></span><br><span class="line"><span class="string">&gt; &gt;     nacos:</span></span><br><span class="line"><span class="string">&gt; &gt;       config:</span></span><br><span class="line"><span class="string">&gt; &gt;         server-addr: localhost:8848</span></span><br><span class="line"><span class="string">&gt; &gt;         namespace: 5f96fa79-8abf-49a7-a148-7bee7f77a575</span></span><br><span class="line"><span class="string">&gt; &gt;</span></span><br></pre></td></tr></table></figure></blockquote></blockquote><p>&gt;</p><blockquote><p>1.2每一个微服务相互隔离配置，每一个微服务都创建自己的命名空间</p><p>2.配置集：所有的配置的集合</p><p>3.配置集Id：类似文件名</p><p>​    Data ID：类似文件名</p><p>4.配置分组：默认所有的配置集都属于DEFAULT_GROUP</p><p>要指定group，在bootstrap.yml中配置group</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&gt; spring:</span></span><br><span class="line"><span class="string">&gt;   application:</span></span><br><span class="line"><span class="string">&gt;     name: gulimall-coupon</span></span><br><span class="line"><span class="string">&gt;   cloud:</span></span><br><span class="line"><span class="string">&gt;     nacos:</span></span><br><span class="line"><span class="string">&gt;       config:</span></span><br><span class="line"><span class="string">&gt;         group: 双11</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>5.<strong>加载多配置文件</strong></p><p>直接在nacos中操作</p><p>在bootstrap.properties/bootstrap.yml添加ext-config</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.server-addr=127.0.0.1:8848</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.namespace=31098de9-fa28-41c9-b0bd-c754ce319ed4</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.ext-config[0].data-id=gulimall-datasource.yml</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string"># 是否自动刷新</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.ext-config[0].refresh=false</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.ext-config[0].group=dev</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string"></span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.ext-config[0].data-id=gulimall-mybatis.yml</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string"># 是否自动刷新</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.ext-config[0].refresh=false</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.ext-config[0].group=dev</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string"></span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.ext-config[0].data-id=gulimall-other.yml</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string"># 是否自动刷新</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.ext-config[0].refresh=false</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.ext-config[0].group=dev</span></span><br><span class="line"><span class="attr">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>然后就可以把application.yml注释掉，直接用nacos的配置</p></blockquote><h5 id="SpringCloud-Ribbon：负载均衡"><a href="#SpringCloud-Ribbon：负载均衡" class="headerlink" title="SpringCloud - Ribbon：负载均衡"></a><strong>SpringCloud - Ribbon</strong>：负载均衡</h5><h5 id="SpringCloud-Feign：声明式-HTTP-客户端（调用远程服务）"><a href="#SpringCloud-Feign：声明式-HTTP-客户端（调用远程服务）" class="headerlink" title="SpringCloud - Feign：声明式 HTTP 客户端（调用远程服务）"></a><strong>SpringCloud - Feign</strong>：声明式 <strong>HTTP</strong> <strong>客户端（调用远程服务）</strong></h5><h5 id="SpringCloud-Alibaba-Sentinel：服务容错（限流、降级、熔断）"><a href="#SpringCloud-Alibaba-Sentinel：服务容错（限流、降级、熔断）" class="headerlink" title="SpringCloud Alibaba - Sentinel：服务容错（限流、降级、熔断）"></a><strong>SpringCloud Alibaba - Sentinel</strong>：服务容错（限流、降级、熔断）</h5><blockquote><p>对比Hystrix</p></blockquote><h5 id="SpringCloud-Gateway：API-网关（webflux-编程模式）"><a href="#SpringCloud-Gateway：API-网关（webflux-编程模式）" class="headerlink" title="SpringCloud - Gateway：API 网关（webflux 编程模式）"></a><strong>SpringCloud - Gateway</strong>：<strong>API </strong>网关（<strong>webflux</strong> <strong>编程模式）</strong></h5><blockquote><p>比zuul功能更多，取代了zuul</p><p>route(路由)</p><p>predicate(断言)</p><p>filter</p><p>通过路由经过断言和过滤器抵达请求，类似SpringMVC流程</p><p>1.添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>2.网关不需要数据库，添加如下配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@SpringBootApplication</span>(exclude = &#123;DataSourceAutoConfiguration.class&#125; )</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h5 id="SpringCloud-Sleuth：调用链监控"><a href="#SpringCloud-Sleuth：调用链监控" class="headerlink" title="SpringCloud - Sleuth：调用链监控"></a><strong>SpringCloud - Sleuth</strong>：调用链监控</h5><h5 id="SpringCloud-Alibaba-Seata：原Fescar，即分布式事务解决方案"><a href="#SpringCloud-Alibaba-Seata：原Fescar，即分布式事务解决方案" class="headerlink" title="SpringCloud Alibaba - Seata：原Fescar，即分布式事务解决方案"></a><strong>SpringCloud Alibaba - Seata</strong>：原Fescar<strong>，即分布式事务解决方案</strong></h5><h5 id="SpringCloud-Alibaba-OSS"><a href="#SpringCloud-Alibaba-OSS" class="headerlink" title="SpringCloud Alibaba - OSS"></a>SpringCloud Alibaba - OSS</h5><p>1.导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alicloud-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.配置yml</p><p>3.注入OSSClient(实际要注入的是OSS)</p><h3 id="后端正式开发"><a href="#后端正式开发" class="headerlink" title="后端正式开发"></a>后端正式开发</h3><h4 id="1-构建权限树"><a href="#1-构建权限树" class="headerlink" title="1.构建权限树"></a>1.构建权限树</h4><blockquote><p>思路，先把所有的id和entity用map存起来，再遍历</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来存放结果</span></span><br><span class="line">List&lt;AuthPO&gt; authTree = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 使用map表示每一个菜单与id的对应关系</span></span><br><span class="line">Map&lt;Long,AuthPO&gt; authMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 将菜单id与菜单对象以K-V对模式存入map</span></span><br><span class="line"><span class="keyword">for</span>(AuthPO auth: authPOList)&#123;</span><br><span class="line">    authMap.put(auth.getId(),auth);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (AuthPO auth:authPOList)&#123;</span><br><span class="line">    Long pid = auth.getAuthParentId();</span><br><span class="line">    <span class="keyword">if</span>(Objects.equals(pid,<span class="number">0L</span>))&#123;</span><br><span class="line">        authTree.add(auth);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AuthPO father = authMap.get(pid);</span><br><span class="line">    father.getChildren().add(auth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-gateway配置路由-作用-前端项目不用再一个一个改请求地址"><a href="#2-gateway配置路由-作用-前端项目不用再一个一个改请求地址" class="headerlink" title="2.gateway配置路由(作用:前端项目不用再一个一个改请求地址)"></a>2.gateway配置路由(作用:前端项目不用再一个一个改请求地址)</h4><blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&gt; spring:</span></span><br><span class="line"><span class="string">&gt;   cloud:</span></span><br><span class="line"><span class="string">&gt;     gateway:</span></span><br><span class="line"><span class="string">&gt;       routes:</span></span><br><span class="line"><span class="string">&gt;         - id: admin_route</span></span><br><span class="line"><span class="string">&gt;           # lb表示负载均衡(loadbalance),renren-fast是微服务名称</span></span><br><span class="line"><span class="string">&gt;           uri: lb://renren-fast</span></span><br><span class="line"><span class="string">&gt;           predicates:</span></span><br><span class="line"><span class="string">&gt;           ********项目中这个路由最好写到最后，最后才生效******</span></span><br><span class="line"><span class="string">&gt;             - Path=/api/**</span></span><br><span class="line"><span class="string">&gt;           filters:</span></span><br><span class="line"><span class="string">&gt;             - RewritePath=/api/(?&lt;segment&gt;/?.*), /renren-fast/$\&#123;segment&#125;</span></span><br><span class="line"><span class="string">&gt;             </span></span><br><span class="line"><span class="string">&gt; 前端请求：localhost:88/api/captcha.jpg</span></span><br><span class="line"><span class="string">&gt; 转到后端请求会重新拼接上来：localhost:8080/api/captcha.jpg</span></span><br><span class="line"><span class="string">&gt; 所以要用- RewritePath=/api/(?&lt;segment&gt;/?.*), /renren-fast/$\&#123;segment&#125;</span></span><br><span class="line"><span class="string">&gt; 效果就是把api替换为renren-fast即localhost:8080/api/captcha.jpg-&gt;localhost:8080/renren-fast/captcha.jpg</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="3-跨域-amp-CORS同源策略"><a href="#3-跨域-amp-CORS同源策略" class="headerlink" title="==3.跨域&amp;CORS同源策略=="></a>==3.跨域&amp;CORS同源策略==</h4><blockquote><p>localhost:8080和localhost:88就是非同源，协议、ip和端口号一致才叫同源(域名和域名对应ip都不行)，这就不符合CORS同源策略</p><p><img alt="5" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230108213019.png"></p><p>==跨域流程参考课件图==</p><p>非简单请求(json数据不是)都会先发送预检请求，成功后，才发送真实请求</p></blockquote><p><strong>解决方案</strong></p><p>1.使用nginx部署为统一域(有图)</p><p>2.给预检请求配置，此次请求能跨域</p><blockquote><p>不止这一种方式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallCorsConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsWebFilter <span class="title">corsWebFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line"></span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、配置跨域</span></span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">"*"</span>);</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">// 是否允许携带cookie</span></span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 任意路径都需要跨域配置</span></span><br><span class="line">        source.registerCorsConfiguration(<span class="string">"/**"</span>,corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsWebFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-对象存储"><a href="#4-对象存储" class="headerlink" title="==4.对象存储=="></a>==4.对象存储==</h4><p><img alt="6" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230108212958.png"></p><p>分布式项目一定要有一个专门存储图片、文件等对象的服务</p><p>对象存储上传方式(参考ppt图)</p><blockquote><p>服务器签名后直传，文件不经过服务器，只是从服务器拿一个签名</p></blockquote><p>步骤：</p><p>1.导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alicloud-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.配置yml</p><p>3.注入OSSClient(实际要注入的是OSS)</p><p>==4.请求/oss/policy获取签名==</p><p>==5.因为是浏览器直接向OSS传输文件，所以还存在跨域问题，要在阿里云OSS配置跨域==</p><p><img alt="7" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230108212933.png"></p><p>6.如果上传成功后，不能通过直链访问，还要配置bucket的读写权限</p><p><img alt="9" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230112140644.png"></p><h4 id="5-校验配置"><a href="#5-校验配置" class="headerlink" title="5.校验配置"></a>5.校验配置</h4><h5 id="5-1-可以紧跟-Valid后的bean声明BindingResult获得校验结果"><a href="#5-1-可以紧跟-Valid后的bean声明BindingResult获得校验结果" class="headerlink" title="5.1 可以紧跟@Valid后的bean声明BindingResult获得校验结果"></a>5.1 可以紧跟@Valid后的bean声明BindingResult获得校验结果</h5><p>这边引用的是注册功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(value = <span class="string">"/register"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">(@Valid UserRegisterVo vos, BindingResult result,</span></span></span><br><span class="line"><span class="function"><span class="params">                       RedirectAttributes attributes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果有错误回到注册页面</span></span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">        Map&lt;String, String&gt; errors = result.getFieldErrors().stream().collect(Collectors.toMap(FieldError::getField, FieldError::getDefaultMessage));</span><br><span class="line">        attributes.addFlashAttribute(<span class="string">"errors"</span>,errors);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//效验出错回到注册页面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:http://auth.gulimall.com/reg.html"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-分组校验"><a href="#5-2-分组校验" class="headerlink" title="5.2 分组校验"></a>5.2 分组校验</h5><p>定义空的interface，配置校验时，指定该分组</p><h5 id="5-3-自定义校验"><a href="#5-3-自定义校验" class="headerlink" title="5.3 自定义校验"></a>5.3 自定义校验</h5><p>编写自定义Annotation和Validator，编写ValidationMessages.properties文件</p><p><strong>下面的例子就是要满足取得值在vals内</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = &#123; ListValueConstraintValidator.class &#125;)<span class="comment">// 可以指定多个校验器</span></span><br><span class="line"><span class="meta">@Target</span>(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ListValue &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "</span>&#123;com.atguigu.common.valid.ListValue.message&#125;<span class="string">";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Class&lt;?&gt;[] groups() default &#123; &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Class&lt;? extends Payload&gt;[] payload() default &#123; &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    int[] vals() default &#123; &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListValueConstraintValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">ListValue</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> constraintAnnotation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ListValue constraintAnnotation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] vals = constraintAnnotation.vals();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> val : vals) &#123;</span><br><span class="line">            set.add(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否效验成功</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 需要效验的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Integer value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否有包含的值</span></span><br><span class="line">        <span class="keyword">boolean</span> contains = set.contains(value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> contains;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-日志"><a href="#6-日志" class="headerlink" title="6.日志"></a>6.日志</h4><p>直接使用@Slf4j+log</p><h4 id="7-推荐不要使用关联查询，把sql语句拆成多句"><a href="#7-推荐不要使用关联查询，把sql语句拆成多句" class="headerlink" title="7.推荐不要使用关联查询，把sql语句拆成多句"></a>7.推荐不要使用关联查询，把sql语句拆成多句</h4><h4 id="8-for和foreach的区别"><a href="#8-for和foreach的区别" class="headerlink" title="8.for和foreach的区别"></a>8.for和foreach的区别</h4><p><a href="https://blog.csdn.net/cpcpcp123/article/details/125410074" target="_blank" rel="noopener">参考</a></p><h4 id="9-feign细节"><a href="#9-feign细节" class="headerlink" title="==9.feign细节=="></a>==9.feign细节==</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">feign流程:</span><br><span class="line">1、CouponFeignService.saveSpuBounds(spuBoundTo);</span><br><span class="line">*      1）、@RequestBody将这个对象转为json。</span><br><span class="line">*      2）、找到gulimall-coupon服务，给/coupon/spubounds/save发送请求。</span><br><span class="line">*          将上一步转的json放在请求体位置，发送请求；</span><br><span class="line">*      3）、对方服务收到请求。请求体里有json数据。</span><br><span class="line">*          (@RequestBody SpuBoundsEntity spuBounds)；将请求体的json转为SpuBoundsEntity；</span><br><span class="line">feign细节:只要json数据模型是兼容的。双方服务无需使用同一个to</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1)、让所有请求过网关；</span><br><span class="line">*          1、@FeignClient(&quot;gulimall-gateway&quot;)：给gulimall-gateway所在的机器发请求</span><br><span class="line">*          2、/api/product/skuinfo/info/&#123;skuId&#125;</span><br><span class="line">2）、直接让后台指定服务处理</span><br><span class="line">*          1、@FeignClient(&quot;gulimall-product&quot;)</span><br><span class="line">*          2、/product/skuinfo/info/&#123;skuId&#125;</span><br></pre></td></tr></table></figure><h4 id="10-SPU和SKU"><a href="#10-SPU和SKU" class="headerlink" title="10.SPU和SKU"></a>10.SPU和SKU</h4><p>SPU表示通用的一类商品，SKU表示具体的某个型号某个参数的商品</p><h3 id="前端项目开发"><a href="#前端项目开发" class="headerlink" title="前端项目开发"></a>前端项目开发</h3><blockquote><p>入门案例先参考category.vue就行</p></blockquote><h4 id="1-index-js中配置请求路径"><a href="#1-index-js中配置请求路径" class="headerlink" title="1.index.js中配置请求路径"></a>1.index.js中配置请求路径</h4><blockquote><p>localhost:88  统一从网关获取访问路径，</p><p>这样多个微服务地址，不用改来改去</p><p>配合后端第2条看</p></blockquote><h4 id="2-data-解构数据"><a href="#2-data-解构数据" class="headerlink" title="2.{data}解构数据"></a>2.{data}解构数据</h4><p>原始的data传到前端是这样的</p><p><img alt="10" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230112162643.png"></p><p>{data}解构之后才是后端真正传的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">getMenus() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$http(&#123;</span><br><span class="line">        url: <span class="keyword">this</span>.$http.adornUrl(<span class="string">"/product/category/list"</span>),</span><br><span class="line">        method: <span class="string">"get"</span></span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功获取到菜单数据..."</span>, data.page);</span><br><span class="line">        <span class="keyword">this</span>.menus = data.page;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line">因为这边要得数据是数组类型，而我们的数据是</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"msg"</span>: <span class="string">"success"</span>,</span><br><span class="line">  <span class="string">"code"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">"page"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"图书、音像、电子书刊"</span>,</span><br><span class="line">      <span class="string">"parentId"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">"status"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">"sort"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">"icon"</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="string">"unit"</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="string">"children"</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">这样的对象类型</span><br><span class="line">否则就这样写</span><br><span class="line">getMenus() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$http(&#123;</span><br><span class="line">        url: <span class="keyword">this</span>.$http.adornUrl(<span class="string">"/product/category/list"</span>),</span><br><span class="line">        method: <span class="string">"get"</span></span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功获取到菜单数据..."</span>, data.data.page);</span><br><span class="line">        <span class="keyword">this</span>.menus = data.data.page;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="3-飘号-引用变量"><a href="#3-飘号-引用变量" class="headerlink" title="3.``(飘号)引用变量"></a>3.``(飘号)引用变量</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$confirm(<span class="string">`是否删除【<span class="subst">$&#123;data.name&#125;</span>】菜单?`</span>, <span class="string">"提示"</span>, &#123;</span><br><span class="line">    confirmButtonText: <span class="string">"确定"</span>,</span><br><span class="line">    cancelButtonText: <span class="string">"取消"</span>,</span><br><span class="line">    type: <span class="string">"warning"</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="4-拖拽功能有空可以看看"><a href="#4-拖拽功能有空可以看看" class="headerlink" title="4.拖拽功能有空可以看看"></a>4.拖拽功能有空可以看看</h4><h4 id="5-this-refs-menuTree"><a href="#5-this-refs-menuTree" class="headerlink" title="==5.this.$refs.menuTree=="></a>==5.this.$refs.menuTree==</h4><blockquote><p>在category.vue中</p><p>$refs表示从template节点中取，menuTree是vue的template其中一个节点取得名字</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">el-tree</span> <span class="attr">:data</span>=<span class="string">"menus"</span> <span class="attr">ref</span>=<span class="string">"menuTree"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-tree</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>这样就能拿到这个节点的属性</p><p>其实后台开发人员可能也是要写前端的，真正的前端开发人员是写面向用户的前端</p></blockquote><h4 id="6-slot"><a href="#6-slot" class="headerlink" title="==6.slot=="></a>==6.slot==</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">"showStatus"</span> <span class="attr">header-align</span>=<span class="string">"center"</span> <span class="attr">align</span>=<span class="string">"center"</span> <span class="attr">label</span>=<span class="string">"显示状态"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-switch</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">v-model</span>=<span class="string">"scope.row.showStatus"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">active-color</span>=<span class="string">"#13ce66"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">inactive-color</span>=<span class="string">"#ff4949"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">:active-value</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">:inactive-value</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">                   @<span class="attr">change</span>=<span class="string">"updateBrandStatus(scope.row)"</span></span></span><br><span class="line"><span class="tag">                   &gt;</span><span class="tag">&lt;/<span class="name">el-switch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>scope中封装了这一列的所有信息</p></blockquote><h4 id="7-上传文件"><a href="#7-上传文件" class="headerlink" title="==7.上传文件=="></a>==7.上传文件==</h4><p>记得在components中声明要是用哪些组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SingleUpload <span class="keyword">from</span> <span class="string">"@/components/upload/singleUpload"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123; SingleUpload &#125;,</span><br><span class="line">  data() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==因为是直接浏览器向OSS传输文件，所以还存在跨域问题，要在阿里云OSS配置跨域==</p><p><img alt="7" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230108212933.png"></p><p>如果上传成功后，不能通过直链访问，还要配置bucket的读写权限</p><p><img alt="9" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230112140644.png"></p><h4 id="8-父子组件传值"><a href="#8-父子组件传值" class="headerlink" title="8.父子组件传值"></a>8.父子组件传值</h4><blockquote><p>上传文件</p><p>category.vue 树形菜单</p></blockquote><h5 id="8-1-使用了-emit向父组件中返回值"><a href="#8-1-使用了-emit向父组件中返回值" class="headerlink" title="==8.1 使用了$emit向父组件中返回值=="></a>==8.1 使用了$emit向父组件中返回值==</h5><p>父组件(brand-add-or-update.vue)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">single-upload</span> <span class="attr">v-model</span>=<span class="string">"dataForm.logo"</span>&gt;</span><span class="tag">&lt;/<span class="name">single-upload</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件(singleUpload.vue)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">emitInput(val) &#123;</span><br><span class="line">    在这里返回给父组件</span><br><span class="line">    <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, val)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">handleUploadSuccess(res, file) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"上传成功..."</span>)</span><br><span class="line">        <span class="keyword">this</span>.showFileList = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.fileList.pop();</span><br><span class="line">        <span class="keyword">this</span>.fileList.push(&#123;<span class="attr">name</span>: file.name, <span class="attr">url</span>: <span class="keyword">this</span>.dataObj.host + <span class="string">'/'</span> + <span class="keyword">this</span>.dataObj.key.replace(<span class="string">"$&#123;filename&#125;"</span>,file.name)&#125;);</span><br><span class="line">        <span class="comment">// 在这里返回给父组件logo的地址</span></span><br><span class="line">        <span class="keyword">this</span>.emitInput(<span class="keyword">this</span>.fileList[<span class="number">0</span>].url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-2-父组件可以使用-props-把数据传给子组件"><a href="#8-2-父组件可以使用-props-把数据传给子组件" class="headerlink" title="8.2 父组件可以使用 props 把数据传给子组件"></a>8.2 父组件可以使用 props 把数据传给子组件</h5><h4 id="9-表单校验"><a href="#9-表单校验" class="headerlink" title="9.表单校验"></a>9.表单校验</h4><p>默认校验+自定义校验</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="1-什么是微服务？"><a href="#1-什么是微服务？" class="headerlink" title="1.什么是微服务？"></a>1.什么是微服务？</h4><h4 id="2-分布式和集群的区别？"><a href="#2-分布式和集群的区别？" class="headerlink" title="2.分布式和集群的区别？"></a>2.分布式和集群的区别？</h4><blockquote><p>分布式是将不同的业务分布在不同的地方</p><p>集群指的是将几台服务器集中在一起，实现同一业务</p><p><img alt="分布式-集群" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230108213120.png"></p></blockquote><h3 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h3><h4 id="1-nacos-报错endpoint-is-blank"><a href="#1-nacos-报错endpoint-is-blank" class="headerlink" title="1.nacos 报错endpoint is blank"></a>1.nacos 报错endpoint is blank</h4><blockquote><p>解决：</p><p>在bootstrap.yml中添加</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&gt; spring:</span></span><br><span class="line"><span class="string">&gt;   application:</span></span><br><span class="line"><span class="string">&gt;     name: gulimall-coupon</span></span><br><span class="line"><span class="string">&gt;   cloud:</span></span><br><span class="line"><span class="string">&gt;     nacos:</span></span><br><span class="line"><span class="string">&gt;       config:</span></span><br><span class="line"><span class="string">&gt;         server-addr: localhost:8848</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>注意是nacos.config而不是nacos.discovery</p></blockquote><h2 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h2><h3 id="要点"><a href="#要点" class="headerlink" title="==要点=="></a>==要点==</h3><h4 id="1-项目中使用elasticsearch"><a href="#1-项目中使用elasticsearch" class="headerlink" title="1.项目中使用elasticsearch"></a>1.项目中使用elasticsearch</h4><p>不仅要把数据存到mysql中，还要存到es中，才能以后调用es的api进行检索</p><h4 id="2-使用typeReference封装接口"><a href="#2-使用typeReference封装接口" class="headerlink" title="2.使用typeReference封装接口"></a>2.使用typeReference封装接口</h4><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用fastjson进行反序列化</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getData</span><span class="params">(TypeReference&lt;T&gt; typeReference)</span> </span>&#123;</span><br><span class="line">    Object data = get(<span class="string">"data"</span>);<span class="comment">//默认是map</span></span><br><span class="line">    String jsonString = JSON.toJSONString(data);</span><br><span class="line">    T t = JSON.parseObject(jsonString, typeReference);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R skuHasStock = wareFeignService.getSkuHasStock(skuIdList);</span><br><span class="line"></span><br><span class="line">TypeReference&lt;List&lt;SkuHasStockVo&gt;&gt; typeReference = <span class="keyword">new</span> TypeReference&lt;List&lt;SkuHasStockVo&gt;&gt;() &#123;&#125;;</span><br><span class="line">stockMap = skuHasStock.getData(typeReference).stream()</span><br><span class="line">    .collect(Collectors.toMap(SkuHasStockVo::getSkuId, item -&gt; item.getHasStock()));</span><br></pre></td></tr></table></figure><h4 id="3-测试分布式场景"><a href="#3-测试分布式场景" class="headerlink" title="3.测试分布式场景"></a>3.测试分布式场景</h4><p>同一个应用在idea配置那边多复制几份，改下端口，然后运行即可。</p><h4 id="4-注意线程池配置"><a href="#4-注意线程池配置" class="headerlink" title="4.注意线程池配置"></a>4.注意线程池配置</h4><blockquote><p>放在这里的原因是注意这边的参数注入，学着点</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties</span>(ThreadPoolConfigProperties.class)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolExecutor <span class="title">threadPoolExecutor</span><span class="params">(ThreadPoolConfigProperties poolConfigProperties)</span></span>&#123;</span><br><span class="line">        <span class="comment">// poolConfigProperties这边就可以直接从配置文件中获取到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                poolConfigProperties.getCoreSize(),</span><br><span class="line">                poolConfigProperties.getMaxSize(),</span><br><span class="line">                poolConfigProperties.getKeepAliveTime(),</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">100000</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-feign远程请求丢失请求头"><a href="#5-feign远程请求丢失请求头" class="headerlink" title="5.feign远程请求丢失请求头"></a>5.feign远程请求丢失请求头</h4><p>原因：feign远程调用会创建一个全新的请求，从而丢失了请求头(后面可能导致丢失各种登录状态)</p><p><img alt="36" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230210212732.png"></p><p>解决</p><blockquote><p>在feign的RequestInterceptor中加上同步请求头就行了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuliFeignConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"requestInterceptor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestInterceptor <span class="title">requestInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RequestInterceptor requestInterceptor = <span class="keyword">new</span> RequestInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//1、使用RequestContextHolder拿到刚进来的请求数据</span></span><br><span class="line">                ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 主要同步cookie,</span></span><br><span class="line">                <span class="keyword">if</span> (requestAttributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//老请求</span></span><br><span class="line">                    HttpServletRequest request = requestAttributes.getRequest();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//2、同步请求头的数据（主要是cookie）</span></span><br><span class="line">                        String cookie = request.getHeader(<span class="string">"Cookie"</span>);</span><br><span class="line">                        <span class="comment">//把老请求的cookie值放到新请求上来，进行一个同步(注意这里是设置请求头，而不是localstorage)</span></span><br><span class="line">                        template.header(<span class="string">"Cookie"</span>, cookie);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> requestInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-feign异步调用丢失上下文信息"><a href="#6-feign异步调用丢失上下文信息" class="headerlink" title="6.feign异步调用丢失上下文信息"></a>6.feign异步调用丢失上下文信息</h4><blockquote><p>原因：这里主要是异步调用，异步调用会开启新线程，而新线程中没有请求数据</p><p>==说一下这里使用问题5中的RequestInterceptor拦截器为什么没有用？==</p><p>因为在cart和address异步线程中RequestContextHolder本来就没有相应的请求信息，所以后面同步cookie自然也没有用。</p><p>这个只有主线程请求进来的时候RequestContextHolder中才有请求信息。</p><p>所以要做的就是把主线程中RequestContextHolder的请求数据放到cart和address异步线程。</p></blockquote><p><img alt="37" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230210214712.png"></p><h4 id="7-幂等性"><a href="#7-幂等性" class="headerlink" title="==7.幂等性=="></a>==7.幂等性==</h4><blockquote><p>有文档</p></blockquote><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p><strong>接口幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的</strong></p><h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><p>用户多次点击按钮</p><p>用户页面回退再次提交</p><p>微服务互相调用，由于网络问题，导致请求失败。feign 触发重试机制</p><p>其他业务情况</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><h6 id="1-token机制"><a href="#1-token机制" class="headerlink" title="1.token机制"></a>1.token机制</h6><blockquote><p>前端传的token和redis的Token一样，就执行业务</p></blockquote><h6 id="2-锁机制"><a href="#2-锁机制" class="headerlink" title="2.锁机制"></a>2.锁机制</h6><p>乐观锁</p><p>悲观锁</p><p>业务层分布式锁</p><h6 id="3-各种唯一约束"><a href="#3-各种唯一约束" class="headerlink" title="3.各种唯一约束"></a>3.各种唯一约束</h6><p>数据库唯一约束</p><p>redis  set防重</p><h6 id="4-防重表"><a href="#4-防重表" class="headerlink" title="4.防重表"></a>4.防重表</h6><h6 id="5-全局请求唯一id"><a href="#5-全局请求唯一id" class="headerlink" title="5.全局请求唯一id"></a>5.全局请求唯一id</h6><h3 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h3><blockquote><p>有参考文档</p><p>可以快速地<strong>储存、搜索和分析</strong>海量数据</p></blockquote><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><blockquote><p>可参考</p><p><a href="https://blog.csdn.net/Vincent9847/article/details/118244167" target="_blank" rel="noopener">https://blog.csdn.net/Vincent9847/article/details/118244167</a></p></blockquote><p><img alt="11" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230115212116.png"></p><h5 id="1-index-索引-，"><a href="#1-index-索引-，" class="headerlink" title="1.index(索引)，"></a>1.index(索引)，</h5><p>动词，相当于 MySQL 中的 insert；</p><p>名词，相当于 MySQL 中的 Database</p><h5 id="2-type-类型-，类似于mysql的table"><a href="#2-type-类型-，类似于mysql的table" class="headerlink" title="2.type(类型)，类似于mysql的table"></a>2.type(类型)，类似于mysql的table</h5><h5 id="3-Document-文档-，相当于mysql表中的数据-行"><a href="#3-Document-文档-，相当于mysql表中的数据-行" class="headerlink" title="3.Document(文档)，相当于mysql表中的数据(行)"></a>3.Document(文档)，相当于mysql表中的数据(行)</h5><h5 id="4-倒排索引"><a href="#4-倒排索引" class="headerlink" title="==4.倒排索引=="></a>==4.倒排索引==</h5><p>ElasticSearch搜索为什么很快的原因</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><blockquote><p>参考文档</p></blockquote><p>改变权限</p><blockquote><p>chmod -R 777 /mydata/elasticsearch/ 保证权限</p><p>-R递归所有目录改变权限</p></blockquote><p>第一次启动ElasticSearch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e &quot;discovery.type=single-node&quot; \</span><br><span class="line">-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; \</span><br><span class="line">-v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-d elasticsearch:7.4.2</span><br><span class="line"></span><br><span class="line">9200是http请求接口，9300是分布式集群下的端口</span><br></pre></td></tr></table></figure><blockquote><p>docker update elasticsearch —restart=always</p></blockquote><p>第一次启动Kibana</p><blockquote><p>docker run —name kibana -e ELASTICSEARCH_HOSTS=<a href="http://192.168.56.108:9200" target="_blank" rel="noopener">http://192.168.56.108:9200</a> -p 5601:5601 -d kibana:7.4.2</p></blockquote><p>如果已启动过</p><blockquote><p>docker start 进程编号(部分即可)</p><p>参考文档</p></blockquote><p>增删改查+批量操作</p><p>批量测试数据地址</p><blockquote><p><a href="https://gitee.com/xlh_blog/common_content/blob/master/es%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE.json#" target="_blank" rel="noopener">https://gitee.com/xlh_blog/common_content/blob/master/es%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE.json#</a></p></blockquote><h4 id="高级检索"><a href="#高级检索" class="headerlink" title="高级检索"></a>高级检索</h4><blockquote><p>参考文档</p></blockquote><h5 id="1-SearchAPI"><a href="#1-SearchAPI" class="headerlink" title="1.SearchAPI"></a>1.SearchAPI</h5><blockquote><p>GET bank/_search?q=*&amp;sort=account_number:asc</p></blockquote><p>match,sort..</p><h5 id="2-Query-DSL"><a href="#2-Query-DSL" class="headerlink" title="2.Query DSL"></a>2.Query DSL</h5><blockquote><p>返回部分字段</p><p>匹配查询(match 只要匹配到任意一个单词，默认会分词)(address.keyword就可以匹配精确值(是全等))</p><p>短语匹配(全部匹配)</p><p>多字段匹配(<strong>multi_match</strong>，多个字段包含指定字符)</p><p>复合匹配(bool，这里面的条件必须都要满足(must,should,must_not)</p><p>==结果过滤(用在复合匹配中，filter查出结果后过滤，和Must区别就是不贡献相关性得分)==</p><p>term(多个就是terms)   和 match一样，匹配某个属性值，但推荐全文检索使用match，其他非text字段匹配使用term</p><p>nested用于存储复杂类型(对象)</p><p><strong>aggregations</strong>聚合分析结果(平均值，年龄段个数)，类似SQL的group by(求多个年龄段的平均薪资)</p></blockquote><h5 id="3-Mapping"><a href="#3-Mapping" class="headerlink" title="3.Mapping"></a>3.Mapping</h5><blockquote><p>可以类比mybatis</p><p>ElasticSearch默认会推断出所以的映射类型，但可以自己指定</p></blockquote><h5 id="4-分词"><a href="#4-分词" class="headerlink" title="4.分词"></a>4.分词</h5><blockquote><p>下载</p><p>wget <a href="https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.4.2/elasticsearch-analysis-ik-7.4.2.zip" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.4.2/elasticsearch-analysis-ik-7.4.2.zip</a></p><p>自定义分词</p><p>需要借助nginx，nginx安装参考附录</p></blockquote><h4 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h4><h5 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallElasticSearchConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RequestOptions COMMON_OPTIONS;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        RequestOptions.Builder builder = RequestOptions.DEFAULT.toBuilder();</span><br><span class="line">        <span class="comment">// builder.addHeader("Authorization", "Bearer " + TOKEN);</span></span><br><span class="line">        <span class="comment">// builder.setHttpAsyncResponseConsumerFactory(</span></span><br><span class="line">        <span class="comment">//         new HttpAsyncResponseConsumerFactory</span></span><br><span class="line">        <span class="comment">//                 .HeapBufferedResponseConsumerFactory(30 * 1024 * 1024 * 1024));</span></span><br><span class="line">        COMMON_OPTIONS = builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">esRestClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(</span><br><span class="line">                RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">"192.168.77.130"</span>, <span class="number">9200</span>, <span class="string">"http"</span>)));</span><br><span class="line">        <span class="keyword">return</span>  client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="DSL在java中的示例"><a href="#DSL在java中的示例" class="headerlink" title="==DSL在java中的示例=="></a>==DSL在java中的示例==</h5><p>见search服务中的MallSearchServiceImpl#buildSearchRequest</p><p>请看P173-192</p><h4 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h4><p>181P，分享一个自己遇到的问题：<br>问题：org.elasticsearch.ElasticsearchException: Elasticsearch exception [type=illegal_argument_exception, reason=Can’t load fielddata on 【brandName】 because fielddata is unsupported on fields of type 【keyword】. Use doc values instead.]</p><p>思路：出现该错误是因为ES5.x之后，对聚合所依据的字段用单独的数据结构(fielddata)缓存到内存里了，但是在text字段上默认是禁用的，如果有需要单独开启，这样做的目的是为了节省内存空间。<br>具体实现方法可以参考文档或者自行百度。</p><p>解决：在字段里加上keyword，例如：<br>.field(“brandName.keyword”)<br>.field(“brandImg.keyword”)<br>.field(“catalogName.keyword”)<br>.field(“attrs.attrName.keyword”)</p><h3 id="nginx"><a href="#nginx" class="headerlink" title="==nginx=="></a>==nginx==</h3><blockquote><p>1.保护了真实的web服务器</p><p>2.方便动静分离和负载均衡</p></blockquote><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><blockquote><p>详情见文档</p><p>1.随便启动一个 nginx 实例，只是为了复制出配置</p><p>docker run -p 80:80 —name nginx -d nginx:1.10</p><p>2.将容器内的配置文件拷贝到当前目录：docker container cp nginx:/etc/nginx . </p><p><strong>别忘了后面的点</strong></p><p>3.修改文件名称：mv nginx conf 把这个 conf 移动到/mydata/nginx 下</p><p>4.终止原容器：docker stop nginx</p><p>5.执行命令删除原容器：docker rm $ContainerId</p><p>6.创建新的 nginx；执行以下命令</p><p>启动</p><p>docker run -p 80:80 —name nginx -v /mydata/nginx/html:/usr/share/nginx/html -v /mydata/nginx/logs:/var/log/nginx -v /mydata/nginx/conf:/etc/nginx -d nginx:1.10</p></blockquote><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>详情</p><p><img alt="img" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230201212605.png"></p><h4 id="使用nginx反向代理"><a href="#使用nginx反向代理" class="headerlink" title="==使用nginx反向代理=="></a>==使用nginx反向代理==</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><img alt="img" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230201213548.png"></p><p>步骤：</p><p>1.用户访问gulimall.com(由于是本地测试，这边只是改了本地的hosts模仿DNS域名解析器)，发到nginx</p><p>==tips：记住不能挂VPN，否则DNS解析默认走代理服务器，不会走Hosts文件中配置的地址==</p><p>2.nginx监听gulimall.com这个域名，监听到请求就发给proxy_pass配置的后台服务器(这里配置的是网关，网关再转发给相应的服务器)</p><p>3.网关根据路由规则，匹配后台服务器</p><p>4.转到后台服务器调用接口。</p><h5 id="不改进"><a href="#不改进" class="headerlink" title="不改进"></a>不改进</h5><p>配置文件</p><p>conf.d/default.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  gulimall.com; # nginx监听客户端访问的域名(ip地址),然后根据下面配置的转发给相应的后台服务器</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    #access_log  /var/log/nginx/log/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://192.168.56.1:10000; # 转发给相应的服务器,这里是本机(不是虚拟机)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page /50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h5><p>==将转发的地址改为网关的地址==</p><p>nginx.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line">    upstream gulimall&#123; # 这里的gulimall和default.conf中对应</span><br><span class="line">        server 192.168.56.1:88; # 配置上游服务器的地址,即网关地址</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>conf.d/default.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  gulimall.com; # nginx监听客户端访问的域名(ip地址),然后根据下面配置的转发给相应的后台服务器</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    #access_log  /var/log/nginx/log/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">    proxy_set_header Host $host; # nginx给网关转发的时候会丢掉host,不补上识别不到,所以要加上</span><br><span class="line">        proxy_pass http://gulimall; # 默认转发给上游服务器(网关),之后再负载均衡的转给各个服务器</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page /50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网关的yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- id:</span> <span class="string">gulimall_host_route</span></span><br><span class="line"><span class="attr">uri:</span> <span class="attr">lb://gulimall-product</span></span><br><span class="line"><span class="attr">predicates:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Host=gulimall.com,item.gulimall.com</span></span><br></pre></td></tr></table></figure><h4 id="使用nginx实现动静分离"><a href="#使用nginx实现动静分离" class="headerlink" title="==使用nginx实现动静分离=="></a>==使用nginx实现动静分离==</h4><p>简单来说就是，静态资源不要放到后台服务器，这样会直接请求到tomcat，</p><p>而是应该把静态资源放到nginx，让用户去直接请求nginx得到这些静态资源，缓解后台tomcat的压力。</p><p><img alt="14" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230202162959.png"></p><p>在conf.d/gulimall.conf中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  gulimall.com; # nginx监听客户端访问的域名(ip地址),然后根据下面配置的转发给相应的后台服务器</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    #access_log  /var/log/nginx/log/host.access.log  main;</span><br><span class="line">    ##############################看这里##########################</span><br><span class="line">    location /static/&#123;</span><br><span class="line">    root /usr/share/nginx/html;  # 注意这边是nginx的/bin/bash里面的路径，而不是外头的路径</span><br><span class="line">    &#125;</span><br><span class="line">    ##############################看这里##########################</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">    proxy_set_header Host $host; # nginx给网关转发的时候会丢掉host,不补上识别不到,所以要加上</span><br><span class="line">        proxy_pass http://gulimall; # 默认转发给上游服务器(网关),之后再负载均衡的转给各个服务器</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page /50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p>TPS:系统每秒处理交易数，单位是笔/秒。</p><p>QPS:系统每秒处理查询次数，单位是次/秒</p><p>一般情况下：</p><p>金融行业：1000TPS~50000TPS，不包括互联网化的活动</p><p>保险行业：100TPS~100000TPS，不包括互联网化的活动</p><p>制造行业：10TPS~5000TPS</p><p>互联网电子商务：10000TPS~1000000TPS</p><p>互联网中型网站：1000TPS~50000TPS</p><p>互联网小型网站：500TPS~10000TPS</p><h4 id="Jemter工具"><a href="#Jemter工具" class="headerlink" title="Jemter工具"></a>Jemter工具</h4><p><a href="https://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">下载</a></p><p>具体使用见资料</p><h5 id="bug-1"><a href="#bug-1" class="headerlink" title="bug"></a>bug</h5><p>报错：<strong>JMeter Address Already in use</strong></p><blockquote><p>windows 本身提供的端口访问机制的问题。</p><p>Windows 提供给 TCP/IP 链接的端口为 1024-5000，并且要四分钟来循环回收他们。就导致</p><p>我们在短时间内跑大量的请求时将端口占满了。</p><p>1.cmd 中，用 regedit 命令打开注册表</p><p>2.在 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters 下，</p><p>1 .右击 parameters，添加一个新的 DWORD，名字为 MaxUserPort</p><p>2 .然后双击 MaxUserPort，输入数值数据为 65534，基数选择十进制（如果是分布式运</p><p>行的话，控制机器和负载机器都需要这样操作哦）</p><ol><li>修改配置完毕之后记得重启机器才会生效</li></ol><p><a href="https://support.microsoft.com/zh-cn/help/196271/when-you-try-to-connect-from-tcp-ports-grea" target="_blank" rel="noopener">https://support.microsoft.com/zh-cn/help/196271/when-you-try-to-connect-from-tcp-ports-grea</a></p><p>ter-than-5000-you-receive-t</p><p>TCPTimedWaitDelay：30</p></blockquote><h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><h4 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h4><p>jvisualvm是升级版的jconsole，所以一般都使用jvisualvm，Jmeter压测配合jvisualvm观察</p><p>==下图是课上压测的结果==</p><p><img alt="13" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230202155547.png"></p><p>==结论(优化方向)==：</p><p>中间件越多，性能损失越大，大多都损失在网络交互了；</p><p>业务：</p><p>​    Db（MySQL 优化）</p><p>​    模板的渲染速度（缓存）</p><p>​    静态资源</p><h3 id="缓存与分布式锁-Redis"><a href="#缓存与分布式锁-Redis" class="headerlink" title="==缓存与分布式锁(Redis)=="></a>==缓存与分布式锁(Redis)==</h3><p>使用redis做分布式缓存架构图</p><p><img alt="img" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230202181916.png"></p><h4 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h4><blockquote><p>安装</p><p>docker pull redis</p><p>配置</p><p>mkdir -p /mydata/redis/conf</p><p>touch /mydata/redis/conf/redis.conf</p><p>启动</p><p>docker run -p 6379:6379 —name redis -v /mydata/redis/data:/data -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf</p><p>设置开机自动启动</p><p>docker update redis —restart=always</p><p>以redis-cli进入内部</p><p>docker exec -it redis redis-cli</p></blockquote><h4 id="SpringBoot整合-1"><a href="#SpringBoot整合-1" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h4><p>导入依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引入redis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">lettuce会产生堆外内存溢出OutOfDirectMemoryError:</span><br><span class="line">//1)、springboot2.0以后默认使用lettuce操作redis的客户端，它使用通信</span><br><span class="line">//2)、lettuce的bug导致netty堆外内存溢出   可设置：-Dio.netty.maxDirectMemory</span><br><span class="line">//解决方案：不能直接使用-Dio.netty.maxDirectMemory去调大堆外内存</span><br><span class="line">//1)、升级lettuce客户端。      2）、切换使用jedis</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line"><span class="attr">        host:</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.108</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><p>注入StringRedisTemplate进行使用</p><h4 id="本地锁"><a href="#本地锁" class="headerlink" title="本地锁"></a>本地锁</h4><p>synchronized，juc(lock)只能锁住当前进程，在分布式场景下想要锁住所有的必须使用分布式锁</p><p><img alt="15" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230202201550.png"></p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>原理图</p><p><img alt="16" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230202203300.png"></p><p>==实现过程中有好多坑，详细可以看资料图以及视频P158==</p><p>代码</p><p>==获取锁和设置过期时间必须是原子操作，否则很可能会有并发问题==</p><p>==删除锁+判断锁也是要原子操作(使用lua脚本)==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据库查询并封装数据::分布式锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatalogJsonFromDbWithRedisLock() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、占分布式锁。去redis占坑      设置过期时间必须和加锁是同步的，保证原子性（避免死锁）</span></span><br><span class="line">    String uuid = UUID.randomUUID().toString();</span><br><span class="line">    Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(<span class="string">"lock"</span>, uuid,<span class="number">300</span>,TimeUnit.SECONDS);<span class="comment">// 相当于setnxex</span></span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        System.out.println(<span class="string">"获取分布式锁成功..."</span>);</span><br><span class="line">        Map&lt;String, List&lt;Catelog2Vo&gt;&gt; dataFromDb = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//加锁成功...执行业务</span></span><br><span class="line">            dataFromDb = getDataFromDb();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 使用Lua脚本</span></span><br><span class="line">            String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//删除锁</span></span><br><span class="line">            stringRedisTemplate.execute(<span class="keyword">new</span> DefaultRedisScript&lt;Long&gt;(script, Long.class), Arrays.asList(<span class="string">"lock"</span>), uuid);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先去redis查询下保证当前的锁是自己的</span></span><br><span class="line">        <span class="comment">//获取值对比，对比成功删除=原子性 lua脚本解锁</span></span><br><span class="line">        <span class="comment">// String lockValue = stringRedisTemplate.opsForValue().get("lock");</span></span><br><span class="line">        <span class="comment">// if (uuid.equals(lockValue)) &#123;</span></span><br><span class="line">        <span class="comment">//     //删除我自己的锁</span></span><br><span class="line">        <span class="comment">//     stringRedisTemplate.delete("lock");</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dataFromDb;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"获取分布式锁失败...等待重试..."</span>);</span><br><span class="line">        <span class="comment">//加锁失败...重试机制</span></span><br><span class="line">        <span class="comment">//休眠一百毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        <span class="keyword">return</span> getCatalogJsonFromDbWithRedisLock();     <span class="comment">//自旋的方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Redisson实现分布式锁"><a href="#使用Redisson实现分布式锁" class="headerlink" title="使用Redisson实现分布式锁"></a>使用Redisson实现分布式锁</h4><blockquote><p>一个实现了分布式锁的框架，包括所有JUC锁的分布式版</p></blockquote><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedissonConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有对Redisson的使用都是通过RedissonClient</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(destroyMethod=<span class="string">"shutdown"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redisson</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1、创建配置</span></span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">"redis://192.168.56.108:6379"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、根据Config创建出RedissonClient实例</span></span><br><span class="line">        <span class="comment">//Redis url should start with redis:// or rediss://</span></span><br><span class="line">        RedissonClient redissonClient = Redisson.create(config);</span><br><span class="line">        <span class="keyword">return</span> redissonClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="阻塞锁Rlock测试"><a href="#阻塞锁Rlock测试" class="headerlink" title="阻塞锁Rlock测试"></a>阻塞锁Rlock测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、获取一把锁，只要锁的名字一样，就是同一把锁</span></span><br><span class="line">    RLock myLock = redisson.getLock(<span class="string">"my-lock"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、加锁</span></span><br><span class="line">    myLock.lock();      <span class="comment">//阻塞式等待。默认加的锁都是30s</span></span><br><span class="line">    <span class="comment">//1）、锁的自动续期，如果业务超长，运行期间自动锁上新的30s。不用担心业务时间长，锁自动过期被删掉</span></span><br><span class="line">    <span class="comment">//2）、加锁的业务只要运行完成，就不会给当前锁续期，即使不手动解锁，锁默认会在30s内自动过期，不会产生死锁问题</span></span><br><span class="line">    <span class="comment">// myLock.lock(10,TimeUnit.SECONDS);   //10秒钟自动解锁,自动解锁时间一定要大于业务执行时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//问题：在锁时间到了以后，不会自动续期</span></span><br><span class="line">    <span class="comment">//1、如果我们传递了锁的超时时间，就发送给redis执行脚本，进行占锁，默认超时就是 我们制定的时间  myLock.lock(10,TimeUnit.SECONDS);   </span></span><br><span class="line">    <span class="comment">//2、如果我们未指定锁的超时时间，就使用 lockWatchdogTimeout = 30 * 1000 【看门狗默认时间】   myLock.lock(); </span></span><br><span class="line">    <span class="comment">//只要占锁成功，就会启动一个定时任务【重新给锁设置过期时间，新的过期时间就是看门狗的默认时间】,每隔10秒都会自动的再次续期，续成30秒</span></span><br><span class="line">    <span class="comment">// internalLockLeaseTime 【看门狗时间】 / 3， 10s</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最佳实践:省去了看门狗机制,手动指定大一点的超时时间</span></span><br><span class="line">    <span class="comment">// myLock.lock(30,TimeUnit.SECONDS); </span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"加锁成功，执行业务..."</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">20</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3、解锁  假设解锁代码没有运行，Redisson会不会出现死锁</span></span><br><span class="line">        System.out.println(<span class="string">"释放锁..."</span> + Thread.currentThread().getId());</span><br><span class="line">        myLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==重要==</p><p>redisson</p><p>1）、==锁的自动续期==，如果业务超长，运行期间自动锁上新的30s。不用担心业务时间长，锁自动过期被删掉<br>2）、加锁的业务只要运行完成，就不会给当前锁续期，即使不手动解锁，锁默认会在30s内自动过期，不会产生死锁问题</p><h5 id="读写锁RReadWriteLock测试"><a href="#读写锁RReadWriteLock测试" class="headerlink" title="读写锁RReadWriteLock测试"></a>读写锁RReadWriteLock测试</h5><blockquote><p>改数据加写锁，读数据加读锁(操作系统中读写者问题)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保证一定能读到最新数据，修改期间，写锁是一个排它锁（互斥锁、独享锁），读锁是一个共享锁</span></span><br><span class="line"><span class="comment">     * 写锁没释放读锁必须等待</span></span><br><span class="line"><span class="comment">     * 读 + 读 ：相当于无锁，并发读，只会在Redis中记录好，所有当前的读锁。他们都会同时加锁成功</span></span><br><span class="line"><span class="comment">     * 写 + 读 ：必须等待写锁释放</span></span><br><span class="line"><span class="comment">     * 写 + 写 ：阻塞方式</span></span><br><span class="line"><span class="comment">     * 读 + 写 ：有读锁。写也需要等待</span></span><br><span class="line"><span class="comment">     * 只要有读或者写的存都必须等待</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/write"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">writeValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">""</span>;</span><br><span class="line">    RReadWriteLock readWriteLock = redisson.getReadWriteLock(<span class="string">"rw-lock"</span>);</span><br><span class="line">    RLock rLock = readWriteLock.writeLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1、改数据加写锁，读数据加读锁</span></span><br><span class="line">        rLock.lock();</span><br><span class="line">        s = UUID.randomUUID().toString();</span><br><span class="line">        ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();</span><br><span class="line">        ops.set(<span class="string">"writeValue"</span>,s);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/read"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">""</span>;</span><br><span class="line">    RReadWriteLock readWriteLock = redisson.getReadWriteLock(<span class="string">"rw-lock"</span>);</span><br><span class="line">    <span class="comment">//加读锁</span></span><br><span class="line">    RLock rLock = readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        rLock.lock();</span><br><span class="line">        ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();</span><br><span class="line">        s = ops.get(<span class="string">"writeValue"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">10</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="信号量Semaphore测试"><a href="#信号量Semaphore测试" class="headerlink" title="信号量Semaphore测试"></a>信号量Semaphore测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 车库停车</span></span><br><span class="line"><span class="comment"> * 3车位</span></span><br><span class="line"><span class="comment"> * 信号量也可以做分布式限流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/park"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">park</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    RSemaphore park = redisson.getSemaphore(<span class="string">"park"</span>);</span><br><span class="line">    park.acquire();     <span class="comment">//获取一个信号、获取一个值,占一个车位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = park.tryAcquire();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;<span class="comment">// 成功获取到锁</span></span><br><span class="line">        <span class="comment">//执行业务</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ok=&gt;"</span> + flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/go"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RSemaphore park = redisson.getSemaphore(<span class="string">"park"</span>);</span><br><span class="line">    park.release();     <span class="comment">//释放一个车位</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="闭锁CountDownLatch测试"><a href="#闭锁CountDownLatch测试" class="headerlink" title="闭锁CountDownLatch测试"></a>闭锁CountDownLatch测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 放假、锁门</span></span><br><span class="line"><span class="comment"> * 1班没人了</span></span><br><span class="line"><span class="comment"> * 5个班，全部走完，我们才可以锁大门</span></span><br><span class="line"><span class="comment"> * 分布式闭锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/lockDoor"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">lockDoor</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    RCountDownLatch door = redisson.getCountDownLatch(<span class="string">"door"</span>);</span><br><span class="line">    door.trySetCount(<span class="number">5</span>);</span><br><span class="line">    door.await();       <span class="comment">//等待闭锁完成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"放假了..."</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/gogogo/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">gogogo</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">    RCountDownLatch door = redisson.getCountDownLatch(<span class="string">"door"</span>);</span><br><span class="line">    door.countDown();       <span class="comment">//计数-1</span></span><br><span class="line">    <span class="keyword">return</span> id + <span class="string">"班的人都走了..."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存数据库一致性问题"><a href="#缓存数据库一致性问题" class="headerlink" title="缓存数据库一致性问题"></a>缓存数据库一致性问题</h4><h5 id="双写模式"><a href="#双写模式" class="headerlink" title="双写模式"></a>双写模式</h5><p><img alt="17" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230204202833.png"></p><h5 id="失效模式"><a href="#失效模式" class="headerlink" title="失效模式"></a>失效模式</h5><p><img alt="18" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230204203036.png"></p><h5 id="都会有脏数据问题-解决方案"><a href="#都会有脏数据问题-解决方案" class="headerlink" title="都会有脏数据问题(解决方案)"></a>都会有脏数据问题(解决方案)</h5><p>1、对于并发几率很小的数据(如个人维度的订单数据、用户数据等)，这种几乎不用考虑这个问题，很少会发生缓存不一致，可以给缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。</p><p>2、就算并发很高，如果业务上能容忍短时间的缓存数据不一致(如商品名称，商品分类菜单等)，缓存加上过期时间依然可以解决大部分业务对于缓存的要求。</p><p>3、如果不能容忍缓存数据不一致，可以通过加<strong>读写锁</strong>保证并发读写或写写的时候按顺序排好队，<strong>读读的时候相当于无锁</strong>。</p><p>4、也可以用阿里开源的canal通过监听数据库的binlog日志及时的去修改缓存，但是引入了新的中间件，增加了系统的复杂度。</p><p><img alt="19" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230204203615.png"></p><p><strong>总结：</strong></p><p>以上我们针对的都是<strong>读多写少</strong>的情况加入缓存提高性能，如果<strong>写多读多</strong>的情况又不能容忍缓存数据不一致，那就没必要加缓存了，可以直接操作数据库。放入缓存的数据应该是对实时性、一致性要求不是很高的数据。切记不要为了用缓存，同时又要保证绝对的一致性做大量的过度设计和控制，增加系统复杂性！</p><h3 id="SpringCache"><a href="#SpringCache" class="headerlink" title="SpringCache"></a>SpringCache</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>SpringCache是用来整合缓存的框架，==简化缓存判断操作==</p><p><img alt="20" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230204210113.png"></p><p>Cache 接口为缓存的组件规范定义，包含缓存的各种操作集合；Cache 接 口 下 Spring 提 供 了 各 种 xxxCache 的 实 现 ； 如 RedisCache ， EhCacheCache , </p><p>ConcurrentMapCache 等；</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置类上配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallProductApplication</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>yml中设置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    cache:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">      <span class="comment"># 下面的配置可选</span></span><br><span class="line">      <span class="attr">redis:</span></span><br><span class="line"><span class="attr">          time-to-live:</span> <span class="number">3600000</span></span><br><span class="line">          <span class="comment"># 如果指定了前缀就用我们指定的前缀，如果没有就默认使用缓存的名字(Value)作为前缀</span></span><br><span class="line"><span class="attr">          key-prefix:</span> <span class="string">CHCHE_</span></span><br><span class="line"><span class="attr">          use-key-prefix:</span> <span class="literal">true</span></span><br><span class="line">          <span class="comment"># 是否缓存空值,防止缓存穿透</span></span><br><span class="line"><span class="attr">          cache-null-values:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><p><img alt="21" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230204210737.png"></p><h5 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h5><p>细节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1.每一个需要缓存的数据我们都来指定要放到那个名字的缓存。【缓存的分区(按照业务类型分)】</span><br><span class="line">2.代表当前方法的结果需要缓存，如果缓存中有，方法都不用调用，如果缓存中没有，会调用方法。最后将方法的结果放入缓存</span><br><span class="line">3.默认行为</span><br><span class="line">     如果缓存中有，方法不再调用</span><br><span class="line">      key是默认生成的:     缓存的名字(即设置的value值)::SimpleKey::[](自动生成key值)</span><br><span class="line">      缓存的value值，默认使用jdk序列化机制，将序列化的数据存到redis中</span><br><span class="line">      默认时间是 -1：</span><br><span class="line"></span><br><span class="line">   自定义操作：key的生成</span><br><span class="line">      指定生成缓存的key：key属性指定，接收一个Spel</span><br><span class="line">      指定缓存的数据的存活时间:配置文档中修改存活时间</span><br><span class="line">      将数据保存为json格式 :</span><br><span class="line">          容器中没有RedisCacheConfiguration就用默认的配置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 4、Spring-Cache的不足之处：</span><br><span class="line">  1）、读模式</span><br><span class="line">      缓存穿透：查询一个null数据。解决方案：缓存空数据</span><br><span class="line">      缓存击穿：大量并发进来同时查询一个正好过期的数据。解决方案：加锁 ? 默认是无加锁的;使用sync = true来解决击穿问题</span><br><span class="line">      缓存雪崩：大量的key同时过期。解决：加随机时间。加上过期时间</span><br><span class="line">  2)、写模式：（缓存与数据库一致）</span><br><span class="line">      1）、读写加锁。</span><br><span class="line">      2）、引入Canal,感知到MySQL的更新去更新Redis</span><br><span class="line">      3）、读多写多，直接去数据库查询就行</span><br><span class="line"> </span><br><span class="line">  总结：</span><br><span class="line">      常规数据（读多写少，即时性，一致性要求不高的数据，完全可以使用Spring-Cache）：写模式(只要缓存的数据有过期时间就足够了)</span><br><span class="line">      特殊数据：特殊设计</span><br><span class="line"></span><br><span class="line">  原理：</span><br><span class="line">      CacheManager(RedisCacheManager)-&gt;Cache(RedisCache)-&gt;Cache负责缓存的读写</span><br></pre></td></tr></table></figure><p>实际使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(value = &#123;<span class="string">"category"</span>&#125;,key = <span class="string">"#root.method.name"</span>,sync = <span class="keyword">true</span>)</span><br><span class="line"><span class="comment">// 第一次执行下面方法，并把返回值放入缓存,第二次缓存中有值，就不用走下面方法</span></span><br><span class="line"><span class="comment">// redis中存的key就是上面value和key的结合,sync=true用于解决缓存击穿加锁</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;CategoryEntity&gt; <span class="title">getLevel1Categorys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"getLevel1Categorys........"</span>);</span><br><span class="line">    <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">    List&lt;CategoryEntity&gt; categoryEntities = <span class="keyword">this</span>.baseMapper.selectList(</span><br><span class="line">            <span class="keyword">new</span> QueryWrapper&lt;CategoryEntity&gt;().eq(<span class="string">"parent_cid"</span>, <span class="number">0</span>));</span><br><span class="line">    System.out.println(<span class="string">"消耗时间："</span>+ (System.currentTimeMillis() - l));</span><br><span class="line">    <span class="keyword">return</span> categoryEntities;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义数据(key和value)在redis中的保存形式(这边自定义为json)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties</span>(CacheProperties.class)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCacheConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCacheConfiguration <span class="title">redisCacheConfiguration</span><span class="params">(CacheProperties cacheProperties)</span> </span>&#123;</span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line">        config = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> StringRedisSerializer()))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer()));</span><br><span class="line">        CacheProperties.Redis redisProperties = cacheProperties.getRedis();</span><br><span class="line">        <span class="comment">//将配置文件中所有的配置都生效</span></span><br><span class="line">        <span class="keyword">if</span> (redisProperties.getTimeToLive() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            config = config.entryTtl(redisProperties.getTimeToLive());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (redisProperties.getKeyPrefix() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            config = config.prefixKeysWith(redisProperties.getKeyPrefix());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!redisProperties.isCacheNullValues()) &#123;</span><br><span class="line">            config = config.disableCachingNullValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!redisProperties.isUseKeyPrefix()) &#123;</span><br><span class="line">            config = config.disableKeyPrefix();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h5><p>缓存数据库一致性中的删除模式使用这个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheEvict</span>(value = <span class="string">"category"</span>,allEntries = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><h5 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h5><p>适用于双写模式，更新缓存</p><h5 id="Caching"><a href="#Caching" class="headerlink" title="@Caching"></a>@Caching</h5><p>用于组合缓存注解，比如下面方法结束后，从redis中删除多个缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Caching</span>(evict = &#123;</span><br><span class="line">        <span class="meta">@CacheEvict</span>(value = <span class="string">"category"</span>,key = <span class="string">"'getLevel1Categorys'"</span>),</span><br><span class="line">        <span class="meta">@CacheEvict</span>(value = <span class="string">"category"</span>,key = <span class="string">"'getCatalogJson'"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>删除指定某个分区也能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheEvict</span>(value = <span class="string">"category"</span>,allEntries = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><h5 id="读模式"><a href="#读模式" class="headerlink" title="读模式"></a>读模式</h5><p>缓存穿透：解决-缓存空数据(cache-null-values=true)</p><p>缓存击穿：解决-加锁(只准有一个线程进入mysql)？@Cacheable(sync=true)</p><p>缓存雪崩：解决-随机过期时间</p><h5 id="写模式-缓存数据库不一致"><a href="#写模式-缓存数据库不一致" class="headerlink" title="写模式(缓存数据库不一致)"></a>写模式(缓存数据库不一致)</h5><p>读写加锁(读写锁)</p><p>引入canal，感知mysql的Binlog更新去更新数据库</p><p>读多写多，直接去查数据库</p><h3 id="异步"><a href="#异步" class="headerlink" title="==异步=="></a>==异步==</h3><p>3种方式创建线程</p><p>Thread,Runnable,Callable</p><p>此外还有线程池，使用线程池可以降低资源消耗，有效管理线程。</p><h4 id="CompletableFuture异步编排"><a href="#CompletableFuture异步编排" class="headerlink" title="CompletableFuture异步编排"></a>CompletableFuture异步编排</h4><blockquote><p>详细见文档</p></blockquote><p>不同的异步任务可能存在关联 ，就需要用到异步编排，类似前端的promise</p><blockquote><p><strong>方法不以</strong> <strong>Async</strong> <strong>结尾，意味着</strong> <strong>Action</strong> <strong>使用相同的线程执行，而</strong> <strong>Async</strong> <strong>可能会使用其他线程</strong></p><p><strong>执行（如果是使用相同的线程池，也可能会被同一个线程选中执行）</strong></p></blockquote><h5 id="初步使用-1"><a href="#初步使用-1" class="headerlink" title="初步使用"></a>初步使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">    <span class="number">20</span>,</span><br><span class="line">    <span class="number">100</span>,</span><br><span class="line">    <span class="number">10L</span>,</span><br><span class="line">    TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="number">10000</span>),</span><br><span class="line">    Executors.defaultThreadFactory(),</span><br><span class="line">    <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 没返回值</span></span><br><span class="line">CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"运行结果："</span> + i);</span><br><span class="line">&#125;,executor);</span><br><span class="line"><span class="comment">// 有返回值</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"运行结果："</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor);</span><br><span class="line"></span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure><h5 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h5><blockquote><p>whenComplete:方法执行完，不管成没成功都会调用</p><p>exceptionally:发生异常调用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"运行结果："</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor).whenComplete((res,exception)-&gt;&#123;<span class="comment">// 不管完没完成都会调用,相当于finally</span></span><br><span class="line">    <span class="comment">// 不能处理返回结果</span></span><br><span class="line">    System.out.println(<span class="string">"异步任务成功完成了...结果是："</span> + res + <span class="string">"异常是："</span> + exception);</span><br><span class="line">&#125;).exceptionally((throwable -&gt; &#123;<span class="comment">// 异常调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h5 id="handle"><a href="#handle" class="headerlink" title="handle()"></a>handle()</h5><blockquote><p>用于方法执行成功后处理</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"运行结果："</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor).handle((result,thr) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (thr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"异步任务成功完成了...结果是："</span> + result + <span class="string">"异常是："</span> + thr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h5><blockquote><p>业务场景：A执行完再执行B</p><p>thenApply 方法：当一个线程依赖另一个线程时，获取上一个任务返回的结果，并返回当前任务的返回值。(能接受上一步结果，有返回值)</p><p>thenAccept 方法：消费处理结果。接收任务的处理结果，并消费处理，无返回结果。(能接受上一步结果，但是无返回值)</p><p>thenRun 方法：只要上面的任务执行完成，就开始执行 thenRun，只是处理完任务后，执行thenRun 的后续操作（不能获取上一步的执行结果）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"运行结果："</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor).thenAccept((res)-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="number">11</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//                .thenApplyAsync(res -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("任务2启动了..." + res);</span></span><br><span class="line"><span class="comment">//            return "Hello" + res;</span></span><br><span class="line"><span class="comment">//        &#125;, executor);</span></span><br></pre></td></tr></table></figure><h5 id="两个任务都要完成"><a href="#两个任务都要完成" class="headerlink" title="两个任务都要完成"></a>两个任务都要完成</h5><blockquote><p>两个任务都完成，再执行后面的</p><p>thenCombine：组合两个 future，获取两个 future 的返回结果，并返回当前任务的返回值</p><p>thenAcceptBoth：组合两个 future，获取两个 future 任务的返回结果，然后处理任务，没有返回值。</p><p>runAfterBoth：组合两个 future，不需要获取 future 的结果，只需两个 future 处理完任务后，处理该任务。</p><p><strong>方法不以</strong> <strong>Async</strong> <strong>结尾，意味着</strong> <strong>Action</strong> <strong>使用相同的线程执行，而</strong> <strong>Async</strong> <strong>可能会使用其他线程</strong></p><p><strong>执行（如果是使用相同的线程池，也可能会被同一个线程选中执行）</strong></p><p>使用方法同上面的回调方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"运行结果："</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"当前线程2："</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"运行结果2："</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor);</span><br><span class="line">future1.runAfterBothAsync(future2,()-&gt;&#123;<span class="comment">// 这个任务是两个任务都执行完再执行的任务</span></span><br><span class="line">    System.out.println(<span class="string">"任务三"</span>);</span><br><span class="line">&#125;,executor);</span><br><span class="line">future1.thenAcceptBothAsync(future2,(res1,res2)-&gt;&#123;<span class="comment">// 这个任务是两个任务都执行完再执行的任务</span></span><br><span class="line">    System.out.println(res1+<span class="string">"："</span>+res2);</span><br><span class="line">&#125;,executor);</span><br></pre></td></tr></table></figure><h5 id="两个任务只要一个完成"><a href="#两个任务只要一个完成" class="headerlink" title="两个任务只要一个完成"></a>两个任务只要一个完成</h5><blockquote><p>applyToEither：两个任务有一个执行完成，获取它的返回值，处理任务并有新的返回值。</p><p>acceptEither：两个任务有一个执行完成，获取它的返回值，处理任务，没有新的返回值。</p><p>runAfterEither：两个任务有一个执行完成，不需要获取 future 的结果，处理任务，也没有返回值。</p><p><strong>方法不以</strong> <strong>Async</strong> <strong>结尾，意味着</strong> <strong>Action</strong> <strong>使用相同的线程执行，而</strong> <strong>Async</strong> <strong>可能会使用其他线程</strong></p><p><strong>执行（如果是使用相同的线程池，也可能会被同一个线程选中执行）</strong></p></blockquote><h5 id="多任务组合"><a href="#多任务组合" class="headerlink" title="多任务组合"></a>多任务组合</h5><blockquote><p>allOf：等待所有任务完成</p><p>anyOf：只要有一个任务完成</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"运行结果："</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"当前线程2："</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"运行结果2："</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; future3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"当前线程3："</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"运行结果3："</span> + i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor);</span><br><span class="line">CompletableFuture&lt;Void&gt; allOf = CompletableFuture.allOf(future1, future2, future3);</span><br><span class="line">allOf.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">//CompletableFuture&lt;Object&gt; anyOf = CompletableFuture.anyOf(future1, future2, future3);</span></span><br><span class="line"><span class="comment">//System.out.println("end"+anyOf.get());</span></span><br></pre></td></tr></table></figure><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>代码在product服务的SkuInfoServiceImpl类中</p><h3 id="认证服务"><a href="#认证服务" class="headerlink" title="认证服务"></a>认证服务</h3><h4 id="简单登录逻辑"><a href="#简单登录逻辑" class="headerlink" title="简单登录逻辑"></a>简单登录逻辑</h4><h5 id="验证码-令牌机制"><a href="#验证码-令牌机制" class="headerlink" title="验证码(令牌机制)"></a>验证码(令牌机制)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/sms/sendCode"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">sendCode</span><span class="params">(@RequestParam(<span class="string">"phone"</span>)</span> String phone) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、接口防刷</span></span><br><span class="line">    String redisCode = stringRedisTemplate.opsForValue().get(AuthServerConstant.SMS_CODE_CACHE_PREFIX + phone);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(redisCode)) &#123;</span><br><span class="line">        <span class="comment">//活动存入redis的时间，用当前时间减去存入redis的时间，判断用户手机号是否在60s内发送验证码</span></span><br><span class="line">        <span class="keyword">long</span> currentTime = Long.parseLong(redisCode.split(<span class="string">"_"</span>)[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() - currentTime &lt; <span class="number">60000</span>) &#123;</span><br><span class="line">            <span class="comment">//60s内不能再发</span></span><br><span class="line">            <span class="keyword">return</span> R.error(BizCodeEnum.SMS_CODE_EXCEPTION.getCode(),BizCodeEnum.SMS_CODE_EXCEPTION.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、验证码的再次效验 redis.存key-phone,value-code</span></span><br><span class="line">    <span class="keyword">int</span> code = (<span class="keyword">int</span>) ((Math.random() * <span class="number">9</span> + <span class="number">1</span>) * <span class="number">100000</span>);</span><br><span class="line">    String codeNum = String.valueOf(code);</span><br><span class="line">    String redisStorage = codeNum + <span class="string">"_"</span> + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存入redis，防止同一个手机号在60秒内再次发送验证码</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(AuthServerConstant.SMS_CODE_CACHE_PREFIX+phone,</span><br><span class="line">                                          redisStorage,<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这边是测试所以就不真正发了</span></span><br><span class="line">    <span class="comment">// 调用第三方接口发送</span></span><br><span class="line">    <span class="comment">//        thirdPartFeignService.sendCode(phone, codeNum);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span> 重定向携带数据：利用session原理，将数据放在session中。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span> 只要跳转到下一个页面取出这个数据以后，session里面的数据就会删掉</span></span><br><span class="line"><span class="comment">     * TODO：分布下session问题</span></span><br><span class="line"><span class="comment">     * RedirectAttributes：重定向也可以保留数据，不会丢失</span></span><br><span class="line"><span class="comment">     * 用户注册</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@PostMapping</span>(value = <span class="string">"/register"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">(@Valid UserRegisterVo vos, BindingResult result,</span></span></span><br><span class="line"><span class="function"><span class="params">                       RedirectAttributes attributes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果有错误回到注册页面</span></span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">        Map&lt;String, String&gt; errors = result.getFieldErrors().stream().collect(Collectors.toMap(FieldError::getField, FieldError::getDefaultMessage));</span><br><span class="line">        attributes.addFlashAttribute(<span class="string">"errors"</span>,errors);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//效验出错回到注册页面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:http://auth.gulimall.com/reg.html"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、效验验证码</span></span><br><span class="line">    String code = vos.getCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取存入Redis里的验证码</span></span><br><span class="line">    String redisCode = stringRedisTemplate.opsForValue().get(AuthServerConstant.SMS_CODE_CACHE_PREFIX + vos.getPhone());</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(redisCode)) &#123;</span><br><span class="line">        <span class="comment">//截取字符串</span></span><br><span class="line">        <span class="keyword">if</span> (code.equals(redisCode.split(<span class="string">"_"</span>)[<span class="number">0</span>])) &#123;<span class="comment">// 传入的验证码正确</span></span><br><span class="line">            <span class="comment">//删除验证码;令牌机制</span></span><br><span class="line">            stringRedisTemplate.delete(AuthServerConstant.SMS_CODE_CACHE_PREFIX+vos.getPhone());</span><br><span class="line">            <span class="comment">//验证码通过，真正注册，调用远程服务进行注册</span></span><br><span class="line">            R register = memberFeignService.register(vos);</span><br><span class="line">            <span class="keyword">if</span> (register.getCode() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"redirect:http://auth.gulimall.com/login.html"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//失败</span></span><br><span class="line">                Map&lt;String, String&gt; errors = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                errors.put(<span class="string">"msg"</span>, register.getData(<span class="string">"msg"</span>,<span class="keyword">new</span> TypeReference&lt;String&gt;()&#123;&#125;));</span><br><span class="line">                attributes.addFlashAttribute(<span class="string">"errors"</span>,errors);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"redirect:http://auth.gulimall.com/reg.html"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//效验出错回到注册页面</span></span><br><span class="line">            Map&lt;String, String&gt; errors = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            errors.put(<span class="string">"code"</span>,<span class="string">"验证码错误"</span>);</span><br><span class="line">            attributes.addFlashAttribute(<span class="string">"errors"</span>,errors);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"redirect:http://auth.gulimall.com/reg.html"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//效验出错回到注册页面</span></span><br><span class="line">        Map&lt;String, String&gt; errors = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        errors.put(<span class="string">"code"</span>,<span class="string">"验证码错误"</span>);</span><br><span class="line">        attributes.addFlashAttribute(<span class="string">"errors"</span>,errors);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:http://auth.gulimall.com/reg.html"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="社交登录"><a href="#社交登录" class="headerlink" title="社交登录"></a>社交登录</h4><blockquote><p>使用第三方账号登录</p><p>通过访问令牌，只能访问获得公共的信息</p></blockquote><p>使用OAuth2.0原理图</p><p><img alt="22" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230207210459.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.用户点击社交登录</span></span><br><span class="line"><span class="comment">// 2.跳转到微博授权页面</span></span><br><span class="line"><span class="comment">// 3.微博返回授权页面(code在这边返回)</span></span><br><span class="line"><span class="comment">// 4.用户输入账号密码授权</span></span><br><span class="line"><span class="comment">// 5.跳转到微博进行登录</span></span><br><span class="line"><span class="comment">// 6.微博远程登录成功,返回会获得code,然后用code可以换取token(这里对应图中的第四步)</span></span><br><span class="line"><span class="comment">// 7.本地服务登录：查看是否是第一次登录(是否有账号),若没账号,还要走注册流程(在memberFeignService.oauthLogin(socialUser)中)</span></span><br><span class="line"><span class="comment">// 8.返回登录成功页面(到首页去？)</span></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/oauth2.0/weibo/success"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">weibo</span><span class="params">(@RequestParam(<span class="string">"code"</span>)</span> String code, HttpSession session) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"client_id"</span>,<span class="string">"2077705774"</span>);</span><br><span class="line">    map.put(<span class="string">"client_secret"</span>,<span class="string">"40af02bd1c7e435ba6a6e9cd3bf799fd"</span>);</span><br><span class="line">    map.put(<span class="string">"grant_type"</span>,<span class="string">"authorization_code"</span>);</span><br><span class="line">    map.put(<span class="string">"redirect_uri"</span>,<span class="string">"http://auth.gulimall.com/oauth2.0/weibo/success"</span>);</span><br><span class="line">    map.put(<span class="string">"code"</span>,code);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、根据用户授权返回的code换取access_token</span></span><br><span class="line">    HttpResponse response = HttpUtils.doPost(<span class="string">"https://api.weibo.com"</span>, <span class="string">"/oauth2/access_token"</span>, <span class="string">"post"</span>, <span class="keyword">new</span> HashMap&lt;&gt;(), map, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、处理</span></span><br><span class="line">    <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">//获取到了access_token,转为通用社交登录对象</span></span><br><span class="line">        String json = EntityUtils.toString(response.getEntity());</span><br><span class="line">        <span class="comment">//String json = JSON.toJSONString(response.getEntity());</span></span><br><span class="line">        SocialUser socialUser = JSON.parseObject(json, SocialUser.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//知道了哪个社交用户</span></span><br><span class="line">        <span class="comment">//1）、当前用户如果是第一次进网站，自动注册进来（为当前社交用户生成一个会员信息，以后这个社交账号就对应指定的会员）</span></span><br><span class="line">        <span class="comment">//登录或者注册这个社交用户</span></span><br><span class="line">        System.out.println(socialUser.getAccess_token());</span><br><span class="line">        <span class="comment">//调用远程服务</span></span><br><span class="line">        R oauthLogin = memberFeignService.oauthLogin(socialUser);</span><br><span class="line">        <span class="keyword">if</span> (oauthLogin.getCode() == <span class="number">0</span>) &#123;</span><br><span class="line">            MemberResponseVo data = oauthLogin.getData(<span class="string">"data"</span>, <span class="keyword">new</span> TypeReference&lt;MemberResponseVo&gt;() &#123;&#125;);</span><br><span class="line">            log.info(<span class="string">"登录成功：用户信息：&#123;&#125;"</span>,data.toString());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1、第一次使用session，命令浏览器保存卡号，JSESSIONID这个cookie</span></span><br><span class="line">            <span class="comment">//以后浏览器访问哪个网站就会带上这个网站的cookie</span></span><br><span class="line">            <span class="comment">//TODO 1、默认发的令牌。当前域（解决子域session共享问题）</span></span><br><span class="line">            <span class="comment">//TODO 2、使用JSON的序列化方式来序列化对象到Redis中</span></span><br><span class="line">            session.setAttribute(LOGIN_USER,data);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//2、登录成功跳回首页</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"redirect:http://gulimall.com"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"redirect:http://auth.gulimall.com/login.html"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:http://auth.gulimall.com/login.html"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分布式Session"><a href="#分布式Session" class="headerlink" title="==分布式Session=="></a>==分布式Session==</h4><p><img alt="23" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230207223539.png"></p><p>==问题：session只能用于一台机器，对于不同机器，不同服务，不同域名都不能共享==</p><h5 id="方案1-session复制"><a href="#方案1-session复制" class="headerlink" title="方案1-session复制"></a>方案1-session复制</h5><p>小型系统可以考虑，大型系统同步代价太高</p><p><img alt="24" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208140252.png"></p><h5 id="方案2-客户端存储"><a href="#方案2-客户端存储" class="headerlink" title="方案2-客户端存储"></a>方案2-客户端存储</h5><p>不安全，不推荐</p><p><img alt="25" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208140505.png"></p><h5 id="方案3-使用hash一致性"><a href="#方案3-使用hash一致性" class="headerlink" title="方案3-使用hash一致性"></a>方案3-使用hash一致性</h5><p>问题不是很大，该方案也常用</p><p><img alt="26" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208140648.png"></p><h5 id="方案4-统一存储"><a href="#方案4-统一存储" class="headerlink" title="方案4-统一存储"></a>方案4-统一存储</h5><p><img alt="27" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208140845.png"></p><h5 id="使用SpringSession的最终方案"><a href="#使用SpringSession的最终方案" class="headerlink" title="==使用SpringSession的最终方案=="></a>==使用SpringSession的最终方案==</h5><h6 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h6><p><img alt="28" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208141949.png"></p><p>每次将session存入redis，取得时候不要取出(auth.gulimall.com)这样的域名，而是取出(.gulimall.com)这样的域名，这样所有其他子域名下的服务拿到session也能认证成功。</p><h6 id="导入依赖-1"><a href="#导入依赖-1" class="headerlink" title="导入依赖"></a>导入依赖</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 整合springsession --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h6><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    session:</span></span><br><span class="line"><span class="attr">        store-type:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure><h6 id="配置类的注解"><a href="#配置类的注解" class="headerlink" title="配置类的注解"></a>配置类的注解</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@EnableRedisHttpSession     //整合Redis作为session存储</span><br><span class="line">public class GulimallAuthServerApplication &#123;&#125;</span><br></pre></td></tr></table></figure><h6 id="存入redis"><a href="#存入redis" class="headerlink" title="==存入redis=="></a>==存入redis==</h6><p>==注意别忘了pojo要想存入redis，必须实现序列化接口(因为对象在内存中，要想存到远程的redis中，就必须转化为二进制流通过网络传输到redis服务器)或使用json序列化传输==</p><p>使用序列化接口方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MemberResponseVo data = oauthLogin.getData(<span class="string">"data"</span>, <span class="keyword">new</span> TypeReference&lt;MemberResponseVo&gt;() &#123;&#125;);</span><br><span class="line">log.info(<span class="string">"登录成功：用户信息：&#123;&#125;"</span>,data.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、第一次使用session，命令浏览器保存卡号，JSESSIONID这个cookie</span></span><br><span class="line"><span class="comment">//以后浏览器访问哪个网站就会带上这个网站的cookie</span></span><br><span class="line"><span class="comment">//TODO 1、默认发的令牌。当前域（解决子域session共享问题）</span></span><br><span class="line"><span class="comment">//TODO 2、使用JSON的序列化方式来序列化对象到Redis中</span></span><br><span class="line">session.setAttribute(LOGIN_USER,data);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberResponseVo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>使用json序列化：</p><p>需要配置序列化器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallSessionConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现子域session共享的问题</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CookieSerializer <span class="title">cookieSerializer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DefaultCookieSerializer cookieSerializer = <span class="keyword">new</span> DefaultCookieSerializer();</span><br><span class="line">        <span class="comment">//放大作用域</span></span><br><span class="line">        cookieSerializer.setDomainName(<span class="string">"gulimall.com"</span>);</span><br><span class="line">        cookieSerializer.setCookieName(<span class="string">"GULISESSION"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cookieSerializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// json-&gt;redis的序列化器,这样就不需要每个类都要继承序列化接口类了</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisSerializer&lt;Object&gt; <span class="title">springSessionDefaultRedisSerializer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericJackson2JsonRedisSerializer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="实现子域session共享的问题"><a href="#实现子域session共享的问题" class="headerlink" title="==实现子域session共享的问题=="></a>==实现子域session共享的问题==</h6><p>配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallSessionConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现子域session共享的问题</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CookieSerializer <span class="title">cookieSerializer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DefaultCookieSerializer cookieSerializer = <span class="keyword">new</span> DefaultCookieSerializer();</span><br><span class="line">        <span class="comment">//放大作用域</span></span><br><span class="line">        cookieSerializer.setDomainName(<span class="string">"gulimall.com"</span>);</span><br><span class="line">        cookieSerializer.setCookieName(<span class="string">"GULISESSION"</span>);<span class="comment">// 名字应该无所谓</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cookieSerializer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="SpringSession核心原理"><a href="#SpringSession核心原理" class="headerlink" title="==SpringSession核心原理=="></a>==SpringSession核心原理==</h6><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.@EnableRedisHttpSession导入RedisHttpSessionConfiguration配置</span></span><br><span class="line"><span class="code">      1、给容器中添加了一个组件</span></span><br><span class="line"><span class="code">          SessionRepository-》RedisOperationsSessionRepository：Redis操作session，session的增删改查封装类</span></span><br><span class="line"><span class="code">      2.SessionRepositoryFilter-&gt;Filter:每个请求过来都必须经过filter</span></span><br><span class="line"><span class="code">          2.1创建的时候，就自动从容器中获取到了SessionRepository</span></span><br><span class="line"><span class="code">          2.2原生的request和response对象在里面经过包装变成SessionRepositoryRequestWrapper和SessionRepositoryResponseWrapper(装饰者模式)</span></span><br><span class="line"><span class="code">          2.3我们获取session,通常使用request.getSession(),这里就实际上调用了SessionRepositoryRequestWrapper.getSession()方法</span></span><br></pre></td></tr></table></figure><p><img alt="29" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208150723.png"></p><h4 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h4><blockquote><p>SSO(Single Sign On) 一处登陆、处处可用</p><p>适用于多系统(不同的父域名)</p></blockquote><h3 id="购物车功能"><a href="#购物车功能" class="headerlink" title="购物车功能"></a>购物车功能</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>电商购物车<br>    存储<br>        1）以用户id为key<br>        2）商品id为field<br>        3）商品数量为value<br>    操作<br>        添加商品：hset cart:1001 10088 1<br>        增加数量：hincrby cart:1001 10088 1<br>        商品总数：hlen cart:1001<br>        删除商品：hdel cart:1001 10088<br>        获取购物车所有商品：hgetall cart:1001</p><p><img alt="3" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208174708.png"></p><h4 id="业务需求"><a href="#业务需求" class="headerlink" title="==业务需求=="></a>==业务需求==</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">去购物车页面的请求</span><br><span class="line">浏览器有一个cookie:user-key 标识用户的身份，一个月过期</span><br><span class="line">如果第一次使用jd的购物车功能，都会给一个临时的用户身份:</span><br><span class="line">浏览器以后保存，每次访问都会带上这个cookie；</span><br><span class="line"></span><br><span class="line">登录：session有</span><br><span class="line">没登录：按照cookie里面带来user-key来做</span><br><span class="line">第一次，如果没有临时用户，自动创建一个临时用户</span><br></pre></td></tr></table></figure><p>==使用HandlerInterceptor+ThreadLocal实现拦截添加临时用户的功能==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;UserInfoTo&gt; toThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 目标方法执行之前</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        UserInfoTo userInfoTo = <span class="keyword">new</span> UserInfoTo();</span><br><span class="line"></span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        <span class="comment">//获得当前登录用户的信息</span></span><br><span class="line">        MemberResponseVo memberResponseVo = (MemberResponseVo) session.getAttribute(LOGIN_USER);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (memberResponseVo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//用户登录了</span></span><br><span class="line">            userInfoTo.setUserId(memberResponseVo.getId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="keyword">null</span> &amp;&amp; cookies.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                <span class="comment">//user-key</span></span><br><span class="line">                String name = cookie.getName();</span><br><span class="line">                <span class="keyword">if</span> (name.equals(TEMP_USER_COOKIE_NAME)) &#123;</span><br><span class="line">                    userInfoTo.setUserKey(cookie.getValue());</span><br><span class="line">                    <span class="comment">//标记为已是临时用户</span></span><br><span class="line">                    userInfoTo.setTempUser(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有临时用户一定分配一个临时用户</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(userInfoTo.getUserKey())) &#123;</span><br><span class="line">            String uuid = UUID.randomUUID().toString();</span><br><span class="line">            userInfoTo.setUserKey(uuid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//目标方法执行之前</span></span><br><span class="line">        toThreadLocal.set(userInfoTo);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务执行之后，分配临时用户来浏览器保存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelAndView</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前用户的值</span></span><br><span class="line">        UserInfoTo userInfoTo = toThreadLocal.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有临时用户一定保存一个临时用户</span></span><br><span class="line">        <span class="keyword">if</span> (!userInfoTo.getTempUser()) &#123;</span><br><span class="line">            <span class="comment">//创建一个cookie</span></span><br><span class="line">            Cookie cookie = <span class="keyword">new</span> Cookie(TEMP_USER_COOKIE_NAME, userInfoTo.getUserKey());</span><br><span class="line">            <span class="comment">//扩大作用域</span></span><br><span class="line">            cookie.setDomain(<span class="string">"gulimall.com"</span>);</span><br><span class="line">            <span class="comment">//设置过期时间</span></span><br><span class="line">            cookie.setMaxAge(TEMP_USER_COOKIE_TIMEOUT);</span><br><span class="line">            response.addCookie(cookie);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="购物车redis代码"><a href="#购物车redis代码" class="headerlink" title="购物车redis代码"></a>购物车redis代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定指定的key操作Redis</span></span><br><span class="line">BoundHashOperations&lt;String, Object, Object&gt; operations = stringRedisTemplate.boundHashOps(cartKey);</span><br><span class="line">operations.get(skuId.toString());</span><br><span class="line">operations.put(skuId.toString(), cartItemJson);</span><br><span class="line">operations.delete(skuId.toString());</span><br></pre></td></tr></table></figure><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><blockquote><p>docker pull rabbitmq:managment</p><p>启动</p><p>docker run -d —name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management</p><p>tip:没有的话，docker run 会先安装在启动</p><p>解释</p><blockquote><p>4369, 25672 (Erlang发现&amp;集群端口)</p><p>5672, 5671 (AMQP端口)</p><p>15672 (web管理后台端口)</p><p>61613, 61614 (STOMP协议端口)</p><p>1883, 8883 (MQTT协议端口)</p><p><a href="https://www.rabbitmq.com/networking.html" target="_blank" rel="noopener">https://www.rabbitmq.com/networking.html</a></p></blockquote><p>默认账号  guest/guest</p></blockquote><h4 id="MQ优势"><a href="#MQ优势" class="headerlink" title="MQ优势"></a>MQ优势</h4><p>​    应用解耦</p><blockquote><p>如若订单系统调用库存系统的接口改了，那么订单系统也要跟着改，不方便维护</p></blockquote><p><img alt="1" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208203444.png"></p><p>​    异步提速</p><p><img alt="2" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208203447.png"></p><p>​    削峰填谷</p><p><img alt="3" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208203450.png"></p><h4 id="消息队列两大规范"><a href="#消息队列两大规范" class="headerlink" title="消息队列两大规范"></a>消息队列两大规范</h4><p>JMS，ActiveMQ实现</p><p>AMQP，RabbitMQ实现</p><p><img alt="30" data-src="E:\desktop\自学\MyNote\项目\谷粒商城\images\30.png"></p><h4 id="基本组件图-概念图"><a href="#基本组件图-概念图" class="headerlink" title="基本组件图(概念图)"></a>基本组件图(概念图)</h4><blockquote><p>这是比较整体的图，具体的来说有好几种模式(工作模式，路由模式(Direct：定向)，发布/订阅模式(Fanout：广播)，Topics主题模式(Topic：通配符))</p></blockquote><p><img alt="img" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208210335.png"></p><p>其中MQ就充当了Broker消息代理的角色</p><p>route-key路由键结合交换机的类型(direct,fanout,topic)决定消息发给哪些队列，==注意和队列名称和交换机名称没有关系==</p><p>VHost</p><blockquote><p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</p><p>比如java和PHP可以隔离出两个VHost，一个崩溃了不会影响另一个；或者生产和测试可以隔离出两个VHost </p></blockquote><h4 id="SpringBoot整合-2"><a href="#SpringBoot整合-2" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h4><h5 id="导入依赖-2"><a href="#导入依赖-2" class="headerlink" title="导入依赖"></a>导入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="AmqpAdmin用于增删改查队列、交换机及其绑定关系等"><a href="#AmqpAdmin用于增删改查队列、交换机及其绑定关系等" class="headerlink" title="AmqpAdmin用于增删改查队列、交换机及其绑定关系等"></a>AmqpAdmin用于增删改查队列、交换机及其绑定关系等</h5><blockquote><p>结合web图形界面更直观</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DirectExchange(String name, boolean durable, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">    <span class="comment">// 名称,持久化,是否自动删除,额外参数</span></span><br><span class="line">    admin.declareExchange(<span class="keyword">new</span> DirectExchange(<span class="string">"hello-java-exchange"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>));</span><br><span class="line">    log.info(<span class="string">"Exchange:&#123;&#125;创建成功"</span>,<span class="string">"hello-java-exchange"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Queue(String name, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">    <span class="comment">// 名称,是否持久化,是否排他(只能被一个人连接),是否自动删除,额外参数</span></span><br><span class="line">    admin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">"hello-java-queue"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>));</span><br><span class="line">    log.info(<span class="string">"Queue:&#123;&#125;创建成功"</span>,<span class="string">"hello-java-queue"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Binding(String destination, Binding.DestinationType destinationType, String exchange, String routingKey,</span></span><br><span class="line"><span class="comment">//                Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">    <span class="comment">// 目的地，目的地类型(交换机或队列)，交换机，路由键</span></span><br><span class="line">    admin.declareBinding(<span class="keyword">new</span> Binding(<span class="string">"hello-java-queue"</span>,Binding.DestinationType.QUEUE,</span><br><span class="line">            <span class="string">"hello-java-exchange"</span>,</span><br><span class="line">            <span class="string">"hello.java"</span>,<span class="keyword">null</span>));</span><br><span class="line">    log.info(<span class="string">"Binding:&#123;&#125;创建成功"</span>,<span class="string">"hello-java-binding"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="RabbitTemplate用于发送消息"><a href="#RabbitTemplate用于发送消息" class="headerlink" title="RabbitTemplate用于发送消息"></a>RabbitTemplate用于发送消息</h5><p>如果要发送对象，就必须实现序列化接口</p><p>或者转为json发送(需要往容器中注入rabbitmq的json转换器 Jackson2JsonMessageConverter)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    OrderReturnReasonEntity reasonEntity = <span class="keyword">new</span> OrderReturnReasonEntity();</span><br><span class="line">    reasonEntity.setId(<span class="number">1L</span>);</span><br><span class="line">    reasonEntity.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">    reasonEntity.setName(<span class="string">"reason"</span>);</span><br><span class="line">    reasonEntity.setStatus(<span class="number">1</span>);</span><br><span class="line">    reasonEntity.setSort(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 如果要发送对象，就必须实现序列化接口或者转为json发送</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"hello-java-exchange"</span>,<span class="string">"hello.java"</span>,reasonEntity);</span><br><span class="line">    log.info(<span class="string">"消息:&#123;&#125;发送完成"</span>,<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="RabbitListner用于监听信息"><a href="#RabbitListner用于监听信息" class="headerlink" title="@RabbitListner用于监听信息"></a>@RabbitListner用于监听信息</h5><blockquote><p>例如接收如上RabbitTemplate发送的信息</p><p>@RabbitHandler也常用，不过只能用于方法；@RabbitListner可以用于方法和类。但是@RabbitHandler标注能够方便标注重载方法(区分不同的消息)，@RabbitListner此时就用来标注到类上，表示接收哪个队列的消息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"orderItemService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderItemServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">OrderItemDao</span>, <span class="title">OrderItemEntity</span>&gt; <span class="keyword">implements</span> <span class="title">OrderItemService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = &#123;<span class="string">"hello-java-queue"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revieveMessage</span><span class="params">(Message message,</span></span></span><br><span class="line"><span class="function"><span class="params">                               OrderReturnReasonEntity content,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//拿到主体内容</span></span><br><span class="line">        <span class="keyword">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="comment">//拿到的消息头属性信息</span></span><br><span class="line">        MessageProperties messageProperties = message.getMessageProperties();</span><br><span class="line">        System.out.println(<span class="string">"接受到的消息...内容"</span> + message + <span class="string">"===内容："</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息确认机制"><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h4><blockquote><p>==保证消息不丢失，可靠抵达，虽然可以使用事务消息，但是性能下降250倍，为此引入确认机制==</p></blockquote><p>==分别从服务端和消费端实现确认机制==</p><p><img alt="32" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230210170128.png"></p><h5 id="ConfirmCallback"><a href="#ConfirmCallback" class="headerlink" title="ConfirmCallback"></a>ConfirmCallback</h5><p>只要消息抵达Broker就ack=true</p><p><img alt="33" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230210170520.png"></p><h5 id="ReturnCallback"><a href="#ReturnCallback" class="headerlink" title="ReturnCallback"></a>ReturnCallback</h5><p>==只要消息没有投递给指定的队列，就触发这个失败回调==</p><p><img alt="34" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230210170517.png"></p><h5 id="Ack消息确认机制"><a href="#Ack消息确认机制" class="headerlink" title="==Ack消息确认机制=="></a>==Ack消息确认机制==</h5><p><img alt="35" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230210170513.png"></p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    rabbitmq:</span></span><br><span class="line"><span class="attr">        host:</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.108</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">        virtual-host:</span> <span class="string">/</span></span><br><span class="line">        <span class="comment"># 开启发送端消息抵达Broker确认</span></span><br><span class="line"><span class="attr">        publisher-confirms:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 开启发送端消息抵达Queue确认</span></span><br><span class="line"><span class="attr">        publisher-returns:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 只要消息抵达Queue，就会异步发送优先回调returnfirm</span></span><br><span class="line"><span class="attr">        template:</span></span><br><span class="line"><span class="attr">          mandatory:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 手动ack消息，不使用默认的消费端确认</span></span><br><span class="line"><span class="attr">        listener:</span></span><br><span class="line"><span class="attr">          simple:</span></span><br><span class="line"><span class="attr">            acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure><p>服务端确认需要的配置config.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageConverter <span class="title">messageConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制RabbitTemplate</span></span><br><span class="line"><span class="comment">     * 1、服务收到消息就会回调</span></span><br><span class="line"><span class="comment">     *      1、spring.rabbitmq.publisher-confirms: true</span></span><br><span class="line"><span class="comment">     *      2、设置确认回调</span></span><br><span class="line"><span class="comment">     * 2、消息正确抵达队列就会进行回调</span></span><br><span class="line"><span class="comment">     *      1、spring.rabbitmq.publisher-returns: true</span></span><br><span class="line"><span class="comment">     *         spring.rabbitmq.template.mandatory: true</span></span><br><span class="line"><span class="comment">     *      2、设置确认回调ReturnCallback</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3、消费端确认(保证每个消息都被正确消费，此时才可以broker删除这个消息)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// @PostConstruct  //MyRabbitConfig对象创建完成以后，执行这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initRabbitTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1、只要消息抵达Broker就ack=true</span></span><br><span class="line"><span class="comment">         * correlationData：当前消息的唯一关联数据(这个是消息的唯一id)</span></span><br><span class="line"><span class="comment">         * ack：消息是否成功收到</span></span><br><span class="line"><span class="comment">         * cause：失败的原因</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//设置确认回调</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback((correlationData,ack,cause) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"confirm...correlationData["</span>+correlationData+<span class="string">"]==&gt;ack:["</span>+ack+<span class="string">"]==&gt;cause:["</span>+cause+<span class="string">"]"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 只要消息没有投递给指定的队列，就触发这个失败回调</span></span><br><span class="line"><span class="comment">         * message：投递失败的消息详细信息</span></span><br><span class="line"><span class="comment">         * replyCode：回复的状态码</span></span><br><span class="line"><span class="comment">         * replyText：回复的文本内容</span></span><br><span class="line"><span class="comment">         * exchange：当时这个消息发给哪个交换机</span></span><br><span class="line"><span class="comment">         * routingKey：当时这个消息用哪个路邮键</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setReturnCallback((message,replyCode,replyText,exchange,routingKey) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"Fail Message["</span>+message+<span class="string">"]==&gt;replyCode["</span>+replyCode+<span class="string">"]"</span> +</span><br><span class="line">                    <span class="string">"==&gt;replyText["</span>+replyText+<span class="string">"]==&gt;exchange["</span>+exchange+<span class="string">"]==&gt;routingKey["</span>+routingKey+<span class="string">"]"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ack消费者确认机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revieveMessage</span><span class="params">(Message message,</span></span></span><br><span class="line"><span class="function"><span class="params">                           OrderReturnReasonEntity content,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Channel channel)</span></span>&#123;</span><br><span class="line">    <span class="comment">//拿到主体内容</span></span><br><span class="line">    <span class="keyword">byte</span>[] body = message.getBody();</span><br><span class="line">    <span class="comment">//拿到的消息头属性信息</span></span><br><span class="line">    MessageProperties messageProperties = message.getMessageProperties();</span><br><span class="line">    System.out.println(<span class="string">"接受到的消息...内容"</span> + <span class="keyword">new</span> String(body) + <span class="string">"===内容："</span> + content);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deliveryTag在该通道内从1开始计数   表示消息唯一标识</span></span><br><span class="line">    <span class="keyword">long</span> deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">    <span class="comment">// 签收消息</span></span><br><span class="line">    <span class="comment">// multiple=false(挨个签收)</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.basicAck(deliveryTag,<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 表示消息唯一标识,是否批量,拒绝后是否发挥服务器重新入队</span></span><br><span class="line">        <span class="comment">// channel.basicNack(deliveryTag,false,true);</span></span><br><span class="line">        <span class="comment">//            // 表示消息唯一标识,拒绝后是否发挥服务器重新入队</span></span><br><span class="line">        <span class="comment">// channel.basicReject(deliveryTag,true);</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 网络中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h4><h5 id="死信路由-DLX"><a href="#死信路由-DLX" class="headerlink" title="死信路由(DLX)"></a>死信路由(DLX)</h5><p>一个消息在满足如下条件下，会进死信路由，记住这里是路由而不是队列， 一个路由可以对应很多队列。（什么是死信）</p><p>成为死信的情况：</p><p>​        1.一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不会被再次放在队列里，被其他消费者使用。（basic.reject/ basic.nack）requeue=false<br>​        2.上面的消息的TTL到了，消息过期了。<br>​        3.队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上</p><p>Dead Letter Exchange其实就是一种普通的exchange，和创建其他exchange没有两样。只是在某一个设置Dead Letter Exchange的队列中有 消息过期了，会自动触发消息的转发，发送到Dead Letter Exchange中去。</p><p>我们既可以控制消息在一段时间后变成死信，又可以控制变成死信的消息 被路由到某一个指定的交换机，结合二者，其实就可以实现一个延时队列</p><p>手动ack&amp;异常消息统一放在一个队列处理建议的两种方式<br>        catch异常后，手动发送到指定队列，然后使用channel给rabbitmq确认消息已消费<br>        给Queue绑定死信队列，使用nack（requque为false）确认消息消费失败</p><h5 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h5><p><img alt="39" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/39.png"></p><h5 id="定时任务时效性"><a href="#定时任务时效性" class="headerlink" title="定时任务时效性"></a>定时任务时效性</h5><p><img alt="40" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/40.png"></p><h4 id="订单业务—使用MQ实现最终一致性的分布式事务"><a href="#订单业务—使用MQ实现最终一致性的分布式事务" class="headerlink" title="==订单业务—使用MQ实现最终一致性的分布式事务=="></a>==订单业务—使用MQ实现最终一致性的分布式事务==</h4><p>==遵循一个服务一个交换机的原则==，延时队列设计如下图。</p><p><img alt="41" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/41.png"></p><h5 id="整体消息队列架构"><a href="#整体消息队列架构" class="headerlink" title="整体消息队列架构"></a>整体消息队列架构</h5><p><img alt="消息队列流程" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/消息队列流程.jpg"></p><h5 id="创建延时队列"><a href="#创建延时队列" class="headerlink" title="创建延时队列"></a>创建延时队列</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">orderDelayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Queue(String name,  队列名字</span></span><br><span class="line"><span class="comment">        boolean durable,  是否持久化</span></span><br><span class="line"><span class="comment">        boolean exclusive,  是否排他</span></span><br><span class="line"><span class="comment">        boolean autoDelete, 是否自动删除</span></span><br><span class="line"><span class="comment">        Map&lt;String, Object&gt; arguments) 属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HashMap&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    arguments.put(<span class="string">"x-dead-letter-exchange"</span>, <span class="string">"order-event-exchange"</span>);<span class="comment">// 死信之后发给那个交换机</span></span><br><span class="line">    arguments.put(<span class="string">"x-dead-letter-routing-key"</span>, <span class="string">"order.release.order"</span>);<span class="comment">// 死信之后的routing-key</span></span><br><span class="line">    arguments.put(<span class="string">"x-message-ttl"</span>, <span class="number">60000</span>); <span class="comment">// 消息过期时间 1分钟</span></span><br><span class="line">    Queue queue = <span class="keyword">new</span> Queue(<span class="string">"order.delay.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建死信交换机"><a href="#创建死信交换机" class="headerlink" title="创建死信交换机"></a>创建死信交换机</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TopicExchange</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Exchange <span class="title">orderEventExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *   String name,</span></span><br><span class="line"><span class="comment">     *   boolean durable,</span></span><br><span class="line"><span class="comment">     *   boolean autoDelete,</span></span><br><span class="line"><span class="comment">     *   Map&lt;String, Object&gt; arguments</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"order-event-exchange"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建目的地交换机"><a href="#创建目的地交换机" class="headerlink" title="创建目的地交换机"></a>创建目的地交换机</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">orderReleaseQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue queue = <span class="keyword">new</span> Queue(<span class="string">"order.release.order.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="绑定关系"><a href="#绑定关系" class="headerlink" title="绑定关系"></a>绑定关系</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">orderCreateBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * String destination, 目的地（队列名或者交换机名字）</span></span><br><span class="line"><span class="comment">     * DestinationType destinationType, 目的地类型（Queue、Exhcange）</span></span><br><span class="line"><span class="comment">     * String exchange,</span></span><br><span class="line"><span class="comment">     * String routingKey,</span></span><br><span class="line"><span class="comment">     * Map&lt;String, Object&gt; arguments</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Binding(<span class="string">"order.delay.queue"</span>,</span><br><span class="line">            Binding.DestinationType.QUEUE,</span><br><span class="line">            <span class="string">"order-event-exchange"</span>,</span><br><span class="line">            <span class="string">"order.create.order"</span>,</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">orderReleaseBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Binding(<span class="string">"order.release.order.queue"</span>,</span><br><span class="line">            Binding.DestinationType.QUEUE,</span><br><span class="line">            <span class="string">"order-event-exchange"</span>,</span><br><span class="line">            <span class="string">"order.release.order"</span>,</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="发消息"><a href="#发消息" class="headerlink" title="发消息"></a>发消息</h5><p>订单创建成功往延时队列中发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 订单创建成功，发送消息给MQ</span></span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">"order-event-exchange"</span>,<span class="string">"order.create.order"</span>,order.getOrder());</span><br><span class="line"><span class="comment">// 这里不需要有消费者,过期之后让消费者取消订单就行</span></span><br></pre></td></tr></table></figure><h5 id="监听过期消息"><a href="#监听过期消息" class="headerlink" title="监听过期消息"></a>监听过期消息</h5><p>在延迟队列中的消息，相当于有个定时器，到期之后，能够监听到，就可以调用方法来取消订单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"order.release.order.queue"</span>)</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderCloseListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listener</span><span class="params">(OrderEntity orderEntity, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到过期的订单信息，准备关闭订单"</span> + orderEntity.getOrderSn());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            orderService.closeOrder(orderEntity);</span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            channel.basicReject(message.getMessageProperties().getDeliveryTag(),<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MQ的几个可靠性问题"><a href="#MQ的几个可靠性问题" class="headerlink" title="MQ的几个可靠性问题"></a>MQ的几个可靠性问题</h4><h5 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h5><p>没抵达broker(MQ服务器)：保证每个消息一定会发出去，做好日志(存到mysql中)。定期扫描数据库，重新发送失败的消息</p><p>抵达了broker(MQ服务器)：使用publisher的消息确认机制</p><p><img alt="42" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/42.png"></p><h5 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h5><p><img alt="43" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/43.png"></p><h5 id="消息积压"><a href="#消息积压" class="headerlink" title="消息积压"></a>消息积压</h5><p><img alt="44" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/44.png"></p><h3 id="订单业务"><a href="#订单业务" class="headerlink" title="==订单业务=="></a>==订单业务==</h3><h4 id="幂等性"><a href="#幂等性" class="headerlink" title="==幂等性=="></a>==幂等性==</h4><blockquote><p><strong>接口幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的</strong></p></blockquote><p>进入订单确认页的时候存一份令牌</p><blockquote><p>order服务下的OrderServiceImpl</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为用户设置一个token，三十分钟过期时间（存在redis）</span></span><br><span class="line">String token = UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">redisTemplate.opsForValue().set(USER_ORDER_TOKEN_PREFIX+memberResponseVo.getId(),token,<span class="number">30</span>, TimeUnit.MINUTES);</span><br><span class="line">confirmVo.setOrderToken(token);</span><br></pre></td></tr></table></figure><p>提交订单的时候就要使用lua脚本原子性查，并且删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、验证令牌是否合法【令牌的对比和删除必须保证原子性】</span></span><br><span class="line">String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">String orderToken = vo.getOrderToken();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过lua脚本原子验证令牌和删除令牌</span></span><br><span class="line">Long result = redisTemplate.execute(<span class="keyword">new</span> DefaultRedisScript&lt;Long&gt;(script, Long.class),</span><br><span class="line">        Arrays.asList(USER_ORDER_TOKEN_PREFIX + memberResponseVo.getId()),</span><br><span class="line">        orderToken);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0L</span>) &#123;</span><br><span class="line">    <span class="comment">//令牌验证失败</span></span><br><span class="line">    responseVo.setCode(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> responseVo;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//令牌验证成功</span></span><br></pre></td></tr></table></figure><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="==分布式事务=="></a>==分布式事务==</h4><p>本地事务异常</p><p><img alt="38" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/38.png"></p><h5 id="seata（2PC）"><a href="#seata（2PC）" class="headerlink" title="seata（2PC）"></a>seata（2PC）</h5><h6 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h6><p>1.给每个服务的数据库中加入undo_log表(具体内容从官网上查)</p><p>2.安装事务协调器seata(从Github下载)，并启动</p><p>3.导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.配置</p><p>注册中心配置—&gt;registry.conf</p><p>seata配置—&gt;file.conf</p><p>5.注入Seata代理数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySeataConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSourceProperties dataSourceProperties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties dataSourceProperties)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HikariDataSource dataSource = dataSourceProperties.initializeDataSourceBuilder().type(HikariDataSource.class).build();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(dataSourceProperties.getName())) &#123;</span><br><span class="line">            dataSource.setPoolName(dataSourceProperties.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProxy(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.(==这个0.xx才有，1.2之后都没有了==)每个微服务都需要导入file.conf和registry.conf，还要在file.conf修改</p><blockquote><p>   service下的vgroup_mapping修改成vgroup_mapping.微服务名称-fescar-service-group = “default”</p></blockquote><p>7.给大事务方法加上@GlobalTransactional，小事务加上@Transactional就行</p><h6 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h6><p>AT模式(默认)，不适合高并发，不考虑2PC，也不考虑TCC模式，这样的是强一致性，很消耗性能</p><h5 id="高性能的实现方式"><a href="#高性能的实现方式" class="headerlink" title="==高性能的实现方式=="></a>==高性能的实现方式==</h5><p>这就是文档中的<strong>柔性事务+可靠消息+最终一致性方案</strong></p><p>使用MQ回滚，保证弱一致性-最终一致性</p><h4 id="业务分析"><a href="#业务分析" class="headerlink" title="业务分析"></a>业务分析</h4><p>库存解锁：就是防止后续付款的时候，库存没货了。所以在创建订单时就把库存锁定，后面付款时就肯定有库存。</p><h3 id="分布式原理"><a href="#分布式原理" class="headerlink" title="==分布式原理=="></a>==分布式原理==</h3><blockquote><p>  参考文档</p><p>  <a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></p><p>  <a href="https://raft.github.io/" target="_blank" rel="noopener">https://raft.github.io/</a></p></blockquote><p>==C和A无法同时满足(一致性和可用性无法同时满足)，所以不存在CA系统，只有AP和CP系统==</p><p>ABC系统，A给C同步数据时，网线断了，那么此时A和B都是8，C还是7。如要满足可用性，那么读出来的数据是7，不满足一致性；如要满足一致性，读出来的数据是8，那么C就不能用。综上，一致性和可用性无法同时满足</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础篇&quot;&gt;&lt;a href=&quot;#基础篇&quot; class=&quot;headerlink&quot; title=&quot;基础篇&quot;&gt;&lt;/a&gt;基础篇&lt;/h2&gt;&lt;h3 id=&quot;项目背景&quot;&gt;&lt;a href=&quot;#项目背景&quot; class=&quot;headerlink&quot; title=&quot;项目背景&quot;&gt;&lt;/a&gt;项目背
      
    
    </summary>
    
    
      <category term="JavaEE" scheme="https://alexander-wd.github.io/categories/JavaEE/"/>
    
    
      <category term="项目" scheme="https://alexander-wd.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>mybatis面试题</title>
    <link href="https://alexander-wd.github.io/2022/10/18/%E9%9D%A2%E8%AF%95%E9%A2%98/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://alexander-wd.github.io/2022/10/18/%E9%9D%A2%E8%AF%95%E9%A2%98/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-10-18T11:12:20.000Z</published>
    <updated>2023-02-13T10:13:30.647Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、什么是Mybatis？"><a href="#1、什么是Mybatis？" class="headerlink" title="1、什么是Mybatis？"></a>1、什么是Mybatis？</h3><blockquote><p>1.Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。</p><p>2.MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p><p>3.通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。（从执行sql到返回result的过程）。</p></blockquote><h3 id="2、-和-的区别是什么？"><a href="#2、-和-的区别是什么？" class="headerlink" title="2、#{}和${}的区别是什么？"></a><strong>2、#{}和${}的区别是什么？</strong></h3><blockquote><p> {}是预编译处理，${}是字符串替换。</p><p> Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</p><p> Mybatis在处理${}时，就是把${}替换成变量的值。</p><p> 使用#{}可以有效的防止SQL注入，提高系统安全性。</p></blockquote><h3 id="3、简述-MyBatis-的插件运行原理，以及如何编写一个插件。"><a href="#3、简述-MyBatis-的插件运行原理，以及如何编写一个插件。" class="headerlink" title="3、简述 MyBatis 的插件运行原理，以及如何编写一个插件。"></a>3、简述 MyBatis 的插件运行原理，以及如何编写一个插件。</h3><p>MyBatis 仅可以编写针对 <code>ParameterHandler</code> 、 <code>ResultSetHandler</code> 、 <code>StatementHandler</code> 、 <code>Executor</code> 这 4 种接口的插件，MyBatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 <code>InvocationHandler</code> 的 <code>invoke()</code> 方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>实现 MyBatis 的 <code>Interceptor</code> 接口并复写 <code>intercept()</code> 方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p><p><img alt="MyBatis插件过程" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Mybatis/20230131112919.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、什么是Mybatis？&quot;&gt;&lt;a href=&quot;#1、什么是Mybatis？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是Mybatis？&quot;&gt;&lt;/a&gt;1、什么是Mybatis？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;1.Mybatis是一个半
      
    
    </summary>
    
    
      <category term="面试题" scheme="https://alexander-wd.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="mybatis" scheme="https://alexander-wd.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mysql面试题</title>
    <link href="https://alexander-wd.github.io/2022/10/15/%E9%9D%A2%E8%AF%95%E9%A2%98/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://alexander-wd.github.io/2022/10/15/%E9%9D%A2%E8%AF%95%E9%A2%98/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-10-15T01:40:20.000Z</published>
    <updated>2023-02-13T10:12:42.293Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="说一下-MySQL-执行一条查询语句的内部执行过程？"><a href="#说一下-MySQL-执行一条查询语句的内部执行过程？" class="headerlink" title="说一下 MySQL 执行一条查询语句的内部执行过程？"></a>说一下 MySQL 执行一条查询语句的内部执行过程？</h4><ul><li>客户端先通过连接器连接到 MySQL 服务器。</li><li>连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。</li><li>分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。</li><li>优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。</li><li>优化器执行完就进入执行器，执行器就开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。</li></ul><p><img alt="1" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Mysql/20230130185311.png"></p><h4 id="常用的存储引擎-InnoDB-和-MyISAM-有什么区别？"><a href="#常用的存储引擎-InnoDB-和-MyISAM-有什么区别？" class="headerlink" title="常用的存储引擎 InnoDB 和 MyISAM 有什么区别？"></a>常用的存储引擎 InnoDB 和 MyISAM 有什么区别？</h4><p>InnoDB 和 MyISAM 最大的区别是 InnoDB 支持事务，而 MyISAM 不支持事务，它们主要区别如下：、</p><ul><li>InnoDB 支持崩溃后安全恢复，MyISAM 不支持崩溃后安全恢复；</li><li>InnoDB 支持行级锁，MyISAM 不支持行级锁，只支持到表锁；</li><li>InnoDB 支持外键，MyISAM 不支持外键；</li><li>MyISAM 性能比 InnoDB 高；</li><li>MyISAM 支持 FULLTEXT 类型的全文索引，InnoDB 不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，并且效果更好；</li><li>InnoDB 主键查询性能高于 MyISAM。</li><li>InnoDB使用的是聚集索引，MyISAM使用的是非聚集索引</li></ul><h4 id="一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？"><a href="#一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？" class="headerlink" title="一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？"></a>一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？</h4><p>如果这张表的引擎是 MyISAM，那么 ID=4，如果是 InnoDB 那么 ID=2（MySQL 8 之前的版本）。</p><h4 id="limit-3-2-的含义是什么？"><a href="#limit-3-2-的含义是什么？" class="headerlink" title="limit 3,2 的含义是什么？"></a>limit 3,2 的含义是什么？</h4><p>去除前三条数据之后查询两条信息。</p><h4 id="count-column-和-count-有什么区别？"><a href="#count-column-和-count-有什么区别？" class="headerlink" title="count(column) 和 count(*) 有什么区别？"></a>count(column) 和 count(*) 有什么区别？</h4><p>count(column) 和 count() 最大区别是统计结果可能不一致，count(column) 统计不会统计列值为 null 的数据，而 count() 则会统计所有信息，所以最终的统计结果可能会不同。</p><h4 id="在-InnoDB-引擎中-count-、count-1-、count-主键-、count-字段-哪个性能最高？"><a href="#在-InnoDB-引擎中-count-、count-1-、count-主键-、count-字段-哪个性能最高？" class="headerlink" title="在 InnoDB 引擎中 count(*)、count(1)、count(主键)、count(字段) 哪个性能最高？"></a>在 InnoDB 引擎中 count(*)、count(1)、count(主键)、count(字段) 哪个性能最高？</h4><p>count(字段)&lt;count(主键 id)&lt;count(1)≈count(*) 题目解析：</p><ul><li><p>对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p></li><li><p>对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p></li><li><p>对于 count(字段) 来说，如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</p></li><li><p>对于 count(*) 来说，并不会把全部字段取出来，而是专门做了优化，不取值，直接按行累加。</p></li></ul><p>所以最后得出的结果是：count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)。</p><h3 id="索引底层原理"><a href="#索引底层原理" class="headerlink" title="索引底层原理"></a>索引底层原理</h3><h4 id="何为索引？有什么作用"><a href="#何为索引？有什么作用" class="headerlink" title="何为索引？有什么作用"></a>何为索引？有什么作用</h4><p>​    索引是一种能帮助 MySQL 提高查询效率的排好序的数据结构<br>​    索引的作用就相当于书的目录</p><h4 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h4><p>​    优点<br>​        ==快速访问数据表中的特定信息，提高检索速度。<br>​        创建唯一性索引，保证数据表中每一行数据的唯一性。==<br>​        加速表与表之间的连接。<br>​        使用分组和排序进行数据检索时，可以显著减少查询中分组和排序的时间<br>​    缺点<br>​        创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。<br>​        索引需要使用物理文件存储，也会耗费一定空间<br>​    ==追问==<br>​        <strong>==使用索引一定能提高查询性能吗==</strong><br>​            大多数情况下，索引查询都是比全表扫描要快的。<br>​            但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升</p><h4 id="为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键？"><a href="#为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键？" class="headerlink" title="为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键？"></a>为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键？</h4><p>​    为什么必须要有主键<br>​        如果设置了主键，就会使用主键作为聚集索引。<br>​        如果你没有创建主键，他会寻找一个不为null的字段作为主键索引。<br>​        如果还是没有则会隐式的创建一个字段作为主键。<br>​    为什么使用整型<br>​        1.整型比较比字符串要快，因为字符串要逐个比较ASCII值，节省硬盘空间；整型容易比较大小进行排序<br>​    为什么要求自增<br>​        mysql为了维护索引的有序性，使得新增的主键会在B+tree叶子节点中最后末尾添加，使得树分叉概率变小<br>​        换句话说，如果不是自增的，B+树会自己做调整，分裂出新节点，效率不如自增</p><h4 id="为什么非主键索引结构叶子节点存储的是主键值？"><a href="#为什么非主键索引结构叶子节点存储的是主键值？" class="headerlink" title="为什么非主键索引结构叶子节点存储的是主键值？"></a>为什么非主键索引结构叶子节点存储的是主键值？</h4><p>​    1.节省存储空间<br>​    2.一致性：若非主键索引也存了完整的数据记录，那么非主键索引和主键索引的索引文件要保证数据一致性的问题</p><h4 id="B树和B-树区别"><a href="#B树和B-树区别" class="headerlink" title="==B树和B+树区别=="></a>==B树和B+树区别==</h4><p>​    共同点<br>​        节点中的数据索引从左到右递增排列<br>​    B树所有节点都存索引和数据，B+树只有叶子结点存数据<br>​    B+树叶子结点用指针连接<br>​        与范围查找相关如rol&gt;20:B+树可以顺着找到的结点找下去，而B树只能从根节点重新找<br>​    按照B树，一个结点1KB的数据，一页能放16个结点，树的高度要远远大于3</p><h4 id="为什么用B-树不用B树"><a href="#为什么用B-树不用B树" class="headerlink" title="==为什么用B+树不用B树=="></a>==为什么用B+树不用B树==</h4><p>​    按照B树，一个结点1KB的数据，一页能放16个结点，树的高度要远远大于3<br>​    与范围查找相关，如rol&gt;20:B+树可以顺着找到的结点找下去，而B树只能从根节点重新找</p><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="什么是前缀索引？"><a href="#什么是前缀索引？" class="headerlink" title="什么是前缀索引？"></a>什么是前缀索引？</h4><p>前缀索引也叫局部索引，比如给身份证的前 10 位添加索引，类似这种给某列部分信息添加索引的方式叫做前缀索引。</p><h4 id="为什么要用前缀索引？"><a href="#为什么要用前缀索引？" class="headerlink" title="为什么要用前缀索引？"></a>为什么要用前缀索引？</h4><p>前缀索引能有效减小索引文件的大小，让每个索引页可以保存更多的索引值，从而提高了索引查询的速度。但前缀索引也有它的缺点，不能在 order by 或者 group by 中触发前缀索引，也不能把它们用于覆盖索引。</p><h4 id="什么情况下适合使用前缀索引？"><a href="#什么情况下适合使用前缀索引？" class="headerlink" title="什么情况下适合使用前缀索引？"></a>什么情况下适合使用前缀索引？</h4><p>当字符串本身可能比较长，而且前几个字符就开始不相同，适合使用前缀索引；相反情况下不适合使用前缀索引，比如，整个字段的长度为 20，索引选择性为 0.9，而我们对前 10 个字符建立前缀索引其选择性也只有 0.5，那么我们需要继续加大前缀字符的长度，但是这个时候前缀索引的优势已经不明显，就没有创建前缀索引的必要了。</p><h4 id="以下-or-查询有什么问题吗？该如何优化？"><a href="#以下-or-查询有什么问题吗？该如何优化？" class="headerlink" title="以下 or 查询有什么问题吗？该如何优化？"></a>以下 or 查询有什么问题吗？该如何优化？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where num=10 or num=20;</span><br></pre></td></tr></table></figure><p>答：如果使用 or 查询会使 MySQL 放弃索引而全表扫描，可以改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where num=10 union select * from t where num=20;</span><br></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务是什么？"><a href="#事务是什么？" class="headerlink" title="事务是什么？"></a>事务是什么？</h4><p>事务是一系列的数据库操作，是数据库应用的基本单位。MySQL 事务主要用于处理操作量大，复杂度高的数据。</p><h4 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h4><p>在 MySQL 中只有 InnDB 引擎支持事务，它的四个特性如下：</p><ul><li>原子性（Atomic）：要么全部执行，要么全部不执行；</li><li>一致性（Consistency）：事务的执行使得数据库从一种正确状态转化为另一种正确状态；</li><li>隔离性（Isolation）：在事务正确提交之前，不允许把该事务对数据的任何改变提供给其他事务；</li><li>持久性（Durability）：事务提交后，其结果永久保存在数据库中。</li></ul><p>==原子性，持久性侧重于研究事务本身不同，隔离性研究的是不同事务之间的相互影响。==</p><p>ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。</p><h4 id="并发事务一般有哪些问题？"><a href="#并发事务一般有哪些问题？" class="headerlink" title="并发事务一般有哪些问题？"></a>并发事务一般有哪些问题？</h4><ul><li><p>更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题，最后的更新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本，每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。 最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改，如果在前一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题。</p></li><li><p>脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务完成并提交前， 这条记录的数据就处于不一致状态； 这时， 另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些脏数据，并据此做进一步的处理，就会产生未提交的数据依赖关系，这种现象被形象地叫做脏读。</p></li><li><p>不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读” 。</p></li><li><p>幻读（Phantom Reads）： 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读” 。</p></li></ul><h4 id="MySQL-中有几种事务隔离级别？分别是什么？"><a href="#MySQL-中有几种事务隔离级别？分别是什么？" class="headerlink" title="MySQL 中有几种事务隔离级别？分别是什么？"></a>MySQL 中有几种事务隔离级别？分别是什么？</h4><p>MySQL 中有四种事务隔离级别，它们分别是：</p><ul><li><p>read uncommited：未提交读，读到未提交数据；</p></li><li><p>read committed：读已提交，也叫不可重复读，两次读取到的数据不一致；</p></li><li><p>repetable read：可重复读；</p></li><li><p>serializable：串行化，读写数据都会锁住整张表，数据操作不会出错，但并发性能极低，开发中很少用到。</p></li></ul><p>==MySQL 默认使用 REPEATABLE-READ 的事务隔离级别。==</p><h4 id="幻读和不可重复读的区别？"><a href="#幻读和不可重复读的区别？" class="headerlink" title="幻读和不可重复读的区别？"></a>幻读和不可重复读的区别？</h4><ul><li>不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）。</li><li>幻读的重点在于新增或者删除：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）。</li></ul><h4 id="并发事务有什么问题-隔离性-？应该如何解决？"><a href="#并发事务有什么问题-隔离性-？应该如何解决？" class="headerlink" title="==并发事务有什么问题(隔离性)？应该如何解决？=="></a>==并发事务有什么问题(隔离性)？应该如何解决？==</h4><p>并发事务可能造成：脏读、不可重复读和幻读等问题 ，这些问题其实都是数据库读一致性问题，==必须由数据库提供一定的事务隔离机制来解决==，解决方案如下：</p><ul><li>加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。</li><li>提供数据多版本并发控制（MultiVersion Concurrency Control，简称 MVCC 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取，从用户的角度来看，好象是数据库可以提供同一数据的多个版本。</li></ul><h4 id="什么是-MVCC？"><a href="#什么是-MVCC？" class="headerlink" title="什么是 MVCC？"></a>什么是 MVCC？</h4><p>MVCC 全称是多版本并发控制系统，InnoDB 和 Falcon 存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决幻读问题。</p><h4 id="MVCC-是怎么工作的？-事务隔离性的实现原理"><a href="#MVCC-是怎么工作的？-事务隔离性的实现原理" class="headerlink" title="MVCC 是怎么工作的？(事务隔离性的实现原理)"></a>MVCC 是怎么工作的？(事务隔离性的实现原理)</h4><blockquote><p>==在读已提交和可重复读隔离级别下实现==</p><p>自己的总结：MVCC机制的实现就是通过read-view机制与undo版本链比对机制，使得不同的事务会根据数据版本链对比规则读取 同一条数据在版本链上的不同版本数据。</p><p>read view机制：这个视图由执行查询时所有未提交事务id数组（数组里最小的id为min_id）和已创建的最大事务id（max_id）组成，事务里的任何sql查询结果需要从对应 版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。</p></blockquote><p>InnoDB 的 MVCC 是通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动新增，事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较。</p><h4 id="MySQL-事务实现原理是什么？"><a href="#MySQL-事务实现原理是什么？" class="headerlink" title="MySQL 事务实现原理是什么？"></a>MySQL 事务实现原理是什么？</h4><p><a href="https://blog.csdn.net/weixin_43337246/article/details/117968344" target="_blank" rel="noopener">事务的ACID实现原理</a></p><p>事务的实现是基于数据库的存储引擎，不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有InnoDB 和 NDB。 InnoDB 是高版本 MySQL 的默认的存储引擎，因此就以 InnoDB 的事务实现为例，InnoDB 是通过多版本并发控制（MVCC，Multiversion Concurrency Control ）解决不可重复读问题，加上间隙锁（也就是并发控制）解决幻读问题。因此 InnoDB 的 RR 隔离级别其实实现了串行化级别的效果，而且保留了比较好的并发性能。事务的隔离性是通过锁实现，==而事务的原子性、一致性和持久性则是通过事务日志实现==。</p><p>原子性：InnoDB能够实现回滚的主要原因就是靠undo log： 当事务对数据库进行修改的时候，InnoDB会生成对应的undo log ；如果此时事务执行失败或者调动了 rollback，导致事务出现回滚情况，可以利用undo log中的信息将数据回滚到修改前的样子。</p><p>持久性：BufferPool缓存机制+redo log + binlog</p><p>一致性：一致性是事物追求的最终目标，前面提到的原子性，隔离性，持久性都是为了保证数据库的一致性。此外除了数据库底层的保障，一致性的实现也需要应用层的保障。数据库通过原子性、隔离性、持久性来保证一致性。</p><p>隔离性：MVCC解决写+读；解锁解决写+写</p><h4 id="REPEATABLE-READ（可重读）隔离级别下-MVCC-如何工作？"><a href="#REPEATABLE-READ（可重读）隔离级别下-MVCC-如何工作？" class="headerlink" title="REPEATABLE READ（可重读）隔离级别下 MVCC 如何工作？"></a>REPEATABLE READ（可重读）隔离级别下 MVCC 如何工作？</h4><ul><li>SELECT：InnoDB 会根据以下条件检查每一行记录：第一，InnoDB 只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行要么是在开始事务之前已经存在要么是事务自身插入或者修改过的。第二，行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除。</li><li>INSERT：InnoDB 为新插入的每一行保存当前系统版本号作为行版本号。</li><li>DELETE：InnoDB 为删除的每一行保存当前系统版本号作为行删除标识。</li><li>UPDATE：InnoDB 为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识保存这两个版本号，使大多数操作都不用加锁。它不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。</li></ul><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h4 id="redo-log-和-binlog-有什么区别？"><a href="#redo-log-和-binlog-有什么区别？" class="headerlink" title="redo log 和 binlog 有什么区别？"></a>redo log 和 binlog 有什么区别？</h4><p>redo log（重做日志）和 binlog（归档日志）都是 MySQL 的重要的日志，它们的区别如下：</p><ul><li><p>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”。</p></li><li><p>binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</p></li><li><p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p></li><li><p>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p></li></ul><p>最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统，也就是 redo log 来实现 crash-safe 能力。</p><h4 id="如何解决-bin-log-与-redo-log-的一致性问题？"><a href="#如何解决-bin-log-与-redo-log-的一致性问题？" class="headerlink" title="==如何解决 bin log 与 redo log 的一致性问题？=="></a>==如何解决 bin log 与 redo log 的一致性问题？==</h4><p>其实就是BufferBool那一块的内容</p><p>所谓两阶段提交，其实就是把 redo log 的写入拆分成了两个步骤：prepare 和 commit。<br>首先，存储引擎将执行更新好的新数据存到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 <code>prepare</code> 状态。然后告知执行器执行完成了，随时可以提交事务<br>然后执行器生成这个操作的 bin log，并把 bin log 写入磁盘<br>最后执行器调用存储引擎的提交事务接口，存储引擎把刚刚写入的 redo log 状态改成提交（<code>commit</code>）状态，更新完成</p><p>如果数据库在写入 redo log(prepare) 阶段之后、写入 binlog 之前，发生了崩溃：<br>此时 redo log 里面的事务处于 prepare 状态，binlog 还没写，之后从库进行同步的时候，无法执行这个操作，但是实际上主库已经完成了这个操作，所以为了主备一致，MySQL 崩溃时会在主库上回滚这个事务<br>而如果数据库在写入 binlog 之后，redo log 状态修改为 commit 前发生崩溃，此时 redo log 里面的事务仍然是 prepare 状态，binlog 存在并完整，这样之后就会被从库同步过去，但是实际上主库并没有完成这个操作，所以为了主备一致，即使在这个时刻数据库崩溃了，主库上事务仍然会被正常提交。</p><p><img alt="img" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Mysql/20230130202826.png"></p><h4 id="一条-SQL-更新语句是如何执行的？"><a href="#一条-SQL-更新语句是如何执行的？" class="headerlink" title="一条 SQL 更新语句是如何执行的？"></a>一条 SQL 更新语句是如何执行的？</h4><p>同上</p><h4 id="讲一下-redo-log-redo-log-两阶段提交原理"><a href="#讲一下-redo-log-redo-log-两阶段提交原理" class="headerlink" title="讲一下 redo log / redo log 两阶段提交原理"></a>讲一下 redo log / redo log 两阶段提交原理</h4><p>同上</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="MySQL-的优化手段都有哪些？"><a href="#MySQL-的优化手段都有哪些？" class="headerlink" title="MySQL 的优化手段都有哪些？"></a>MySQL 的优化手段都有哪些？</h4><p>MySQL 的常见的优化手段有以下五种：</p><h5 id="①-查询优化"><a href="#①-查询优化" class="headerlink" title="① 查询优化"></a>① 查询优化</h5><ul><li><p>避免 SELECT *，只查询需要的字段。</p></li><li><p>小表驱动大表，即小的数据集驱动大的数据集，比如，当 B 表的数据集小于 A 表时，用 in 优化 exist，两表执行顺序是先查 B 表，再查 A 表，查询语句：select * from A where id in (select id from B) 。</p></li><li><p>一些情况下，可以使用连接代替子查询，因为使用 join 时，MySQL 不会在内存中创建临时表。</p></li></ul><h5 id="②-优化索引的使用"><a href="#②-优化索引的使用" class="headerlink" title="② 优化索引的使用"></a>② 优化索引的使用</h5><ul><li><p>尽量使用主键查询，而非其他索引，因为主键查询不会触发回表查询。</p></li><li><p>不做列运算，把计算都放入各个业务系统实现</p></li><li><p>查询语句尽可能简单，大语句拆小语句，减少锁时间</p></li><li><p>不使用 select * 查询</p></li><li><p>or 查询改写成 in 查询</p></li><li><p>不用函数和触发器</p></li><li><p>避免 %xx 查询</p></li><li><p>少用 join 查询</p></li><li><p>使用同类型比较，比如 ‘123’ 和 ‘123’、123 和 123</p></li><li><p>尽量避免在 where 子句中使用 != 或者 &lt;&gt; 操作符，查询引用会放弃索引而进行全表扫描</p></li><li><p>列表数据使用分页查询，每页数据量不要太大</p></li><li><p>用 exists 替代 in 查询</p></li><li><p>避免在索引列上使用 is null 和 is not null</p></li><li><p>尽量使用主键查询</p></li><li><p>避免在 where 子句中对字段进行表达式操作</p></li><li><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型</p></li></ul><h5 id="③-表结构设计优化"><a href="#③-表结构设计优化" class="headerlink" title="③ 表结构设计优化"></a>③ 表结构设计优化</h5><ul><li><p>使用可以存下数据最小的数据类型。</p></li><li><p>使用简单的数据类型，int 要比 varchar 类型在 MySQL 处理简单。</p></li><li><p>尽量使用 tinyint、smallint、mediumint 作为整数类型而非 int。</p></li><li><p>尽可能使用 not null 定义字段，因为 null 占用 4 字节空间。</p></li><li><p>尽量少用 text 类型，非用不可时最好考虑分表。</p></li><li><p>尽量使用 timestamp，而非 datetime。</p></li><li><p>单表不要有太多字段，建议在 20 个字段以内。</p></li></ul><h5 id="④-表拆分"><a href="#④-表拆分" class="headerlink" title="④ 表拆分"></a>④ 表拆分</h5><p>当数据库中的数据非常大时，查询优化方案也不能解决查询速度慢的问题时，我们可以考虑拆分表，让每张表的数据量变小，从而提高查询效率。 <strong>a）垂直拆分</strong>：是指数据表列的拆分，把一张列比较多的表拆分为多张表，比如，用户表中一些字段经常被访问，将这些字段放在一张表中，另外一些不常用的字段放在另一张表中，插入数据时，使用事务确保两张表的数据一致性。 垂直拆分的原则：</p><ul><li><p>把不常用的字段单独放在一张表；</p></li><li><p>把 text，blob 等大字段拆分出来放在附表中；</p></li><li><p>经常组合查询的列放在一张表中。</p></li></ul><p><strong>b）水平拆分</strong>：指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。</p><p>通常情况下，我们使用取模的方式来进行表的拆分，比如，一张有 400W 的用户表 users，为提高其查询效率我们把其分成 4 张表 users1，users2，users3，users4，然后通过用户 ID 取模的方法，同时查询、更新、删除也是通过取模的方法来操作。</p><h5 id="⑤-读写分离"><a href="#⑤-读写分离" class="headerlink" title="⑤ 读写分离"></a>⑤ 读写分离</h5><p>一般情况下对数据库而言都是“读多写少”，换言之，数据库的压力多数是因为大量的读取数据的操作造成的，我们可以采用数据库集群的方案，使用一个库作为主库，负责写入数据；其他库为从库，负责读取数据。这样可以缓解对数据库的访问压力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;h4 id=&quot;说一下-MySQL-执行一条查询语句的内部执行过程？&quot;&gt;&lt;a href=&quot;#说一下-MySQL-执行一条查询语句的内部执行过程？&quot;
      
    
    </summary>
    
    
      <category term="面试题" scheme="https://alexander-wd.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="mysql" scheme="https://alexander-wd.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础面试题</title>
    <link href="https://alexander-wd.github.io/2022/09/29/%E9%9D%A2%E8%AF%95%E9%A2%98/java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://alexander-wd.github.io/2022/09/29/%E9%9D%A2%E8%AF%95%E9%A2%98/java%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-09-29T09:10:20.000Z</published>
    <updated>2023-02-13T10:09:48.651Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="JAVA概述"><a href="#JAVA概述" class="headerlink" title="JAVA概述"></a>JAVA概述</h4><h5 id="1-JVM、JRE和JDK的关系"><a href="#1-JVM、JRE和JDK的关系" class="headerlink" title="1.JVM、JRE和JDK的关系"></a>1.JVM、JRE和JDK的关系</h5><blockquote><p>JDK包含JRE，JRE包含JVM</p><p>JDK=开发工具(java.exe,javac.exe等等)+JRE</p><p>JRE=核心类库(util,concurrent等等)+JVM</p></blockquote><h5 id="2-什么是跨平台性？原理是什么"><a href="#2-什么是跨平台性？原理是什么" class="headerlink" title="2.什么是跨平台性？原理是什么"></a>2.什么是跨平台性？原理是什么</h5><blockquote><p>跨平台性<br>    一次编译到处执行</p><p>原理<br>    Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序</p></blockquote><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><h5 id="1-Java有哪些数据类型"><a href="#1-Java有哪些数据类型" class="headerlink" title="1.Java有哪些数据类型"></a>1.Java有哪些数据类型</h5><blockquote><p>基本数据类型<br>    数值型<br>        整数类型(byte,short,int,long)<br>        浮点类型(float,double)<br>    字符型(char)<br>    布尔型(boolean)</p><p>引用数据类型(String等)</p></blockquote><h5 id="2-用最有效率的方法计算-2-乘以-8"><a href="#2-用最有效率的方法计算-2-乘以-8" class="headerlink" title="2.用最有效率的方法计算 2 乘以 8"></a>2.用最有效率的方法计算 2 乘以 8</h5><blockquote><p>2&lt;&lt;3</p></blockquote><h5 id="3-float-f-3-4-是否正确"><a href="#3-float-f-3-4-是否正确" class="headerlink" title="3.float f=3.4;是否正确"></a>3.float f=3.4;是否正确</h5><blockquote><p>不正确<br>    3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失<br>    因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;</p></blockquote><h5 id="4-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#4-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="4.short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗"></a>4.short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</h5><blockquote><p>前者不对，后者对<br>由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型<br>因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换，所以后者对</p></blockquote><h5 id="5-访问修饰符-public-private-protected-以及不写（默认）时的区别"><a href="#5-访问修饰符-public-private-protected-以及不写（默认）时的区别" class="headerlink" title="==5.访问修饰符 public,private,protected,以及不写（默认）时的区别=="></a><strong>==5.访问修饰符 public,private,protected,以及不写（默认）时的区别==</strong></h5><blockquote><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/java基础/20230103193453.png"></p><p>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）<br>default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。<br>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</p><p>public : 对所有类可见。使用对象：类、接口、变量、方法</p></blockquote><h5 id="6-final-有什么用"><a href="#6-final-有什么用" class="headerlink" title="==6.final 有什么用=="></a>==6.final 有什么用==</h5><blockquote><p><strong>被final修饰的类不可以被继承</strong><br><strong>被final修饰的方法不可以被重写</strong><br><strong>被final修饰的变量不可以被改变</strong>，被final修饰不可变的是变量的引用(堆中的)，而不是引用本身(栈中的)，引用本身是可以改变的</p></blockquote><h5 id="7-final-finally-finalize区别"><a href="#7-final-finally-finalize区别" class="headerlink" title="7.final finally finalize区别"></a>7.final finally finalize区别</h5><blockquote><p>final可以修饰类、变量、方法<br>    参考Q.6<br>finally一般作用在try-catch代码块中，无论是否发生异常，finally的代码块都会执行<br>finalize是一个方法，属于Object类的一个方法<br>    当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断</p></blockquote><h5 id="8-在-Java-中，如何跳出当前的多重嵌套循环"><a href="#8-在-Java-中，如何跳出当前的多重嵌套循环" class="headerlink" title="8.在 Java 中，如何跳出当前的多重嵌套循环"></a>8.在 Java 中，如何跳出当前的多重嵌套循环</h5><blockquote><p>可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环</p></blockquote><h4 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h4><h5 id="1-重写和重载的区别？重载中方法的返回值可以相同吗？"><a href="#1-重写和重载的区别？重载中方法的返回值可以相同吗？" class="headerlink" title="1.重写和重载的区别？重载中方法的返回值可以相同吗？"></a>1.重写和重载的区别？重载中方法的返回值可以相同吗？</h5><blockquote><p>重写(override)⽅法原则<br>    1.⼦类的⽅法的名称必须和所覆盖的⽅法相同<br>    2.⼦类的⽅法的参数必须和所覆盖的⽅法相同<br>    3.⼦类的返回类型必须和所覆盖的⽅法相同 （除过⼦类中⽅法的返回类型是⽗类中返回类型的⼦类）<br>    4.⼦类抛出异常⼩于等于⽗类⽅法抛出异常<br>    5.⼦类访问权限⼤于等于⽗类⽅法访问权限<br>重载(overload)⽅法原则<br>    1.⽅法名必须相同<br>    2.⽅法的参数列表不相同（包括参数类型，参数个数，参数顺序）<br>    3.⽅法的返回类型和⽅法的修饰符可以不相同<br>总结<br>    方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性<br>    ⽅法重载的返回值类型可以不相同，⽅法重写的返回类型必须相同，否则编译报错</p></blockquote><h5 id="2-JAVA支持多继承吗，如果想要多继承怎么办？"><a href="#2-JAVA支持多继承吗，如果想要多继承怎么办？" class="headerlink" title="2.JAVA支持多继承吗，如果想要多继承怎么办？"></a>2.JAVA支持多继承吗，如果想要多继承怎么办？</h5><blockquote><p>不支持，可以考虑多实现、内部类、多层继承</p></blockquote><h5 id="3-抽象类和接口的区别，抽象类和接口可以实例化吗？"><a href="#3-抽象类和接口的区别，抽象类和接口可以实例化吗？" class="headerlink" title="3.抽象类和接口的区别，抽象类和接口可以实例化吗？"></a>3.抽象类和接口的区别，抽象类和接口可以实例化吗？</h5><blockquote><p>共同点：都不能实例化</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:left">声明</th><th style="text-align:left">实现</th><th style="text-align:left">构造器</th><th style="text-align:left">访问修饰符</th><th style="text-align:left">多继承</th><th style="text-align:left">字段声明</th></tr></thead><tbody><tr><td style="text-align:center">抽象类</td><td style="text-align:left">抽象类使用abstract关键字声明</td><td style="text-align:left">子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td><td style="text-align:left">抽象类可以有构造器</td><td style="text-align:left">抽象类中的方法可以是任意访问修饰符</td><td style="text-align:left">一个类最多只能继承一个抽象类</td><td style="text-align:left">抽象类的字段声明可以是任意的</td></tr><tr><td style="text-align:center">接口</td><td style="text-align:left">接口使用interface关键字声明</td><td style="text-align:left">子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现</td><td style="text-align:left">接口不能有构造器</td><td style="text-align:left">接口方法默认修饰符是public。并且不允许定义为 private 或者 protected</td><td style="text-align:left">一个类可以实现多个接口</td><td style="text-align:left">接口的字段默认都是 static 和 final 的</td></tr></tbody></table></div><p>参考Q.5</p></blockquote><h5 id="4-String可以被继承吗"><a href="#4-String可以被继承吗" class="headerlink" title="4.String可以被继承吗"></a>4.String可以被继承吗</h5><blockquote><p>不能被继承,因为String类有final修饰符</p></blockquote><h5 id="5-抽象类和接口的对比"><a href="#5-抽象类和接口的对比" class="headerlink" title="5.抽象类和接口的对比"></a>5.抽象类和接口的对比</h5><blockquote><p>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。<br>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。<br>相同点<br>    接口和抽象类都不能实例化<br>    都位于继承的顶端，用于被其他实现或继承<br>    都包含抽象方法，其子类都必须覆写这些抽象方法</p></blockquote><h5 id="6-内部类的分类有哪些"><a href="#6-内部类的分类有哪些" class="headerlink" title="6.内部类的分类有哪些"></a>6.内部类的分类有哪些</h5><blockquote><p>静态内部类<br>成员内部类<br>局部内部类<br>匿名内部类<br>    就是没有名字的内部类，日常开发中使用的比较多</p></blockquote><h5 id="7-内部类的优点"><a href="#7-内部类的优点" class="headerlink" title="7.内部类的优点"></a>7.内部类的优点</h5><blockquote><p><strong>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</strong><br>内部类不为同一包的其他类所见，具有很好的封装性；<br>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。<br>匿名内部类可以很方便的定义回调。</p></blockquote><h5 id="8-局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final"><a href="#8-局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final" class="headerlink" title="==8.局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final=="></a>==8.局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final==</h5><blockquote><p>是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在(该匿名内部类作为返回值返回了)，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题<br><a href="https://blog.csdn.net/Angiexia/article/details/21244303?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164335989916780269832426%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164335989916780269832426&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-21244303.pc_search_insert_es_download&amp;utm_term=%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AA%E8%83%BD%E8%AE%BF%E9%97%AEfinal%E5%8F%98%E9%87%8F%E8%AF%A6%E7%BB%86%E4%BE%8B%E5%AD%90&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener">参考</a></p></blockquote><h5 id="9-String中equals与-的区别"><a href="#9-String中equals与-的区别" class="headerlink" title="9.String中equals与==的区别"></a>9.String中equals与==的区别</h5><blockquote><p>equals比较的是值比较<br>\==表示：<br>    引用数据类型比较引用地址<br>    基本数据类型比较值</p></blockquote><h5 id="10-hashCode-与-equals"><a href="#10-hashCode-与-equals" class="headerlink" title="==10.hashCode 与 equals=="></a>==10.hashCode 与 equals==</h5><blockquote><p>Object中的实现<br>    hashcode()<br>        本地方法，返回调用对象在内存堆上的独特值<br>    equals()<br>        this==obj<br>为什么散列表hash一定要重写hashcode和equals<br>    步骤<br>        先调用hashcode比较是否相等(是否在一个bucket中)<br>        如果Hashcode相等，再调用equals判断是否是一个对象(属性是否相同)<br>equals 方法被覆盖过，则 hashCode 方法也必须被覆盖<br>    若hashcode不重写，默认调用Object的，无论如何hashcode都不会相等</p><p>​    若equals不重写，默认调用Object的，除非是同一个对象，否则就算属性值相同也会返回false。</p><p>总结<br>    当我们需要将某一个类的对象存入散列表时（如 HashMap、HashTable 等），hashCode 和 equals 都必须重写</p><p><a href="https://blog.csdn.net/qq_46698411/article/details/119753966?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-119753966-blog-113819810.t0_layer_searchtargeting_s&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3" target="_blank" rel="noopener">原理</a>    <a href="https://blog.csdn.net/qq_43842093/article/details/117387063?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-117387063-blog-125721508.pc_relevant_aa&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3" target="_blank" rel="noopener">例子</a></p></blockquote><h5 id="11-值传递和引用传递有什么区别"><a href="#11-值传递和引用传递有什么区别" class="headerlink" title="11.值传递和引用传递有什么区别"></a>11.值传递和引用传递有什么区别</h5><blockquote><p>值传递<br>    传的是值的拷贝<br>引用传递<br>    传的是引用地址(即存在栈中的)</p></blockquote><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="1-说一下JAVA中的泛型"><a href="#1-说一下JAVA中的泛型" class="headerlink" title="1.说一下JAVA中的泛型?"></a>1.说一下JAVA中的泛型?</h5><blockquote><p>使用泛型参数，可以增强代码的可读性以及稳定性<br>泛型一般有三种使用方式:泛型类、泛型接口、泛型方法</p></blockquote><h5 id="2-Java-int-和Integer的区别，怎样比较int和Integer类型的值是否相等。"><a href="#2-Java-int-和Integer的区别，怎样比较int和Integer类型的值是否相等。" class="headerlink" title="==2.Java int 和Integer的区别，怎样比较int和Integer类型的值是否相等。=="></a>==2.Java int 和Integer的区别，怎样比较int和Integer类型的值是否相等。==</h5><blockquote><p>区别<br>    1.Integer是int的包装类，int则是java的一种基本数据类型<br>    2.Integer变量必须实例化后才能使用，而int变量不需要<br>    3.Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值<br>    4.Integer的默认值是null，int的默认值是0<br>int和Integer比较<br>    Integer会自动拆箱，相当于两个int比较<br>缓存机制<br>    如对于两个非new生成的Integer对象(值在-128~127之间，会从缓存中拿)<br>自动装箱和自动装箱<br>    装箱：将基本类型用它们对应的引用类型包装起来；<br>        Integer i = 10;  //装箱<br>        等价于Integer i = Integer.valueOf(10)<br>    拆箱：将包装类型转换为基本数据类型；<br>        int n = i;   //拆箱<br>        等价于int n = i.intValue()</p></blockquote><h5 id="3-java-中-IO-流分为几种"><a href="#3-java-中-IO-流分为几种" class="headerlink" title="3.java 中 IO 流分为几种"></a>3.java 中 IO 流分为几种</h5><blockquote><p>按照流的流向分，可以分为输入流和输出流；<br>按照操作单元划分，可以划分为字节流和字符流；<br>按照流的角色划分为节点流和处理流<br>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。<br>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流</p></blockquote><h5 id="4-BIO-NIO-AIO-有什么区别"><a href="#4-BIO-NIO-AIO-有什么区别" class="headerlink" title="4.BIO,NIO,AIO 有什么区别"></a>4.BIO,NIO,AIO 有什么区别</h5><blockquote><p>BIO<br>    Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低<br>NIO<br>    Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用<br>AIO<br>    实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制</p></blockquote><h5 id="5-什么是反射机制"><a href="#5-什么是反射机制" class="headerlink" title="5.什么是反射机制"></a>5.什么是反射机制</h5><blockquote><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性</p></blockquote><h5 id="6-反射机制优缺点"><a href="#6-反射机制优缺点" class="headerlink" title="6.反射机制优缺点"></a>6.反射机制优缺点</h5><blockquote><p>优点： 运行期类型的判断，动态加载类，提高代码灵活度。<br>缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</p></blockquote><h5 id="7-获取反射的三种方法"><a href="#7-获取反射的三种方法" class="headerlink" title="7.获取反射的三种方法"></a>7.获取反射的三种方法</h5><blockquote><p>通过建立对象<br>    Student stu = new Student();<br>    Class classobj1 = stu.getClass();<br>所在通过路径-相对路径<br>    Class classobj2 = Class.forName(“fanshe.Student”)<br>通过类名<br>    Class classobj3 = Student.class</p></blockquote><h5 id="8-String的特性"><a href="#8-String的特性" class="headerlink" title="==8.String的特性=="></a>==8.String的特性==</h5><blockquote><p><strong>不变性</strong><br>    定义了final char value[]的成员变量<br>    但是引用自身(栈中)可以改变，但是引用指向的内容(堆中)不能变<br>字符串常量池<br>    位于堆内存，提高内存的使用率<br>final<br>    不可被继承</p></blockquote><h5 id="9-在使用-HashMap-的时候，用-String-做-key-有什么好处"><a href="#9-在使用-HashMap-的时候，用-String-做-key-有什么好处" class="headerlink" title="9.在使用 HashMap 的时候，用 String 做 key 有什么好处"></a>9.在使用 HashMap 的时候，用 String 做 key 有什么好处</h5><blockquote><p><strong>因为String的不变性</strong>，它的hashcode被缓存了下来，不需要被再次计算，速度比其他对象更快</p></blockquote><h5 id="10-String和StringBuffer、StringBuilder的区别是什么"><a href="#10-String和StringBuffer、StringBuilder的区别是什么" class="headerlink" title="==10.String和StringBuffer、StringBuilder的区别是什么=="></a>==10.String和StringBuffer、StringBuilder的区别是什么==</h5><blockquote><p>可变性<br>    <strong>String 是不可变的</strong><br>    StringBuilder与StringBuffer都继承自AbstractStringBuilder类，定义了char[] value，这两种对象都是可变的<br>线程安全性<br>    String中的对象是不可变的，也就可以理解为常量，线程安全<br>    StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的<br>    StringBuilder并没有对方法进行加同步锁，所以是非线程安全的<br>性能<br>    每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象<br>    StringBuffer和StringBuilder每次都会对对象本身进行操作，而不是生成新的对象并改变对象引用<br>总结<br>    如果要操作少量的数据用 =&gt; String<br>    单线程操作字符串缓冲区 下操作大量数据 =&gt; StringBuilder<br>    多线程操作字符串缓冲区 下操作大量数据 =&gt; StringBuffer</p></blockquote><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h4><h5 id="1-说说-List-Set-Queue-Map-四者的区别"><a href="#1-说说-List-Set-Queue-Map-四者的区别" class="headerlink" title="1.说说 List, Set, Queue, Map 四者的区别"></a>1.说说 List, Set, Queue, Map 四者的区别</h5><blockquote><p><img alt="2" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/java基础/20230104201918.png"></p><p>如上图所示</p><p>List<br>    存储的元素是有序的、可重复的。<br>Set<br>    存储的元素是无序的、不可重复的。<br>Queue<br>    按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。<br>Map<br>    使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</p></blockquote><h5 id="2-集合框架底层数据结构"><a href="#2-集合框架底层数据结构" class="headerlink" title="==2.集合框架底层数据结构=="></a>==2.集合框架底层数据结构==</h5><blockquote><p> Collection<br>     List<br>         Arraylist： Object数组<br>         Vector： Object数组<br>         LinkedList： 双向循环链表<br>     Set<br>         HashSet（无序，唯一）<br>             基于 HashMap 实现的，底层采用 HashMap 来保存元素<br>         LinkedHashSet<br>             LinkedHashSet 继承于HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。<br>         TreeSet（有序，唯一）<br>              红黑树(自平衡的排序二叉树。)<br> Map<br>     HashMap<br>         JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间<br>     LinkedHashMap<br>         LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。<br>     HashTable<br>         数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的<br>     TreeMap<br>         红黑树（自平衡的排序二叉树）</p></blockquote><h5 id="3-Java集合的快速失败机制-“fail-fast”"><a href="#3-Java集合的快速失败机制-“fail-fast”" class="headerlink" title="3.Java集合的快速失败机制 “fail-fast”"></a>3.Java集合的快速失败机制 “fail-fast”</h5><blockquote><p>是java集合的一种错误检测机制，如在增强for循环(foreach)中remove</p><p>会触发ConcurrentModificationException</p><p><a href="https://blog.csdn.net/weixin_50276625/article/details/115157076" target="_blank" rel="noopener">详解</a>   <a href="https://blog.csdn.net/feiying0canglang/article/details/124853294" target="_blank" rel="noopener">正确使用方法</a></p></blockquote><h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><h5 id="1-迭代器-Iterator-是什么"><a href="#1-迭代器-Iterator-是什么" class="headerlink" title="1.迭代器 Iterator 是什么"></a>1.迭代器 Iterator 是什么</h5><blockquote><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例</p></blockquote><h5 id="2-Iterator-和-ListIterator-有什么区别"><a href="#2-Iterator-和-ListIterator-有什么区别" class="headerlink" title="2.Iterator 和 ListIterator 有什么区别"></a>2.Iterator 和 ListIterator 有什么区别</h5><blockquote><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li><li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li></ul></blockquote><h5 id="3-ArrayList-和-LinkedList-的区别是什么"><a href="#3-ArrayList-和-LinkedList-的区别是什么" class="headerlink" title="==3.ArrayList 和 LinkedList 的区别是什么=="></a>==3.ArrayList 和 LinkedList 的区别是什么==</h5><blockquote><p>区别</p><ul><li><p>数据结构实现<br>  ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</p></li><li><p>随机访问效率<br>  ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p></li><li>增加和删除效率<br>  在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li><li>内存空间占用<br>  LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li><li>线程安全<br>  ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全</li></ul><p>总结<br>使用ArrayList就行，LinkedList创作者自己都不用</p></blockquote><h5 id="4-ArrayList-和-Vector-的区别是什么"><a href="#4-ArrayList-和-Vector-的区别是什么" class="headerlink" title="==4.ArrayList 和 Vector 的区别是什么=="></a>==4.ArrayList 和 Vector 的区别是什么==</h5><blockquote><ul><li>线程安全<br>  Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li><li>性能<br>  ArrayList 在性能方面要优于 Vector。</li><li>扩容<br>  ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%</li></ul></blockquote><h5 id="5-多线程场景下如何使用-ArrayList"><a href="#5-多线程场景下如何使用-ArrayList" class="headerlink" title="==5.多线程场景下如何使用 ArrayList=="></a>==5.多线程场景下如何使用 ArrayList==</h5><blockquote><p>可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用</p></blockquote><h5 id="6-为什么-ArrayList-的-elementData-加上-transient-修饰"><a href="#6-为什么-ArrayList-的-elementData-加上-transient-修饰" class="headerlink" title="6.为什么 ArrayList 的 elementData 加上 transient 修饰"></a>6.为什么 ArrayList 的 elementData 加上 transient 修饰</h5><blockquote><p><strong>对于transient 修饰的成员变量，在类的实例对象的序列化处理过程中会被忽略。</strong></p><p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，<strong>这样既加快了序列化的速度，又减小了序列化之后的文件大小</strong></p></blockquote><h5 id="7-说一说-ArrayList-的扩容机制吧"><a href="#7-说一说-ArrayList-的扩容机制吧" class="headerlink" title="==7.说一说 ArrayList 的扩容机制吧=="></a>==7.说一说 ArrayList 的扩容机制吧==</h5><blockquote><p> 底层维护了一个数组，add()首先判断容量够不够，不够按照原容量的1.5倍扩容(System.arraycopy)，然后添加进数组</p></blockquote><h4 id="set接口"><a href="#set接口" class="headerlink" title="set接口"></a>set接口</h4><h5 id="1-list和set区别"><a href="#1-list和set区别" class="headerlink" title="1.list和set区别"></a>1.list和set区别</h5><blockquote><p>list<br>    有序容器(元素存入集合的顺序和取出的顺序一致)<br>    可重复<br>    检索效率高，删除插入效率低<br>set<br>    无序<br>    不可重复<br>    检索效率低，删除插入效率高</p></blockquote><h5 id="2-说一下-HashSet-的实现原理"><a href="#2-说一下-HashSet-的实现原理" class="headerlink" title="==2.说一下 HashSet 的实现原理=="></a>==2.说一下 HashSet 的实现原理==</h5><blockquote><p>基于HashMap实现，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT。参考HashMap。相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><p>HashSet部分源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">&gt; <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;  map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">&gt;  <span class="comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span></span><br><span class="line">&gt; <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h5 id="3-HashSet和HashMap的区别"><a href="#3-HashSet和HashMap的区别" class="headerlink" title="3.HashSet和HashMap的区别"></a>3.HashSet和HashMap的区别</h5><blockquote><p>HashMap<br>    实现了Map接口<br>    存储键值对<br>    调用put（）向map中添加元素<br>    HashMap使用键（Key）计算Hashcode<br>    HashMap相对于HashSet较快，因为它是使用唯一的键获取对象<br>HashSet<br>    实现Set接口<br>    仅存储对象<br>    调用add（）方法向Set中添加元素<br>    HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false<br>    HashSet较HashMap来说比较慢</p><p><strong>==两者性能上的疑问解答：==</strong></p><p><strong>==它们都必须计算哈希码，但要考虑HashMap的键的性质 - 它通常是一个简单的字符串甚至是一个数字。计算它的哈希码比整个对象的默认哈希码计算快得多。如果HashMap的键与存储在HashSet中的键相同，那么性能就没有真正的区别。不同之处在于HashMap的关键是什么类型的对象。==</strong></p></blockquote><h4 id="map接口"><a href="#map接口" class="headerlink" title="==map接口=="></a>==map接口==</h4><h5 id="1-说一下-HashMap-的实现原理"><a href="#1-说一下-HashMap-的实现原理" class="headerlink" title="==1.说一下 HashMap 的实现原理=="></a>==1.说一下 HashMap 的实现原理==</h5><blockquote><p>JDK1.7<br>    计算key的hash，hash相同的话，比较key；key相同，覆盖原值，key不同，放入链表中；最后检查Map中元素个数是否大于阈值，是的话，扩容<br>    拉链法示意图</p><p>​    <img alt="3" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/java基础/20230104213314.png"></p><p>JDK1.8后<br>    1.在初始化的时候走resize()<br>    2.在插入值的时候判断是否是树节点，是的话，走红黑树插入流程，否则，走插入链表的流程，插入完之后，检查链表长度是否大于8，是的话，转换为红黑树，最后检查Map中元素个数是否大于阈值，是的话，扩容<br>    数组+链表+红黑树示意图</p><p>​    <img alt="4" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/java基础/20230104213326.png"></p></blockquote><h5 id="2-HashMap-JDK1-7与JDK1-8比较"><a href="#2-HashMap-JDK1-7与JDK1-8比较" class="headerlink" title="2.HashMap(JDK1.7与JDK1.8比较)"></a>2.HashMap(JDK1.7与JDK1.8比较)</h5><div class="table-container"><table><thead><tr><th></th><th>存储结构</th><th>初始化方式</th><th>hash值计算方式</th><th>插入数据方式</th><th>存放数据的规则</th><th>扩容后存储位置的计算方式</th><th>线程安全</th></tr></thead><tbody><tr><td>JDK1.7</td><td>数组 + 链表</td><td>单独函数：inflateTable()</td><td>扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算</td><td>头插法（先将原位置的数据移到后1位，再插入数据到该位置）</td><td>无冲突时，存放数组；冲突时，存放链表</td><td>全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td><td>不安全，多线程扩容时会形成环形链表</td></tr><tr><td>JDK1.8</td><td>数组 + 链表 + 红黑树</td><td>直接集成到了扩容函数resize()中</td><td>扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算</td><td>尾插法（直接插入到链表尾部/红黑树）</td><td>无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td><td>按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）</td><td>不安全，采用高低位拆分转移方式解决了多线程死循环问题。但仍是非线程安全的，多线程时可能会造成数据丢失问题</td></tr></tbody></table></div><h5 id="3-HashMap的put-具体流程-jdk1-8"><a href="#3-HashMap的put-具体流程-jdk1-8" class="headerlink" title="==3.HashMap的put()具体流程(jdk1.8)=="></a>==3.HashMap的put()具体流程(jdk1.8)==</h5><blockquote><p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；<br>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；<br>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；<br>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；<br>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；<br>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p><p>图解</p><p><img alt="5" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/java基础/20230104215122.png"></p></blockquote><h5 id="4-HashMap的扩容操作是怎么实现的"><a href="#4-HashMap的扩容操作是怎么实现的" class="headerlink" title="4.HashMap的扩容操作是怎么实现的"></a>4.HashMap的扩容操作是怎么实现的</h5><blockquote><p>①.在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；<br>②.每次扩展的时候，都是扩展2倍；<br>③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</p></blockquote><h5 id="5-HashMap是怎么解决哈希冲突的"><a href="#5-HashMap是怎么解决哈希冲突的" class="headerlink" title="==5.HashMap是怎么解决哈希冲突的=="></a>==5.HashMap是怎么解决哈希冲突的==</h5><blockquote><ol><li>使用链地址法（使用散列表）来链接拥有相同hash值的数据；</li><li>使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</li><li>引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</li></ol></blockquote><h5 id="6-为什么HashMap中String、Integer这样的包装类适合作为K"><a href="#6-为什么HashMap中String、Integer这样的包装类适合作为K" class="headerlink" title="6.为什么HashMap中String、Integer这样的包装类适合作为K"></a>6.为什么HashMap中String、Integer这样的包装类适合作为K</h5><blockquote><ol><li>都是final类型，即不可变性(hashCode() 值可以被缓存起来)，保证key的不可更改性，不会存在获取hash值不同的情况</li><li>内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</li></ol></blockquote><h5 id="7-HashMap-的长度为什么是2的幂次方"><a href="#7-HashMap-的长度为什么是2的幂次方" class="headerlink" title="7.HashMap 的长度为什么是2的幂次方"></a>7.HashMap 的长度为什么是2的幂次方</h5><blockquote><p>1.计算hashcode时，return h &amp; (length-1);因为要获取数组下标使用位运算，如果不是2的整数次幂，会出错<br>2.使用位运算，而不是用mod运算，是因为位运算效率比mod运算高得多，后续扩容效率更高。</p><p>==为什么是两次扰动呢?==<br>    加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的</p></blockquote><h5 id="8-加载因子为什么是0-75"><a href="#8-加载因子为什么是0-75" class="headerlink" title="8.加载因子为什么是0.75"></a>8.加载因子为什么是0.75</h5><blockquote><p>加载因子又叫负载因子，表示HashMap表中元素的填满的程度</p><p>时间和空间上比较均衡<br>目的:为了减少hash碰撞table长度会扩容一倍</p></blockquote><h5 id="9-HashMap与HashTable的区别"><a href="#9-HashMap与HashTable的区别" class="headerlink" title="==9.HashMap与HashTable的区别=="></a>==9.HashMap与HashTable的区别==</h5><blockquote><ol><li>线程安全</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;  HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ol><li><p>效率</p><p> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</p></li><li><p>对Null key 和Null value的支持</p><p> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</p></li><li><p>初始容量大小和每次扩充容量大小的不同 </p><p> ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。<br> ②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。</p></li><li><p>底层数据结构</p><p> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p></li><li><p>推荐使用</p><p> 在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</p></li></ol></blockquote><h5 id="10-ConcurrentHashMap-和-Hashtable-的区别"><a href="#10-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="==10.ConcurrentHashMap 和 Hashtable 的区别=="></a>==10.ConcurrentHashMap 和 Hashtable 的区别==</h5><blockquote><p>底层数据结构<br>    ConcurrentHashMap<br>         JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，<br>         JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。<br>    HashTable<br>        Hashtable 和 JDK1.8 之前(JDK1.7)的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；<br>实现线程安全的方式<br>    ConcurrentHashMap<br>         JDK1.7的 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分bucket</p><p>​    <img alt="7" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/java基础/20230106214911.png"></p><p>​        JDK1.8 使用 synchronized 和 CAS 来操作，每把锁只锁一个bucket</p><p>​        <img alt="8" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/java基础/20230106214926.png"></p><p>​    HashTable</p><p>​        示意图</p><p>​        <img alt="6" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/java基础/20230106214741.png"></p><p>​        给全表加synchronized锁，锁粒度太大</p></blockquote><h5 id="11-ConcurrentHashMap-底层具体实现"><a href="#11-ConcurrentHashMap-底层具体实现" class="headerlink" title="==11.ConcurrentHashMap 底层具体实现=="></a>==11.ConcurrentHashMap 底层具体实现==</h5><blockquote><p>JDK1.7<br>    Segment(ReentrantLock) + HashEntry<br>    会锁住多个HashEntry<br>JDK1.8<br>    Node + CAS + Synchronized</p><p>​            CAS体现在hash不冲突是自旋插入</p><p>​            Synchronized在hash冲突时，加上同步锁，保证线程安全</p><p>​    synchronized只锁定当前链表或红黑二叉树的首节点</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h3&gt;&lt;h4 id=&quot;JAVA概述&quot;&gt;&lt;a href=&quot;#JAVA概述&quot; class=&quot;headerlink&quot; title=&quot;JAVA概
      
    
    </summary>
    
    
      <category term="面试题" scheme="https://alexander-wd.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>spring源码(八)--MyBatis源码及Spring整合源码</title>
    <link href="https://alexander-wd.github.io/2022/08/18/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E4%B9%9D)--Spring%E6%95%B4%E5%90%88mybatis/"/>
    <id>https://alexander-wd.github.io/2022/08/18/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E4%B9%9D)--Spring%E6%95%B4%E5%90%88mybatis/</id>
    <published>2022-08-18T15:21:22.000Z</published>
    <updated>2023-02-13T09:40:19.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mybatis源码"><a href="#Mybatis源码" class="headerlink" title="Mybatis源码"></a>Mybatis源码</h2><h3 id="mybatis基础笔记"><a href="#mybatis基础笔记" class="headerlink" title="mybatis基础笔记"></a>mybatis基础笔记</h3><h3 id="mybatis的设计模式"><a href="#mybatis的设计模式" class="headerlink" title="mybatis的设计模式"></a>mybatis的设计模式</h3><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul><li><p>解析配置文件</p><ul><li><p>类型处理器</p><ul><li>TypeHandlerRegistry</li></ul></li><li><p>重要的对象</p><ul><li><p>SqlSessionFactoryBuilder</p><ul><li>SqlSessionFactory构造器</li></ul></li><li><p>Configuration</p><ul><li>mybatis所有的属性都放到了configuration里面</li><li>存储了自己的内置的一些类型处理器和sql语句</li></ul></li></ul></li><li><p>XMLConfigBuilder.parse()</p><ul><li><p>parseConfiguration</p><ul><li><p>解析mybatis-config.xml</p></li><li><p>。。。解析各种属性</p></li><li><p>pluginElement</p></li><li><p>typeHandlerElement</p></li><li><p>mapperElement</p><p>  <mappers></mappers></p><pre><code> &lt;mapper resource=&quot;mybatis/mapper/EmployeeMapper.xml&quot;/&gt; &lt;mapper class=&quot;com.tuling.mapper.DeptMapper&quot;&gt;&lt;/mapper&gt;</code></pre></li></ul></li></ul></li></ul></li></ul><pre><code>                 &lt;package name=&quot;com.tuling.mapper&quot;&gt;&lt;/package&gt;               --&gt;            &lt;/mappers&gt;            - XMLMapperBuilder.parse                - 解释                    - 解析mapper.xml文件                - setCurrentNamespace                    - 设置&lt;namespace&gt;                - cacheElement                    - 设置&lt;cache&gt;二级缓存                    - useNewCache                        - CacheBuilder.build                            - setStandardDecorators                                - 运用了装饰器模式                - resultMapElements                    - 设置&lt;resultMap&gt;                - sqlElement                - buildStatementFromContext                    - 解析sql语句，然后得到MappedStatement对象                    - XMLStatementBuilder.parseStatementNode                        - getStringAttribute                            - 解析id                        - 。。。解析各种属性                        - createSqlSource                            - 解析出sqlSource，这里不会替换参数，替换参数会在调用sql时                            - XMLScriptBuilder.parseScriptNode                                - 解释                                    - 把所有sql语句结点解析为SqlNode                                    - SqlNode实现类                                - parseDynamicTags                                    - handleNode                                - tip:SqlNode的apply方法要调用sql时才执行                        - getStringAttribute                            - 结果集的映射                        - addMappedStatement                            - 构建MappedStatement对象，mybatis解析的所有sql信息都存在此对象中                - 公共方法                    - context.evalNodes                        - 把节点解析为XNode</code></pre><ul><li><p>调用</p><ul><li><p>SqlSessionFactory.openSession</p><ul><li><p>解释</p><ul><li>开启一个新会话</li></ul></li><li><p>newTransaction</p><ul><li>开启一个新事务</li></ul></li><li><p>newExecutor</p><ul><li>创建一个sql语句执行器对象</li><li><p>new SimpleExecutor</p><ul><li>实例化一个执行器</li><li>默认SimpleExecutor，其他的还有BaseExecutor(BatchExecutor、ReuseExecutor、SimpleExecutor)—默认一级缓存、CachingExecutor(开启了二级缓存)</li></ul></li><li><p>interceptorChain.pluginAll</p><ul><li>创建Executor的插件</li><li><p>Plugin.wrap</p><ul><li><p>getAllInterfaces</p><ul><li>当前代理类型 和 @signature指定的type进行配对， 配对成功则可以代理</li></ul></li><li><p>Proxy.newProxyInstance</p><ul><li>对当前executor进行增强</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>selectOne</p><ul><li><p>selectList</p><ul><li><p>getMappedStatement</p><ul><li><p>解释</p><ul><li>从MappedStatement中获取sql信息</li></ul></li></ul></li><li><p>executor.query</p><ul><li><p>CachingExecutor#query</p><ul><li><p>ms.getBoundSql</p><ul><li>解析sql，将参数、<if>、<where>动态替换掉</where></if></li><li><p>sqlSource.getBoundSql</p><ul><li><p>DynamicSqlSource#getBoundSql</p><ul><li>rootSqlNode.apply</li></ul></li></ul></li></ul></li><li><p>createCacheKey</p><ul><li>创建缓存key</li></ul></li><li><p>query</p><ul><li><p>ms.getCache()</p><ul><li>从二级缓存中取，取不到查</li></ul></li><li><p>delegate#query</p><ul><li><p>BaseExecutor#query</p><ul><li><p>localCache.getObject(key)</p><ul><li>先从一级缓存中取，取不到查数据库</li></ul></li><li><p>queryFromDatabase</p><ul><li>查数据库</li><li><p>SimpleExecutor#doQuery</p><ul><li>调用JDBC查询数据库</li><li><p>configuration.newStatementHandler</p><ul><li><p>RoutingStatementHandler</p><ul><li><p>new PreparedStatementHandler</p><ul><li>configuration.newParameterHandler</li><li>configuration.newResultSetHandler</li></ul></li></ul></li><li><p>为StatementHandler添加插件(interceptorChain.pluginAll)</p></li></ul></li><li><p>handler.query</p><ul><li>查出结果</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>调用sql详细流程图</p></li></ul></li></ul><h3 id="mybatis中几个重要的XML…Builder"><a href="#mybatis中几个重要的XML…Builder" class="headerlink" title="mybatis中几个重要的XML…Builder"></a>mybatis中几个重要的XML…Builder</h3><ul><li><p>1 XMLConfigBuilder</p><p>  解析mybatis中configLocation属性中的全局xml文件，内部会使用XMLMapperBuilder解析各个xml文件。</p></li><li><p>2 XMLMapperBuilder</p><p>  遍历mybatis中mapperLocations属性中的xml文件中每个节点的Builder，比如user.xml，内部会使用XMLStatementBuilder处理xml中的每个节点。</p></li><li><p>3 XMLStatementBuilder</p><p>  解析xml文件中各个节点，比如select,insert,update,delete节点，内部会使用XMLScriptBuilder处理节点的sql部分，遍历产生的数据会丢到Configuration的mappedStatements中。</p></li><li><p>4 XMLScriptBuilder</p><p>  解析xml中各个节点sql部分的Builder。</p></li></ul><h3 id="Mybatis四大重要执行对象"><a href="#Mybatis四大重要执行对象" class="headerlink" title="Mybatis四大重要执行对象"></a>Mybatis四大重要执行对象</h3><ul><li>Executor</li><li>ParameterHandler</li><li>ResultSetHandler</li><li><p>StatementHandler</p><ul><li>sql执行者</li></ul></li></ul><h3 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h3><ul><li>插件</li><li>cache</li><li>解析sql</li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li>构造器模式</li><li>装饰模式—缓存</li><li>代理模式(增强四大组件)—插件</li></ul><h3 id="插件-动态代理-责任链-、缓存-装饰器、责任链-、sql注解"><a href="#插件-动态代理-责任链-、缓存-装饰器、责任链-、sql注解" class="headerlink" title="插件(动态代理+责任链)、缓存(装饰器、责任链)、sql注解"></a>插件(动态代理+责任链)、缓存(装饰器、责任链)、sql注解</h3><h2 id="Spring整合Mybatis"><a href="#Spring整合Mybatis" class="headerlink" title="Spring整合Mybatis"></a>Spring整合Mybatis</h2><h3 id="spring怎么管理mapper接口，怎么注入到IOC容器中的"><a href="#spring怎么管理mapper接口，怎么注入到IOC容器中的" class="headerlink" title="spring怎么管理mapper接口，怎么注入到IOC容器中的"></a>spring怎么管理mapper接口，怎么注入到IOC容器中的</h3><ul><li><p>思路：mybatis在spring生产bean的时候修改BeanDefinition从而注入到IOC中</p><ul><li>由于mybatis的代理类是动态生成的，所以spring拿不到代理类型，并且在BeanDefinition中设置为接口类型，后续Spring也无法生成实例，所以Mybatis需要自己去实例Bean</li><li>所以就可以用到FactoryBean，自己控制Bean的生产过程</li></ul></li><li><p>MapperScannerConfigurer</p><ul><li><p>目的</p><ul><li>为了解决MapperFactoryBean需要重复配置</li><li>会扫描org.crowd.mapper下的所有接口，然后创建各自接口的动态代理类。</li></ul></li><li><p>类继承图</p><ul><li>会在invokeBeanFactoryPostProcessors执行</li></ul></li><li><p>SSM阶段需要自己注入MapperScannerConfigurer</p></li><li>使用xml方式</li></ul></li><li><p>@MapperScan#MapperScannerRegistrar</p><ul><li><p>目的</p><ul><li>为了解决MapperFactoryBean需要重复配置</li><li>会扫描org.crowd.mapper下的所有接口，然后创建各自接口的动态代理类。</li></ul></li><li><p>registerBeanDefinitions</p><ul><li><p>doScan</p><ul><li>拿到所有的Mapper接口</li><li><p>processBeanDefinitions</p><ul><li><p>definition.setBeanClass(this.mapperFactoryBean.getClass());</p><ul><li>设置Class类型为FactoryBean</li></ul></li><li><p>definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName);</p><ul><li>表示会调用FactoryBean的构造方法生成实例，并传入Mapper接口中</li></ul></li><li><p>definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE)</p><ul><li>为了通过set方法按类型注入sqlSessionFactory</li></ul></li></ul></li></ul></li></ul></li><li><p>不在xml配置的话，必须通过MapperScan来扫描，扫描注册的类就是MapperScannerRegistrar</p></li><li>会在invokeBeanFactoryPostProcessors执行</li></ul></li><li><p>MapperFactoryBean</p><ul><li><p>getBean</p><ul><li>调用getObject执行Mybatis的动态代理</li></ul></li></ul></li><li><p>说明</p><ul><li>mybatis-spring1.2.2中xml方式全程使用MapperScannerConfigurer；注解方式MapperScannerRegistrar会注册MapperScannerConfigurer的beanDefinition</li><li>mybatis-spring2.0.0中xml方式全程使用MapperScannerConfigurer；注解方式全程使用MapperScannerRegistrar</li></ul></li></ul><h3 id="构建SqlSessionFactory，用于操作数据库SqlSessionFactoryBean继承了FactoryBean和InitializingBean"><a href="#构建SqlSessionFactory，用于操作数据库SqlSessionFactoryBean继承了FactoryBean和InitializingBean" class="headerlink" title="构建SqlSessionFactory，用于操作数据库SqlSessionFactoryBean继承了FactoryBean和InitializingBean"></a>构建SqlSessionFactory，用于操作数据库SqlSessionFactoryBean继承了FactoryBean和InitializingBean</h3><ul><li>会在bean初始化时，执行</li><li><p>getObject</p><ul><li><p>afterPropertiesSet</p><ul><li><p>buildSqlSessionFactory</p><ul><li>XMLConfigBuilder</li><li>XMLMapperBuilder</li><li><p>SpringManagedTransactionFactory</p><ul><li>会使用spring的数据源</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="整合Spring和Mybatis三步"><a href="#整合Spring和Mybatis三步" class="headerlink" title="整合Spring和Mybatis三步"></a>整合Spring和Mybatis三步</h3><ul><li><ol><li>定义一个MyFactoryBean </li></ol></li><li><ol><li>定义一个MyImportBeanDefinitionRegistrar </li></ol></li><li><ol><li>在AppConfig上添加一个注解@Import(MyImportBeanDefinitionRegistrar.class)</li></ol></li><li>流程图</li></ul><h3 id="Component、-Import和-Bean区别"><a href="#Component、-Import和-Bean区别" class="headerlink" title="@Component、@Import和@Bean区别"></a>@Component、@Import和@Bean区别</h3><ul><li>@Component无法注入接口，只能注入类，@Bean可以自定义实现，可以控制bean的实例化过程，可以注入接口的实现类</li><li><p>@Import可以批量注入，可以导入不在扫描范围里的Bean，所以集成第三方框架一般都用@Import</p><ul><li><p>ImportSelector无法改变Bean的使用顺序，如Springboot中想要自定义某个默认的Bean(SqlSessionFactory)，就不能实现</p><ul><li>@ConditionalOnBean(SqlSessionFactory.class)配置了该bean，才注册</li><li>可以使用DeffredImportSelector，最后导入</li></ul></li></ul></li></ul><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Mybatis源码&quot;&gt;&lt;a href=&quot;#Mybatis源码&quot; class=&quot;headerlink&quot; title=&quot;Mybatis源码&quot;&gt;&lt;/a&gt;Mybatis源码&lt;/h2&gt;&lt;h3 id=&quot;mybatis基础笔记&quot;&gt;&lt;a href=&quot;#mybatis基础笔记&quot; c
      
    
    </summary>
    
    
      <category term="JavaEE" scheme="https://alexander-wd.github.io/categories/JavaEE/"/>
    
    
      <category term="spring" scheme="https://alexander-wd.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>spring源码(八)--SpringMVC</title>
    <link href="https://alexander-wd.github.io/2022/08/07/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E5%85%AB)--SpringMVC/"/>
    <id>https://alexander-wd.github.io/2022/08/07/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E5%85%AB)--SpringMVC/</id>
    <published>2022-08-07T08:21:22.000Z</published>
    <updated>2023-02-13T09:38:39.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringMVC源码"><a href="#SpringMVC源码" class="headerlink" title="SpringMVC源码"></a>SpringMVC源码</h2><h3 id="参数注入"><a href="#参数注入" class="headerlink" title="参数注入"></a>参数注入</h3><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul><li><p>@Target</p><ul><li><p>指定作用的位置</p><ul><li><p>METHOD</p><ul><li>方法</li></ul></li><li><p>TYPE</p><ul><li>类、接口</li></ul></li><li><p>FIELD</p><ul><li>字段</li></ul></li></ul></li></ul></li><li><p>@Retention</p><ul><li><p>指定保留策略</p><ul><li><p>RUNTIME</p><ul><li>运行时保留，可以通过反射拿到</li></ul></li><li><p>CLASS</p></li></ul></li></ul></li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul><li><p>初始化</p><ul><li><p>DispatcherServlet#onRefresh</p><ul><li>initStrategies</li></ul></li></ul></li><li><p>调用</p><ul><li><p>DispatcherServlet#doService</p><ul><li><p>doDispatch(request, response);</p><ul><li><p>checkMultipart(request);</p><ul><li>检查是否有文件操作</li><li><p>resolveMultipart</p><ul><li>是的话处理文件</li></ul></li></ul></li><li><p>HandlerExecutionChain mappedHandler =getHandler(processedRequest);</p><ul><li><p>解释</p><ul><li>拿到执行链(HandlerInceptor*n+Handler)</li></ul></li><li><p>getHandlerInternal</p><ul><li>从缓存中找到对应的处理器</li></ul></li><li><p>obtainApplicationContext().getBean</p><ul><li>从容器中获得处理器实例</li></ul></li><li><p>getHandlerExecutionChain</p><ul><li>拿到所有的执行链(HandlerInceptor*n+Handler)</li></ul></li><li><p>getCorsHandlerExecutionChain</p><ul><li>处理CORS同源策略</li></ul></li></ul></li><li><p>HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler())</p><ul><li><p>解释</p><ul><li>拿到适配器，因为Controller可能有多种实现方式(注解、接口…)</li></ul></li><li><p>遍历this.handlerAdapters拿到对应的适配器</p></li></ul></li><li><p>mappedHandler.applyPreHandle</p><ul><li>遍历执行所有拦截器的preHandle方法</li></ul></li><li><p>ha.handle</p><ul><li><p>解释</p><ul><li>调用controller方法</li></ul></li><li><p>SimpleControllerHandlerAdapter#handle</p><ul><li>((Controller) handler).handleRequest(request, response);</li></ul></li></ul></li><li><p>mappedHandler.applyPostHandle</p><ul><li>遍历执行所有拦截器的postHandle方法</li></ul></li><li><p>processDispatchResult</p><ul><li><p>解释</p><ul><li>处理调用结果</li></ul></li><li><p>render(mv, request, response);</p><ul><li>视图解析</li><li><p>view = mv.getView();</p><ul><li>拿到视图</li></ul></li><li><p>view.render(mv.getModelInternal(), request, response);</p><ul><li>渲染视图</li><li><p>AbstractView#render</p><ul><li><p>AbstractJackson2View#renderMergedOutputModel</p><ul><li>对应的解析json数据</li></ul></li><li><p>InternalResourceView#renderMergedOutputModel</p><ul><li>前后端不分离时，解析返回的视图</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="spring与springmvc容器"><a href="#spring与springmvc容器" class="headerlink" title="spring与springmvc容器"></a>spring与springmvc容器</h3><ul><li>springmvc是子容器，spring是父容器，父容器拿不到子容器的bean，子容器可以拿到父容器的bean</li></ul><h3 id="手写springMVC代码"><a href="#手写springMVC代码" class="headerlink" title="手写springMVC代码"></a>手写springMVC代码</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SpringMVC源码&quot;&gt;&lt;a href=&quot;#SpringMVC源码&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC源码&quot;&gt;&lt;/a&gt;SpringMVC源码&lt;/h2&gt;&lt;h3 id=&quot;参数注入&quot;&gt;&lt;a href=&quot;#参数注入&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="JavaEE" scheme="https://alexander-wd.github.io/categories/JavaEE/"/>
    
    
      <category term="spring" scheme="https://alexander-wd.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>spring源码(七)--日志</title>
    <link href="https://alexander-wd.github.io/2022/08/03/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E4%B8%83)--%E6%97%A5%E5%BF%97/"/>
    <id>https://alexander-wd.github.io/2022/08/03/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E4%B8%83)--%E6%97%A5%E5%BF%97/</id>
    <published>2022-08-03T12:21:22.000Z</published>
    <updated>2023-02-13T09:38:26.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="spring4默认使用的是jcl-log4j，没有log4j，使用jul"><a href="#spring4默认使用的是jcl-log4j，没有log4j，使用jul" class="headerlink" title="spring4默认使用的是jcl+log4j，没有log4j，使用jul"></a>spring4默认使用的是jcl+log4j，没有log4j，使用jul</h3><h3 id="spring5默认使用spring-jcl-jul，可以指定log4j2"><a href="#spring5默认使用spring-jcl-jul，可以指定log4j2" class="headerlink" title="spring5默认使用spring-jcl+jul，可以指定log4j2"></a>spring5默认使用spring-jcl+jul，可以指定log4j2</h3><h3 id="springboot使用的是slf4j-logback"><a href="#springboot使用的是slf4j-logback" class="headerlink" title="springboot使用的是slf4j+logback"></a>springboot使用的是slf4j+logback</h3><h3 id="日志-1"><a href="#日志-1" class="headerlink" title="日志"></a>日志</h3><ul><li>log4j(最早的日志框架)</li><li>jul(输出日志为红色)(java.util.logging)(sun公司)</li><li>jcl(门面)(commons-logging)</li><li>slf4j(门面)(log4j作者觉得jcl太low)</li><li>logback(log4j作者觉得log4j性能太低而开发出来的)</li><li>log4j2(apache仿照logback)</li><li>spring-jcl(门面)(spring自己补充的，因为jcl不更新了)</li><li><p>最新的</p><ul><li>slf4j+logback</li><li>slf4j+log4j2</li></ul></li></ul><h3 id="不同日志适配"><a href="#不同日志适配" class="headerlink" title="不同日志适配"></a>不同日志适配</h3><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li><p>86.SpringBoot默认日志实现框架是什么，怎么切换成别的</p><ul><li><p>默认实现框架</p><ul><li>logback</li><li><p>参考</p><ul><li><p>log4j到logback原理</p><ul><li>1.log4j-api通过log4j-to-slf4j适配器转换为slf4j</li><li>2.slf4j通过logback-classic桥接器最终使用logback输出</li></ul></li></ul></li><li><p>springboot默认提供了jul和log4j到slf4j的适配器</p></li></ul></li><li><p>切换</p><ul><li><p>切换为log4j2</p><ul><li><p>添加slf4j对应的桥接器</p><ul><li>排除logback桥接器</li><li>加入log4j2桥接器</li><li>参考</li></ul></li></ul></li><li><p>切换为log4j</p><ul><li>排除logback桥接器</li><li>加入log4j的桥接器</li><li>参考</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;日志&quot;&gt;&lt;a href=&quot;#日志&quot; class=&quot;headerlink&quot; title=&quot;日志&quot;&gt;&lt;/a&gt;日志&lt;/h2&gt;&lt;h3 id=&quot;spring4默认使用的是jcl-log4j，没有log4j，使用jul&quot;&gt;&lt;a href=&quot;#spring4默认使用的是jcl-
      
    
    </summary>
    
    
      <category term="JavaEE" scheme="https://alexander-wd.github.io/categories/JavaEE/"/>
    
    
      <category term="spring" scheme="https://alexander-wd.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>spring源码(六)--事务</title>
    <link href="https://alexander-wd.github.io/2022/07/27/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E5%85%AD)--%E4%BA%8B%E5%8A%A1/"/>
    <id>https://alexander-wd.github.io/2022/07/27/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E5%85%AD)--%E4%BA%8B%E5%8A%A1/</id>
    <published>2022-07-27T11:21:22.000Z</published>
    <updated>2023-02-13T09:38:23.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事务源码"><a href="#事务源码" class="headerlink" title="事务源码"></a>事务源码</h2><h3 id="默认使用jdk"><a href="#默认使用jdk" class="headerlink" title="默认使用jdk?"></a>默认使用jdk?</h3><ul><li><p>JDK</p><ul><li>只有一个动态代理文件，不会重复增强</li><li>反射调用invoke</li></ul></li><li><p>CGLIB</p><ul><li>会有多个动态代理文件。有一个路由文件，根据索引去路由文件中找到对应方法</li><li>直接调用intercept</li><li>方法会重复增强，但是在spring中使用不会重复增强，因为springaop没有使用cglib的inctercept去执行方法，而是使用责任链直接调用方法本身</li></ul></li><li><p>嵌套事务正常调用，就算传播行为是REQUIRED_NEW也只会有一次代理，就算cglib代理也是一样(同一个类中事务方法调用)</p></li><li><p>分析解决</p><ul><li>不懂、忘了嵌套事务就看这个分析解决方案</li><li>注解开启 exposeProxy = true</li></ul></li></ul><h3 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h3><ul><li><p>REQUIRED（默认）</p><ul><li>开启新事务</li><li>适用于增删改查</li><li>融合到外部事务中</li></ul></li><li><p>SUPPORTS</p><ul><li>适用于查询</li></ul></li><li><p>REQUIRES_NEW</p><ul><li>开启新事务</li><li>适用于内部事务和外部事务不存在业务关联情况，如日志</li><li>内外部事务互相不影响</li><li>不用外部事务，创建新的事务</li></ul></li><li><p>NOT_SUPPORTED</p></li><li>NEVER </li><li>MANDATORY</li><li><p>NESTED</p><ul><li>开启新事务</li><li>外层影响内层， 内层不会影响外层，即可以局部回滚，外层提交内层才会提交</li></ul></li><li><p>参考</p></li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul><li><p>解析切面</p><ul><li>事务增强advisor的代码是内置的</li><li><p>@EnableTransactionManagement导入的两个类</p><ul><li><p>AutoProxyRegistrar</p><ul><li>导入InfrastructureAdvisorAutoProxyCreator</li></ul></li><li><p>ProxyTransactionManagementConfiguration</p><ul><li>定义了怎么增强事务方法调用，根据@Transactional(切点)去找对应的方法</li><li>事务内置的切面信息BeanFactoryTransactionAttributeSourceAdvisor</li><li>AnnotationTransactionAttributeSource();</li></ul></li></ul></li><li><p>AbstractAutoProxyCreator#postProcessBeforeInstantiation</p><ul><li><p>解释</p><ul><li>在bean实例化之前调用</li><li>AspectJAwareAdvisorAutoProxyCreator类继承图</li></ul></li><li><p>Object cacheKey = getCacheKey(beanClass, beanName);</p><ul><li>构建缓存，尝试从缓存中取</li></ul></li><li><p>shouldSkip</p><ul><li><p>findCandidateAdvisors</p><ul><li>找到候选的Advisors(前置、后置、异常通知…)</li><li><p>findAdvisorBeans</p><ul><li><p>beanNamesForTypeIncludingAncestors</p><ul><li><p>解释</p><ul><li>找出已注册的Advisor，事务在解析配置类的时候添加了一个事务相关的Advisor类</li></ul></li></ul></li><li><p>isEligibleBean(name)</p><ul><li>判断是不是InfrastructureAdvisorAutoProxyCreator</li></ul></li><li><p>advisors.add(this.beanFactory.getBean(name, Advisor.class));</p><ul><li>实例化advisor，并添加到advisors当中</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>创建代理</p><ul><li><p>与AOP流程差不多，findAdvisorsThatCanApply-&gt;canApply使用PointCut匹配方法时，调用TransactionAttributeSourcePointcut#matches</p><ul><li><p>getTransactionAttributeSource</p><ul><li>获取我们@EnableTransactionManagement注解为我们容器中导入的ProxyTransactionManagementConfiguration配置类中的TransactionAttributeSource对象</li></ul></li><li><p>tas.getTransactionAttribute</p><ul><li><p>解释</p><ul><li>通过getTransactionAttribute看是否有@Transactional注解</li><li>TransactionAttribute封装了@Transactional的所有信息</li></ul></li><li><p>computeTransactionAttribute</p><ul><li><p>解释</p><ul><li>依次从实现类方法、实现类、实现接口方法、实现接口找@Transactional注解</li></ul></li><li><p>findTransactionAttribute</p><ul><li><p>SpringTransactionAnnotationParser#parseTransactionAnnotation</p><ul><li><p>AnnotatedElementUtils.findMergedAnnotationAttributes</p><ul><li>从element对象中获取@Transactional注解 然后把注解属性封装到了AnnotationAttributes</li><li>searchWithFindSemantics</li></ul></li><li><p>parseTransactionAnnotation(attributes)</p><ul><li>解析事务的各个属性封装到TransactionAttribute中</li></ul></li></ul></li></ul></li></ul></li><li><p>setDescriptor(methodIdentification)</p><ul><li>把方法描述设置到事务属性上去</li></ul></li><li><p>this.attributeCache.put(cacheKey, txAttr);</p><ul><li>加入到缓存中</li></ul></li></ul></li></ul></li></ul></li><li><p>调用代理</p><ul><li><p>JdkDynamicAopProxy#invoke</p><ul><li><p>getInterceptorsAndDynamicInterceptionAdvice</p><ul><li>把aop的advisor 全部转化为拦截器</li></ul></li><li><p>new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</p><ul><li>创建调用对象</li></ul></li><li><p>invocation.proceed();</p><ul><li><p>TransactionInterceptor#invoke</p><ul><li><p>invokeWithinTransaction</p><ul><li><p>getTransactionAttributeSource</p><ul><li>获得在ProxyTransactionManagementConfiguration添加的事务属源对象</li></ul></li><li><p>getTransactionAttribute</p><ul><li>获得解析的所有@Transactional的信息</li></ul></li><li><p>determineTransactionManager</p><ul><li>获得事务管理器</li></ul></li><li><p>methodIdentification</p><ul><li>获得匹配的方法(哪些需要事务)</li></ul></li><li><p>处理事务，分两种</p><ul><li><p>声明式事务</p><ul><li><p>createTransactionIfNecessary</p><ul><li><p>解释</p><ul><li>创建事务</li></ul></li><li><p>tm.getTransaction(txAttr);</p><ul><li><p>doGetTransaction</p><ul><li>尝试获取一个事务对象，从TransactionSynchronizationManager获取</li></ul></li><li><p>definition == null？</p><ul><li>判断从上一个方法传递进来的事务属性是不是为空，是空就创建一个默认的</li><li>if成立：definition = new DefaultTransactionDefinition();</li></ul></li><li><p>isExistingTransaction(transaction)？</p><ul><li>判断是否已经存在了事务(嵌套事务)</li><li><p>txObject.hasConnectionHolder() &amp;&amp; txObject.getConnectionHolder().isTransactionActive()</p><ul><li>若第一次进来开始事务，txObject.hasConnectionHolder() 返回的null 那么表示不存在事务</li></ul></li><li><p>if成立：return handleExistingTransaction(definition, transaction, debugEnabled);</p><ul><li><p>处理嵌套事务(分支)</p><ul><li>PROPAGATION_NEVER</li><li>PROPAGATION_NOT_SUPPORTED</li><li>PROPAGATION_REQUIRES_NEW</li><li>PROPAGATION_NESTED</li><li>默认(REQUIRED)</li><li>事务挂起</li></ul></li></ul></li></ul></li><li><p>判断事务传播行为，能不能创建事务</p><ul><li><p>PROPAGATION_MANDATORY</p><ul><li>抛出异常</li></ul></li><li><p>PROPAGATION_REQUIRED</p></li><li>PROPAGATION_REQUIRES_NEW</li><li>PROPAGATION_NESTED</li></ul></li></ul></li><li><p>prepareTransactionInfo</p><ul><li>把事物状态和事物属性等信息封装成一个TransactionInfo对象，方便后续事务回滚提交</li><li>txInfo.newTransactionStatus(status);</li><li><p>txInfo.bindToThread();</p><ul><li>把事务信息对象绑定到当前线程变量中</li></ul></li></ul></li></ul></li></ul></li><li><p>编程式事务</p></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="案例解析"><a href="#案例解析" class="headerlink" title="案例解析"></a>案例解析</h3><ul><li><p>1.普通方法调用事务方法，事务失效</p><ul><li>在调用代理时，getInterceptorsAndDynamicInterceptionAdvice会使用创建代理时TransactionAttributeSourcePointcut#matches(Method,class)方法匹配用户访问的方法是否有@Transactional注解；</li><li>若匹配成功会创建一个责任链，显而易见匹配会通不过，因此相当于直接调用方法，不使用事务</li></ul></li><li><p>AopContext.currentProxy()实质上就是重复调用了getInterceptorsAndDynamicInterceptionAdvice()和proceed()添加事务</p></li><li><p>2.事务方法A调用事务方法B，只有方法A起作用</p><ul><li>因为不使用AopContext.currentProxy()实质上就是简单的方法(调用的对象是普通的bean，是JDK代理方式在代理的时候反射生成的，CGLIB是子类直接调用父类的业务代码)调用了B，不会给方法B加上事务；而方法A是Spring使用动态代理去调用的，所以有事务</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;事务源码&quot;&gt;&lt;a href=&quot;#事务源码&quot; class=&quot;headerlink&quot; title=&quot;事务源码&quot;&gt;&lt;/a&gt;事务源码&lt;/h2&gt;&lt;h3 id=&quot;默认使用jdk&quot;&gt;&lt;a href=&quot;#默认使用jdk&quot; class=&quot;headerlink&quot; title=&quot;默认使
      
    
    </summary>
    
    
      <category term="JavaEE" scheme="https://alexander-wd.github.io/categories/JavaEE/"/>
    
    
      <category term="spring" scheme="https://alexander-wd.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>spring源码(五)--AOP</title>
    <link href="https://alexander-wd.github.io/2022/07/16/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E4%BA%94)--AOP/"/>
    <id>https://alexander-wd.github.io/2022/07/16/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E4%BA%94)--AOP/</id>
    <published>2022-07-16T01:21:20.000Z</published>
    <updated>2023-02-13T09:28:35.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul><li><p>JDK</p><ul><li>只有一个动态代理文件，不会重复增强</li><li>反射调用invoke</li></ul></li><li><p>CGLIB</p><ul><li>会有多个动态代理文件。有一个路由文件，根据索引去路由文件中找到对应方法</li><li>直接调用intercept</li><li>方法会重复增强，但是在spring中使用不会重复增强，因为springaop没有使用cglib的inctercept去执行方法，而是使用责任链直接调用方法本身</li></ul></li><li><p>参考</p></li></ul><h3 id="切面：类，被-AspectJ标注的类"><a href="#切面：类，被-AspectJ标注的类" class="headerlink" title="切面：类，被@AspectJ标注的类"></a>切面：类，被@AspectJ标注的类</h3><ul><li><p>advisor：某个具体的通知=advise+pointcut</p><ul><li>advise：通知类型(如前置通知)</li><li>pointcut：切点</li></ul></li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul><li><p>解析切面</p><ul><li><p>AbstractAutoProxyCreator#postProcessBeforeInstantiation</p><ul><li><p>解释</p><ul><li>在bean实例化之前调用</li><li>AspectJAwareAdvisorAutoProxyCreator类继承图</li></ul></li><li><p>Object cacheKey = getCacheKey(beanClass, beanName);</p><ul><li>构建缓存，尝试从缓存中取</li></ul></li><li><p>shouldSkip</p><ul><li><p>findCandidateAdvisors</p><ul><li>找到候选的Advisors(前置、后置、异常通知…)</li><li><p>buildAspectJAdvisors</p><ul><li><p>this.advisorFactory.isAspect(beanType)</p><ul><li>判断是不是切面</li></ul></li><li><p>this.advisorFactory.getAdvisors(factory);</p><ul><li>解析advisors</li><li><p>getAdvisor</p><ul><li>解析一个具体的advisor</li><li><p>getPointcut</p><ul><li>获取切点表达式</li></ul></li><li><p>InstantiationModelAwarePointcutAdvisorImpl将advisor封装到此对象中</p></li></ul></li></ul></li><li><p>this.advisorsCache.put(beanName, classAdvisors);</p><ul><li>添加到缓存中</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>创建代理</p><ul><li><p>AbstractAutoProxyCreator#postProcessAfterInitialization</p><ul><li><p>解释</p><ul><li>在bean初始化完之后调用</li></ul></li><li><p>getCacheKey(bean.getClass(), beanName);</p><ul><li>尝试从缓存中取</li></ul></li><li><p>wrapIfNecessary</p><ul><li><p>getAdvicesAndAdvisorsForBean</p><ul><li>根据bean找到匹配的advisor</li><li><p>findEligibleAdvisors</p><ul><li><p>findCandidateAdvisors</p><ul><li>获取之前解析过的advisors</li></ul></li><li><p>findAdvisorsThatCanApply</p><ul><li>切点是否命中当前Bean(匹配方法)</li></ul></li></ul></li></ul></li><li><p>createProxy</p><ul><li><p>创建动态代理对象</p><ul><li>proxy-target-class=”true”强制创建cglib代理</li><li>有接口则创建jdk代理，否则cglib代理</li></ul></li><li><p>proxyFactory.getProxy</p><ul><li>createAopProxy().getProxy</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>调用代理</p><ul><li><p>解释</p><ul><li>责任链模式调用</li></ul></li><li><p>以jdk代理为例</p><ul><li><p>JdkDynamicAopProxy#invoke</p><ul><li><p>getInterceptorsAndDynamicInterceptionAdvice</p><ul><li>把aop的advisor 全部转化为拦截器</li></ul></li><li><p>new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</p><ul><li>创建调用对象</li></ul></li><li><p>invocation.proceed();</p><ul><li>基于责任链模式递归调用</li><li>通知advisor(前置、后置通知…)的拦截器都继承了MethodInterceptor</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><ul><li>aop源码</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AOP&quot;&gt;&lt;a href=&quot;#AOP&quot; class=&quot;headerlink&quot; title=&quot;AOP&quot;&gt;&lt;/a&gt;AOP&lt;/h2&gt;&lt;h3 id=&quot;动态代理&quot;&gt;&lt;a href=&quot;#动态代理&quot; class=&quot;headerlink&quot; title=&quot;动态代理&quot;&gt;&lt;/a&gt;动态代
      
    
    </summary>
    
    
      <category term="JavaEE" scheme="https://alexander-wd.github.io/categories/JavaEE/"/>
    
    
      <category term="spring" scheme="https://alexander-wd.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>spring源码(四)--监听器</title>
    <link href="https://alexander-wd.github.io/2022/07/05/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E5%9B%9B)--%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <id>https://alexander-wd.github.io/2022/07/05/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E5%9B%9B)--%E7%9B%91%E5%90%AC%E5%99%A8/</id>
    <published>2022-07-05T00:11:20.000Z</published>
    <updated>2023-02-13T09:26:29.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul><li><p>创建事件多播器</p><ul><li><p>initApplicationEventMulticaster</p><p>beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</p></li></ul></li><li><p>ApplicationListener接口的监听器解析</p><ul><li><p>两条路线</p><ul><li><p>registerListeners</p><ul><li><p>getApplicationEventMulticaster().addApplicationListener(listener);</p><ul><li>在onRefresh里面注册的监听器</li></ul></li><li><p>getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</p><ul><li>将bean的名字注册到多播器中</li></ul></li></ul></li><li><p>prepareBeanFactory</p><ul><li><p>beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));</p><ul><li><p>解释</p><ul><li>注册ApplicationListenerDetector</li></ul></li><li><p>在bean初始化结束后调用ApplicationListenerDetector#postProcessAfterInitialization</p><ul><li>this.applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</li></ul></li></ul></li></ul></li><li><p>为什么要注册两遍</p><ul><li>防止@Lazy懒加载的漏网之鱼</li></ul></li></ul></li></ul></li><li><p>@EventListener注解解析过程</p><ul><li>1.在创始bean定义中注册了两个用于解析@EventListener</li><li><p>2.在bean初始完后调用smartSingleton.afterSingletonsInstantiated();</p><ul><li>EventListenerMethodProcessor实现了SmartInitializingSingleton</li></ul></li></ul></li><li><p>publishEvent：多播器发布事件</p><ul><li><p>SimpleApplicationEventMulticaster#multicastEvent</p><ul><li><p>接口</p><ul><li><p>listener.onApplicationEvent</p><ul><li>实现ApplicationListener之后直接调用</li></ul></li></ul></li><li><p>注解</p><ul><li><p>ApplicationListenerMethodAdapter</p><ul><li>反射实现</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li><p>bean创建完后扩展</p><ul><li>SmartInitializingSingleton</li><li>内置监听器</li></ul></li><li><p>使用了观察者模式</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;监听器&quot;&gt;&lt;a href=&quot;#监听器&quot; class=&quot;headerlink&quot; title=&quot;监听器&quot;&gt;&lt;/a&gt;监听器&lt;/h2&gt;&lt;h3 id=&quot;流程&quot;&gt;&lt;a href=&quot;#流程&quot; class=&quot;headerlink&quot; title=&quot;流程&quot;&gt;&lt;/a&gt;流程&lt;/h3&gt;&lt;u
      
    
    </summary>
    
    
      <category term="JavaEE" scheme="https://alexander-wd.github.io/categories/JavaEE/"/>
    
    
      <category term="spring" scheme="https://alexander-wd.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>spring源码(三)--循环依赖(bean的创建)</title>
    <link href="https://alexander-wd.github.io/2022/06/26/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E4%B8%89)--bean%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
    <id>https://alexander-wd.github.io/2022/06/26/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E4%B8%89)--bean%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/</id>
    <published>2022-06-26T06:11:20.000Z</published>
    <updated>2023-02-13T09:24:44.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="循环依赖-bean的创建"><a href="#循环依赖-bean的创建" class="headerlink" title="循环依赖(bean的创建)"></a>循环依赖(bean的创建)</h2><h3 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h3><ul><li><p>doGetBean</p><ul><li><p>getSingleton(beanName)：出口</p><p>protected Object getSingleton(String beanName, boolean allowEarlyReference) {<br>   /**</p><pre><code>* 第一步:我们尝试去一级缓存(单例缓存池中去获取对象,一般情况从该map中获取的对象是直接可以使用的)* IOC容器初始化加载单实例bean的时候第一次进来的时候 该map中一般返回空*/</code></pre><p>   Object singletonObject = this.singletonObjects.get(beanName);<br>   /**</p><pre><code>* 若在第一级缓存中没有获取到对象,并且singletonsCurrentlyInCreation这个list包含该beanName* IOC容器初始化加载单实例bean的时候第一次进来的时候 该list中一般返回空,但是循环依赖的时候可以满足该条件*/</code></pre><p>   if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {</p><pre><code>  synchronized (this.singletonObjects) {     /**      * 尝试去二级缓存中获取对象(二级缓存中的对象是一个早期对象)      * 何为早期对象:就是bean刚刚调用了构造方法，还来不及给bean的属性进行赋值的对象(纯净态)      * 就是早期对象      */     singletonObject = this.earlySingletonObjects.get(beanName);     /**      * 二级缓存中也没有获取到对象,allowEarlyReference为true(参数是有上一个方法传递进来的true)      */     if (singletonObject == null &amp;&amp; allowEarlyReference) {        /**         * 直接从三级缓存中获取 ObjectFactory对象 这个对接就是用来解决循环依赖的关键所在         * 在ioc后期的过程中,当bean调用了构造方法的时候,把早期对象包裹成一个ObjectFactory         * 暴露到三级缓存中         */        ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);        //从三级缓存中获取到对象不为空        if (singletonFactory != null) {           /**            * 在这里通过暴露的ObjectFactory 包装对象中,通过调用他的getObject()来获取我们的早期对象            * 在这个环节中会调用到 getEarlyBeanReference()来进行后置处理            */           singletonObject = singletonFactory.getObject();           //把早期对象放置在二级缓存,           this.earlySingletonObjects.put(beanName, singletonObject);           //ObjectFactory 包装对象从三级缓存中删除掉           this.singletonFactories.remove(beanName);        }     }  }</code></pre><p>   }<br>   return singletonObject;</p><ul><li>尝试从一级缓存中获取bean</li><li><p>this.earlySingletonObjects.put(beanName, singletonObject);</p><ul><li>如果bean正在创建过程中且三级缓存中存在该bean，才会进入此方法，将纯静态的bean放入二级缓存中</li></ul></li></ul></li><li><p>getSingleton(beanName, () -&gt; {}</p><ul><li><p>this.singletonObjects.get(beanName);</p><ul><li>尝试从一级缓存中获取bean，解决多线程下重复创建的问题，意义参考如何解决并发bean不完整的问题</li></ul></li><li><p>beforeSingletonCreation(beanName);</p><ul><li>标记当前的bean马上就要被创建了</li></ul></li><li><p>createBean(beanName, mbd, args);</p><ul><li><p>①resolveBeforeInstantiation</p><ul><li><p>postProcessBeforeInstantiation</p><ul><li>InstantiationAwareBeanPostProcessors后置处理器的postProcessBeforeInstantiation</li><li>aop的才会被调用</li></ul></li></ul></li><li><p>doCreateBean</p><ul><li><p>解释</p><ul><li>真的创建bean的逻辑,该方法是最复杂的包含了调用构造函数,给bean的属性赋值</li><li>调用bean的初始化操作以及 生成代理对象 都是在这里</li><li><p>方法在AbstractAutowireCapableBeanFactory类中</p><ul><li>类继承图</li><li>DefaultSingletonBeanRegistry类中声明了一二三级缓存</li></ul></li></ul></li><li><p>createBeanInstance</p><ul><li><p>解释</p><ul><li>创建bean实例化</li><li>使用合适的实例化策略来创建新的实例：工厂方法、构造函数自动注入、简单初始化 该方法很复杂也很重要</li></ul></li><li><p>②determineConstructorsFromBeanPostProcessors</p><ul><li>determineCandidateConstructors</li></ul></li><li><p>instantiateBean</p><ul><li>默认会调用无参构造函数</li></ul></li></ul></li><li><p>③applyMergedBeanDefinitionPostProcessors</p><ul><li>进行后置处理 @AutoWired @Value的注解的预解析</li></ul></li><li><p>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</p><ul><li><p>缓存单例到三级缓存中</p><ul><li>普通对象(无循环依赖)直接忽略三级缓存？</li></ul></li><li><p>④getEarlyBeanReference</p><ul><li>产生循环依赖会提前在属性赋值(populateBean里getBean回调getEarlyBeanReference)时，创建动态代理</li><li>正常情况会在初始化时创建动态代理</li></ul></li></ul></li><li><p>populateBean</p><ul><li><p>解释</p><ul><li>属性赋值 给我们的属性进行赋值(调用set方法进行赋值)</li></ul></li><li><p>⑤postProcessAfterInstantiation</p></li><li><p>autowire注入属性</p><ul><li><p>autowireByName</p><ul><li>getBean(propertyName)：依赖循环</li></ul></li><li><p>autowireByType</p></li></ul></li><li><p>⑥postProcessPropertyValues</p></li></ul></li><li><p>initializeBean</p><ul><li><p>解释</p><ul><li>进行对象初始化操作(在这里可能生成代理对象)</li></ul></li><li><p>invokeAwareMethods</p><ul><li>实现XXXAware接口进行方法的回调</li></ul></li><li><p>⑦applyBeanPostProcessorsBeforeInitialization</p><ul><li>调用我们的bean的后置处理器的postProcessorsBeforeInitialization方法  @PostConstruct注解的方法</li></ul></li><li><p>invokeInitMethods</p><ul><li>调用初始化方法</li></ul></li><li><p>⑧applyBeanPostProcessorsAfterInitialization</p><ul><li>调用我们bean的后置处理器的PostProcessorsAfterInitialization方法</li></ul></li></ul></li><li><p>earlySingletonExposure？</p><ul><li><p>getSingleton(beanName, false);</p><ul><li>返回二级缓存中的早期对象</li><li>为了返回回去清除二三级缓存？</li></ul></li></ul></li></ul></li></ul></li><li><p>afterSingletonCreation(beanName);</p><ul><li>后置处理</li><li>主要做的事情就是把singletonsCurrentlyInCreation标记正在创建的bean从集合中移除</li></ul></li><li><p>addSingleton(beanName, singletonObject);</p><ul><li>加入一级缓存中</li></ul></li></ul></li></ul></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li><p>为什么要三级缓存</p><ul><li><p>一级缓存</p><ul><li>单线程中能保证循环依赖</li><li>存的是成熟态的bean</li></ul></li><li><p>二级缓存</p><ul><li>多线程下，避免获取的Bean不完整，防止多线程中在Bean还未创建完成时读取到的Bean时不完整的</li><li>存的是纯静态的bean</li><li><p>tips</p><ul><li>正常普通的bean(不存在循环依赖的bean) 创建的过程中，压根不会把三级缓存提升到二级缓存中</li></ul></li></ul></li><li><p>三级缓存</p><ul><li>单一职责原则，避免耦合，</li><li>存的是函数接口（即不会立即缓存单例对象，而是等待调用时再返回）</li><li><p>好处</p><ul><li>1：延迟获取，提高性能： 因为并不是所有的Bean都存在循环引用（不需要所有单例都缓存起来等待循环依赖调用），所以当真正调用时再缓存该单例到二级缓存。</li><li>2：提高扩展性：这是spring一贯作风，采用bean的后置处理器方式可以提高扩展性（如代理操作等..）</li><li>3：aop的考虑：如果依赖的bean是代理类，那么将代理创建的方法作为回调方法。</li></ul></li></ul></li><li><p>循环依赖重点：缓存早期对象(实例化之后的对象)</p></li></ul></li><li><p>不能解决构造器的循环依赖</p><ul><li>在构造器实例化之前(构造器是实例化时调用)，一二三级缓存中没有bean的相关信息</li><li><p>例</p><ul><li><p>比如A先调用B，造成循环依赖。A先使用构造器注入，构造器注入过程中发现此时B还没有创建，于是就去创建B了，但是此时A的构造器还没有走完，三级缓存中也没有A；</p><ul><li>下次创建B时，去调用getBean(A)，就会发现一二三级缓存中都没有A，于是去DefaultSingletonBeanRegistry#getSingleton(beanName, () -&gt; {}中加入singletonsCurrentlyInCreation(保存正在创建的bean)集合时会报错</li></ul></li><li><p>如果使用的是setter注入，默认是使用的无参构造，之后就会将A放入三级缓存中，此时再调用getBean(A)，就能直接从三级缓存中获取到A了</p></li></ul></li><li><p>最主要的原因是构造器注入是在createBeanInstance中，而setter注入是在populateBean中，所以setter注入不会报错</p></li></ul></li><li><p>不能解决多例的循环依赖</p><ul><li>单例意味着只需要创建一次对象，后面就可以从缓存中取出来，字段注入，意味着我们无需调用构造方法进行注入。</li><li>如果是原型bean，那么就意味着每次都要去创建对象，无法利用缓存；</li><li>如果是构造方法注入，那么就意味着需要调用构造方法注入，也无法利用缓存</li><li><p>doGetBean代码中有一句是多例直接报错</p><p>if (isPrototypeCurrentlyInCreation(beanName)) {<br>   throw new BeanCurrentlyInCreationException(beanName);<br>}</p></li></ul></li><li><p>为什么循环依赖的AOP要在实例化之后就创建</p><ul><li><p>比如A先调用B，造成循环依赖。这时候会一路执行，直到调用B的属性赋值时，发现一级缓存中没有A，就调用getBean(A)，并执行三级缓存中的函数接口。</p><ul><li>正常流程的话调用这个接口就会创建AOP，正常执行下面的流程</li><li>若在这个函数接口这不创建A的动态代理，那么最终创建出来给B赋值的A只是普通的Bean，而不是动态代理。而这是A的动态代理则会在最后A初始化完之后创建</li></ul></li></ul></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>循环依赖</li><li>图解</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;循环依赖-bean的创建&quot;&gt;&lt;a href=&quot;#循环依赖-bean的创建&quot; class=&quot;headerlink&quot; title=&quot;循环依赖(bean的创建)&quot;&gt;&lt;/a&gt;循环依赖(bean的创建)&lt;/h2&gt;&lt;h3 id=&quot;getBean&quot;&gt;&lt;a href=&quot;#getB
      
    
    </summary>
    
    
      <category term="JavaEE" scheme="https://alexander-wd.github.io/categories/JavaEE/"/>
    
    
      <category term="spring" scheme="https://alexander-wd.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>spring源码(二)--注册bean定义详解</title>
    <link href="https://alexander-wd.github.io/2022/06/17/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E4%BA%8C)--%E6%B3%A8%E5%86%8CBean%E5%AE%9A%E4%B9%89%E8%AF%A6%E8%A7%A3/"/>
    <id>https://alexander-wd.github.io/2022/06/17/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E4%BA%8C)--%E6%B3%A8%E5%86%8CBean%E5%AE%9A%E4%B9%89%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-06-17T07:11:20.000Z</published>
    <updated>2023-02-13T09:22:28.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="invokeBeanFactoryPostProcessors注册bean定义详解"><a href="#invokeBeanFactoryPostProcessors注册bean定义详解" class="headerlink" title="invokeBeanFactoryPostProcessors注册bean定义详解"></a>invokeBeanFactoryPostProcessors注册bean定义详解</h2><h3 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors"></a>invokeBeanFactoryPostProcessors</h3><ul><li><p>ConfigurationClassPostProcessor类继承图</p></li><li><p>实现了PriorityOrdered接口(ConfigurationClassPostProcessor)的invokeBeanDefinitionRegistryPostProcessors</p><ul><li><p>currentRegistryProcessors.add(beanFactory.getBean()</p><p>  if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {</p><pre><code> //显示的调用getBean()的方式获取出该对象然后加入到currentRegistryProcessors集合中去 currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); //同时也加入到processedBeans集合中去 processedBeans.add(ppName);</code></pre><p>  }</p><ul><li>从IOC中实例化并取出ConfigurationClassPostProcessor</li></ul></li><li><p>postProcessBeanDefinitionRegistry</p><ul><li><p>解释</p><ul><li>解析@Configuration的配置类</li><li>解析@ComponentScan注解扫描的包</li><li>解析@Import，@Component，@Bean等注解</li></ul></li><li><p>for循环configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));</p><ul><li><p>解释</p><ul><li><p>ConfigurationClassUtils.checkConfigurationClassCandidate</p><ul><li>检查是不是full的配置类@Configuration</li><li>lite的配置类Component，ComponentScan，Import，ImportResource</li></ul></li></ul></li></ul></li><li><p>ConfigurationClassParser.parse(candidates);递归</p><ul><li><p>解释</p><ul><li>解析配置类</li></ul></li><li><p>processConfigurationClass(new ConfigurationClass(metadata, beanName));</p><ul><li><p>解释</p><ul><li>真的解析我们的配置类</li><li>把我们的配置类源信息和beanName包装成一个ConfigurationClass 对象</li></ul></li><li><p>this.conditionEvaluator.shouldSkip</p><ul><li>解析判断@Conditional是否满足条件</li></ul></li><li><p>doProcessConfigurationClass(configClass, sourceClass);</p><ul><li>processPropertySource(propertySource);</li><li><p>this.componentScanParser.parse</p><ul><li><p>this.componentScanParser.parse</p><ul><li><p>解释</p><ul><li>解析@Scope的ProxyMode属性</li><li>设置CompentScan对象的includeFilters 包含的属性</li><li>设置CompentScan对象的excludeFilters 包含的属性</li><li>是否懒加载</li><li><p>扫描时会判断</p><ul><li>1.类上是否有@Component</li><li>2.类是否为接口、抽象类</li></ul></li></ul></li><li><p>scanner(ClassPathBeanDefinitionScanner).doScan</p><ul><li>将bean定义注册到BeanDefinitionMap中</li><li><p>findCandidateComponents(basePackage);</p><ul><li><p>scanCandidateComponents(basePackage);</p><ul><li>获得包下所有的.class文件</li><li><p>isCandidateComponent</p><ul><li>1.类上是否有@Component</li><li>2.类是否为接口、抽象类</li></ul></li></ul></li></ul></li><li><p>registerBeanDefinition(definitionHolder, this.registry);</p><ul><li>将bean定义注册到BeanDefinitionMap中</li></ul></li></ul></li></ul></li></ul></li><li><p>processImports</p></li><li>configClass.addImportedResource</li><li><p>retrieveBeanMethodMetadata(sourceClass);</p><ul><li>获取到我们配置类中所有标注了@Bean的方法</li><li>放到Set中，并未解析成Bean定义放到BeanDefinitionMap中</li></ul></li><li><p>processInterfaces(configClass, sourceClass);</p><ul><li>处理配置类接口 默认方法的@Bean</li></ul></li></ul></li><li><p>this.configurationClasses.put(configClass, configClass);</p><ul><li>放入缓存</li></ul></li></ul></li><li><p>processDeferredImportSelectors();</p><ul><li>处理我们延时的DeferredImportSelectors</li><li>springboot就是通过这步进行记载spring.factories文件中的自定装配的对象</li></ul></li></ul></li><li><p>this.reader.loadBeanDefinitions(configClasses);</p><ul><li>此处才把@Bean的方法和@Import 注册到BeanDefinitionMap中</li></ul></li></ul></li></ul></li><li><p>实现了Ordered接口(包含自定义的)的invokeBeanDefinitionRegistryPostProcessors</p><ul><li>实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessor也在这里，推测是因为在上一步ConfigurationClassPostProcessor把注解标注的Definition注册进来，而ConfigurationClassPostProcessor在上下文的构造函数就注册进来了，而自定义的PriorityOrdered接口的BeanDefinitionRegistryPostProcessor却还没注册BeanDefinition，所以这在上一步获取不到</li></ul></li><li><p>没实现任何优先级接口(包含自定义的)的invokeBeanDefinitionRegistryPostProcessors</p></li><li><p>BeanDefinitionRegistryPostProcessor(包含自定义的)#invokeBeanFactoryPostProcessors(registryProcessors</p><ul><li><p>ConfigurationClassPostProcessor的invokeBeanFactoryPostProcessors</p><p>  //调用 BeanDefinitionRegistryPostProcessor.postProcessBeanFactory方法<br>  invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</p><ul><li><p>enhanceConfigurationClasses</p><ul><li>使用cglib对配置类进行代理，调用@Bean方法就不会重复创建实例</li></ul></li></ul></li><li><p>执行BeanDefinitionRegistryPostProcessor#postProcessBeanFactory</p></li></ul></li><li><p>通过getBeanFactoryPostProcessors添加进来的BeanFactoryPostProcessor#invokeBeanFactoryPostProcessors(regularPostProcessors</p><ul><li>getBeanFactoryPostProcessors添加进来的BeanPostProcessor，如springboot添加进来的ConfigFileApplicationListener$PropertySourceOrderingPostProcessor</li></ul></li><li><p>细节</p><ul><li>processedBeans会保存处理过的BeanDefinitionRegistryPostProcessor，执行只继承了BeanFactoryPostProcessor的类时，便不再执行带注册bean功能的工厂后置处理器</li></ul></li><li><p>实现了PriorityOrdered接口(包含自定义的)的BeanFactoryProcessor</p></li><li><p>实现了Ordered接口(包含自定义的)的BeanFactoryProcessor</p></li><li><p>没有实现任何优先级接口(包含自定义的)的BeanFactoryProcessor</p></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li><p>@Configuration加与不加的区别</p><ul><li><p>ConfigurationClassPostProceessor执行postProcessBeanFactory方法时会给配置类做cjlib动态代理，让@Bean的实例不会被重复new</p><ul><li>会判断实例是否是第一次创建（是否已经存在于IOC容器），如果说已经存在，那么spring应该直接去容器中拿这个beaninstance</li></ul></li><li><p>答案图片</p></li></ul></li><li><p>invokeBeanDefinitionRegistryPostProcessors(PriorityOrdered)</p><ul><li><p>解析配置类的时候会重新new 一个scanner(ClassPathBeanDefinitionScanner)和AnnotationConfigApplicationContext中的不是一个</p><ul><li>AnnotationConfigApplicationContext中的只是为了自己调用scan方法</li></ul></li></ul></li><li><p>创始类什么时候实例化</p><ul><li>getBean会实例化创始类</li></ul></li><li><p>@Component、@Import和@Bean区别</p><ul><li>@Component无法注入接口，只能注入类，@Bean可以自定义实现，可以控制bean的实例化过程，可以注入接口的实现类</li><li><p>@Import可以批量注入，可以导入不在扫描范围里的Bean，所以集成第三方框架一般都用@Import</p><ul><li><p>ImportSelector无法改变Bean的使用顺序，如Springboot中想要自定义某个默认的Bean(SqlSessionFactory)，就不能实现</p><ul><li>@ConditionalOnBean(SqlSessionFactory.class)配置了该bean，才注册</li><li>可以使用DeffredImportSelector，最后导入</li></ul></li></ul></li></ul></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>invokeBeanFactoryPostProcessors</li><li>注册bean定义流程图</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;invokeBeanFactoryPostProcessors注册bean定义详解&quot;&gt;&lt;a href=&quot;#invokeBeanFactoryPostProcessors注册bean定义详解&quot; class=&quot;headerlink&quot; title=&quot;invokeBean
      
    
    </summary>
    
    
      <category term="JavaEE" scheme="https://alexander-wd.github.io/categories/JavaEE/"/>
    
    
      <category term="spring" scheme="https://alexander-wd.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>spring源码(一)--IOC容器整体</title>
    <link href="https://alexander-wd.github.io/2022/06/01/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E4%B8%80)--IOC%E5%AE%B9%E5%99%A8%E6%95%B4%E4%BD%93/"/>
    <id>https://alexander-wd.github.io/2022/06/01/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E4%B8%80)--IOC%E5%AE%B9%E5%99%A8%E6%95%B4%E4%BD%93/</id>
    <published>2022-06-01T14:10:20.000Z</published>
    <updated>2023-02-13T09:41:12.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IOC容器源码-大体"><a href="#IOC容器源码-大体" class="headerlink" title="IOC容器源码(大体)"></a>IOC容器源码(大体)</h2><h3 id="1-整体介绍"><a href="#1-整体介绍" class="headerlink" title="1.整体介绍"></a>1.整体介绍</h3><ul><li><p>IOC控制反转的意义</p><ul><li>当一个依赖的类改变了，不用处处都改，只需要改变IOC容器中的bean</li></ul></li><li><p>BeanFactory和ApplicationContext区别</p></li><li><p>循环依赖</p><ul><li>设置三级缓存解决</li></ul></li><li><p>扩展点</p><ul><li>集成其他框架时，用的非常多</li><li><p>BeanFactoryPostProcessor</p><ul><li>集成其他框架时，用的非常多</li></ul></li><li><p>BeanDefinitionRegistryPostProcessor</p><ul><li>用于注册扩展的bean定义，相当于“增加图纸”</li></ul></li></ul></li><li><p>问题</p><ul><li>描述下BeanFactory</li><li><p>BeanFactory和ApplicationContext的区别</p><ul><li>BeanFactory是spring的顶层核心接口，工厂只负责按照要求(beanDefinition)生产bean，要生产成什么样由ApplicationContext决定</li><li>ApplicationContext面向的是用户，需要提供各种人性化的服务，继承了BeanFactory，离开了BeanFactory生产不了bean(就行各种店铺离不开工厂)</li></ul></li><li><p>简述SpringIOC的加载过程</p></li><li><p>简述Bean的生命周期</p><ul><li><p>实例化</p><ul><li><ol><li>实例化Bean对象，这个时候Bean的对象是非常低级的，基本不能够被我们使用，因为连最基本的属性都没有设置，可以理解为 连Autowired注解都是没有解析的； </li></ol></li></ul></li><li><p>属性注入</p><ul><li><ol><li>填充属性，当做完这一步，Bean对象基本是完整的了，可以理解为Autowired注解已经解析完毕，依赖注入完成了； </li></ol></li></ul></li><li><p>初始化Initialization</p><ul><li><p>invokeAwareMethods</p><ul><li><ol><li>如果Bean实现了BeanNameAware接口，则调用setBeanName方法； </li></ol></li><li><ol><li>如果Bean实现了BeanClassLoaderAware接口，则调用setBeanClassLoader方法；</li></ol></li><li><ol><li>如果Bean实现了BeanFactoryAware接口，则调用setBeanFactory方法； </li></ol></li></ul></li><li><ol><li>调用BeanPostProcessor的postProcessBeforeInitialization方法；</li></ol></li><li><p>init</p><ul><li><ol><li>如果Bean实现了InitializingBean接口，调用afterPropertiesSet方法； </li></ol></li><li><ol><li>如果Bean定义了init-method方法，则调用Bean的init-method方法；</li></ol></li><li><ol><li>调用BeanPostProcessor的postProcessAfterInitialization方法；当进行到这一步，Bean已经被准备就绪了，一直停留在应用的 上下文中，直到被销毁；</li></ol></li></ul></li><li><p>close()</p><ul><li><ol><li>如果应用的上下文被销毁了，如果Bean实现了DisposableBean接口，则调用destroy方法，如果Bean定义了destory-method 声明了销毁方法也会被调用。</li></ol></li></ul></li></ul></li></ul></li><li><p>Spring中有哪些扩展接口及调用时机</p><ul><li>BeanFactoryPostProcessor</li><li>FactoryBean</li><li>BeanPostProcessor</li><li>初始化生命周期回调方法</li></ul></li></ul></li></ul><h3 id="2-源码介绍-IOC容器初始化过程"><a href="#2-源码介绍-IOC容器初始化过程" class="headerlink" title="2.源码介绍(IOC容器初始化过程)"></a>2.源码介绍(IOC容器初始化过程)</h3><ul><li><p>源码编译</p><ul><li><p>问题</p><ul><li><p>Error resolving plugin</p></li><li><p>Kotlin: warnings found and -Werror specified</p></li><li><p>CoroutinesRegistrar不存在</p></li></ul></li></ul></li><li><p>使用配置类的设计理念更先进</p></li><li><p>问题</p><ul><li><p>FactoryBean和BeanFactory区别</p><ul><li>FactoryBean就是一个扩展点，BeanFactory是使用了简单工厂模式，用于生产bean</li></ul></li><li><p>BeanFactoryPostProcessor和BeanPostProcessor区别</p><ul><li>BeanFactoryPostProcessor用于扩展bean定义，BeanPostProcessor用于扩展bean</li></ul></li><li><p>介绍下BeanFactoryPostProcessor在Spring中的用途</p><ul><li>扩展点，mybatis基于此与spring集成</li></ul></li><li><p>@Component、@Import和@Bean区别</p><ul><li>@Component无法注入接口，只能注入类，@Bean可以自定义实现，可以控制bean的实例化过程，可以注入接口的实现类</li><li><p>@Import可以批量注入，可以导入不在扫描范围里的Bean，所以集成第三方框架一般都用@Import</p><ul><li><p>ImportSelector无法改变Bean的使用顺序，如Springboot中想要自定义某个默认的Bean(SqlSessionFactory)，就不能实现</p><ul><li>@ConditionalOnBean(SqlSessionFactory.class)配置了该bean，才注册</li><li>可以使用DeffredImportSelector，最后导入</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="AnnotationConfigApplicationContext-MainConfig-class"><a href="#AnnotationConfigApplicationContext-MainConfig-class" class="headerlink" title="AnnotationConfigApplicationContext(MainConfig.class)"></a>AnnotationConfigApplicationContext(MainConfig.class)</h3><ul><li><p>this();</p><ul><li><p>this.beanFactory = new DefaultListableBeanFactory();</p><p>调用父类的构造函数，初始化BeanFactory</p><ul><li><p>解释</p><ul><li>调用父类的构造函数，初始化BeanFactory</li><li>DefaultListableBeanFactory还继承了BeanDefinitionRegistry的功能</li><li>DefaultListableBeanFactory属性</li></ul></li></ul></li><li><p>this.reader = new AnnotatedBeanDefinitionReader(this);</p><ul><li><p>解释</p><ul><li><p>注册spring内置的PostProcessor到BeanDefinitionMap中，这几个类是spring的创始类</p><ul><li><p>AutowiredAnnotationBeanPostProcessor</p><p>用于解析@Autowired</p></li><li><p>internalConfigurationAnnotationProcessorConfigurationClassPostProcessor</p><p>在这个类中，会解析加了@Configuration的配置类，还会解析@ComponentScan、@ComponentScans注解扫描的包，以及解析@Import等注解。</p></li><li><p>RequiredAnnotationBeanPostProcessor</p><p>用于解析@Required</p></li><li><p>CommonAnnotationBeanPostProcessor</p><p>它负责解析<br>@Resource、@WebServiceRef、@EJB三个注解。<br>这三个注解都是定义在javax.*包下的注解，属于java中的注解。</p></li><li><p>EventListenerMethodProcessor</p></li><li><p>DefaultEventListenerFactory</p><p>负责创建监听器：ApplicationListenerMethodAdapter<br>为标注了@EventListener的方法<br>创建调用监听适配器：ApplicationListenerMethodAdapter</p></li></ul></li></ul></li><li><p>AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);</p><p>public static Set<beandefinitionholder> registerAnnotationConfigProcessors(</beandefinitionholder></p><pre><code>  BeanDefinitionRegistry registry, @Nullable Object source) {</code></pre><p>   DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);<br>   if (beanFactory != null) {</p><pre><code>  if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {     //注册了实现Order接口的排序器     beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);  }  //设置@AutoWired的候选的解析器：ContextAnnotationAutowireCandidateResolver  // getLazyResolutionProxyIfNecessary方法，它也是唯一实现。  //如果字段上带有@Lazy注解，表示进行懒加载 Spring不会立即创建注入属性的实例，而是生成代理对象，来代替实例  if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {     beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());  }</code></pre><p>   }</p><p>   Set<beandefinitionholder> beanDefs = new LinkedHashSet&lt;&gt;(8);</beandefinitionholder></p><p>   /**</p><pre><code>* 为我们容器中注册了解析我们配置类的后置处理器ConfigurationClassPostProcessor* 名字叫:org.springframework.context.annotation.internalConfigurationAnnotationProcessor*/</code></pre><p>   if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {</p><pre><code>  RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);  def.setSource(source);  beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</code></pre><p>   }</p><p>   /**</p><pre><code>* 为我们容器中注册了处理@Autowired 注解的处理器AutowiredAnnotationBeanPostProcessor* 名字叫:org.springframework.context.annotation.internalAutowiredAnnotationProcessor*/</code></pre><p>   if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {</p><pre><code>  RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);  def.setSource(source);  beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</code></pre><p>   }</p><p>   /**</p><pre><code>* 为我们容器中注册处理@Required属性的注解处理器RequiredAnnotationBeanPostProcessor* 名字叫:org.springframework.context.annotation.internalRequiredAnnotationProcessor*/</code></pre><p>   if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {</p><pre><code>  RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);  def.setSource(source);  beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</code></pre><p>   }</p><p>   /**</p><pre><code>* 为我们容器注册处理JSR规范的注解处理器CommonAnnotationBeanPostProcessor* org.springframework.context.annotation.internalCommonAnnotationProcessor*/</code></pre><p>   if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {</p><pre><code>  RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);  def.setSource(source);  beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</code></pre><p>   }</p><p>   /**</p><pre><code>* 处理jpa注解的处理器org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor*/</code></pre><p>   if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {</p><pre><code>  RootBeanDefinition def = new RootBeanDefinition();  try {     def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,           AnnotationConfigUtils.class.getClassLoader()));  }  catch (ClassNotFoundException ex) {     throw new IllegalStateException(           &quot;Cannot load optional framework class: &quot; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);  }  def.setSource(source);  beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</code></pre><p>   }</p><p>   /**</p><pre><code>* 处理监听方法的注解@EventListener解析器EventListenerMethodProcessor*/</code></pre><p>   if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {</p><pre><code>  RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);  def.setSource(source);  beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</code></pre><p>   }</p><p>   /**</p><pre><code>* 注册事件监听器工厂*/</code></pre><p>   if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {</p><pre><code>  RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);  def.setSource(source);  beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</code></pre><p>   }</p><p>   return beanDefs;<br>}</p><ul><li><p>registerPostProcessor()</p><p>注册某个具体的内置PostProcessor，会存放到BeanDefinitionMap中</p></li></ul></li></ul></li><li><p>this.scanner = new ClassPathBeanDefinitionScanner(this);</p><ul><li><p>解释</p><ul><li>会加载系统环境变量和资源读取器，并且里面定义了扫描包的核心方法doScan()</li><li>但是这里的scanner只用于applicationContext调用调度扫描包注册beanDefinition</li><li>还有个非常重要的地方，new ClassPathBeanDefinitionScanner的时候会调用registerDefaultFilters();在里面注册扫描时过滤候选component的includeFilters</li></ul></li><li><p>registerDefaultFilters();</p></li><li><p>setEnvironment(environment);</p><ul><li>设置环境对象</li></ul></li><li><p>setResourceLoader(resourceLoader);</p><ul><li>设置资源加载器</li></ul></li></ul></li></ul></li><li><p>register(componentClasses);</p><p>for (Class&lt;?&gt; annotatedClass : annotatedClasses) {<br>   registerBean(annotatedClass);<br>}</p><ul><li><p>解释</p><ul><li>将配置类(@Configuration标注的)注册到BeanDefinitionMap中。(这个类是启动容器的配置类)</li></ul></li></ul></li><li><p>refresh();</p><ul><li><p>invokeBeanFactoryPostProcessors(beanFactory);</p><ul><li><p>解释</p><ul><li>调用我们的bean工厂的后置处理器</li><li>会在此将class扫描成beanDefinition到beanDefinitionMap中</li><li>bean工厂的后置处理器调用</li></ul></li><li><p>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</p><ul><li><p>解释</p><ul><li>if (beanFactory instanceof BeanDefinitionRegistry)可以发现这句代码，如果是applicationContext就进入，有众多流程</li><li><p>若仅仅是beanFactory，则执行如下代码</p><p>invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</p></li></ul></li><li><p>invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</p><ul><li><p>解释</p><ul><li>获取容器中的ConfigurationClassPostProcessor的后置处理器进行bean定义的扫描，解析@Bean,@Component,@Service等等注解，添加到beanDefinitionMap中</li></ul></li></ul></li></ul></li><li><p>getBeanFactoryPostProcessors()</p><ul><li>我们自己调用addBeanFactoryPostProcessor的自定义BeanFactoryPostProcessor</li></ul></li></ul></li><li><p>registerBeanPostProcessors(beanFactory);</p><ul><li><p>解释</p><ul><li>注册BeanPostProcessor</li></ul></li><li><p>后置处理器9处调用</p></li><li><p>registerBeanPostProcessors</p><ul><li><p>注册主要的几个BeanPostProcessor</p><ul><li><p>AutowiredAnnotationBeanPostProcessor</p><p>解析@Autowired</p></li><li><p>RequiredAnnotationBeanPostProcessor</p><p>解析@Required</p></li><li><p>CommonAnnotationBeanPostProcessor</p><p>解析@Resource、@WebServiceRef、@EJB</p></li></ul></li></ul></li></ul></li><li><p>finishBeanFactoryInitialization(beanFactory);</p><ul><li><p>解释</p><ul><li>整个bean的创建过程</li></ul></li><li><p>beanFactory.preInstantiateSingletons();</p><p>实例化单例bean</p><ul><li><p>getBean</p><ul><li><p>doGetBean</p><ul><li>实例化createBean</li><li>属性注入@Autowired   @Value</li><li><p>初始化initMethod   destroy</p><ul><li>Aware</li><li>@PostConstruct</li><li>InitializingBean</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><ul><li><p>spring底层核心常用注解</p><ul><li><p>1.配置</p><ul><li>@Configuration</li><li>@Bean</li></ul></li><li><p>2.包扫描</p><ul><li><p>@ComponentScan</p><ul><li>excludeFilters</li><li>includeFilters</li><li>Filter</li></ul></li></ul></li><li><p>3.配置bean的作用域</p><ul><li><p>@Scope</p><ul><li>a) singleton 单实例的(默认) </li><li>b) prototype 多实例的 </li><li>c) request 同一次请求 </li><li>d) session 同一个会话级别</li></ul></li></ul></li><li><p>4.Bean的懒加载</p><ul><li>@Lazy</li></ul></li><li><p>5.条件判断</p><ul><li>@Conditional</li></ul></li><li><p>6.往IOC中添加组件</p><ul><li><p>@CompentScan +@Controller @Service @Respository @compent</p><ul><li>针对我们自己写的组件可以通过该方式来进行加载到容器中。</li></ul></li><li><p>@Bean</p><ul><li>适用于导入第三方组件的类</li></ul></li><li><p>@Import</p><ul><li>导入组件的id为全类名路径</li><li>ImportSelector</li><li>ImportBeanDefinitionRegister</li></ul></li><li><p>实现FactoryBean</p></li></ul></li><li><p>7.Bean的初始化和销毁方法</p><ul><li>@Bean(initMethod = “init”,destroyMethod = “destroy”)</li><li>实现InitializingBean和DisposableBean</li><li>使用@PostConstruct 和@ProDestory标注方法</li><li>实现BeanPostProcessor重写postProcessBeforeInitialization和postProcessAfterInitialization</li></ul></li><li><p>8.给组件赋值</p><ul><li>@Value +@PropertySource</li></ul></li><li><p>9.自动装配</p><ul><li>@Autowired</li><li><p>@Qualifier</p><ul><li>指定特定的bean装配，===在@bean后加@Primary</li></ul></li><li><p>@Resource</p></li><li>@Inject</li></ul></li><li><p>10.使用IOC的组件，如ApplicationContext</p><ul><li>实现XXXAware接口</li></ul></li><li><p>11.@Profile</p><ul><li>根据不同环境激活bean</li><li>运行时jvm参数来切换 -Dspring.profiles.active=test|dev|prod</li></ul></li></ul></li><li><p>IOC容器整体加载流程图</p></li><li>IOC容器整体加载流程图(详细)</li><li>spring设计模式</li><li><p>spring源码脑图</p></li><li><p>spring中文文档</p></li><li><p>IOC概念</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IOC容器源码-大体&quot;&gt;&lt;a href=&quot;#IOC容器源码-大体&quot; class=&quot;headerlink&quot; title=&quot;IOC容器源码(大体)&quot;&gt;&lt;/a&gt;IOC容器源码(大体)&lt;/h2&gt;&lt;h3 id=&quot;1-整体介绍&quot;&gt;&lt;a href=&quot;#1-整体介绍&quot; class
      
    
    </summary>
    
    
      <category term="JavaEE" scheme="https://alexander-wd.github.io/categories/JavaEE/"/>
    
    
      <category term="spring" scheme="https://alexander-wd.github.io/tags/spring/"/>
    
  </entry>
  
</feed>
