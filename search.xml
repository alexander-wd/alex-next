<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM学习笔记</title>
    <url>/alex-next/2022/03/22/javaEE/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="1-类加载机制"><a href="#1-类加载机制" class="headerlink" title="1.类加载机制"></a>1.类加载机制</h2><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h3><p>在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的 main()方法，new对象等等，在加载阶段会在内存中生成一个代表这个类的 java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>
<ul>
<li><p>1.类加载器初始化过程</p>
<p>  参见类运行加载全过程图可知其中会创建JVM启动器实例sun.misc.Launcher。<br>  sun.misc.Launcher初始化使用了单例模式设计，保证一个JVM虚拟机内只有一个 sun.misc.Launcher实例。<br>   在Launcher构造方法内部，其创建了两个类加载器，<br>  分别是<br>  sun.misc.Launcher.ExtClassLoader(扩展类加载器)和sun.misc.Launcher.AppClassLoader(应 用类加载器)。 JVM默认使用Launcher的getClassLoader()方法返回的类加载器AppClassLoader的实例加载我们 的应用程序。</p>
<ul>
<li>类加载运行全过程图</li>
<li><p>类加载器</p>
<ul>
<li>1.引导类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如rt.jar、charsets.jar等 </li>
<li>2.扩展类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR类包</li>
<li>3.应用程序类加载器：负责加载ClassPath路径下的类包，主要就是加载你自己写的那些类</li>
<li>4.自定义加载器：负责加载用户自定义路径下的类包 </li>
</ul>
</li>
</ul>
</li>
<li><p>2.双亲委派机制</p>
<ol>
<li>首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接 返回。<ol>
<li>如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加 载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加载器来加载。</li>
</ol>
</li>
<li>如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的 findClass方法来完成类加载。(注意AppClassLoader和ExtClassLoader的findClass方法均在URLClassLoader中实现)</li>
</ol>
<ul>
<li><p>双亲委派机制</p>
</li>
<li><p>为什么要设计双亲委派机制</p>
<ul>
<li>1.沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心<br>  API库被随意篡改 </li>
<li>2.避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证被加载类的唯一性</li>
</ul>
</li>
<li><p>细节</p>
<p>  双亲委派机制<br>  向上委托主要是判断要加载的类有没有被加载到内存，如果已被加载到内存，就没必要继续向上委托。<br>  而父类向下委托则是判断自己的类路径中有没有该类，有的话直接加载进内存。</p>
</li>
</ul>
</li>
<li><p>2.*全盘负责委托机制</p>
<ul>
<li>“全盘负责”是指当一个ClassLoder装载一个类时，除非显示的使用另外一个ClassLoder，该类<br>  所依赖及引用的类也由这个ClassLoder载入。 </li>
</ul>
</li>
</ul>
<h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h3><p>校验字节码文件的正确性</p>
<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3.准备"></a>3.准备</h3><p>给类的静态变量分配内存，并赋予默认值</p>
<h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h3><p>将符号引用替换为直接引用(也就是得到类或者字段、方法在内存中的指针或者偏移量)，该阶段会把一些静态方法(符号引用，<br>比如 main()方法替换为指向数据所存内存的指针或句柄等(直接引用)，<br>这是所谓的静态链接过程(类加载期间完成)，动态链接是在程序运行期间完成的将符号引用替换为直接引用，下节课会讲到动态链接</p>
<h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h3><p>对类的静态变量初始化为指定的值，<br>执行静态代码块</p>
<h3 id="6-结果"><a href="#6-结果" class="headerlink" title="6.结果"></a>6.结果</h3><p>类被加载到方法区中后主要包含<br>运行时常量池、类型信息、字段信息、方法信息、类加载器的 引用、对应class实例的引用等信息。<br>类加载器的引用：这个类到类加载器实例的引用 对应class实例的引用：类加载器在加载类信息放到方法区中后，会创建一个对应的Class 类型的 对象实例放到堆(Heap)中, 作为开发人员访问方法区中类定义的入口和切入点。</p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，<br>一个是 loadClass(String, boolean)，实现了双亲委派机制，<br>还有一个方法是findClass，默认实现是空 方法，所以我们自定义类加载器主要是重写findClass方法。<br>注:AppClassLoader和ExtClassLoader都继承了URLClassLoader，所以在后续向下委托过程中都能够在各自的类路径中找到并加载相应的类，<br>所以重写findClass方法实际上就是为了实现defineClass方法，将类路径的类加载进来。</p>
<h3 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h3><p>主要思路：<br>在双亲委派的核心方法loadClass中，删掉原有双亲委派的代码，判断哪些类需要双薪委派，哪些类不需要。<br>注：因为Object,String 等JAVA类库中的类只能通过BootStrapClassLoader进行加载。</p>
<ul>
<li>示例</li>
</ul>
<h3 id="tomcat类加载器分析-P13"><a href="#tomcat类加载器分析-P13" class="headerlink" title="tomcat类加载器分析(P13)"></a>tomcat类加载器分析(P13)</h3><ul>
<li><p>1.为什么要打破双亲委派机制</p>
<ul>
<li><p>1.一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。</p>
<ul>
<li>默认的类加载机制是无法加载两个相同类库的不同版本的，默认 的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。</li>
</ul>
</li>
<li><p>2.部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程 序，那么要有10份相同的类库加载进虚拟机。</p>
<ul>
<li>默认的类加载机制是可以实现的，因为他的职责就是保证唯一性</li>
</ul>
</li>
<li><p>3.web容器也有自己依赖的类库，不能与应用程序的类库混淆。基于安全考虑，应该让容器的 类库和程序的类库隔离开来。</p>
<ul>
<li>和第一个问题一样</li>
</ul>
</li>
<li><p>4.web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中 运行，但程序运行后修改jsp已经是司空见惯的事情， web容器需要支持 jsp 修改后不用重启。</p>
<ul>
<li><p>我们想我们要怎么实现jsp文件的热加载，jsp 文件其实也就是class文 件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp 是不会重新加载的。</p>
<ul>
<li>每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载 器。重新创建类加载器，重新加载jsp文件。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="如何判断两个class对象是否相同？"><a href="#如何判断两个class对象是否相同？" class="headerlink" title="如何判断两个class对象是否相同？"></a>如何判断两个class对象是否相同？</h3><ul>
<li>1.类的完整类名必须一致，包括包名</li>
<li>2.加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</li>
</ul>
<h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><ul>
<li><p>1.为什么自定义的类加载器的parent属性是AppClassLoader</p>
<p>  通常实现自己的类加载器都会继承ClassLoader类，<br>  在执行自己的类加载器构造方法时，会先执行父类(ClassLoader)的构造方法，父类构造方法中会将parent属性设置为AppClassLoader。</p>
<ul>
<li>参考图</li>
</ul>
</li>
</ul>
<h2 id="2-对象创建到回收整体流程"><a href="#2-对象创建到回收整体流程" class="headerlink" title="2.对象创建到回收整体流程"></a>2.对象创建到回收整体流程</h2><h3 id="JDK体系结构"><a href="#JDK体系结构" class="headerlink" title="JDK体系结构"></a>JDK体系结构</h3><p>JDK包含了JRE和各种开发工具(如java.exe,javap.exe,javac.exe)，<br>而JRE又包含了JVM和各种JAVA常用类库(如util,concurrency,)</p>
<ul>
<li>参考</li>
</ul>
<h3 id="Java的跨平台特性"><a href="#Java的跨平台特性" class="headerlink" title="Java的跨平台特性"></a>Java的跨平台特性</h3><h3 id="整体结构和内存模型"><a href="#整体结构和内存模型" class="headerlink" title="整体结构和内存模型"></a>整体结构和内存模型</h3><ul>
<li><p>运行时数据区</p>
<ul>
<li>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域</li>
</ul>
</li>
<li><p>五大区域</p>
<ul>
<li><p>程序计数器</p>
<ul>
<li>当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成</li>
</ul>
</li>
<li><p>虚拟机栈(线程栈)</p>
<ul>
<li>用于存储局部变量表、操作数栈、动态链接、方法出口等信息</li>
</ul>
</li>
<li><p>本地方法栈</p>
<ul>
<li>与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的</li>
<li><p>局部变量表</p>
<ul>
<li>存基本数据类型和对象引用</li>
</ul>
</li>
<li><p>操作数栈</p>
<ul>
<li>方法调用的中转站</li>
</ul>
</li>
<li><p>动态链接</p>
<ul>
<li>动态链接的作用就是为了将符号引用转换为调用方法的直接引用(与类装载解析阶段是将静态方法的符号引用转换为直接引用不同)</li>
</ul>
</li>
<li><p>方法出口</p>
<ul>
<li>return 或异常</li>
</ul>
</li>
</ul>
</li>
<li><p>堆</p>
<ul>
<li>Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存</li>
</ul>
</li>
<li><p>方法区</p>
<ul>
<li>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据</li>
</ul>
</li>
</ul>
</li>
<li><p>线程共享</p>
<ul>
<li>堆</li>
<li>方法区</li>
</ul>
</li>
<li><p>线程私有</p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
</li>
</ul>
<h3 id="元空间默认是21M，如果设置过小，满了之后会频繁full-gc"><a href="#元空间默认是21M，如果设置过小，满了之后会频繁full-gc" class="headerlink" title="元空间默认是21M，如果设置过小，满了之后会频繁full gc"></a>元空间默认是21M，如果设置过小，满了之后会频繁full gc</h3><p>-XX：MetaspaceSize： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M，达到该值就会触发 full gc进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超 过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。</p>
<h3 id="方法区、元空间、永久代"><a href="#方法区、元空间、永久代" class="headerlink" title="方法区、元空间、永久代"></a>方法区、元空间、永久代</h3><h2 id="3-内存分配机制"><a href="#3-内存分配机制" class="headerlink" title="3.内存分配机制"></a>3.内存分配机制</h2><h3 id="方法区中的类元信息使用C-实现的，是JVM调用代码使用的，类加载完成之后会在堆中生成Class对象，这个是供开发人员使用的"><a href="#方法区中的类元信息使用C-实现的，是JVM调用代码使用的，类加载完成之后会在堆中生成Class对象，这个是供开发人员使用的" class="headerlink" title="方法区中的类元信息使用C++实现的，是JVM调用代码使用的，类加载完成之后会在堆中生成Class对象，这个是供开发人员使用的"></a>方法区中的类元信息使用C++实现的，是JVM调用代码使用的，类加载完成之后会在堆中生成Class对象，这个是供开发人员使用的</h3><h3 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1.对象的创建"></a>1.对象的创建</h3><ul>
<li><p>对象创建主要流程</p>
</li>
<li><p>1.类加载检查</p>
<p>  首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个<br>  符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
</li>
<li><p>2.分配内存(详见对象内存分配)</p>
<ul>
<li><p>分配内存的方法</p>
<ul>
<li>指针碰撞：类比顺序链表，依次分配内存</li>
<li>空闲链表：类比单链表，哪有空间就存哪</li>
</ul>
</li>
<li><p>解决并发问题</p>
<ul>
<li><p>CAS轮询</p>
<p>  类比并发中的CAS操作，失败重试</p>
</li>
<li><p>本地线程分配缓冲TLAB</p>
<p>  每个线程在堆中预先分配一小块内存，若不够，再CAS轮询</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>3.初始化</p>
<p>  内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）， 如果使用TLAB，这一工作过程也<br>  可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问<br>  到这些字段的数据类型所对应的零值。</p>
</li>
<li><p>4.设置对象头</p>
<ul>
<li><p>1.对象头</p>
<ul>
<li>mark word</li>
<li>Klass Pointer类型指针：对象指向它的类元数据的指针</li>
<li>数组长度(4字节，只有数组对象才有)</li>
</ul>
</li>
<li><p>对象的内存布局</p>
<ul>
<li><p>1.对象头</p>
<ul>
<li>如上</li>
</ul>
</li>
<li><p>2.实例数据</p>
</li>
<li><p>3.对齐填充</p>
<ul>
<li><p>一般以8B为倍数填充，因为计算机组成原理告诉我们一行一行找比一个一个找效率高</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>5.执行<init>方法</init></p>
<p>  执行<init>方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋值（注意，这与上面的赋<br>  零值不同，这是由程序员赋的值），和执行构造方法。</init></p>
</li>
<li><p>指针压缩</p>
<ul>
<li>节省空间</li>
<li>减少GC</li>
<li>对象指针在栈中，对象实体在堆中</li>
</ul>
</li>
<li><p>对象创建初始化与类加载中的初始化对比</p>
<ul>
<li>1.类加载的整体过程都包含在对象创建的加载类中，是对象创建的其中一步(类加载检查，检查是否已加载该类，没加载，就执行第一章的类加载的过程)</li>
<li>2.类加载中的初始化 ，是初始化静态变量以及执行静态代码块，而对象创建的初始化是初始化普通变量(赋0值)</li>
</ul>
</li>
</ul>
<h3 id="2-对象内存分配"><a href="#2-对象内存分配" class="headerlink" title="2.对象内存分配"></a>2.对象内存分配</h3><ul>
<li><p>对象内存分配流程图</p>
</li>
<li><p>1.对象栈上分配(很少发生)：分配到栈空间上，方法结束能够立即回收，减少GC压力</p>
<ul>
<li><p>逃逸分析</p>
<ul>
<li>就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。</li>
</ul>
</li>
<li><p>标量替换</p>
<ul>
<li>通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该 对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就 不会因为没有一大块连续空间导致对象内存不够分配。</li>
</ul>
</li>
<li><p>标量与聚合量</p>
<ul>
<li>例如int,long是标量，对象是聚合量</li>
</ul>
</li>
</ul>
</li>
<li><p>2.对象在Eden区分配</p>
<p>  大量的对象被分配在eden区，eden区满了后会触发minor gc，可能会有99%以上的对象成为垃圾被回收掉，剩余存活的对象会被挪到为空的那块survivor区，下一次eden区满了后又会触发minor gc，把eden区和survivor区垃圾对象回收，把剩余存活的对象一次性挪动到另外一块为空的survivor区，因为新生代的对象都是朝生夕死的，存活时间很短，所以JVM默认的8:1:1的比例是很合适的，让eden区尽量的大，survivor区够用即可，<br>  JVM默认有这个参数-XX:+UseAdaptiveSizePolicy(默认开启)，会导致这个8:1:1比例自动变化，如果不想这个比例有变 化可以设置参数-XX:-UseAdaptiveSizePolicy</p>
</li>
<li><p>大对象直接进入老年代</p>
<ul>
<li>避免大对象分配内存时复制操作而降低效率</li>
<li><p>-XX:PretenureSizeThreshold 可以设置大 对象的大小，只在 Serial 和ParNew两个收集器下 有效。</p>
<ul>
<li>比如设置JVM参数：-XX:PretenureSizeThreshold=1000000 (单位是字节) -XX:+UseSerialGC</li>
</ul>
</li>
</ul>
</li>
<li><p>长期存活的对象将进入老年代</p>
<ul>
<li>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1。</li>
<li>对象晋升到老年代 的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置</li>
</ul>
</li>
<li><p>对象动态年龄判断</p>
<p>  当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的 50%(-XX:TargetSurvivorRatio可以指定)，那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了，<br>  例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会 把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。对象动态年 龄判断机制一般是在minor gc之后触发的。</p>
<ul>
<li>详解</li>
</ul>
</li>
<li><p>老年代空间分配担保机制</p>
</li>
</ul>
<h3 id="3-对象内存回收"><a href="#3-对象内存回收" class="headerlink" title="3.对象内存回收"></a>3.对象内存回收</h3><ul>
<li><p>minorGC和fullGC</p>
<ul>
<li>minorGC:发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。</li>
<li>fullGC:一般会回收老年代 ，年轻代，方法区的垃圾，Major GC的速度一般会比Minor GC的慢 10倍以上</li>
<li>minorGC在eden区满了回收，fullGC在old区满了回收</li>
</ul>
</li>
<li><p>1.引用计数法</p>
<ul>
<li>算法：每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0 的对象就是不可能再被使用的。</li>
<li>弊端：循环引用发生内存泄漏</li>
</ul>
</li>
<li><p>2.可达性分析算法</p>
<ul>
<li>将“GC Roots” 对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为非垃圾对象，其余未标记的 对象都是垃圾对象 GC Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等</li>
</ul>
</li>
<li><p>finalize()方法最终判定对象是否存活(不常用)</p>
</li>
<li><p>如何判断一个类是无用的类</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
</ul>
<h2 id="4-垃圾回收"><a href="#4-垃圾回收" class="headerlink" title="4.垃圾回收"></a>4.垃圾回收</h2><h3 id="1-垃圾回收算法"><a href="#1-垃圾回收算法" class="headerlink" title="1.垃圾回收算法"></a>1.垃圾回收算法</h3><ul>
<li><p>分代收集理论</p>
<p>  在新生代中，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可 以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，<br>  所以我们必须选 择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法慢10倍以上。</p>
</li>
<li><p>1.复制算法</p>
</li>
<li><p>2.标记清除算法</p>
</li>
<li><p>3.标记整理算法</p>
</li>
</ul>
<h3 id="2-垃圾收集器"><a href="#2-垃圾收集器" class="headerlink" title="2.垃圾收集器"></a>2.垃圾收集器</h3><ul>
<li><p>1.Serial</p>
<ul>
<li>-XX:+UseSerialGC -XX:+UseSerialOldGC</li>
</ul>
</li>
<li><p>2.Parallel</p>
<ul>
<li>-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代)</li>
</ul>
</li>
<li><p>3.ParNew</p>
<ul>
<li>-XX:+UseParNewGC，和Parallel相似，主要区别是ParNew可以和CMS收集器配合使用</li>
</ul>
</li>
<li><p>4.CMS</p>
<ul>
<li><p>-XX:+UseConcMarkSweepGC(old)</p>
</li>
<li><p>步骤</p>
<ul>
<li><p>1.初始标记</p>
<ul>
<li>STW暂停所有其他线程，记录下gc roots直接能引用的对象，速度很快。</li>
</ul>
</li>
<li><p>2.并发标记</p>
<p>  这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。</p>
<ul>
<li>从gc roots的直接关联对象开始遍历整个对象图的过程</li>
</ul>
</li>
<li><p>3.重新标记</p>
<p>  这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三色标记里的增量更新算法(见下面详解)做重新标记。</p>
<ul>
<li>会STW，为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对 象的标记记录</li>
</ul>
</li>
<li><p>4.并发清理</p>
<ul>
<li>开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理</li>
</ul>
</li>
<li><p>5.并发重置</p>
<ul>
<li>重置本次GC过程中的标记数据</li>
</ul>
</li>
</ul>
</li>
<li><p>优点和缺点</p>
<ul>
<li><p>优点</p>
<ul>
<li>并发收集、低停顿，对用户反馈友好</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>对CPU资源敏感(会和服务抢资源)</p>
</li>
<li><p>无法处理浮动垃圾</p>
<p>  在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了</p>
</li>
<li><p>使用标记清除算法结束后会产生大量空间碎片</p>
</li>
<li><p>执行过程中的不确定性:若一边回收，一边运行，可能没回收完，就会触发Full GC，会报”concurrent mode failure”，会STW，退化为用serial old收集器处理</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>核心参数</p>
<ul>
<li>-XX:+UseConcMarkSweepGC：启用cms</li>
<li>-XX:ConcGCThreads：并发的GC线程数</li>
<li>-XX:+UseCMSCompactAtFullCollection：FullGC之后做压缩整理（减少碎片），解决缺点第三条</li>
<li>-XX:CMSFullGCsBeforeCompaction：多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一 次</li>
<li>-XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC（默认是92，这是百分比）</li>
<li>-XX:+UseCMSInitiatingOccupancyOnly：只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设 定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整</li>
<li>-XX:+CMSScavengeBeforeRemark：在CMS GC前启动一次minor gc，目的在于减少老年代对年轻代的引 用，降低CMS GC的标记阶段时的开销，一般CMS的GC耗时 80%都在标记阶段</li>
<li>-XX:+CMSParallellnitialMarkEnabled：表示在初始标记的时候多线程执行，缩短STW</li>
<li>-XX:+CMSParallelRemarkEnabled：在重新标记的时候多线程执行，缩短STW;</li>
</ul>
</li>
</ul>
</li>
<li><p>5.G1</p>
<ul>
<li><p>重要特性</p>
<p>  软实时（soft real-time）。所谓的实时垃圾回收，是指在要求的时间内完成垃圾回收。“软实时”则是指，用户可以指定垃圾回收时间的限时，G1会努力在这个时限内完成垃圾回收，但是G1并不担保每次都能在这个时限内完成垃圾回收。通过设定一个合理的目标，可以让达到90%以上的垃圾回收时间都在这个时限内。</p>
</li>
<li><p>回收流程图</p>
</li>
<li><p>特点</p>
<ul>
<li><p>可预测的停顿</p>
<ul>
<li>这是 G1 相对于 CMS 的一个大优势</li>
</ul>
</li>
<li><p>空间整合</p>
<ul>
<li>与 CMS 的“标记-清理”算法不同</li>
<li>G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li>
</ul>
</li>
<li><p>分代收集</p>
<ul>
<li>虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念</li>
</ul>
</li>
<li><p>并行与并发</p>
<ul>
<li>G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。</li>
<li>部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
</ul>
</li>
<li><p>有优先级的回收策略</p>
<ul>
<li><p>在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字 Garbage-First的由来)</p>
<ul>
<li>比如一个Region花200ms能回收10M垃圾，另外一个Region花50ms能回收20M垃圾，在回收时间有限情况下，G1当然会优先选择后面这个Region回收。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>步骤</p>
<ul>
<li><p>初始标记</p>
<ul>
<li>同CMS</li>
</ul>
</li>
<li><p>并发标记</p>
<ul>
<li>同CMS</li>
</ul>
</li>
<li><p>最终标记</p>
<ul>
<li>同CMS重新标记</li>
</ul>
</li>
<li><p>筛选回收</p>
<ul>
<li>会STW</li>
<li><p>首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划</p>
<ul>
<li>例：老年代此时有1000个 Region都满了，但是因为根据预期停顿时间，本次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得 知，可能回收其中800个Region刚好需要200ms，那么就只会回收800个Region(Collection Set，要回收的集合)，尽量把GC导致的停顿时间控制在我们指定的范围内。</li>
<li>可以用JVM参数 -XX:MaxGCPauseMillis指定GC停顿时间</li>
</ul>
</li>
<li><p>不管是年轻代或是老年代，回收算法主要用的是复制算法</p>
<ul>
<li>将一个region中的存活对象复制到另一个region中，这种不会像CMS那样 回收完因为有很多内存碎片还需要整理一次，G1采用复制算法回收几乎不会有太多内存碎片</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>G1 垃圾收集分类</p>
<ul>
<li><p>Young GC</p>
<ul>
<li>YoungGC并不是说现有的Eden区放满了就会马上触发，而是接近参数 -XX:MaxGCPauseMills 设定的值</li>
</ul>
</li>
<li><p>Mixed GC</p>
<ul>
<li>老年代的堆占有率达到参数(-XX:InitiatingHeapOccupancyPercent)设定的值则触发</li>
<li>回收所有的 Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区</li>
</ul>
</li>
<li><p>Full GC</p>
<ul>
<li>Mixed GC使用复制算法发现没有足够的空region就会触发</li>
<li>STW，使用Serial单线程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>*6.ZGC(了解)</p>
<ul>
<li><p>过程</p>
<ul>
<li>1.并发标记：和G1差不多，只不过会用颜色指针记录GC信息</li>
<li>2.并发预备重分配：找出哪些region需要回收</li>
<li>3.并发重分配：利用复制算法GC，每个region维护了一个转发表，后续使用读屏障的地址就是根据转发表获取</li>
<li>4.并发重映射：复制算法将存活对象移到新region中，其他引用该存活对象的引用也要修改，比较耗时，并发执行或者到下次GC并发标记</li>
</ul>
</li>
<li><p>颜色指针</p>
<ul>
<li>概念:GC过程中，将对象可达性标记信息记在引用对象的指针上的技术(无需进行对象访问就可以获得 GC 信息)—结合并发重分配和读屏障理解</li>
<li><p>优点</p>
<ul>
<li>因为可达性标记信息都记录在引用对象指针上，所以region的存活对象被移走后，这个region就能被回收，而不用等到所有引用该对象的对象都修改完毕。</li>
<li>大幅减少GC过程中内存屏障的使用次数</li>
<li>具有强大的扩展性</li>
</ul>
</li>
<li><p>结合读屏障实现垃圾回收</p>
<ul>
<li>如果这时候对象在GC时被移动了，接下来JVM就会加上一个读屏障，这个 屏障会把读出的指针更新到对象的新地址上，并且把堆里的这个指针“修正”到原本的字段里。</li>
</ul>
</li>
</ul>
</li>
<li><p>读屏障</p>
<ul>
<li>在读操作之前，改变引用地址</li>
</ul>
</li>
</ul>
</li>
<li><p>并发标记底层原理—三色标记算法</p>
<ul>
<li><p>标记颜色含义</p>
<ul>
<li>黑色： 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描 过， 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过 灰色对象） 指向某个白色对象。</li>
<li>灰色： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。</li>
<li>白色： 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若 在分析结束的阶段， 仍然是白色的对象， 即代表不可达。</li>
</ul>
</li>
<li><p>步骤</p>
<ul>
<li>1.初始时，所有对象都在 【白色集合】中；</li>
<li>2.将GC Roots 直接引用到的对象 挪到 【灰色集合】中；</li>
<li><p>3.从灰色集合中获取对象：</p>
<ul>
<li>将本对象 引用到的 其他对象 全部挪到 【灰色集合】中；</li>
<li>将本对象 挪到 【黑色集合】里面。</li>
</ul>
</li>
<li><p>重复步骤3，直至【灰色集合】为空时结束。</p>
</li>
</ul>
</li>
<li><p>产生的问题</p>
<ul>
<li><p>浮动垃圾(多标)</p>
<ul>
<li><p>原因</p>
<ul>
<li>并发标记过程中一开始标记为非垃圾，之后方法结束gc root被销毁，只能等下一轮gc</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li>并发清理或并发标记过程中产生的新对象都标记为黑色，本轮不进行清除</li>
</ul>
</li>
</ul>
</li>
<li><p>对象消失(漏标)</p>
<ul>
<li><p>原因</p>
<ul>
<li>在并发标记时，若一个对象本来是垃圾，后又被其他对象引用(救回来了)，这时候这个垃圾如果被GC，会产生严重的bug</li>
<li><p>示例：先赋null，后赋值</p>
<ul>
<li>objE.fieldG = null</li>
<li>objD.fieldG = G</li>
</ul>
</li>
</ul>
</li>
<li><p>产生漏标需要满足的条件</p>
<ul>
<li>赋值器插入了一条或者多条从黑色对象到白色对象的新引用；</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p>增量更新</p>
<p>  当黑色对象插入新的指向白色对象的引用关系时， 就将这个新插入的引用记录下来， 等并发扫描结束之后， 再将这些记录过的引用关系中的黑色对象为根， 重新扫描一次。这可以简化理解为， 黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了。</p>
<ul>
<li>当黑色对象插入新的指向白色对象的引用时，就将这个新加入的引用记录下来，待并发标记完成后，重新对这种新增的引用记录进行扫描</li>
<li><p>实质</p>
<ul>
<li>破坏第一个条件</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>会重新扫描这个黑色对象的所有引用,比较浪费时间</li>
</ul>
</li>
</ul>
</li>
<li><p>原始快照</p>
<ul>
<li>记录从灰色对象删除的引用，并发标记完成后，对该记录进行重新扫描,并将重新扫描到的白色对象直接标记为黑色，不用一层层遍历</li>
<li><p>实质</p>
<ul>
<li>破坏第二个条件</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>这个白色对象有可能并没有黑色对象去引用它，导致它本来应该被回收掉却在本次GC活了下来，产生浮动垃圾</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>相比增量更新来说，只需从灰色对象开始扫描，节省时间。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>解决方案底层原理</p>
<ul>
<li>增量更新和原始快照对引用关系的记录(无论是删除还是新增的引用)，虚拟机的记录操作都是通过写屏障实现的</li>
<li><p>增量更新</p>
<ul>
<li>类似AOP，在成员变量赋值后，记录下新增的引用记录</li>
</ul>
</li>
<li><p>原始快照(SATB)</p>
<ul>
<li>类似AOP，在成员变量赋值前(比如a.b=null引用消失)，记录下来</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>疑惑</p>
<ul>
<li><p>在增量更新中。灰色对象引用了白色对象，不用管吗</p>
<ul>
<li><p>根据三色标记算法步骤得知，灰色对象引用白色对象，不用管，不会造成漏标（在前灰色对象未扫描时，被其他灰色对象引用，这个其后的灰色对象必定会紧接着被扫描到，而黑色对象不会再被扫描到）</p>
<ul>
<li><p>灰色对象未扫描到(灰色)</p>
<ul>
<li>那么就会按照步骤继续扫描</li>
</ul>
</li>
<li><p>灰色对象被扫描到(不可能是灰色，必是黑色)</p>
<ul>
<li>如果是黑色，那就是黑色对象引用了白色对象的问题了，就记录下来</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>G1和CMS的区别</p>
<ul>
<li>1.G1垃圾回收器是compacting的，使用的是复制算法，因此其回收得到的空间是连续的。这避免了CMS回收器因为不连续空间所造成的问题。如需要更大的堆空间，更多的floating garbage。连续空间意味着G1垃圾回收器可以不必采用空闲链表的内存分配方式，而可以直接采用bump-the-pointer的方式；</li>
<li>2.G1回收器的内存与CMS回收器要求的内存模型有极大的不同。G1将内存划分一个个固定大小的region，每个region可以是年轻代、老年代的一个。内存的回收是以region作为基本单位的；</li>
<li>3.CMS：标记清除；G1从整体上是标记整理，局部是标记复制。</li>
<li>4.G1软实时的特性，STW时间可控</li>
</ul>
</li>
<li><p>记忆集和卡表</p>
<ul>
<li><p>原因</p>
<ul>
<li>！！！避免把整个老年代加入GCRoots扫描范围。！！！在新生代做GCRoots可达性扫描过程中可能会碰到跨代引用的对象，这种如果又去对老年代再去扫描效率太低了。</li>
</ul>
</li>
<li><p>记忆集和卡表的关系</p>
<ul>
<li>卡表是记忆集的一种实现方式</li>
<li>类比为Java语言中HashMap与Map的关系</li>
</ul>
</li>
<li><p>卡表存储</p>
<ul>
<li>卡表就是一个数组，每个元素成为卡页，是一个特定大小的内存块</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li>一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变脏，否则为0</li>
<li>GC时，只要筛选本收集区的卡表中变脏的元素加入GCRoots里</li>
</ul>
</li>
<li><p>原理/维护</p>
<ul>
<li>写屏障，类似AOP，更新卡表对应的标识</li>
</ul>
</li>
</ul>
</li>
<li><p>安全点和安全域</p>
<ul>
<li><p>安全点</p>
<ul>
<li><p>概念</p>
<ul>
<li>安全点就是指代码中一些特定的位置,当线程运行到这些位置时它的状态是确定的,这样JVM就可以安全的进行一些操作,比 如GC等</li>
</ul>
</li>
<li><p>常见的安全点</p>
<ul>
<li><ol>
<li>方法返回之前 </li>
</ol>
</li>
<li><ol>
<li>调用某个方法之后 </li>
</ol>
</li>
<li><ol>
<li>抛出异常的位置 </li>
</ol>
</li>
<li><ol>
<li>循环的末尾</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>安全域</p>
<ul>
<li><p>概念</p>
<ul>
<li>Safe Region 是指在一段代码片段中，引用关系不会发生变化。在这个区域内的任意地方开始 GC 都是安全的。</li>
</ul>
</li>
<li><p>比较</p>
<ul>
<li>安全域是对正在执行的线程设定的</li>
<li>如果一个线程处于 Sleep 或中断状态，它就不能响应 JVM 的中断请求，再运行到 Safe Point 上。 因此 JVM 引入了 Safe Region</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-调优实战"><a href="#5-调优实战" class="headerlink" title="5.调优实战"></a>5.调优实战</h2><h3 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h3><ul>
<li>集成了以下所有命令的功能</li>
</ul>
<h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><ul>
<li>查看启动的java进程pid</li>
</ul>
<h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><ul>
<li><p>jmap -histo pid:查看内存信息，实例个数</p>
</li>
<li><p>jmap -heap pid:查看堆信息</p>
</li>
<li><p>jmap ‐dump:format=b,file=eureka.hprof 进程号:将进程信息导出来分析</p>
<p>  也可以设置内存溢出自动导出dump文件(内存很大的时候，可能会导不出来) </p>
<ol>
<li>-XX:+HeapDumpOnOutOfMemoryError </li>
<li>-XX:HeapDumpPath=./ （路径）</li>
</ol>
</li>
</ul>
<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><ul>
<li>jstack pid:查找死锁</li>
<li>jstack pid|grep nid:追踪CPU过高的原因</li>
</ul>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><ul>
<li>jinfo -flags pid:查看jvm参数</li>
<li>jinfo -sysprops pid:查看java系统参数</li>
</ul>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><ul>
<li>jstat -gc pid:最常用，查看gc的各种信息</li>
</ul>
<h3 id="根据jstat推测出内存模型"><a href="#根据jstat推测出内存模型" class="headerlink" title="根据jstat推测出内存模型"></a>根据jstat推测出内存模型</h3><h3 id="arthas"><a href="#arthas" class="headerlink" title="arthas"></a>arthas</h3><h3 id="gc日志分析"><a href="#gc日志分析" class="headerlink" title="gc日志分析"></a>gc日志分析</h3><ul>
<li>GC日志分析工具</li>
</ul>
<h3 id="调优常用参数"><a href="#调优常用参数" class="headerlink" title="调优常用参数"></a>调优常用参数</h3><h2 id="6-字符串常量池"><a href="#6-字符串常量池" class="headerlink" title="6.字符串常量池"></a>6.字符串常量池</h2><h3 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h3><p>记住，常量池中存的也是引用地址，真正的字符串对象存在堆内存中<br>s.intern()的操作:<br>若常量池中没有字符串s的引用地址，则在常量池中存一份s的引用地址；<br>若常量池中有字符串s的引用地址，无需操作，直接返回常量池中的引用。</p>
<p>String s = new String(“a”)+new String(“bc”);// “a”和”bc”的引用放到常量池中，”abc”<br>String s2 = s.intern();// 将”abc”的引用地址放在常量池中，即s的值<br>String x = “abc”;// “abc”在常量池中已有引用地址，即s2或s的值，无需再创建<br>System.out.println(s2==x);//true<br>System.out.println(s==x);//true<br>System.out.println(s==s2);//true</p>
<ul>
<li>图解</li>
</ul>
<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>new StringBuilder(“aa”).append(“bb”).toString();结果:”aa”和”bb”在字符串常量池中，”aabb”在堆中</p>
<h3 id="字符串加法"><a href="#字符串加法" class="headerlink" title="字符串加法"></a>字符串加法</h3><p>String a = “aa”;<br>String b = “bb”;<br>String c = a+b;<br>第三行代码等同于<br>new StringBuilder.append(a).append(b).toString();</p>
<h3 id="八种基本类型的包装类和对象池"><a href="#八种基本类型的包装类和对象池" class="headerlink" title="八种基本类型的包装类和对象池"></a>八种基本类型的包装类和对象池</h3><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li><p>解释:”在常量池中创建对象”</p>
<ul>
<li>对象依旧在堆内存中，常量池里存的只是对象的引用</li>
</ul>
</li>
<li><p>String s = “abc”</p>
<ul>
<li><p>创建对象s的时候，JVM会先去常量池中通过 equals(key) 方法，判断是否有相同的对象</p>
<ul>
<li>如果有，则直接返回该对象在常量池中的引用</li>
<li>如果没有，则会在常量池中创建一个新对象，再返回引用</li>
</ul>
</li>
</ul>
</li>
<li><p>new String(“abc”)</p>
<ul>
<li>如果字符串常量池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”</li>
<li>如果字符串常量池中没有字符串常量“abc”，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象</li>
<li>最后，将堆内存中的引用返回</li>
</ul>
</li>
<li><p>s.intern()</p>
<ul>
<li>若常量池中没有字符串s的引用地址，则在常量池中存一份s的引用地址</li>
<li>若常量池中有字符串s的引用地址，无需操作，直接返回常量池中的引用</li>
</ul>
</li>
<li><p>在编译时能确定的</p>
<ul>
<li><p>以下几种情况</p>
<ul>
<li>String s2=”zhu” + “ge”</li>
<li>String b = “a” + 1</li>
<li>final String bb = “b”</li>
<li>静态方法获取的不行</li>
</ul>
</li>
<li><p>在编译期间会优化成一个字符串，存的只是常量池中的引用</p>
</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li><p>String bb = “b”String b = “a” + bb</p>
<ul>
<li>含变量的字符串相加等同于<br>  new StringBuilder.append(“a”).append(bb).toString();只会(相加操作)在堆中创建”ab”对象，并不会在常量池中存一个引用</li>
</ul>
</li>
<li><p>StringBuilder的toString()</p>
<ul>
<li>会在堆中创建字符串对象，但不会在常量池中存引用</li>
</ul>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>字面量直观点的理解，代码中能看到的字符串，在常量池中必有引用</li>
<li>编译期是否能确定取决于定义的字符串能不能确定</li>
</ul>
</li>
<li><p>特例</p>
<ul>
<li>“java”等关键字一开始就在常量池中</li>
</ul>
</li>
</ul>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2>]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ学习记录</title>
    <url>/alex-next/2021/08/12/javaEE/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><h2 id="1-Rabbitmq基本概念"><a href="#1-Rabbitmq基本概念" class="headerlink" title="1.Rabbitmq基本概念"></a>1.Rabbitmq基本概念</h2><h3 id="MQ概述"><a href="#MQ概述" class="headerlink" title="MQ概述"></a>MQ概述</h3><ul>
<li>全称 Message Queue（消息队列），是在消息的传输过程中保存消息的容器。多用于分布式系统之间进行通信。</li>
</ul>
<h3 id="MQ优势"><a href="#MQ优势" class="headerlink" title="MQ优势"></a>MQ优势</h3><ul>
<li>应用解耦</li>
<li>异步提速</li>
<li>削峰填谷</li>
</ul>
<h3 id="常见的MQ比较"><a href="#常见的MQ比较" class="headerlink" title="常见的MQ比较"></a>常见的MQ比较</h3><h3 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h3><h3 id="几种工作模式"><a href="#几种工作模式" class="headerlink" title="几种工作模式"></a>几种工作模式</h3><ul>
<li>最简单的</li>
<li><p>工作队列</p>
<ul>
<li>就是有多个消费者</li>
</ul>
</li>
<li><p>发布/订阅</p>
<ul>
<li><p>应用场景</p>
<ul>
<li>关注博主之后，主动推送(广播)</li>
</ul>
</li>
</ul>
</li>
<li><p>路由模式</p>
<ul>
<li>能匹配上路由key就发送</li>
</ul>
</li>
<li><p>Topics 主题模式(通配符模式)</p>
<ul>
<li><p>通配符规则</p>
<ul>
<li><h1 id="可以匹配多个词"><a href="#可以匹配多个词" class="headerlink" title="可以匹配多个词"></a>可以匹配多个词</h1></li>
<li>*只能匹配正好一个词</li>
</ul>
</li>
</ul>
</li>
<li><p>tips</p>
<ul>
<li>要自己手动创建交换机</li>
</ul>
</li>
</ul>
<h3 id="消息确认机制"><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h3><ul>
<li>RabbitMq充当了代理人(broker)的角色</li>
<li>ack表示消息已被Broker接收</li>
<li>nack表示Broker拒收消息(队列已满，限流)</li>
</ul>
<h3 id="spring整合rabbitMQ"><a href="#spring整合rabbitMQ" class="headerlink" title="spring整合rabbitMQ"></a>spring整合rabbitMQ</h3><ul>
<li>有参考代码</li>
</ul>
<h2 id="2-RabbitMq如何可靠性消息传递"><a href="#2-RabbitMq如何可靠性消息传递" class="headerlink" title="2.RabbitMq如何可靠性消息传递"></a>2.RabbitMq如何可靠性消息传递</h2><h3 id="springboot整合rabbitmq"><a href="#springboot整合rabbitmq" class="headerlink" title="springboot整合rabbitmq"></a>springboot整合rabbitmq</h3><ul>
<li><p>生产者</p>
<ul>
<li>1.导入依赖，编写配置类</li>
<li>2.定义交换机、队列、绑定关系的配置类</li>
<li>3.注入RabbitTemplate，调用方法，完成消息发送</li>
</ul>
</li>
<li><p>消费者</p>
<ul>
<li>1.导入依赖，编写配置类</li>
<li>2.定义监听类，使用@RabbitListener完成队列监听</li>
</ul>
</li>
</ul>
<h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><ul>
<li><p>消息确认机制</p>
<ul>
<li><p>生产者</p>
<ul>
<li><p>confirm确认模式</p>
<ul>
<li>消息从 producer 到 exchange 则会返回一个 confirmCallback</li>
<li><p>tips</p>
<ul>
<li>成功和失败的时候都能处理</li>
</ul>
</li>
</ul>
</li>
<li><p>return 回退模式</p>
<ul>
<li>消息从 exchange—&gt;queue 投递失败则会返回一个 returnCallback</li>
<li><p>tips</p>
<ul>
<li>要设置rabbitTemplate.setMandatory(true);</li>
<li>exchange到queue失败才会调用回调函数</li>
<li>失败的时候处理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>消费者</p>
<ul>
<li>自动确认模式</li>
<li><p>手动确认模式</p>
<ul>
<li>如果消费者出现了异常，会一直刷屏</li>
</ul>
</li>
<li><p>根据异常情况确认模式</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>消费端限流</p>
<ul>
<li>如果没接收，就表示堵住了，会被限流</li>
</ul>
</li>
<li><p>TTL</p>
<ul>
<li><p>含义</p>
<ul>
<li>Time to live(存活时间)</li>
</ul>
</li>
<li><p>当消息到达存活时间后，还没有被消费，会被自动清除。</p>
</li>
</ul>
</li>
<li><p>死信队列(DLX)</p>
<ul>
<li>又称为死信交换机(DLX)</li>
<li>若一个消息在TTL的时间内没有被消费，会被重新发送给另一个交换机，这个交换机就是DLX</li>
<li><p>步骤</p>
<ul>
<li>1.声明正常的队列(test_queue_dlx)和交换机(test_exchange_dlx)</li>
<li>2.声明死信队列(queue_dlx)和死信交换机(exchange_dlx)</li>
<li>3.正常队列绑定死信交换机</li>
</ul>
</li>
<li><p>死信的情况</p>
<ul>
<li>1.队列消息长度到达限制</li>
<li>2.消费者拒接消费消息</li>
<li>3.原队列存在消息过期设置，消息到达超时时间未被消费</li>
</ul>
</li>
</ul>
</li>
<li><p>延时队列</p>
<ul>
<li>死信队列+TTL</li>
<li>配置消费者的时候记得有个死信消费者绑定到死信队列上</li>
<li><p>应用</p>
<ul>
<li>在规定时间内，没有接受，就回滚库存</li>
</ul>
</li>
</ul>
</li>
<li><p>消息积压</p>
<ul>
<li><p>产生原因</p>
<ul>
<li>消费者宕机积压</li>
<li>消费者消费能力不足积压</li>
<li>生产者流量太大</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li>上线更多消费者</li>
<li><p>上线专门的队列消费服务</p>
<ul>
<li>将消息先批量取出来，记录到数据库中，再慢慢处理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>消息幂等性</p>
<ul>
<li><p>幂等性</p>
<ul>
<li>一次和多次请求某一个资源对于资源本身应该具有同样的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。</li>
</ul>
</li>
<li><p>产生原因</p>
<ul>
<li>生产者发送信息给消费者，消费者很久没消费，MQ重新发送了，这时候消费者可能会多次消费</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li>使用乐观锁，加版本号</li>
</ul>
</li>
</ul>
</li>
<li><p>事务</p>
<ul>
<li>不推荐重量级事务，吞吐量会下降250倍</li>
</ul>
</li>
</ul>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><ul>
<li>架构图</li>
</ul>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><blockquote>
<p>docker pull rabbitmq:managment</p>
<p>启动</p>
<p>docker run -d —name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management</p>
<p>tip:没有的话，docker run 会先安装在启动</p>
<p>解释</p>
<blockquote>
<p>4369, 25672 (Erlang发现&amp;集群端口)</p>
<p>5672, 5671 (AMQP端口)</p>
<p>15672 (web管理后台端口)</p>
<p>61613, 61614 (STOMP协议端口)</p>
<p>1883, 8883 (MQTT协议端口)</p>
<p><a href="https://www.rabbitmq.com/networking.html" target="_blank" rel="noopener">https://www.rabbitmq.com/networking.html</a></p>
</blockquote>
<p>默认账号  guest/guest</p>
</blockquote>
<h4 id="MQ优势-1"><a href="#MQ优势-1" class="headerlink" title="MQ优势"></a>MQ优势</h4><pre><code>应用解耦
</code></pre><blockquote>
<p>如若订单系统调用库存系统的接口改了，那么订单系统也要跟着改，不方便维护</p>
</blockquote>
<p><img alt="1" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208203444.png"></p>
<pre><code>异步提速
</code></pre><p><img alt="2" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208203447.png"></p>
<pre><code>削峰填谷
</code></pre><p><img alt="3" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208203450.png"></p>
<h4 id="消息队列两大规范"><a href="#消息队列两大规范" class="headerlink" title="消息队列两大规范"></a>消息队列两大规范</h4><p>JMS，ActiveMQ实现</p>
<p>AMQP，RabbitMQ实现</p>
<p><img alt="30" data-src="E:\desktop\自学\MyNote\项目\谷粒商城\images\30.png"></p>
<h4 id="基本组件图-概念图"><a href="#基本组件图-概念图" class="headerlink" title="基本组件图(概念图)"></a>基本组件图(概念图)</h4><blockquote>
<p>这是比较整体的图，具体的来说有好几种模式(工作模式，路由模式(Direct：定向)，发布/订阅模式(Fanout：广播)，Topics主题模式(Topic：通配符))</p>
</blockquote>
<p><img alt="img" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208210335.png"></p>
<p>其中MQ就充当了Broker消息代理的角色</p>
<p>route-key路由键结合交换机的类型(direct,fanout,topic)决定消息发给哪些队列，==注意和队列名称和交换机名称没有关系==</p>
<p>VHost</p>
<blockquote>
<p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</p>
<p>比如java和PHP可以隔离出两个VHost，一个崩溃了不会影响另一个；或者生产和测试可以隔离出两个VHost </p>
</blockquote>
<h4 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h4><h5 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="AmqpAdmin用于增删改查队列、交换机及其绑定关系等"><a href="#AmqpAdmin用于增删改查队列、交换机及其绑定关系等" class="headerlink" title="AmqpAdmin用于增删改查队列、交换机及其绑定关系等"></a>AmqpAdmin用于增删改查队列、交换机及其绑定关系等</h5><blockquote>
<p>结合web图形界面更直观</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DirectExchange(String name, boolean durable, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">    <span class="comment">// 名称,持久化,是否自动删除,额外参数</span></span><br><span class="line">    admin.declareExchange(<span class="keyword">new</span> DirectExchange(<span class="string">"hello-java-exchange"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>));</span><br><span class="line">    log.info(<span class="string">"Exchange:&#123;&#125;创建成功"</span>,<span class="string">"hello-java-exchange"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Queue(String name, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">    <span class="comment">// 名称,是否持久化,是否排他(只能被一个人连接),是否自动删除,额外参数</span></span><br><span class="line">    admin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">"hello-java-queue"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>));</span><br><span class="line">    log.info(<span class="string">"Queue:&#123;&#125;创建成功"</span>,<span class="string">"hello-java-queue"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Binding(String destination, Binding.DestinationType destinationType, String exchange, String routingKey,</span></span><br><span class="line"><span class="comment">//                Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">    <span class="comment">// 目的地，目的地类型(交换机或队列)，交换机，路由键</span></span><br><span class="line">    admin.declareBinding(<span class="keyword">new</span> Binding(<span class="string">"hello-java-queue"</span>,Binding.DestinationType.QUEUE,</span><br><span class="line">            <span class="string">"hello-java-exchange"</span>,</span><br><span class="line">            <span class="string">"hello.java"</span>,<span class="keyword">null</span>));</span><br><span class="line">    log.info(<span class="string">"Binding:&#123;&#125;创建成功"</span>,<span class="string">"hello-java-binding"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RabbitTemplate用于发送消息"><a href="#RabbitTemplate用于发送消息" class="headerlink" title="RabbitTemplate用于发送消息"></a>RabbitTemplate用于发送消息</h5><p>如果要发送对象，就必须实现序列化接口</p>
<p>或者转为json发送(需要往容器中注入rabbitmq的json转换器 Jackson2JsonMessageConverter)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    OrderReturnReasonEntity reasonEntity = <span class="keyword">new</span> OrderReturnReasonEntity();</span><br><span class="line">    reasonEntity.setId(<span class="number">1L</span>);</span><br><span class="line">    reasonEntity.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">    reasonEntity.setName(<span class="string">"reason"</span>);</span><br><span class="line">    reasonEntity.setStatus(<span class="number">1</span>);</span><br><span class="line">    reasonEntity.setSort(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 如果要发送对象，就必须实现序列化接口或者转为json发送</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"hello-java-exchange"</span>,<span class="string">"hello.java"</span>,reasonEntity);</span><br><span class="line">    log.info(<span class="string">"消息:&#123;&#125;发送完成"</span>,<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RabbitListner用于监听信息"><a href="#RabbitListner用于监听信息" class="headerlink" title="@RabbitListner用于监听信息"></a>@RabbitListner用于监听信息</h5><blockquote>
<p>例如接收如上RabbitTemplate发送的信息</p>
<p>@RabbitHandler也常用，不过只能用于方法；@RabbitListner可以用于方法和类。但是@RabbitHandler标注能够方便标注重载方法(区分不同的消息)，@RabbitListner此时就用来标注到类上，表示接收哪个队列的消息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"orderItemService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderItemServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">OrderItemDao</span>, <span class="title">OrderItemEntity</span>&gt; <span class="keyword">implements</span> <span class="title">OrderItemService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = &#123;<span class="string">"hello-java-queue"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revieveMessage</span><span class="params">(Message message,</span></span></span><br><span class="line"><span class="function"><span class="params">                               OrderReturnReasonEntity content,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//拿到主体内容</span></span><br><span class="line">        <span class="keyword">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="comment">//拿到的消息头属性信息</span></span><br><span class="line">        MessageProperties messageProperties = message.getMessageProperties();</span><br><span class="line">        System.out.println(<span class="string">"接受到的消息...内容"</span> + message + <span class="string">"===内容："</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消息确认机制-1"><a href="#消息确认机制-1" class="headerlink" title="消息确认机制"></a>消息确认机制</h4><blockquote>
<p>==保证消息不丢失，可靠抵达，虽然可以使用事务消息，但是性能下降250倍，为此引入确认机制==</p>
</blockquote>
<p>==分别从服务端和消费端实现确认机制==</p>
<p><img alt="32" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230210170128.png"></p>
<h5 id="ConfirmCallback"><a href="#ConfirmCallback" class="headerlink" title="ConfirmCallback"></a>ConfirmCallback</h5><p>只要消息抵达Broker就ack=true</p>
<p><img alt="33" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230210170520.png"></p>
<h5 id="ReturnCallback"><a href="#ReturnCallback" class="headerlink" title="ReturnCallback"></a>ReturnCallback</h5><p>==只要消息没有投递给指定的队列，就触发这个失败回调==</p>
<p><img alt="34" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230210170517.png"></p>
<h5 id="Ack消息确认机制"><a href="#Ack消息确认机制" class="headerlink" title="==Ack消息确认机制=="></a>==Ack消息确认机制==</h5><p><img alt="35" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230210170513.png"></p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    rabbitmq:</span></span><br><span class="line"><span class="attr">        host:</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.108</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">        virtual-host:</span> <span class="string">/</span></span><br><span class="line">        <span class="comment"># 开启发送端消息抵达Broker确认</span></span><br><span class="line"><span class="attr">        publisher-confirms:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 开启发送端消息抵达Queue确认</span></span><br><span class="line"><span class="attr">        publisher-returns:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 只要消息抵达Queue，就会异步发送优先回调returnfirm</span></span><br><span class="line"><span class="attr">        template:</span></span><br><span class="line"><span class="attr">          mandatory:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 手动ack消息，不使用默认的消费端确认</span></span><br><span class="line"><span class="attr">        listener:</span></span><br><span class="line"><span class="attr">          simple:</span></span><br><span class="line"><span class="attr">            acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure>
<p>服务端确认需要的配置config.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageConverter <span class="title">messageConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制RabbitTemplate</span></span><br><span class="line"><span class="comment">     * 1、服务收到消息就会回调</span></span><br><span class="line"><span class="comment">     *      1、spring.rabbitmq.publisher-confirms: true</span></span><br><span class="line"><span class="comment">     *      2、设置确认回调</span></span><br><span class="line"><span class="comment">     * 2、消息正确抵达队列就会进行回调</span></span><br><span class="line"><span class="comment">     *      1、spring.rabbitmq.publisher-returns: true</span></span><br><span class="line"><span class="comment">     *         spring.rabbitmq.template.mandatory: true</span></span><br><span class="line"><span class="comment">     *      2、设置确认回调ReturnCallback</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3、消费端确认(保证每个消息都被正确消费，此时才可以broker删除这个消息)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// @PostConstruct  //MyRabbitConfig对象创建完成以后，执行这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initRabbitTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1、只要消息抵达Broker就ack=true</span></span><br><span class="line"><span class="comment">         * correlationData：当前消息的唯一关联数据(这个是消息的唯一id)</span></span><br><span class="line"><span class="comment">         * ack：消息是否成功收到</span></span><br><span class="line"><span class="comment">         * cause：失败的原因</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//设置确认回调</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback((correlationData,ack,cause) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"confirm...correlationData["</span>+correlationData+<span class="string">"]==&gt;ack:["</span>+ack+<span class="string">"]==&gt;cause:["</span>+cause+<span class="string">"]"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 只要消息没有投递给指定的队列，就触发这个失败回调</span></span><br><span class="line"><span class="comment">         * message：投递失败的消息详细信息</span></span><br><span class="line"><span class="comment">         * replyCode：回复的状态码</span></span><br><span class="line"><span class="comment">         * replyText：回复的文本内容</span></span><br><span class="line"><span class="comment">         * exchange：当时这个消息发给哪个交换机</span></span><br><span class="line"><span class="comment">         * routingKey：当时这个消息用哪个路邮键</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setReturnCallback((message,replyCode,replyText,exchange,routingKey) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"Fail Message["</span>+message+<span class="string">"]==&gt;replyCode["</span>+replyCode+<span class="string">"]"</span> +</span><br><span class="line">                    <span class="string">"==&gt;replyText["</span>+replyText+<span class="string">"]==&gt;exchange["</span>+exchange+<span class="string">"]==&gt;routingKey["</span>+routingKey+<span class="string">"]"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ack消费者确认机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revieveMessage</span><span class="params">(Message message,</span></span></span><br><span class="line"><span class="function"><span class="params">                           OrderReturnReasonEntity content,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Channel channel)</span></span>&#123;</span><br><span class="line">    <span class="comment">//拿到主体内容</span></span><br><span class="line">    <span class="keyword">byte</span>[] body = message.getBody();</span><br><span class="line">    <span class="comment">//拿到的消息头属性信息</span></span><br><span class="line">    MessageProperties messageProperties = message.getMessageProperties();</span><br><span class="line">    System.out.println(<span class="string">"接受到的消息...内容"</span> + <span class="keyword">new</span> String(body) + <span class="string">"===内容："</span> + content);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deliveryTag在该通道内从1开始计数   表示消息唯一标识</span></span><br><span class="line">    <span class="keyword">long</span> deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">    <span class="comment">// 签收消息</span></span><br><span class="line">    <span class="comment">// multiple=false(挨个签收)</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.basicAck(deliveryTag,<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 表示消息唯一标识,是否批量,拒绝后是否发挥服务器重新入队</span></span><br><span class="line">        <span class="comment">// channel.basicNack(deliveryTag,false,true);</span></span><br><span class="line">        <span class="comment">//            // 表示消息唯一标识,拒绝后是否发挥服务器重新入队</span></span><br><span class="line">        <span class="comment">// channel.basicReject(deliveryTag,true);</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 网络中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h4><h5 id="死信路由-DLX"><a href="#死信路由-DLX" class="headerlink" title="死信路由(DLX)"></a>死信路由(DLX)</h5><p>一个消息在满足如下条件下，会进死信路由，记住这里是路由而不是队列， 一个路由可以对应很多队列。（什么是死信）</p>
<p>成为死信的情况：</p>
<pre><code>    1.一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不会被再次放在队列里，被其他消费者使用。（basic.reject/ basic.nack）requeue=false
    2.上面的消息的TTL到了，消息过期了。
    3.队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上
</code></pre><p>Dead Letter Exchange其实就是一种普通的exchange，和创建其他exchange没有两样。只是在某一个设置Dead Letter Exchange的队列中有 消息过期了，会自动触发消息的转发，发送到Dead Letter Exchange中去。</p>
<p>我们既可以控制消息在一段时间后变成死信，又可以控制变成死信的消息 被路由到某一个指定的交换机，结合二者，其实就可以实现一个延时队列</p>
<p>手动ack&amp;异常消息统一放在一个队列处理建议的两种方式<br>        catch异常后，手动发送到指定队列，然后使用channel给rabbitmq确认消息已消费<br>        给Queue绑定死信队列，使用nack（requque为false）确认消息消费失败</p>
<h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><p><img alt="39" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/39.png"></p>
<h5 id="定时任务时效性"><a href="#定时任务时效性" class="headerlink" title="定时任务时效性"></a>定时任务时效性</h5><p><img alt="40" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/40.png"></p>
<h4 id="使用MQ实现最终一致性的分布式事务"><a href="#使用MQ实现最终一致性的分布式事务" class="headerlink" title="==使用MQ实现最终一致性的分布式事务=="></a>==使用MQ实现最终一致性的分布式事务==</h4><p>==遵循一个服务一个交换机的原则==，延时队列设计如下图。</p>
<p><img alt="41" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/41.png"></p>
<h5 id="整体消息队列架构"><a href="#整体消息队列架构" class="headerlink" title="整体消息队列架构"></a>整体消息队列架构</h5><p><img alt="消息队列流程" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/消息队列流程.jpg"></p>
<h5 id="创建延时队列"><a href="#创建延时队列" class="headerlink" title="创建延时队列"></a>创建延时队列</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">orderDelayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Queue(String name,  队列名字</span></span><br><span class="line"><span class="comment">        boolean durable,  是否持久化</span></span><br><span class="line"><span class="comment">        boolean exclusive,  是否排他</span></span><br><span class="line"><span class="comment">        boolean autoDelete, 是否自动删除</span></span><br><span class="line"><span class="comment">        Map&lt;String, Object&gt; arguments) 属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HashMap&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    arguments.put(<span class="string">"x-dead-letter-exchange"</span>, <span class="string">"order-event-exchange"</span>);<span class="comment">// 死信之后发给那个交换机</span></span><br><span class="line">    arguments.put(<span class="string">"x-dead-letter-routing-key"</span>, <span class="string">"order.release.order"</span>);<span class="comment">// 死信之后的routing-key</span></span><br><span class="line">    arguments.put(<span class="string">"x-message-ttl"</span>, <span class="number">60000</span>); <span class="comment">// 消息过期时间 1分钟</span></span><br><span class="line">    Queue queue = <span class="keyword">new</span> Queue(<span class="string">"order.delay.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建死信交换机"><a href="#创建死信交换机" class="headerlink" title="创建死信交换机"></a>创建死信交换机</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TopicExchange</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Exchange <span class="title">orderEventExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *   String name,</span></span><br><span class="line"><span class="comment">     *   boolean durable,</span></span><br><span class="line"><span class="comment">     *   boolean autoDelete,</span></span><br><span class="line"><span class="comment">     *   Map&lt;String, Object&gt; arguments</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"order-event-exchange"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建目的地交换机"><a href="#创建目的地交换机" class="headerlink" title="创建目的地交换机"></a>创建目的地交换机</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">orderReleaseQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue queue = <span class="keyword">new</span> Queue(<span class="string">"order.release.order.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="绑定关系"><a href="#绑定关系" class="headerlink" title="绑定关系"></a>绑定关系</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">orderCreateBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * String destination, 目的地（队列名或者交换机名字）</span></span><br><span class="line"><span class="comment">     * DestinationType destinationType, 目的地类型（Queue、Exhcange）</span></span><br><span class="line"><span class="comment">     * String exchange,</span></span><br><span class="line"><span class="comment">     * String routingKey,</span></span><br><span class="line"><span class="comment">     * Map&lt;String, Object&gt; arguments</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Binding(<span class="string">"order.delay.queue"</span>,</span><br><span class="line">            Binding.DestinationType.QUEUE,</span><br><span class="line">            <span class="string">"order-event-exchange"</span>,</span><br><span class="line">            <span class="string">"order.create.order"</span>,</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">orderReleaseBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Binding(<span class="string">"order.release.order.queue"</span>,</span><br><span class="line">            Binding.DestinationType.QUEUE,</span><br><span class="line">            <span class="string">"order-event-exchange"</span>,</span><br><span class="line">            <span class="string">"order.release.order"</span>,</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="发消息"><a href="#发消息" class="headerlink" title="发消息"></a>发消息</h5><p>订单创建成功往延时队列中发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TODO 订单创建成功，发送消息给MQ</span></span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">"order-event-exchange"</span>,<span class="string">"order.create.order"</span>,order.getOrder());</span><br><span class="line"><span class="comment">// 这里不需要有消费者,过期之后让消费者取消订单就行</span></span><br></pre></td></tr></table></figure>
<h5 id="监听过期消息"><a href="#监听过期消息" class="headerlink" title="监听过期消息"></a>监听过期消息</h5><p>在延迟队列中的消息，相当于有个定时器，到期之后，能够监听到，就可以调用方法来取消订单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"order.release.order.queue"</span>)</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderCloseListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listener</span><span class="params">(OrderEntity orderEntity, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到过期的订单信息，准备关闭订单"</span> + orderEntity.getOrderSn());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            orderService.closeOrder(orderEntity);</span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            channel.basicReject(message.getMessageProperties().getDeliveryTag(),<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MQ的几个可靠性问题"><a href="#MQ的几个可靠性问题" class="headerlink" title="MQ的几个可靠性问题"></a>MQ的几个可靠性问题</h4><h5 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h5><p>没抵达broker(MQ服务器)：保证每个消息一定会发出去，做好日志(存到mysql中)。定期扫描数据库，重新发送失败的消息</p>
<p>抵达了broker(MQ服务器)：使用publisher的消息确认机制</p>
<p><img alt="42" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/42.png"></p>
<h5 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h5><p><img alt="43" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/43.png"></p>
<h5 id="消息积压"><a href="#消息积压" class="headerlink" title="消息积压"></a>消息积压</h5><p><img alt="44" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/44.png"></p>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>springMVC笔记</title>
    <url>/alex-next/2020/07/27/javaEE/SpringMVC/</url>
    <content><![CDATA[<p>项目gitee地址</p>
<blockquote>
<p><a href="https://gitee.com/alexander1/spring-mvc-notes" target="_blank" rel="noopener">https://gitee.com/alexander1/spring-mvc-notes</a></p>
<h1 id="一、SpringMVC入门"><a href="#一、SpringMVC入门" class="headerlink" title="一、SpringMVC入门"></a>一、SpringMVC入门</h1></blockquote>
<p>springMVC的搭建过程：<br>1.导入jar<br>2.在web.xml中配置springMVC的核心控制器DispatcherServlet<br>作用：加载springMVC的配置文件<br>3.创建一个POJO，在此类上加@Controller<br>4.在控制层中，在方法上设置@RequestMapping</p>
<h2 id="1、导入jar"><a href="#1、导入jar" class="headerlink" title="1、导入jar"></a>1、导入jar</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2、在web-xml中配置springMVC的核心控制器DispatcherServlet"><a href="#2、在web-xml中配置springMVC的核心控制器DispatcherServlet" class="headerlink" title="2、在web.xml中配置springMVC的核心控制器DispatcherServlet"></a>2、在web.xml中配置springMVC的核心控制器DispatcherServlet</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/表示拦截除*.jsp之外的请求，静态资源也会拦截，也就不会进入spring的DispatcherServlet类。</span><br><span class="line">/*表示拦截所有请求</span><br></pre></td></tr></table></figure>
<h2 id="3、配置视图解析器-扫描"><a href="#3、配置视图解析器-扫描" class="headerlink" title="3、配置视图解析器+扫描"></a>3、配置视图解析器+扫描</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.springmvc.test"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="二、RequestMapping"><a href="#二、RequestMapping" class="headerlink" title="二、RequestMapping"></a>二、RequestMapping</h1><h2 id="1、-RequestParam"><a href="#1、-RequestParam" class="headerlink" title="1、@RequestParam"></a>1、@RequestParam</h2><p>@RequestParam:</p>
<ul>
<li>value:当不满足赋值条件是，可以试用value属性，指定映射关系</li>
<li>required:设置形参是否必须被赋值，默认为true,必须赋值，若设置为false,则不必须赋值，因此形参的值为null</li>
<li>defaultValue:若形参所获得的值为null,则设置一个默认值</li>
</ul>
<h2 id="2、-RequestHeader"><a href="#2、-RequestHeader" class="headerlink" title="2、@RequestHeader"></a>2、@RequestHeader</h2><p>在处理请求的方法上，获取请求头信息，用法和@RequestParam用法一致</p>
<h2 id="3、-PathVariable"><a href="#3、-PathVariable" class="headerlink" title="3、@PathVariable"></a>3、@PathVariable</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以前：localhost:8080/testRest?id=1001&amp;username=admin</span></span><br><span class="line"><span class="comment">     * 现在：localhost:8080/testRest/1001/admin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@PathVariable</span> 用来获取路径中占位符的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testRest/&#123;id&#125;/&#123;username&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRest</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Integer id,@<span class="title">PathVariable</span><span class="params">(<span class="string">"username"</span>)</span>String username)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"id:"</span>+id+<span class="string">",username:"</span>+username);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、RESTFUL风格"><a href="#三、RESTFUL风格" class="headerlink" title="三、RESTFUL风格"></a>三、RESTFUL风格</h1><p>RESTFUL：</p>
<ul>
<li>method：用来设置请求方式，只有客户端发送请求的方式和method的值一直，才能处理请求</li>
<li>请求方式：GET 查询 POST 添加 PUT 修改 DELETE 删除</li>
<li>params:用来设置客户端传到服务器的数据</li>
<li>headers:用来设置请求头信息,所发送的请求头信息一定要和headers属性一致</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置Restful风格的过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--过滤所有请求--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="前台"><a href="#前台" class="headerlink" title="前台"></a>前台</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"testREST/1001"</span>&gt;</span>测试GET<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"testREST"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"测试POST"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"testREST"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"_method"</span> <span class="attr">value</span>=<span class="string">"PUT"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"测试PUT"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"testREST"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"_method"</span> <span class="attr">value</span>=<span class="string">"DELETE"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"测试DELETE"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"测试AJAX"</span> <span class="attr">onclick</span>=<span class="string">"test()"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="actionscript">            url:<span class="string">"testAjax_DELETE"</span>,</span></span><br><span class="line"><span class="actionscript">            type:<span class="string">"DELETE"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line">                id:1001</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            dataType:<span class="string">"json"</span>,<span class="comment">//预期服务器返回结果类型</span></span></span><br><span class="line"><span class="actionscript">            success:<span class="function"><span class="keyword">function</span> <span class="params">(obj)</span> </span>&#123;</span></span><br><span class="line">                alert(obj)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/testREST/&#123;id&#125;"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Integer id)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"GET,id="</span>+id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/testREST"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">insertUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"POST"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果想跳到success.jsp</span></span><br><span class="line"><span class="comment">     * 解决办法：</span></span><br><span class="line"><span class="comment">     * 1.加入 <span class="doctag">@ResponseBody</span> 注解。</span></span><br><span class="line"><span class="comment">     * 2.请求先转给一个Controller,再返回jsp页面。</span></span><br><span class="line"><span class="comment">     * 3.tomcat换到7.0以及以下版本。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/testREST"</span>,method = RequestMethod.PUT)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"PUT...."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/testREST"</span>,method = RequestMethod.DELETE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deleteUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"DELETE...."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"testAjax_DELETE"</span>,method = RequestMethod.DELETE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAjax_DELETE</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"id="</span>+id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">增加：点击增加超链接按钮，通过GET请求方式到服务器，用请求转发的方式跳转到相应的增加页面，</span><br><span class="line">增加完成后通过POST请求方式到服务器，用重定向的方式跳转的list展示页面</span><br><span class="line"></span><br><span class="line">修改：点击修改超链接按钮，通过GET请求方式到服务器，用请求转发的方式跳转到相应的修改页面</span><br><span class="line">并传给修改页面修改之前的实体类信息，</span><br><span class="line">修改完成后通过PUT请求方式到服务器，用重定向的方式跳转的list展示页面</span><br><span class="line"></span><br><span class="line">删除：通过点击超链接按钮，为form表单赋值，并提交表单</span><br><span class="line">$(function()&#123;</span><br><span class="line">    $(<span class="string">".del"</span>).click(function()&#123;</span><br><span class="line">        <span class="keyword">if</span>(confirm(<span class="string">'确认删除吗'</span>))&#123;</span><br><span class="line">            $(<span class="string">'form'</span>).attr(<span class="string">'action'</span>,<span class="keyword">this</span>.href).submit()</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意！！！:return false会将超链接的默认行为取消</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">通过DELETE方式请求，并重定向的方式跳转的list展示页面</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对post请求来说</span><br><span class="line">条件：</span><br><span class="line">1.POST（后台）</span><br><span class="line">2.参数_method（前台）</span><br><span class="line">若不符合条件：-》POST</span><br><span class="line">如符合条件：经过转换之后，真正的请求方式，就是_method的值</span><br></pre></td></tr></table></figure>
<h1 id="四、往作用域中放值"><a href="#四、往作用域中放值" class="headerlink" title="四、往作用域中放值"></a>四、往作用域中放值</h1><h2 id="1、map"><a href="#1、map" class="headerlink" title="1、map"></a>1、map</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/param"</span>,method = RequestMethod.POST)</span><br><span class="line">    <span class="comment">//DispatcherServlet会调用此函数，并为HttpServletRequest赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">param</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>&#123;</span><br><span class="line">        map.put(<span class="string">"username"</span>,<span class="string">"admin"</span>);<span class="comment">//向request作用域中放值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、Model"><a href="#2、Model" class="headerlink" title="2、Model"></a>2、Model</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/param"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="comment">//DispatcherServlet会调用此函数，并为HttpServletRequest赋值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">param</span><span class="params">(Model model,String name,HttpServletRequest request)</span></span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(request.getContextPath());</span><br><span class="line">    model.addAttribute(<span class="string">"name"</span>,name);<span class="comment">//向request作用域中放值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、ModelAndView"><a href="#3、ModelAndView" class="headerlink" title="3、ModelAndView"></a>3、ModelAndView</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/param"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="comment">//DispatcherServlet会调用此函数，并为HttpServletRequest赋值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">param</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">    ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    <span class="comment">//在request中放值</span></span><br><span class="line">    mav.addObject(<span class="string">"username"</span>,<span class="string">"root"</span>);</span><br><span class="line">    mav.setViewName(<span class="string">"success"</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==<strong>三种方式实现作用域放值,其实底层实现都差不多,最终都会封装成ModelAndView，并且通过ViewResolver视图解析器处理</strong>==</p>
<h1 id="五、静态资源处理"><a href="#五、静态资源处理" class="headerlink" title="五、静态资源处理"></a>五、静态资源处理</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    先交给自己配置的DispatcherServlet处理请求，</span></span><br><span class="line"><span class="comment">    当DispatcherServlet没有相应的处理器，就交给tomcat的DefaultServlet处理</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>在springMVC-servlet.xml中配置<mvc:default-servlet-handler>后，会在Spring MVC上下文中定义一个org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler，==它会对进入DispatcherServlet的URL进行筛查，如果发现是静态资源的请求，就将该请求转由Web应用服务器默认的Servlet处理，如果不是静态资源的请求，才由DispatcherServlet继续处理。==</mvc:default-servlet-handler></p>
<p>不过有几点需要注意：</p>
<p>1.一般Web应用服务器默认的Servlet名称是”default”，因此DefaultServletHttpRequestHandler可以找到它。如果你所有的Web应用服务器的默认Servlet名称不是”default”，则需要通过该标签的default-servlet-name属性显示指定。</p>
<p>2.配置该标签以后，@RequestMapping会失效，所以非静态资源请求就不能映射到相应的方法，所以需要加<mvc:annotation-driven></mvc:annotation-driven></p>
<h1 id="六、设置编码过滤器"><a href="#六、设置编码过滤器" class="headerlink" title="六、设置编码过滤器"></a>六、设置编码过滤器</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置编码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="七、上传与下载"><a href="#七、上传与下载" class="headerlink" title="七、上传与下载"></a>七、上传与下载</h1><h2 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h2><h3 id="①、ResponseEntity-不常用"><a href="#①、ResponseEntity-不常用" class="headerlink" title="①、ResponseEntity(不常用)"></a>①、ResponseEntity(不常用)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/down"</span>)</span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;<span class="keyword">byte</span>[]&gt; down(HttpSession session) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获取下载文件的路径,从服务器上下载图片,要找到图片在服务器中的真实位置</span></span><br><span class="line">    String realPath = session.getServletContext().getRealPath(<span class="string">"img"</span>);</span><br><span class="line">    String finalPath = realPath + File.separator+<span class="string">"0.jpg"</span>;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> FileInputStream(finalPath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//available():获取输入流所读取的文件的最大字节数</span></span><br><span class="line">    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">    is.read(b);</span><br><span class="line">    <span class="comment">//请求头</span></span><br><span class="line">    HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    headers.add(<span class="string">"Content-Disposition"</span>,<span class="string">"attachment;filename=a.jpg"</span>);</span><br><span class="line">    HttpStatus status =  HttpStatus.OK;</span><br><span class="line">    ResponseEntity&lt;<span class="keyword">byte</span>[]&gt; entity = <span class="keyword">new</span> ResponseEntity&lt;&gt;(b,headers,status);</span><br><span class="line">    is.close();</span><br><span class="line">    <span class="keyword">return</span> entity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="②、IOUtils下载单个文件"><a href="#②、IOUtils下载单个文件" class="headerlink" title="②、IOUtils下载单个文件"></a>②、IOUtils下载单个文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>FileUpload.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> alex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 下载单个文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 14:49 2020/8/5</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> [minioClient, bucketname, singleFile, request, response]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downLoadSingleFile</span><span class="params">(MinioClient minioClient, String bucketname, String singleFile, HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String userAgent = request.getHeader(<span class="string">"User-Agent"</span>);</span><br><span class="line">        String filename_c = singleFile;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="comment">// IE 8 至 IE 10</span></span><br><span class="line">            userAgent.toUpperCase().contains(<span class="string">"MSIE"</span>) ||</span><br><span class="line">            <span class="comment">// IE 11</span></span><br><span class="line">            userAgent.contains(<span class="string">"Trident/7.0"</span>)) &#123;</span><br><span class="line">            filename_c = java.net.URLEncoder.encode(singleFile, <span class="string">"UTF-8"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            filename_c = <span class="keyword">new</span> String(singleFile.getBytes(<span class="string">"UTF-8"</span>), <span class="string">"iso-8859-1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filename_c = filename_c.replace(<span class="string">","</span>,<span class="string">"_"</span>);</span><br><span class="line"></span><br><span class="line">        InputStream inputStream = minioClient.getObject(bucketname, singleFile);</span><br><span class="line">        response.setHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename="</span> + filename_c);</span><br><span class="line">        response.setContentType(<span class="string">"application/octet-stream"</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">        IOUtils.copy(inputStream, response.getOutputStream());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Controller.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Description</span>(<span class="string">"文件下载"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/downfile"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloadFile</span><span class="params">(Integer id, String singleFile)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MinioClient minioClient = <span class="keyword">new</span> MinioClient(url, user, password);</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="keyword">null</span>) &#123;<span class="comment">// 单个文件</span></span><br><span class="line">        FileUpload.downLoadSingleFile(minioClient, bucketname, singleFile, request, response);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 多个文件</span></span><br><span class="line">        List&lt;InputStream&gt; isList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String filename : fileNames) &#123;</span><br><span class="line">            InputStream inputStream = minioClient.getObject(bucketname, filename);</span><br><span class="line">            isList.add(inputStream);</span><br><span class="line">        &#125;</span><br><span class="line">        FileUpload.downloadZipFiles(response, isList, fileNames, <span class="string">"package.zip"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下载单个文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadFile</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">	  <span class="keyword">const</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);</span><br><span class="line">	  iframe.style.display = <span class="string">"none"</span>; <span class="comment">// 防止影响页面</span></span><br><span class="line">	  iframe.style.height = <span class="number">0</span>; <span class="comment">// 防止影响页面</span></span><br><span class="line">	  iframe.src = url; </span><br><span class="line">	<span class="comment">// 这一行必须，iframe挂在到dom树上才会发请求</span></span><br><span class="line">	  <span class="built_in">document</span>.body.appendChild(iframe); </span><br><span class="line">	  <span class="comment">// 5分钟之后删除</span></span><br><span class="line">	  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">	    iframe.remove();</span><br><span class="line">	  &#125;, <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载多个文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dload</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> rows = $(<span class="string">"#table"</span>).bootstrapTable(<span class="string">"getSelections"</span>); <span class="comment">// 获得要下载的文件</span></span><br><span class="line">	<span class="keyword">if</span>(id!==<span class="literal">undefined</span>)&#123;<span class="comment">//下载单个文件</span></span><br><span class="line">		<span class="keyword">var</span> data = $(<span class="string">"#table"</span>).bootstrapTable(<span class="string">'getRowByUniqueId'</span>,id);</span><br><span class="line">		rows = data</span><br><span class="line">		downloadFile(<span class="string">"/file/downfile?id="</span>+rows.id+<span class="string">"&amp;singleFile="</span>+rows.filename)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> listFileNames = <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; rows.length; i++)&#123;</span><br><span class="line">		listFileNames = listFileNames+rows[i].filename+<span class="string">","</span></span><br><span class="line">	&#125;</span><br><span class="line">	$.ajax(&#123;</span><br><span class="line">		url:<span class="string">'/file/listFileNames'</span>,<span class="comment">//为了防止get方式参数大小溢出，所以用ajax另外处理listFileNames</span></span><br><span class="line">		data:&#123;</span><br><span class="line">			<span class="string">"listFileNames"</span>:listFileNames</span><br><span class="line">		&#125;,</span><br><span class="line">		type : <span class="string">"post"</span>,</span><br><span class="line">		dataType:<span class="string">'json'</span>,</span><br><span class="line">		success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(data)</span><br><span class="line">			<span class="keyword">var</span> curWwwPath=<span class="built_in">window</span>.document.location.href;</span><br><span class="line">			<span class="keyword">var</span> pathName=<span class="built_in">window</span>.document.location.pathname;</span><br><span class="line">			<span class="keyword">var</span> pos=curWwwPath.indexOf(pathName);</span><br><span class="line">			<span class="keyword">var</span> localhostPath=curWwwPath.substring(<span class="number">0</span>,pos);</span><br><span class="line">			<span class="keyword">var</span> path =localhostPath +<span class="string">"/file/downfile"</span>;</span><br><span class="line">			<span class="built_in">window</span>.open(path);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="③、使用ZipOutputStream批量下载-zip"><a href="#③、使用ZipOutputStream批量下载-zip" class="headerlink" title="③、使用ZipOutputStream批量下载(zip)"></a>③、使用ZipOutputStream批量下载(zip)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> alex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 把文件打成压缩包并输出到客户端浏览器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 14:43 2020/8/4</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> [response, srcFiles, zipFileName]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downloadZipFiles</span><span class="params">(HttpServletResponse response, List&lt;InputStream&gt; isList,String[] fileNames, String zipFileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.reset(); <span class="comment">// 重点突出</span></span><br><span class="line">        response.setCharacterEncoding(<span class="string">"UTF-8"</span>); <span class="comment">// 重点突出</span></span><br><span class="line">        response.setContentType(<span class="string">"application/x-msdownload"</span>); <span class="comment">// 不同类型的文件对应不同的MIME类型 // 重点突出</span></span><br><span class="line">        <span class="comment">// 对文件名进行编码处理中文问题</span></span><br><span class="line">        zipFileName = <span class="keyword">new</span> String(zipFileName.getBytes(), StandardCharsets.UTF_8);</span><br><span class="line">        <span class="comment">// inline在浏览器中直接显示，不提示用户下载</span></span><br><span class="line">        <span class="comment">// attachment弹出对话框，提示用户进行下载保存本地</span></span><br><span class="line">        <span class="comment">// 默认为inline方式</span></span><br><span class="line">        response.setHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename="</span> + zipFileName);</span><br><span class="line">        <span class="comment">//            response.setHeader("Content-Disposition", "attachment;filename=" + URLEncoder.encode(zipFileName, "UTF-8"));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// --设置成这样可以不用保存在本地，再输出， 通过response流输出,直接输出到客户端浏览器中。</span></span><br><span class="line">        ZipOutputStream zos = <span class="keyword">new</span> ZipOutputStream(response.getOutputStream());</span><br><span class="line">        zipFile(isList, zos,fileNames);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> alex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 14:42 2020/8/4</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> [filePaths, zos]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zipFile</span><span class="params">(List&lt;InputStream&gt; isList, ZipOutputStream zos, String[] fileNames)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置读取数据缓存大小</span></span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//循环读取文件路径集合，获取每一个文件的路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;fileNames.length;++i) &#123;</span><br><span class="line">            fileNames[i].replaceAll(<span class="string">","</span>,<span class="string">"_"</span>);</span><br><span class="line">            fileNames[i].replaceAll(<span class="string">"."</span>,<span class="string">"_"</span>);</span><br><span class="line">            <span class="comment">//将文件写入zip内，即将文件进行打包</span></span><br><span class="line">            zos.putNextEntry(<span class="keyword">new</span> ZipEntry(fileNames[i]));</span><br><span class="line">            <span class="comment">//写入文件的方法，同上</span></span><br><span class="line">            <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//设置读取数据缓存大小</span></span><br><span class="line">            <span class="keyword">while</span> ((size = isList.get(i).read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                zos.write(buffer, <span class="number">0</span>, size);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//关闭输入输出流</span></span><br><span class="line">            zos.closeEntry();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != zos) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                zos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、上传"><a href="#2、上传" class="headerlink" title="2、上传"></a>2、上传</h2><p>xml配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    将客户端的File文件，处理为MultipartFile</span></span><br><span class="line"><span class="comment">    文件解析器的id必须设置为multipartResolver</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;property name="maxUploadSize" value="88888"&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="①、自己手写"><a href="#①、自己手写" class="headerlink" title="①、自己手写"></a>①、自己手写</h3><p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/up_old"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">up_old</span><span class="params">(String desc, MultipartFile uploadFile,HttpSession session)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获取上传文件的名称</span></span><br><span class="line">    String fileName = uploadFile.getOriginalFilename();</span><br><span class="line">    <span class="comment">//获取服务器下项目的文件路径</span></span><br><span class="line">    String path = session.getServletContext().getRealPath(<span class="string">"photo"</span>)+File.separator+fileName;</span><br><span class="line">    File file = <span class="keyword">new</span> File(session.getServletContext().getRealPath(<span class="string">"photo"</span>));</span><br><span class="line">    <span class="keyword">if</span> (!file.exists())&#123;<span class="comment">//不存在就创建</span></span><br><span class="line">        file.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取输入流</span></span><br><span class="line">    InputStream is = uploadFile.getInputStream();</span><br><span class="line">    <span class="comment">//获取输出流</span></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(path);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">while</span> ((i = is.read(b))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//最后一次不一定有4096个字节</span></span><br><span class="line">        fos.write(b,<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    fos.close();</span><br><span class="line">    is.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"uploadSuccess"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/up"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    头像：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"uploadFile"</span>/&gt;</span></span><br><span class="line">    描述：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"desc"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="②、使用MultipartFile-transferTo-File-dest"><a href="#②、使用MultipartFile-transferTo-File-dest" class="headerlink" title="②、使用MultipartFile.transferTo(File dest)"></a>②、使用MultipartFile.transferTo(File dest)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/up"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">up</span><span class="params">(String desc, MultipartFile uploadFile,HttpSession session)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获取上传文件的名称</span></span><br><span class="line">    String fileName = uploadFile.getOriginalFilename();</span><br><span class="line">    String finalFileName = UUID.randomUUID()+fileName.substring(fileName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">    <span class="comment">//获取服务器下项目的文件路径</span></span><br><span class="line">    String path = session.getServletContext().getRealPath(<span class="string">"photo"</span>)+File.separator+finalFileName;</span><br><span class="line">    File directory = <span class="keyword">new</span> File(session.getServletContext().getRealPath(<span class="string">"photo"</span>));</span><br><span class="line">    <span class="keyword">if</span> (!directory.exists())&#123;<span class="comment">//不存在就创建</span></span><br><span class="line">        directory.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    File file = <span class="keyword">new</span> File(path);</span><br><span class="line">    uploadFile.transferTo(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"uploadSuccess"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多个文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MultipartFile[] uploadFile</span><br><span class="line"></span><br><span class="line">&lt;form action=&quot;/up&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">头像：&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;/&gt;</span><br><span class="line">头像2：&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;/&gt;</span><br><span class="line">描述：&lt;input type=&quot;text&quot; name=&quot;desc&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<h3 id="③、使用bootstrap-fileinput"><a href="#③、使用bootstrap-fileinput" class="headerlink" title="③、使用bootstrap-fileinput"></a>③、使用bootstrap-fileinput</h3><p>导入相关依赖</p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为上传添加技能</span></span><br><span class="line">initFileInput(<span class="string">"fireName"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initFileInput</span>(<span class="params">ctrlName</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> control = $(<span class="string">'#'</span> + ctrlName);</span><br><span class="line">	control.fileinput(&#123;</span><br><span class="line">		language: <span class="string">'zh'</span>, <span class="comment">// 设置语言</span></span><br><span class="line">		uploadUrl: <span class="string">"/file/upload"</span>, <span class="comment">// 上传的地址</span></span><br><span class="line">		allowedPreviewTypes:[<span class="string">'image'</span>],<span class="comment">// 配置所有的被预览文件类型</span></span><br><span class="line">		allowedFileExtensions: [<span class="string">'xls'</span>, <span class="string">'xlsx'</span>, <span class="string">'pdf'</span>,<span class="string">'doc'</span>,<span class="string">'docx'</span>,<span class="string">'jpg'</span>,<span class="string">'jpeg'</span>,<span class="string">'png'</span>],<span class="comment">// 接收的文件后缀</span></span><br><span class="line">		<span class="comment">// uploadExtraData:&#123;"id": 1, "fileName":'123.mp3'&#125;,</span></span><br><span class="line">		uploadAsync: <span class="literal">true</span>, <span class="comment">// 默认异步上传</span></span><br><span class="line">		showUpload: <span class="literal">true</span>, <span class="comment">// 是否显示上传按钮</span></span><br><span class="line">		showRemove : <span class="literal">false</span>, <span class="comment">// 显示移除按钮</span></span><br><span class="line">		showCaption:<span class="literal">true</span>, <span class="comment">// 是否显示标题</span></span><br><span class="line">		dropZoneEnabled:<span class="literal">true</span>,<span class="comment">// 是否显示拖拽区域</span></span><br><span class="line">		showPreview : <span class="literal">true</span>, <span class="comment">// 是否显示预览</span></span><br><span class="line">		showCaption: <span class="literal">false</span>,<span class="comment">// 是否显示标题</span></span><br><span class="line">		browseClass: <span class="string">"btn btn-primary"</span>, <span class="comment">// 按钮样式</span></span><br><span class="line">		maxFileSize:<span class="number">1024000</span>,<span class="comment">// 允许文件大小单位KB</span></span><br><span class="line"><span class="comment">// maxFileCount: 5, // 允许同时上传的最大文件个数</span></span><br><span class="line">		enctype: <span class="string">'multipart/form-data'</span>,</span><br><span class="line">		validateInitialCount:<span class="literal">true</span>,</span><br><span class="line"><span class="comment">// msgFilesTooMany: "选择上传的文件数量(&#123;n&#125;) 超过允许的最大数值&#123;m&#125;！"</span></span><br><span class="line">		uploadExtraData: <span class="function"><span class="keyword">function</span>(<span class="params">previewId, index</span>) </span>&#123;   <span class="comment">//额外参数的关键点</span></span><br><span class="line">			<span class="keyword">var</span> parameter = &#123;</span><br><span class="line">				<span class="string">"pageId"</span>:Id,</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="keyword">return</span> parameter;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).on(<span class="string">'filepreupload'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event, data, previewId, index</span>) </span>&#123;     <span class="comment">// 上传中</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'文件正在上传'</span>);</span><br><span class="line">	&#125;).on(<span class="string">"fileuploaded"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, file, previewId, index</span>) </span>&#123;    <span class="comment">// 一个文件上传成功</span></span><br><span class="line">		<span class="comment">// file.response得到后台处理后的结果</span></span><br><span class="line">		<span class="comment">// file.filescount .得到文件个数</span></span><br><span class="line">		<span class="comment">// index，当前文件的下标</span></span><br><span class="line">	&#125;).on(<span class="string">'fileerror'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event, data, msg</span>) </span>&#123;  <span class="comment">// 一个文件上传失败</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'文件上传失败！'</span>+data.status);</span><br><span class="line">		swal(<span class="string">"文件上传失败！"</span>,<span class="string">""</span>,<span class="string">"error"</span>);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后台</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 上传多个文件 这个其实一次只处理一个文件，但接收却是用MultipartFile[] file，匪夷所思</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: upload</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="doctag">@param</span>  file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="doctag">@param</span>  pageId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="doctag">@throws</span> IOException 参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Map&lt;String, Object&gt; 返回类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> <span class="doctag">@author</span> 王迪</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020年3月10日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/upload"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">upload</span><span class="params">(@RequestParam(<span class="string">"file"</span>)</span> MultipartFile[] file, String pageId) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="keyword">null</span> || file.length == <span class="number">0</span>) &#123;</span><br><span class="line">        result.put(<span class="string">"code"</span>, <span class="string">"nfile"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储所有map</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; AllMap = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">module</span>.length; i++) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 存储一个模块上传成功的</span></span><br><span class="line">            StringBuffer success = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="comment">// 存储一个模块上传失败的</span></span><br><span class="line">            StringBuffer fail = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="comment">// 其实这个file数组的长度永远是1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; file.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!file[j].isEmpty()) &#123;</span><br><span class="line">                    String originFileName = file[j].getOriginalFilename();<span class="comment">// 获取客户机上的文件名</span></span><br><span class="line">                    List&lt;UpFile&gt; queryFileByName = fileService.queryFileByName(originFileName, <span class="keyword">module</span>[i]);</span><br><span class="line">                    <span class="keyword">boolean</span> isDeleted = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; queryFileByName.size(); k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (queryFileByName.get(k).getSubjection() != <span class="string">"0"</span>) &#123;</span><br><span class="line">                            isDeleted = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!isDeleted) &#123;<span class="comment">// isDeleted代表subjection为0,代表此文件是删除了，就增加该文件，否则加入fail信息中</span></span><br><span class="line">                        flag = <span class="number">0</span>;</span><br><span class="line">                        fail.append(originFileName + <span class="string">","</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        success.append(originFileName + <span class="string">","</span>);</span><br><span class="line">                        addFile(file[j], <span class="keyword">module</span>[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String moduleName = FilePageService.queryFilePageBySubjection(<span class="keyword">module</span>[i]).getModuleName();</span><br><span class="line">            map.put(<span class="string">"moduleName"</span>, moduleName);</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">                map.put(<span class="string">"code"</span>, <span class="string">"exist"</span>);</span><br><span class="line">                map.put(<span class="string">"info"</span>, fail.substring(<span class="number">0</span>, fail.length() - <span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(<span class="string">"code"</span>, <span class="string">"NotExist"</span>);</span><br><span class="line">                map.put(<span class="string">"info"</span>, success.substring(<span class="number">0</span>, success.length() - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            AllMap.add(map);</span><br><span class="line">        &#125;</span><br><span class="line">        result.put(<span class="string">"info"</span>, AllMap);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        result.put(<span class="string">"code"</span>, <span class="string">"error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="八、拦截器"><a href="#八、拦截器" class="headerlink" title="八、拦截器**"></a>八、拦截器**</h1><p><strong>当有多个拦截器时</strong><br>preHandle:按照拦截器数组顺序执行<br>postHandle:按照拦截器数组逆序执行<br>afterCompletion:按照拦截器数组逆序执行</p>
<p>当多个preHandle有不同的值时：<br>第一个返回false,第二个返回false,只有第一个的preHandle会执行<br>第一个返回false,第二个返回true,只有第一个的preHandle会执行<br>第一个返回true,第二个返回false,只有第一个的preHandle和afterCompletion以及第二个的preHandle会执行</p>
<p>执行顺序：<br>客户端请求—&gt;filter—&gt;DispatcherServlet—&gt;interceptor—&gt;服务器</p>
<h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Second:preHandle"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                           ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Second:postHandle..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Second:afterCompletion..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>xml配置,加入IOC容器中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;bean class="com.springmvc.interceptor.FirstInterceptor"&gt;&lt;/bean&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.springmvc.interceptor.SecondInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"firstInterceptor"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        设置自定义拦截方式--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;mvc:interceptor&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--            &lt;mvc:mapping path=""/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--            &lt;mvc:exclude-mapping path=""/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;/mvc:interceptor&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="九、整合Spring-SpringMVC"><a href="#九、整合Spring-SpringMVC" class="headerlink" title="九、整合Spring,SpringMVC**"></a>九、整合Spring,SpringMVC**</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.spring与springmvc的整合：spring的配置文件什么时候加载？什么时候加载？</span><br><span class="line">监听器，可以在ServletContext加载时，通过监听器加载spring的配置文件，创建spring容器</span><br><span class="line">Spring提供的监听器，ContextLoaderListener</span><br><span class="line"></span><br><span class="line">2.bean被创建两次的问题，在springmvc中只扫描控制层，在spring中值包含指定的包</span><br><span class="line"></span><br><span class="line">3.Spring和springMVC的关系；</span><br><span class="line">Spring是父容器</span><br><span class="line">springmvc是子容器</span><br><span class="line">规定：子容器能够调用访问父容器中的bean，而父容器不能够调用访问子容器中的bean</span><br></pre></td></tr></table></figure>
<p>web.xml添加监听器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    自动配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第一个执行，因为listener需要  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过监听器加载spring的配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring.xml"</span>);</span><br><span class="line">        ServletContext servletContext = servletContextEvent.getServletContext();</span><br><span class="line">        servletContext.setAttribute(<span class="string">"ac"</span>,ac);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认返回视图是@RequestMapping的值</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/testListener"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListener</span><span class="params">(HttpSession session)</span></span>&#123;</span><br><span class="line">    ServletContext servletContext = session.getServletContext();</span><br><span class="line">    ApplicationContext ac = (ApplicationContext)servletContext.getAttribute(<span class="string">"ac"</span>);</span><br><span class="line">    Person person = (Person)ac.getBean(<span class="string">"person"</span>);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十、SpringMVC执行流程"><a href="#十、SpringMVC执行流程" class="headerlink" title="十、SpringMVC执行流程**"></a>十、SpringMVC执行流程**</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">springmvc利用DispatcherServlet进行处理客户端的请求，</span><br><span class="line">如果springmvc中有相应的请求，即springmvc能够处理这个请求</span><br><span class="line">    1.由HandlerMapping(存储的是所有的请求和处理器的关系)调用getHandler()</span><br><span class="line">    获取该Handler配置的所有相关的对象(包括Handler对象)以及Handler对象对应的拦截器</span><br><span class="line">    最后以HandlerExecutionChain(某个指定的处理器和请求的关系)对象的形式返回</span><br><span class="line">    2.DispatcherServlet根据获得的Handler对象选择合适的HandlerAdapter(对请求执行和操作)对象</span><br><span class="line">        通过调用getHandlerAdapter()获得</span><br><span class="line">    3.成功获得HandlerAdapter对象后，执行拦截器preHandle方法，</span><br><span class="line">    4.调用Handler的目标方法得到ModelAndView对象</span><br><span class="line">        如果存在异常，由HandlerExceptionResolver组件处理异常，得到新的ModelAndView对象</span><br><span class="line">        如果不存在异常，就执行拦截器的postHandle方法</span><br><span class="line">                     有ViewResolver组件根据ModelAndView对象得到实际的View</span><br><span class="line">                     渲染视图</span><br><span class="line">    5.执行拦截器的afterCompletion方法</span><br><span class="line">否则，查看xml配置文件中有没有&lt;mvc:default-servlet-handler/&gt;(用tomcat默认的servet处理)注解</span><br><span class="line">    如果配置了，且能处理，就成功</span><br><span class="line">              但不能处理，就到404页面,控制台没有报错</span><br><span class="line">    如果没配置，控制台:No mapping found for HTTP request with URI in DispatcherServlet</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql深入学习笔记</title>
    <url>/alex-next/2022/05/28/javaEE/mysql%E6%B7%B1%E5%85%A5/</url>
    <content><![CDATA[<h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><h2 id="1-索引底层原理"><a href="#1-索引底层原理" class="headerlink" title="1.索引底层原理"></a>1.索引底层原理</h2><h3 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h3><p>索引是帮助MySQL高效获取数据的排好序的数据结构</p>
<ul>
<li><p>二叉树</p>
<ul>
<li>若插入数据有顺序，会退化成链表</li>
</ul>
</li>
<li><p>红黑树</p>
<ul>
<li>若查找元素为叶子结点，树的高度依旧很高，效率变低</li>
</ul>
</li>
<li><p>Hash表</p>
<ul>
<li></li>
<li>仅能进行等值查询，不支持范围查询</li>
</ul>
</li>
<li><p>B Tree</p>
<ul>
<li>结构</li>
</ul>
</li>
<li><p>B+Tree(mysql采用)</p>
<ul>
<li>结构</li>
<li>mysql设置页大小为16KB(show global status like ‘Innodb_page_size’)，索引存放大小8B(bigint)，页地址大小6B，一页可放1170个结点，只需三次I/O操作(若一开始，就将根节点放入常驻内存，I/O次数会更少)  注：叶子节点会存放数据，一行数据最多算1KB，页大小有16KB，叶子节点一页可以放16个结点。mysql每次会取一页放入bufferpool</li>
</ul>
</li>
<li><p>B树和B+树</p>
<ul>
<li>节点中的数据索引从左到右递增排列</li>
<li><p>B+树叶子结点用指针连接</p>
<ul>
<li>与范围查找相关如rol&gt;20:B+树可以顺着找到的结点找下去，而B树只能从根节点重新找</li>
</ul>
</li>
<li><p>按照B树，一个结点1KB的数据，一页能放16个结点，树的高度要远远大于3</p>
</li>
</ul>
</li>
<li><p>问题</p>
<ul>
<li><p>为什么用B+树不用B树</p>
<ul>
<li>按照B树，一个结点1KB的数据，一页能放16个结点，树的高度要远远大于3</li>
<li>与范围查找相关，如rol&gt;20:B+树可以顺着找到的结点找下去，而B树只能从根节点重新找</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="存储引擎-针对表"><a href="#存储引擎-针对表" class="headerlink" title="存储引擎(针对表)"></a>存储引擎(针对表)</h3><ul>
<li><p>MyISAM</p>
<ul>
<li>存储结构</li>
<li>先根据MYI文件找出具体的索引值，在从MYD文件中找出数据</li>
<li>非聚集索引(MyISAM、非主键索引等需要回表的索引)：索引和数据分开存储</li>
</ul>
</li>
<li><p>Innodb</p>
<ul>
<li>存储结构</li>
<li>聚集索引：索引和数据存在一起（叶子结点包含了完整的数据记录）</li>
</ul>
</li>
<li><p>问题</p>
<ul>
<li><p>为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键？</p>
<ul>
<li><p>为什么必须要有主键</p>
<ul>
<li>如果设置了主键，就会使用主键作为聚集索引。</li>
<li>如果你没有创建主键，他会寻找一个不为null的字段作为主键索引。</li>
<li>如果还是没有则会隐式的创建一个字段作为主键。</li>
</ul>
</li>
<li><p>为什么使用整型</p>
<ul>
<li>1.整型比较比字符串要快，因为字符串要逐个比较ASCII值，节省硬盘空间；整型容易比较大小进行排序</li>
</ul>
</li>
<li><p>为什么要求自增</p>
<ul>
<li>mysql为了维护索引的有序性，使得新增的主键会在B+tree叶子节点中最后末尾添加，使得树分叉概率变小</li>
<li>换句话说，如果不是自增的，B+树会自己做调整，分裂出新节点，效率不如自增</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么非主键索引结构叶子节点存储的是主键值？</p>
<ul>
<li>1.节省存储空间</li>
<li>2.一致性：若非主键索引也存了完整的数据记录，那么非主键索引和主键索引的索引文件要保证数据一致性的问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="联合索引-复合索引"><a href="#联合索引-复合索引" class="headerlink" title="联合索引(复合索引)"></a>联合索引(复合索引)</h3><ul>
<li></li>
<li><p>最左前缀原理</p>
<ul>
<li>B+树底层就是排好序的，如果不按最左前缀，是乱序的</li>
</ul>
</li>
</ul>
<h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>如果索引的列在 select 所需获得的列中（因为在 mysql 中索引是根据索引列的值进行排序的，所以索引节点中存在该列中的部分值）或者根据一次索引查询就能获得记录就不需要回表，如果 select 所需获得列中有大量的非索引列，索引就需要到表中找到相应的列的信息，这就叫回表。</p>
<ul>
<li>图解</li>
<li>参考</li>
</ul>
<h2 id="2-索引之explain"><a href="#2-索引之explain" class="headerlink" title="2.索引之explain"></a>2.索引之explain</h2><h3 id="重要的原则"><a href="#重要的原则" class="headerlink" title="重要的原则"></a>重要的原则</h3><ul>
<li>如果发现使用索引还不如全表扫描的效率（非主键索引会回表），会放弃使用索引，这里的索引一般为非主键索引。</li>
</ul>
<h3 id="1-id"><a href="#1-id" class="headerlink" title="1.id"></a>1.id</h3><ul>
<li>id越大执行的优先级越高</li>
</ul>
<h3 id="2-select-type"><a href="#2-select-type" class="headerlink" title="2.select_type"></a>2.select_type</h3><p>select_type 表示对应行是简单还是复杂的查询。</p>
<ul>
<li><p>simple:简单查询</p>
<ul>
<li>explain select * from film where id = 2;</li>
</ul>
</li>
<li><p>primary:复杂查询最外层的select</p>
</li>
<li>subquery：包含在 select 中的子查询（不在 from 子句中）</li>
<li>derived：包含在 from 子句中的子查询。</li>
<li><p>union：在 union 中的第二个和随后的 select</p>
<ul>
<li>explain select 1 union all select 1;</li>
</ul>
</li>
</ul>
<h3 id="3-table"><a href="#3-table" class="headerlink" title="3.table"></a>3.table</h3><ul>
<li>这一列表示 explain 的一行正在访问哪个表</li>
</ul>
<h3 id="4-type"><a href="#4-type" class="headerlink" title="4.type"></a>4.type</h3><p>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。<br>依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL<br>一般来说，得保证查询达到range级别，最好达到ref<br>NULL：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表</p>
<ul>
<li>1.system：表中只有一条记录</li>
<li><p>2.const：表示通过索引一次就找到了，结果集只有一条</p>
<ul>
<li>select * from test01 where id  = 1;，其中id是primary key或者unique索引，并且最终只查出有且仅有一条数据。</li>
</ul>
</li>
<li><p>3.eq_ref：本表中和关联表表中的每行都能有且仅能组合成的一行</p>
</li>
<li>4.ref：不使用唯一索引，可能找出多个符合条件的行</li>
<li><p>5.range：只检索给定范围的行，一般就是在WHERE语句中出现了BETWEEN、&lt; &gt;、in等的查询。</p>
<ul>
<li>如select * from test01 where id&gt;1;</li>
</ul>
</li>
<li><p>6.index：扫描全索引就能拿到结果，不需要回表</p>
<ul>
<li>explain select id,empno from emp;其中empno为非主键索引</li>
<li>explain select id,empno,sal,comm from emp;其中id为主键，empno、sal、comm为复合索引，非主键索引数据中会存放id，方便回表</li>
<li>explain select empno,sal,comm from emp;</li>
</ul>
</li>
<li><p>7.all：全表扫描</p>
</li>
</ul>
<h3 id="5-possible-keys"><a href="#5-possible-keys" class="headerlink" title="5.possible_keys"></a>5.possible_keys</h3><ul>
<li>这一列显示查询可能使用哪些索引来查找。</li>
</ul>
<h3 id="6-key"><a href="#6-key" class="headerlink" title="6.key"></a>6.key</h3><ul>
<li>这一列显示mysql实际采用哪个索引来优化对该表的访问。</li>
</ul>
<h3 id="7-key-len"><a href="#7-key-len" class="headerlink" title="7.key_len"></a>7.key_len</h3><ul>
<li>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。</li>
<li>int:4字节；varchar(n):3n+2字节；如果字段允许为NULL，需要1字节记录是否为NULL</li>
</ul>
<h3 id="8-ref"><a href="#8-ref" class="headerlink" title="8.ref"></a>8.ref</h3><ul>
<li>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）</li>
</ul>
<h3 id="9-rows"><a href="#9-rows" class="headerlink" title="9.rows"></a>9.rows</h3><ul>
<li>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</li>
</ul>
<h3 id="10-Extra"><a href="#10-Extra" class="headerlink" title="10.Extra"></a>10.Extra</h3><ul>
<li><p>1.Using index:使用覆盖索引—提倡</p>
<p>  mysql执行计划explain结果里的key有使用索引，如果select后面查询的字段都可以从这个索引的树中<br>  获取，这种情况一般可以说是用到了覆盖索引，extra里一般都有using index；覆盖索引一般针对的是辅助索引，整个<br>  查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值</p>
<ul>
<li>数据在辅助索引中就能拿到，不需要通过辅助索引找到主键树拿数据</li>
</ul>
</li>
<li><p>2.Using where</p>
<ul>
<li>使用 where 语句来处理结果，并且查询的列未被索引覆盖</li>
<li>explain select * from actor where name = ‘a’;</li>
</ul>
</li>
<li><p>3.Using index condition</p>
<ul>
<li>查询的列不完全被索引覆盖，where条件中是一个前导列的范围；</li>
<li>explain select * from film_actor where film_id &gt; 1;</li>
</ul>
</li>
<li><p>4.Using temporary</p>
<p>  mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。</p>
<ul>
<li>explain select distinct name from actor;若name列无索引，会创建临时表；若name列有索引，就会随着索引树去重</li>
</ul>
</li>
<li><p>5.Using filesort</p>
<p>  将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一<br>  般也是要考虑使用索引来优化的。</p>
<ul>
<li>通常就是要排序的列没有创建索引，而造成外部排序，数据小的时候用内存排序，数据大的时候会用磁盘排序(速度慢)</li>
</ul>
</li>
</ul>
<h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><ul>
<li><p>explain select * from emp where empno = 10002 and ename like ‘aa%’ and job like ‘a%’;(见第四节)</p>
<ul>
<li>empno,ename,job是复合索引，按照B+Tree分析ename是有序的，根据aa%条件，我觉得这相当于范围查询，而不是等值查询啊，若是范围查询，job是无序的，自然用不上索引；所以我认为只有empno和ename能用到索引，但事实确是empno,ename,job都能用到索引？</li>
</ul>
</li>
</ul>
<h2 id="3-mysql组件"><a href="#3-mysql组件" class="headerlink" title="3.mysql组件"></a>3.mysql组件</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，<br>这个时候用的就是你输入的用户名和密码。</p>
<ul>
<li>修改user的信息</li>
<li>修改完权限后要重新连接，权限才会生效</li>
</ul>
<h3 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h3><ul>
<li>1、词法分析 2、语法分析 3、语义分析 4、构造执行树 5、生成执行计划 6、计划的执行</li>
</ul>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><ul>
<li>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接 顺序。甚至，不使用索引</li>
</ul>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><h3 id="bin-log"><a href="#bin-log" class="headerlink" title="bin-log"></a>bin-log</h3><ul>
<li>开启之后能够恢复开启之后删除的数据</li>
</ul>
<h2 id="4-优化索引实战（一）"><a href="#4-优化索引实战（一）" class="headerlink" title="4.优化索引实战（一）"></a>4.优化索引实战（一）</h2><h3 id="1-强制走索引效率不一定高"><a href="#1-强制走索引效率不一定高" class="headerlink" title="1.强制走索引效率不一定高"></a>1.强制走索引效率不一定高</h3><ul>
<li>EXPLAIN SELECT * FROM employees force index(idx_name_age_position) WHERE name &gt; ‘LiLei’ AND age = 22 AND position =’manager’;</li>
</ul>
<h3 id="2-利用覆盖索引优化可能不走索引的情况"><a href="#2-利用覆盖索引优化可能不走索引的情况" class="headerlink" title="2.利用覆盖索引优化可能不走索引的情况"></a>2.利用覆盖索引优化可能不走索引的情况</h3><ul>
<li>EXPLAIN SELECT name,age,position FROM employees WHERE name &gt; ‘LiLei’ AND age = 22 AND position =’manag er’;</li>
</ul>
<h3 id="3-in和or在表数据量比较大的情况会走索引，在表记录不多的情况下会选择全表扫描"><a href="#3-in和or在表数据量比较大的情况会走索引，在表记录不多的情况下会选择全表扫描" class="headerlink" title="3.in和or在表数据量比较大的情况会走索引，在表记录不多的情况下会选择全表扫描"></a>3.in和or在表数据量比较大的情况会走索引，在表记录不多的情况下会选择全表扫描</h3><h3 id="4-like-KK-一般情况都会走索引"><a href="#4-like-KK-一般情况都会走索引" class="headerlink" title="4.like KK% 一般情况都会走索引"></a>4.like KK% 一般情况都会走索引</h3><ul>
<li><p>索引下推</p>
<ul>
<li><p>可以在索引遍历过程中，对索引中包含的所有字段先做判断，过滤掉不符合条件的记录之后再回表，可以有效的减少回表次数</p>
</li>
<li><blockquote>
<p>,&gt;=这种范围查询一般不走索引下推是因为，回表查询还不如全表扫描</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="trace工具"><a href="#trace工具" class="headerlink" title="trace工具"></a>trace工具</h3><p>set session optimizer_trace=”enabled=on”,end_markers_in_json=on; ‐‐开启trace<br>select <em> from employees where name &gt; ‘a’ order by position;<br>SELECT </em> FROM information_schema.OPTIMIZER_TRACE;</p>
<ul>
<li>可以查看Mysql内部优化sql语句的过程</li>
</ul>
<h3 id="Order-By-和Group-By"><a href="#Order-By-和Group-By" class="headerlink" title="Order By 和Group By"></a>Order By 和Group By</h3><ul>
<li>Extra里没有Using filesort就是用到了索引</li>
<li>mysql8之前desc不支持索引</li>
</ul>
<h3 id="Using-filesort"><a href="#Using-filesort" class="headerlink" title="Using filesort"></a>Using filesort</h3><ul>
<li><p>单路排序</p>
<ul>
<li>排序的时候把所有字段取到内存中</li>
</ul>
</li>
<li><p>多路排序</p>
<ul>
<li>排序的时候只把排序列和id取到内存中，之后从原表中找出其他字段</li>
</ul>
</li>
<li><p>单路排序占内存，速度快；多路排序省空间，速度慢</p>
</li>
</ul>
<h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><ul>
<li>1、代码先行，索引后上</li>
<li>2、联合索引尽量覆盖条件</li>
<li><p>3、不要在小基数字段上建立索引</p>
<ul>
<li>如，性别</li>
</ul>
</li>
<li><p>4、长字符串我们可以采用前缀索引</p>
<ul>
<li>index(name(20),age,position)。</li>
</ul>
</li>
<li><p>5、where与order by冲突时优先where</p>
</li>
<li>6、基于慢sql查询做优化</li>
</ul>
<h2 id="5-优化索引实战（二）"><a href="#5-优化索引实战（二）" class="headerlink" title="5.优化索引实战（二）"></a>5.优化索引实战（二）</h2><h3 id="1-分页查询优化"><a href="#1-分页查询优化" class="headerlink" title="1.分页查询优化"></a>1.分页查询优化</h3><p>select * from employees limit 10000,10;</p>
<ul>
<li><p>select * from employees limit 10000,10; 原理</p>
<ul>
<li>从索引10000的数据行开始读10条数据</li>
<li>并不是只查10条数据，而是先读取10010条数据，然后抛弃前10000行数据</li>
</ul>
</li>
<li><p>EXPLAIN select * from employees ORDER BY name limit 90000,5优化</p>
<ul>
<li>分析：name字段由于mysql自身优化机制不会走索引，会Using filesort</li>
<li>优化：select * from employees e inner join (select id from employees order by name limit 90000,5) ed on e.id = ed.id;  先找出这5行数据的id，再自连接效率更高</li>
</ul>
</li>
</ul>
<h3 id="2-join关联查询优化"><a href="#2-join关联查询优化" class="headerlink" title="2.join关联查询优化"></a>2.join关联查询优化</h3><ul>
<li><p>表关联算法</p>
<ul>
<li><p>1.嵌套循环连接算法(NLJ)</p>
<ul>
<li><p>sql语句</p>
<ul>
<li>EXPLAIN select * from t1 inner join t2 on t1.a= t2.a;</li>
</ul>
</li>
<li><p>步骤</p>
<ul>
<li><ol>
<li>从表 t2 中读取一行数据（如果t2表有查询过滤条件的，会从过滤结果里取出一行数据）；  </li>
</ol>
</li>
<li><ol>
<li>从第 1 步的数据中，取出关联字段 a，到表 t1 中查找；</li>
</ol>
</li>
<li><ol>
<li>取出表 t1 中满足条件的行，跟 t2 中获取到的结果合并，作为结果返回给客户端；</li>
</ol>
</li>
<li><ol>
<li>重复上面 3 步。</li>
</ol>
</li>
</ul>
</li>
<li><p>分析</p>
<ul>
<li>整个过程会读取 t2 表的所有数据(扫描100行)，然后遍历这每行数据中字段 a 的值，根据 t2 表中 a 的值索引扫描 t1 表 中的对应行(扫描100次 t1 表的索引，1次扫描可以认为最终只扫描 t1 表一行完整数据，也就是总共 t1 表也扫描了100 行)。因此整个过程扫描了 200 行。</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>每次从小表中取出一行数据到内存，再从大表中取数据，若有索引，只需要取一次，否则遍历大表；取出数据后拼接小表和大表的数据作为结果集。</li>
<li>适合有索引</li>
</ul>
</li>
</ul>
</li>
<li><p>2.基于块的嵌套循环连接算法(BNL)</p>
<ul>
<li><p>步骤</p>
<ul>
<li><ol>
<li>把 t2 的所有数据放入到 join_buffer 中  </li>
</ol>
</li>
<li><ol>
<li>把表 t1 中每一行取出来，跟 join_buffer 中的数据做对比</li>
</ol>
</li>
<li><ol>
<li>返回满足 join 条件的数据</li>
</ol>
</li>
</ul>
</li>
<li><p>分析</p>
<ul>
<li>整个过程对表 t1 和 t2 都做了一次全表扫描，因此扫描的总行数为10000(表 t1 的数据总量) + 100(表 t2 的数据总量) = 10100。并且 join_buffer 里的数据是无序的，因此对表 t1 中的每一行，都要做 100 次判断，所以内存中的判断次数是 100 * 10000= 100 万次。</li>
</ul>
</li>
<li><p>若join_buffer放不下</p>
<ul>
<li><p>分段放</p>
<p>  比如 t2 表有1000行记录， join_buffer 一次只能放800行数据，那么执行过程就是先往 join_buffer 里放800行记录，然后从 t1 表里取数据跟 join_buffer 中数据对比得到部分结果，然后清空 join_buffer ，再放入 t2 表剩余200行记录，再次从 t1 表里取数据跟 join_buffer 中数据对比。所以就多扫了一次 t1 表。</p>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>将小表的所有数据都放入join_buffer中，再从大表中依次取数据比对</li>
<li>适合无索引</li>
</ul>
</li>
</ul>
</li>
<li><p>细节</p>
<ul>
<li><p>扫描的含义</p>
<ul>
<li>从磁盘中取数据，NLJ有索引的时候，只需要根据索引(在内存中)从磁盘中取一次数据，速度很快</li>
</ul>
</li>
<li><p>join_buffer</p>
<ul>
<li>在无索引的时候BNL是在内存中操作的，相比NLJ无索引只从磁盘读速度快</li>
</ul>
</li>
<li><p>数据量小的作为驱动表，大的表做被驱动表</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>优化原则</p>
<ul>
<li>1.关联字段加索引</li>
<li>2.小表驱动大表</li>
</ul>
</li>
<li><p>in和Exists</p>
<ul>
<li>in：当B表的数据集小于A表的数据集时，in优于exists</li>
<li>exists：当A表的数据集小于B表的数据集时，exists优于in</li>
</ul>
</li>
</ul>
<h3 id="3-count优化"><a href="#3-count优化" class="headerlink" title="3.count优化"></a>3.count优化</h3><ul>
<li>四个sql的执行计划一样，说明这四个sql执行效率应该差不多，推荐使用count(*)</li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul>
<li>int的长度指填充大小，如长度为5的int数据3填充后为00003,定义时需要加 ZEROFILL</li>
</ul>
<h2 id="6-事务隔离级别和锁机制"><a href="#6-事务隔离级别和锁机制" class="headerlink" title="6.事务隔离级别和锁机制"></a>6.事务隔离级别和锁机制</h2><h3 id="1-事务的ACID属性"><a href="#1-事务的ACID属性" class="headerlink" title="1.事务的ACID属性"></a>1.事务的ACID属性</h3><ul>
<li><p>1.原子性</p>
<ul>
<li>事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。操作层面</li>
</ul>
</li>
<li><p>2.一致性</p>
<ul>
<li>在事务开始和完成时,数据都必须保持一致状态。要么数据全部跟着操作修改，要么全都不变。数据层面</li>
</ul>
</li>
<li><p>3.隔离性</p>
<ul>
<li>数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独 立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。</li>
</ul>
</li>
<li><p>4.持久性</p>
<ul>
<li>事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。</li>
</ul>
</li>
</ul>
<h3 id="2-并发带来的问题"><a href="#2-并发带来的问题" class="headerlink" title="2.并发带来的问题"></a>2.并发带来的问题</h3><ul>
<li><p>1.脏写</p>
<ul>
<li>事务A的更新覆盖了事务B的更新。主要就是事务A的回滚将事务B的更新重置了</li>
</ul>
</li>
<li><p>2.脏读</p>
<ul>
<li>事务A读取了事务B修改但未提交的更新。事务B的回滚使事务A读取的修改数据无效</li>
</ul>
</li>
<li><p>3.不可重复读</p>
<ul>
<li>事务A内部的相同查询语句在不同时刻读出的结果不一致，不符合隔离性。针对某个字段的更新</li>
</ul>
</li>
<li><p>4.幻读</p>
<ul>
<li>事务A读取到了事务B提交的新增数据，在不同时刻读出的数据条数不同，不符合隔离性。针对某张表的插入删除</li>
</ul>
</li>
</ul>
<h3 id="3-事务的隔离级别"><a href="#3-事务的隔离级别" class="headerlink" title="3.事务的隔离级别"></a>3.事务的隔离级别</h3><ul>
<li></li>
<li><p>问题</p>
<ul>
<li><p>可重复读：update account set balance = balance - 50 where id =1，由于可重复读的机制，balance值不要用java减了之后赋值，而是用sql减，这涉及到MVCC机制(维护了一致性)</p>
<ul>
<li>事务A读出balance为400，事务B在事务A执行过程中修改为350，事务A不能根据读出的400(可重复读)做更新，而是根据350做更新(使用sql自减)(MVCC机制，维护了数据一致性)</li>
</ul>
</li>
<li><p>串行化：查了哪条数据哪条数据就会加锁</p>
</li>
<li><p>可重复读和串行化解决隔离性的区别</p>
<ul>
<li>可重复读解决了以字段为单位的隔离性，串行化解决了以行为单位的隔离性</li>
<li>可重复读使用了MVCC解决隔离性，这使读操作能正常进行；串行化使用读锁解决问题，插入或读取了某行就会上锁，直至事务结束。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-锁分类"><a href="#4-锁分类" class="headerlink" title="4.锁分类"></a>4.锁分类</h3><ul>
<li><p>乐观锁</p>
<ul>
<li>类似CAS操作</li>
</ul>
</li>
<li><p>悲观锁</p>
<ul>
<li><p>读锁</p>
<ul>
<li>针对同一份数据，多个读操作可以同时进行而不会互相影响</li>
</ul>
</li>
<li><p>写锁</p>
<ul>
<li><p>表锁</p>
<ul>
<li>每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低； 一般用在整表数据迁移的场景。</li>
<li><p>操作</p>
<ul>
<li>lock table 表名称 read(write),表名称2 read(write);</li>
<li>show open tables;</li>
<li>unlock tables;</li>
</ul>
</li>
</ul>
</li>
<li><p>行锁</p>
<ul>
<li>每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>间隙锁</p>
<ul>
<li>执行update account set name = ‘zhuge’ where id &gt; 8 and id &lt;18;存在间隙(3,10),(10,20),(20,正无穷),则会把(3,20]加锁</li>
<li>间隙锁默认在可重复读隔离级别下会生效</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁,在执行update、insert、delete操作会自动给涉及的表加写锁。</li>
<li>InnoDB在执行查询语句SELECT时(非串行隔离级别)，不会加读锁。但是update、insert、delete操作会加行锁</li>
<li>总而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞</li>
</ul>
</li>
</ul>
<h3 id="5-锁优化建议"><a href="#5-锁优化建议" class="headerlink" title="5.锁优化建议"></a>5.锁优化建议</h3><ul>
<li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁 </li>
<li>合理设计索引，尽量缩小锁的范围</li>
<li>尽可能减少检索条件范围，避免间隙锁</li>
<li>尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行</li>
<li>尽可能低级别事务隔离</li>
</ul>
<h3 id="InnoDB与MYISAM的最大不同有两点"><a href="#InnoDB与MYISAM的最大不同有两点" class="headerlink" title="InnoDB与MYISAM的最大不同有两点"></a>InnoDB与MYISAM的最大不同有两点</h3><ul>
<li>InnoDB支持事务</li>
<li>InnoDB支持行锁</li>
<li><p>其他</p>
<ul>
<li>InnoDB有undo日志和redo日志，MYISAM没有</li>
<li>InnoDB使用聚集索引，MYISAM使用非聚集索引</li>
</ul>
</li>
</ul>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul>
<li><p>常看当前数据库的事务隔离级别</p>
<ul>
<li>show variables like ‘tx_isolation’; </li>
</ul>
</li>
<li><p>设置事务隔离级别</p>
<ul>
<li>set tx_isolation=’read-uncommitted’;</li>
<li>set tx_isolation=’read-committed’;</li>
<li>set tx_isolation=’repeatable-read’;</li>
<li>set tx_isolation=’serializable’;</li>
</ul>
</li>
<li><p>开启事务，提交事务</p>
<ul>
<li>begin; sql语句;commit;</li>
</ul>
</li>
</ul>
<h2 id="7-MVCC多版本并发控制机制及BufferPool缓存机制"><a href="#7-MVCC多版本并发控制机制及BufferPool缓存机制" class="headerlink" title="7.MVCC多版本并发控制机制及BufferPool缓存机制"></a>7.MVCC多版本并发控制机制及BufferPool缓存机制</h2><h3 id="1-MVCC机制"><a href="#1-MVCC机制" class="headerlink" title="1.MVCC机制"></a>1.MVCC机制</h3><p>在读已提交和可重复读隔离级别下实现</p>
<ul>
<li><p>1.undo日志</p>
<ul>
<li>在每个事务修改完后，Mysql会保留修改前的数据undo回滚 日志</li>
</ul>
</li>
<li><p>2.read view机制</p>
<ul>
<li><p>可重复读</p>
<ul>
<li>事务开始后第一条select语句会生成一个read-view一致性视图，直到事务结束都不变</li>
</ul>
</li>
<li><p>读已提交</p>
<ul>
<li>事务开始后，每条select语句都会生成一个新的read-view一致性视图</li>
</ul>
</li>
<li><p>这个视图由执行查询时所有未提交事务id数组（数组里最小的id为min_id）和已创建的最大事务id（max_id）组成，事务里的任何sql查询结果需要从对应 版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。</p>
</li>
</ul>
</li>
<li><p>3.版本链比对规则</p>
<ul>
<li><ol>
<li>如果 row 的 trx_id 落在绿色部分( trx_id&lt;min_id )，表示这个版本是已提交的事务生成的，这个数据是可见的； </li>
</ol>
</li>
<li><ol>
<li>如果 row 的 trx_id 落在红色部分( trx_id&gt;max_id )，表示这个版本是由将来启动的事务生成的，是不可见的(若 row 的 trx_id 就是当前自己的事务是可见的）；</li>
</ol>
</li>
<li><ol>
<li><p>如果 row 的 trx_id 落在黄色部分(min_id &lt;=trx_id&lt;= max_id)，那就包括两种情况</p>
<ul>
<li>a. 若 row 的 trx_id 在视图数组中，表示这个版本是由还没提交的事务生成的，不可见(若 row 的 trx_id 就是当前自 己的事务是可见的)；</li>
<li>b. 若 row 的 trx_id 不在视图数组中，表示这个版本是已经提交了的事务生成的，可见。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>MVCC机制的实现就是通过read-view机制与undo版本链比对机制，使得不同的事务会根据数据版本链对比规则读取 同一条数据在版本链上的不同版本数据。</li>
</ul>
</li>
<li><p>细节</p>
<ul>
<li><p>可重复读隔离级别</p>
<ul>
<li>一致性视图在事务结束之前都不会变化</li>
</ul>
</li>
<li><p>读已提交</p>
<ul>
<li>每次执行查询sql都会重新生成一致性视图</li>
</ul>
</li>
</ul>
</li>
<li><p>举例</p>
</li>
</ul>
<h3 id="2-BufferPool缓存机制"><a href="#2-BufferPool缓存机制" class="headerlink" title="2.BufferPool缓存机制"></a>2.BufferPool缓存机制</h3><ul>
<li><p>为什么Mysql不能直接更新磁盘上的数据而且设置这么一套复杂的机制来执行SQL了？</p>
<ul>
<li>因为磁盘随机读写的性能是非常差的，所以直接更新磁盘文件是不能让数据库抗住很高并发的。</li>
<li>Mysql这套机制看起来复杂，但它可以保证每个更新请求都是更新内存BufferPool，然后顺序写日志文件，同时还能 保证各种异常情况下的数据一致性。</li>
<li>更新内存的性能是极高的，然后顺序写磁盘上的redo日志文件的性能也是非常高的，要远高于随机读写磁盘文件。</li>
</ul>
</li>
<li><p>redo log和binlog区别</p>
<ul>
<li><p>redo日志</p>
<ul>
<li>redo日志让Mysql拥有了故障恢复的能力</li>
<li><p>redo log用来维护BufferPool，binlog用来维护磁盘数据</p>
<ul>
<li>比如事务提交完，但还没写入磁盘，系统宕机了，使用redo log是恢复了BufferPool里的数据(数据页)</li>
</ul>
</li>
<li><p>记录的是innodb引擎数据页的变更，并没有记录具体的sql，只是把数据页修改的前后数据记录下来。</p>
</li>
<li>恢复数据不需要解析sql语句，速度快</li>
</ul>
</li>
<li><p>binlog日志</p>
<ul>
<li>binlog保证了MySQL集群架构的数据一致性</li>
<li>是数据的变更操作日志，记录数据的变更。解析出来是sql语句</li>
</ul>
</li>
</ul>
</li>
<li><p>redo日志和binlog详解(redo的二阶段提交)</p>
</li>
</ul>
<h3 id="事务的ACID实现原理"><a href="#事务的ACID实现原理" class="headerlink" title="事务的ACID实现原理"></a>事务的ACID实现原理</h3><ul>
<li><p>原子性</p>
<ul>
<li>undo log</li>
</ul>
</li>
<li><p>持久性</p>
<ul>
<li>BufferPool缓存机制+redo log + binlog</li>
</ul>
</li>
<li><p>隔离性</p>
<ul>
<li>MVCC解决写+读</li>
<li>解锁解决写+写</li>
</ul>
</li>
<li><p>一致性</p>
<ul>
<li>一致性是事物追求的最终目标，前面提到的原子性，隔离性，持久性都是为了保证数据库的一致性。此外除了数据库底层的保障，一致性的实现也需要应用层的保障。</li>
</ul>
</li>
</ul>
<h2 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h2>]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>spring笔记</title>
    <url>/alex-next/2020/07/17/javaEE/spring/</url>
    <content><![CDATA[<p>项目gitee地址</p>
<blockquote>
<p><a href="https://gitee.com/alexander1/spring-notes" target="_blank" rel="noopener">https://gitee.com/alexander1/spring-notes</a></p>
<h1 id="一、Spring入门"><a href="#一、Spring入门" class="headerlink" title="一、Spring入门"></a>一、Spring入门</h1></blockquote>
<h2 id="1、导入pom依赖"><a href="#1、导入pom依赖" class="headerlink" title="1、导入pom依赖"></a>1、导入pom依赖</h2><p>需要导入spring-beans,spring-context,spring-core,spring-expression,commons-logging</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--为方便起见，直接导入spring-mvc依赖</span></span><br><span class="line"><span class="comment">包含spring和springMVC的基础依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2、编写xml配置文件"><a href="#2、编写xml配置文件" class="headerlink" title="2、编写xml配置文件"></a>2、编写xml配置文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/util</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/util/spring-util-4.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--要记得导入相关资源--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"s1"</span> <span class="attr">class</span>=<span class="string">"com.pojo.Student"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用set方法注入即setId()，而不是根据属性名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>10003<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"zs"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"男"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3、编写测试类"><a href="#3、编写测试类" class="headerlink" title="3、编写测试类"></a>3、编写测试类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//ctrl+alt+u查看向上关系图</span></span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    <span class="comment">//        Person person = (Person)ac.getBean("person");</span></span><br><span class="line">    <span class="comment">//与bean的id无关,但如果IOC容器中，有两个就会报错</span></span><br><span class="line">    <span class="comment">//        Person person = ac.getBean(Person.class);</span></span><br><span class="line">    Person person = ac.getBean(<span class="string">"personTwo"</span>, Person.class);</span><br><span class="line">    Person person1 = ac.getBean(<span class="string">"personTwo"</span>, Person.class);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">    System.out.println(person==person1);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//spring中的bean默认是单例的</span></span><br><span class="line">    Person person2 = ac.getBean(<span class="string">"personOne"</span>, Person.class);</span><br><span class="line">    Person person3 = ac.getBean(<span class="string">"personOne"</span>, Person.class);</span><br><span class="line">    System.out.println(person2==person3);<span class="comment">//false</span></span><br><span class="line">    <span class="comment">//        ac.close();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、IOC容器和bean的配置"><a href="#二、IOC容器和bean的配置" class="headerlink" title="二、IOC容器和bean的配置"></a>二、IOC容器和bean的配置</h1><h2 id="1、给bean的属性赋值"><a href="#1、给bean的属性赋值" class="headerlink" title="1、给bean的属性赋值"></a>1、给bean的属性赋值</h2><h3 id="1）、setter注入"><a href="#1）、setter注入" class="headerlink" title="1）、setter注入"></a>1）、setter注入</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"s1"</span> <span class="attr">class</span>=<span class="string">"com.pojo.Student"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用set方法注入即setId()，而不是根据属性名注入--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在相应的Student类中要有setter--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>10003<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"zs"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"男"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2）、构造器注入"><a href="#2）、构造器注入" class="headerlink" title="2）、构造器注入"></a>2）、构造器注入</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"s2"</span> <span class="attr">class</span>=<span class="string">"com.pojo.Student"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在相应的Student类中要有构造器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"10086"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"李四"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"24"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"男"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3）、给级联属性赋值"><a href="#3）、给级联属性赋值" class="headerlink" title="3）、给级联属性赋值"></a>3）、给级联属性赋值</h3><h4 id="1）、p名称空间"><a href="#1）、p名称空间" class="headerlink" title="1）、p名称空间"></a>1）、p名称空间</h4><p>导入相关资源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/util</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/util/spring-util-4.0.xsd"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"s4"</span> <span class="attr">class</span>=<span class="string">"com.pojo.Student"</span> <span class="attr">p:id</span>=<span class="string">"10033"</span> <span class="attr">p:name</span>=<span class="string">"zs"</span> <span class="attr">p:age</span>=<span class="string">"20"</span> <span class="attr">p:score</span>=<span class="string">"85"</span> <span class="attr">p:sex</span>=<span class="string">"男"</span> <span class="attr">p:teacher-ref</span>=<span class="string">"teacher"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"teacher"</span> <span class="attr">class</span>=<span class="string">"com.pojo.Teacher"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tid"</span> <span class="attr">value</span>=<span class="string">"10000"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tname"</span> <span class="attr">value</span>=<span class="string">"小芳"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2）、ref关键字"><a href="#2）、ref关键字" class="headerlink" title="2）、ref关键字"></a>2）、ref关键字</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        八种基本类型及其包装类和String 都是字面量</span></span><br><span class="line"><span class="comment">        获取引用类型</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"s5"</span> <span class="attr">class</span>=<span class="string">"com.pojo.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1003"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"zs"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"男"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"teacher"</span> <span class="attr">ref</span>=<span class="string">"teacher"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--赋值，而不是新创建了一个--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"teacher.tname"</span> <span class="attr">value</span>=<span class="string">"小红"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"teacher"</span> <span class="attr">class</span>=<span class="string">"com.pojo.Teacher"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tid"</span> <span class="attr">value</span>=<span class="string">"10000"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tname"</span> <span class="attr">value</span>=<span class="string">"小芳"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3）、内部bean"><a href="#3）、内部bean" class="headerlink" title="3）、内部bean"></a>3）、内部bean</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"s6"</span> <span class="attr">class</span>=<span class="string">"com.pojo.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1003"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"zs"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"男"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"teacher"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--内部bean其他的bean不能引用--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tt"</span> <span class="attr">class</span>=<span class="string">"com.pojo.Teacher"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tid"</span> <span class="attr">value</span>=<span class="string">"111"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tname"</span> <span class="attr">value</span>=<span class="string">"ls"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2、集合属性"><a href="#2、集合属性" class="headerlink" title="2、集合属性"></a>2、集合属性</h2><p>Teacher.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: alex</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/7/17 19:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer tid;</span><br><span class="line">    <span class="keyword">private</span> String tname;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; cls;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students;<span class="comment">//不能起sList,类似的一个小写后面跟大写</span></span><br><span class="line">    <span class="keyword">private</span> Integer[] salary;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; set;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; bossMap;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Teacher&#123;"</span> +</span><br><span class="line">                <span class="string">"tid="</span> + tid +</span><br><span class="line">                <span class="string">", tname='"</span> + tname + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", cls="</span> + cls +</span><br><span class="line">                <span class="string">", students="</span> + students +</span><br><span class="line">                <span class="string">", salary="</span> + Arrays.toString(salary) +</span><br><span class="line">                <span class="string">", set="</span> + set +</span><br><span class="line">                <span class="string">", bossMap="</span> + bossMap +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getBossMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bossMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBossMap</span><span class="params">(Map&lt;String, String&gt; bossMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bossMap = bossMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer[] getSalary() &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(Integer[] salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Integer&gt; <span class="title">getSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSet</span><span class="params">(Set&lt;Integer&gt; set)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.set = set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getCls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCls</span><span class="params">(List&lt;String&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cls = cls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">getStudents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> students;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudents</span><span class="params">(List&lt;Student&gt; students)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.students = students;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getTid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTid</span><span class="params">(Integer tid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tid = tid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTname</span><span class="params">(String tname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tname = tname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(Integer tid, String tname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tid = tid;</span><br><span class="line">        <span class="keyword">this</span>.tname = tname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1）、list，array"><a href="#1）、list，array" class="headerlink" title="1）、list，array"></a>1）、list，array</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--set和array类型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"t3"</span> <span class="attr">class</span>=<span class="string">"com.pojo.Teacher"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tid"</span> <span class="attr">value</span>=<span class="string">"000"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tname"</span> <span class="attr">value</span>=<span class="string">"小名"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"salary"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数组既能用array也能用list，因为list底层使用array实现的--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"set"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>4<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>5<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>6<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2）、map"><a href="#2）、map" class="headerlink" title="2）、map"></a>2）、map</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--map数据--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"t4"</span> <span class="attr">class</span>=<span class="string">"com.pojo.Teacher"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tid"</span> <span class="attr">value</span>=<span class="string">"000"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tname"</span> <span class="attr">value</span>=<span class="string">"小名"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"bossMap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1001<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>彤<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1002<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>陈<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3）、util名称空间"><a href="#3）、util名称空间" class="headerlink" title="3）、util名称空间"></a>3）、util名称空间</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"t5"</span> <span class="attr">class</span>=<span class="string">"com.pojo.Teacher"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tid"</span> <span class="attr">value</span>=<span class="string">"000"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tname"</span> <span class="attr">value</span>=<span class="string">"小名"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"students"</span> <span class="attr">ref</span>=<span class="string">"students"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"t6"</span> <span class="attr">class</span>=<span class="string">"com.pojo.Teacher"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tid"</span> <span class="attr">value</span>=<span class="string">"000"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tname"</span> <span class="attr">value</span>=<span class="string">"小名"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"bossMap"</span> <span class="attr">ref</span>=<span class="string">"map"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">"students"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"s1"</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"s2"</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"s3"</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">util:map</span> <span class="attr">id</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:map</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注：要导入名称空间</strong></p>
<h2 id="3、factoryBean"><a href="#3、factoryBean" class="headerlink" title="3、factoryBean"></a>3、factoryBean</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--工厂bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"factory"</span> <span class="attr">class</span>=<span class="string">"com.factoryBean.MyFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>MyFactory.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFactory</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Car</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        car.setBrand(<span class="string">"奥迪"</span>);</span><br><span class="line">        car.setPrice(<span class="number">150000.0</span>);</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Car.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"factory-bean.xml"</span>);</span><br><span class="line">    Object factory = ac.getBean(<span class="string">"factory"</span>);</span><br><span class="line">    <span class="comment">//        Object factory = ac.getBean("&amp;factory");获取工厂类自身</span></span><br><span class="line">    <span class="comment">//自动执行获取getObject</span></span><br><span class="line">    System.out.println(factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、bean的生命周期"><a href="#4、bean的生命周期" class="headerlink" title="4、bean的生命周期"></a>4、bean的生命周期</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"One:创建对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Three:初始化"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Five:销毁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Four:使用--Person&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", sex='"</span> + sex + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Two:依赖注入"</span>);</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bean的后置处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterHandler</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在bean生命周期第三步初始化之前操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        Person person = (Person) bean;</span><br><span class="line">        <span class="keyword">if</span> (person.getSex().equals(<span class="string">"男"</span>))&#123;</span><br><span class="line">            person.setName(<span class="string">"张无忌"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            person.setName(<span class="string">"赵敏"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在bean生命周期第三步初始化之后操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.ioc.life.Person"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1001"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"男"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.ioc.life.AfterHandler"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">结果：</span><br><span class="line">One:创建对象</span><br><span class="line">Two:依赖注入</span><br><span class="line">//postProcessBeforeInitialization</span><br><span class="line">Three:初始化</span><br><span class="line">//postProcessAfterInitialization</span><br><span class="line">Four:使用--Person&#123;id=1001, sex=&apos;男&apos;, name=&apos;张无忌&apos;&#125;</span><br><span class="line">Five:销毁</span><br></pre></td></tr></table></figure>
<h2 id="5、作用域"><a href="#5、作用域" class="headerlink" title="5、作用域"></a>5、作用域</h2><p>用scope指定，默认是singleton</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.ioc.scope.Student"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sid"</span> <span class="attr">value</span>=<span class="string">"1001"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sname"</span> <span class="attr">value</span>=<span class="string">"张三"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//容器初始化的时候就创建单例模式的bean</span></span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"scope.xml"</span>);</span><br><span class="line">    Student student1 = ac.getBean(<span class="string">"student"</span>, Student.class);</span><br><span class="line">    Student student2 = ac.getBean(<span class="string">"student"</span>, Student.class);</span><br><span class="line">    System.out.println(student1);</span><br><span class="line">    <span class="comment">//默认是单例模式</span></span><br><span class="line">    System.out.println(student1==student2);<span class="comment">//单例模式为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6、自动装配-byName-byType"><a href="#6、自动装配-byName-byType" class="headerlink" title="6、自动装配(byName|byType)"></a>6、自动装配(byName|byType)</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        autowire="byName|byType"</span></span><br><span class="line"><span class="comment">        byName根据bean的id和类属性名称匹配，自动装配</span></span><br><span class="line"><span class="comment">        byType根据属性类别自动赋值，具有兼容性，能为它本身、接口、父类赋值</span></span><br><span class="line"><span class="comment">                只能有一个这种类型的对象</span></span><br><span class="line"><span class="comment">        选用建议：当设置autowire属性，会作用于该bean中所有的非字面量属性，因此谁都不用</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"emp"</span> <span class="attr">class</span>=<span class="string">"com.ioc.autowire.Emp"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1001"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;property name="car" ref="car"/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;property name="dept" ref="dept"/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"autowire.xml"</span>);</span><br><span class="line">    Emp emp = ac.getBean(<span class="string">"emp"</span>, Emp.class);</span><br><span class="line">    System.out.println(emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p>Emp{id=1001, name=’张三’, car=Car{cid=666, cname=’奔驰’}, dept=Dept{did=7777, dname=’销售’}}</p>
<h2 id="7、连接数据库"><a href="#7、连接数据库" class="headerlink" title="7、连接数据库"></a>7、连接数据库</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context-4.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--1.加载资源文件--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name="location" value="db.properties"&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--2.加载资源文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"db.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"datasource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>db.properties放在类路径下面</p>
<h2 id="8、通过注解配置bean-扫描包-Autowired"><a href="#8、通过注解配置bean-扫描包-Autowired" class="headerlink" title="8、通过注解配置bean+扫描包+@Autowired"></a>8、通过注解配置bean+扫描包+@Autowired</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context-4.3.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--扫描有注解的类</span></span><br><span class="line"><span class="comment">        会将加上注解的类作为spring的组件进行加载组件</span></span><br><span class="line"><span class="comment">        会自动在spring的配置文件中生成对应的bean,这些bean的id会以类的首字母小写为值</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    &lt;context:include-filter/&gt;只扫描包含的。在使用时use-default-filters="false"一定要将默认的关闭</span></span><br><span class="line"><span class="comment">    &lt;context:exclude-filter/&gt;先扫描再排除。在使用时use-default-filters="true"</span></span><br><span class="line"><span class="comment">    可以同时出现多个include或exclude，但两个不能同时出现</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.ioc.userMod"</span> <span class="attr">use-default-filters</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注解类型--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--具体类的类型--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;context:include-filter type="assignable" expression="com.com.ioc.userMod.controller.UserController"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Repository"/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//@Autowired只会赋值一个属性，消除set方法</span></span><br><span class="line">    <span class="comment">//autowire是对所有非字面量属性赋值(IOC容器中有才赋值)</span></span><br><span class="line">    <span class="comment">//userDao是UserServiceImpl的一个属性</span></span><br><span class="line">    <span class="comment">//@Autowired一开始是根据byType赋值</span></span><br><span class="line">    <span class="comment">//当byType实现不了装配时，再根据byName，要求IOC容器中有一个与bean的id与属性名一致</span></span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    @Qualifier("userDaoImpl")</span></span><br><span class="line"><span class="comment">//    @Resource和@Autowired差不多，只不过默认byName,再byType</span></span><br><span class="line">    UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"userDaoMybatisImpl"</span>)</span><br><span class="line">    <span class="comment">//将IOC容器中bean的id为userDaoMybatisImpl赋值给userDa11o</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDa11o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao=userDa11o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private UserDao userDao1 = new UserDaoImpl();</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        ApplicationContext ac = new ClassPathXmlApplicationContext("user.xml");</span></span><br><span class="line"><span class="comment">//        UserServiceImpl user = ac.getBean("user", UserServiceImpl.class);</span></span><br><span class="line"><span class="comment">//        if (user!=null)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("yes");</span></span><br><span class="line"><span class="comment">//        &#125;else &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("no");</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">if</span> (userDao==<span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"UserServiceImpl...11"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"UserServiceImpl...22"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.addUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Test.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//先加载的是有注解的bean，接着再加载配置文件中的</span></span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"user.xml"</span>);</span><br><span class="line">    <span class="comment">//默认是首字母小写</span></span><br><span class="line">    UserController userController = ac.getBean(<span class="string">"aaa"</span>,UserController.class);</span><br><span class="line">    System.out.println(userController);</span><br><span class="line">    <span class="comment">//由于兼容性，所以这里可以用接口类型接收</span></span><br><span class="line">    UserService userService = ac.getBean(<span class="string">"userServiceImpl"</span>, UserServiceImpl.class);</span><br><span class="line">    UserService user = ac.getBean(<span class="string">"user"</span>, UserServiceImpl.class);</span><br><span class="line">    UserService user1 = ac.getBean(<span class="string">"user"</span>, UserServiceImpl.class);</span><br><span class="line">    System.out.println(user==userService);<span class="comment">//false</span></span><br><span class="line">    System.out.println(user==user1);<span class="comment">//true，别搞混了</span></span><br><span class="line"></span><br><span class="line">    userService.addUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、AOP"><a href="#三、AOP" class="headerlink" title="三、AOP"></a>三、AOP</h1><h2 id="1、使用JDK实现动态代理"><a href="#1、使用JDK实现动态代理" class="headerlink" title="1、使用JDK实现动态代理"></a>1、使用JDK实现动态代理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUtil</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MathImpl mathImpl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyUtil</span><span class="params">(MathImpl mathImpl)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mathImpl=mathImpl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态代理，所以代理对象要动态生成</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取当前类的类加载器，用来加载代理对象所属类</span></span><br><span class="line">        ClassLoader classLoader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">//获取目标对象实现的所有接口的class</span></span><br><span class="line">        Class[] interfaces = mathImpl.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">//返回的是MathImpl的一个实例</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, interfaces, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="comment">//这里的method就是代理对象实现的目标对象的方法</span></span><br><span class="line">            <span class="comment">//proxy:生成的动态代理类，method:对应的方法，args：方法的参数</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    MyLogger.before(method.getName(), Arrays.toString(args));</span><br><span class="line">                    <span class="comment">//动态代理对象实现功能</span></span><br><span class="line">                    Object res = method.invoke(mathImpl, args);</span><br><span class="line">                    MyLogger.after(method.getName(),res);</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    MyLogger.throwing();</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"哪都有我..."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Test.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//        MathI mathI = new MathImpl();</span></span><br><span class="line">    <span class="comment">//        int add = mathI.add(15, 12);</span></span><br><span class="line">    <span class="comment">//        System.out.println(add);</span></span><br><span class="line">    ProxyUtil proxy = <span class="keyword">new</span> ProxyUtil(<span class="keyword">new</span> MathImpl());</span><br><span class="line">    <span class="comment">//兄弟类不能相互转换,</span></span><br><span class="line">    <span class="comment">// proxy.getProxy()生成了实现了MathI接口的类$Proxy0与MathImpl是兄弟类，</span></span><br><span class="line">    <span class="comment">// 不具有兼容性</span></span><br><span class="line">    MathI math = (MathI)proxy.getProxy();</span><br><span class="line">    <span class="keyword">int</span> add = math.div(<span class="number">12</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//        System.out.println(add);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、Spring使用的用cglib实现的动态代理"><a href="#2、Spring使用的用cglib实现的动态代理" class="headerlink" title="2、Spring使用的用cglib实现的动态代理"></a>2、Spring使用的用cglib实现的动态代理</h2><h3 id="1）、注解版AOP"><a href="#1）、注解版AOP" class="headerlink" title="1）、注解版AOP"></a>1）、注解版AOP</h3><blockquote>
<p>注解方式是aspectJ里面实现的</p>
</blockquote>
<h4 id="导入相应的依赖"><a href="#导入相应的依赖" class="headerlink" title="导入相应的依赖"></a>导入相应的依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--aspect--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用于解析切入点表达式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="切面类"><a href="#切面类" class="headerlink" title="切面类"></a>切面类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span> <span class="comment">//标注当前类为切面</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">2</span>)<span class="comment">//定义切面作用的优先级，值越小，优先值越高，默认值为int的最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLoggerAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(value = <span class="string">"execution(* com.spring.aop.*.*(..))"</span>)<span class="comment">//公共切入点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Before</span>: 将方法指定为前置通知</span></span><br><span class="line"><span class="comment">     * 必须设置value,其值为切入点表达式</span></span><br><span class="line"><span class="comment">     * 前置通知：作用于方法执行之前</span></span><br><span class="line"><span class="comment">     * 第一个*表示任意访问修饰符和返回值类型</span></span><br><span class="line"><span class="comment">     * 第二个*表示任意类</span></span><br><span class="line"><span class="comment">     * 第三个*表示类中任意方法</span></span><br><span class="line"><span class="comment">     * ..代表任意的参数列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    @Before(value = "execution(public int com.com.spring.aop.MathImpl.add(int,int))")</span></span><br><span class="line">    <span class="meta">@Before</span>(value = <span class="string">"test()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;<span class="comment">//joinPoint为连接点</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();<span class="comment">//获取方法的参数</span></span><br><span class="line">        String name = joinPoint.getSignature().getName();<span class="comment">//获取方法名</span></span><br><span class="line">        System.out.println(<span class="string">"method:"</span>+name+<span class="string">",arguments:"</span>+ Arrays.toString(args));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知：作用于方法的finally语句块，不管有没有异常都会执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After</span>(value = <span class="string">"execution(* com.spring.aop.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回通知：作用于方法执行之后</span></span><br><span class="line"><span class="comment">     * 可通过returning设置接收方法返回值的变量名</span></span><br><span class="line"><span class="comment">     * 要想在方法中使用，必须在方法的形参中设置和变量名相同的参数名的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"execution(* com.spring.aop.*.*(..))"</span>,returning = <span class="string">"result"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningMethod</span><span class="params">(JoinPoint joinPoint,Object result)</span></span>&#123;</span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">"method:"</span>+methodName+<span class="string">",result:"</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@AfterThrowing</span> 将方法标注为异常通知(例外通知)</span></span><br><span class="line"><span class="comment">     * 异常通知:作用于当方法抛出异常是</span></span><br><span class="line"><span class="comment">     * 可通过throwing设置接收方法返回的异常信息</span></span><br><span class="line"><span class="comment">     * 在参数列表中可以通过具体的异常类型，来对指定的异常信息进行操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value = <span class="string">"execution(* com.spring.aop.*.*(..))"</span>,throwing = <span class="string">"ex"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowingMethod</span><span class="params">(Exception ex)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"有异常了...,异常为："</span>+ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Around(value = "execution(* com.com.spring.aop.*.*(..))")</span></span><br><span class="line"><span class="comment">//    public Object aroundMethod(ProceedingJoinPoint proceedingJoinPoint)&#123;</span></span><br><span class="line"><span class="comment">//        Object res = null;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            //前置通知</span></span><br><span class="line"><span class="comment">//            System.out.println("前置通知");</span></span><br><span class="line"><span class="comment">//            res = proceedingJoinPoint.proceed();//执行方法</span></span><br><span class="line"><span class="comment">//            //返回通知</span></span><br><span class="line"><span class="comment">//            System.out.println("返回通知");</span></span><br><span class="line"><span class="comment">//            return res;</span></span><br><span class="line"><span class="comment">//        &#125; catch (Throwable throwable) &#123;</span></span><br><span class="line"><span class="comment">//            throwable.printStackTrace();</span></span><br><span class="line"><span class="comment">//            //异常通知</span></span><br><span class="line"><span class="comment">//            System.out.println("异常通知");</span></span><br><span class="line"><span class="comment">//        &#125; finally &#123;</span></span><br><span class="line"><span class="comment">//            //后置通知</span></span><br><span class="line"><span class="comment">//            System.out.println("后置通知");</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return -1;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启aspectJ的自动代理功能--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.spring.aop.MyLoggerAspect"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"math"</span> <span class="attr">class</span>=<span class="string">"com.spring.aop.MathImpl"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.spring.aop"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testHandle"</span> <span class="attr">class</span>=<span class="string">"com.spring.aop.TestHandler"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2）、xml版AOP"><a href="#2）、xml版AOP" class="headerlink" title="2）、xml版AOP"></a>2）、xml版AOP</h3><blockquote>
<p>xml配置方式是spring原生的</p>
</blockquote>
<h4 id="切面类-1"><a href="#切面类-1" class="headerlink" title="切面类"></a>切面类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLoggerAspectXML</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="xml配置文件"><a href="#xml配置文件" class="headerlink" title="xml配置文件"></a>xml配置文件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.spring.aopxml"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"myLoggerAspectXML"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"cut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.spring.aopxml.*.*(..))"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;aop:before method="before" pointcut="execution(* com.com.spring.aopxml.*.*(..))"&gt;&lt;/aop:before&gt;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"before"</span> <span class="attr">pointcut-ref</span>=<span class="string">"cut"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="四、JDBCTemplate数据库访问-事务管理"><a href="#四、JDBCTemplate数据库访问-事务管理" class="headerlink" title="四、JDBCTemplate数据库访问+事务管理"></a>四、JDBCTemplate数据库访问+事务管理</h1><h2 id="1、JDBCTemplate使用"><a href="#1、JDBCTemplate使用" class="headerlink" title="1、JDBCTemplate使用"></a>1、JDBCTemplate使用</h2><h3 id="1）、导入依赖"><a href="#1）、导入依赖" class="headerlink" title="1）、导入依赖"></a>1）、导入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    spring.version 版本--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;properties&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;spring.version&gt;5.1.9.RELEASE&lt;/spring.version&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/properties&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        数据库--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.35<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring-jdbc 用于配置JdbcTemplate --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2）、xml配置文件"><a href="#2）、xml配置文件" class="headerlink" title="2）、xml配置文件"></a>2）、xml配置文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--引入属性文件--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name="location" value="db.properties"&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"db.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--创建数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--通过数据源配置JDBCTemplate--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"jdbc.xml"</span>);</span><br><span class="line">    JdbcTemplate jdbcTemplate = ac.getBean(<span class="string">"jdbcTemplate"</span>, JdbcTemplate.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;<span class="comment">//单个增删改</span></span><br><span class="line"><span class="comment">//        jdbcTemplate.update("insert into emp values(null,'张三',23,'男')");</span></span><br><span class="line"><span class="comment">//        String sql = "insert into emp values(null,?,?,?)";</span></span><br><span class="line"><span class="comment">//        jdbcTemplate.update(sql,"李四",24,"女");</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//PreparedStatement里的setString方法赋值字符串的时候，会自动添加单引号</span></span><br><span class="line">        String eids = <span class="string">"1,2,3"</span>;</span><br><span class="line"><span class="comment">//        String sql = "delete from emp where eid in(?)";//不能直接引用eids</span></span><br><span class="line">        <span class="comment">//但这种方式要考虑sql注入的问题</span></span><br><span class="line">        String sql = <span class="string">"delete from emp where eid in("</span>+eids+<span class="string">")"</span>;</span><br><span class="line">        jdbcTemplate.update(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        String sqls = "select * from emp where ename like '%?%'";//不能使用</span></span><br><span class="line">        String sqls = <span class="string">"select * from emp where ename like concat('%',?,'%')"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBatchUpdate</span><span class="params">()</span></span>&#123;<span class="comment">//批量增删改</span></span><br><span class="line">        String sql = <span class="string">"insert into emp values(null,?,?,?)"</span>;</span><br><span class="line">        List&lt;Object[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Object[]&#123;<span class="string">"a1"</span>,<span class="number">1</span>,<span class="string">"男"</span>&#125;);</span><br><span class="line">        list.add(<span class="keyword">new</span> Object[]&#123;<span class="string">"a2"</span>,<span class="number">2</span>,<span class="string">"男"</span>&#125;);</span><br><span class="line">        list.add(<span class="keyword">new</span> Object[]&#123;<span class="string">"a3"</span>,<span class="number">3</span>,<span class="string">"男"</span>&#125;);</span><br><span class="line">        jdbcTemplate.batchUpdate(sql,list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryForObject</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        jdbcTemplate.queryForObject(sql,requiredType);用来获取单个的值</span></span><br><span class="line"><span class="comment">//        String sql = "select *  from emp where eid = ?";</span></span><br><span class="line"><span class="comment">//        jdbcTemplate.queryForObject(sql,rowMapper);用来获取单条数据</span></span><br><span class="line"><span class="comment">//        RowMapper&lt;Emp&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;(Emp.class);</span></span><br><span class="line"><span class="comment">//        Emp emp = jdbcTemplate.queryForObject(sql, new Object[]&#123;4&#125;, rowMapper);</span></span><br><span class="line"><span class="comment">//        System.out.println(emp);</span></span><br><span class="line"></span><br><span class="line">        String sql = <span class="string">"select count(*) from emp"</span>;</span><br><span class="line">        Integer res = jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select eid,ename,age,sex from emp"</span>;</span><br><span class="line">        RowMapper&lt;Emp&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Emp.class);</span><br><span class="line">        List&lt;Emp&gt; query = jdbcTemplate.query(sql, rowMapper);</span><br><span class="line">        System.out.println(query);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、加入事务"><a href="#2、加入事务" class="headerlink" title="2、加入事务"></a>2、加入事务</h2><h3 id="xml文件配置"><a href="#xml文件配置" class="headerlink" title="xml文件配置"></a>xml文件配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.spring.book"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"db.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--创建数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--通过数据源配置JDBCTemplate--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSourceTransactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启注解驱动，即对事务相关的注解进行扫描，解析含义并执行功能--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"dataSourceTransactionManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="注解事务的使用"><a href="#注解事务的使用" class="headerlink" title="注解事务的使用"></a>注解事务的使用</h3><ul>
<li><p>@Transactional: 对方法中所有的操作作为一个事务进行管理</p>
<p>   在方法上使用，只对方法有效果</p>
<p>   在类上使用，对类中所有的方法都有效果</p>
<p>   @Transactional 中可以设置的属性:</p>
<ul>
<li><p>1.事务的传播方式propagation:A方法和B方法都有事务，当A在调用B时，会将A中的事务传播给B方法，B方法对于事务的的处理方式就是事务的传播行为</p>
<p>Propagation.REQUIRED(默认值):必须使用调用者的事务,即checkOut()的事务</p>
<p>Propagation.REQUIRES_NEW:将调用者的事务挂起，不使用调用者的事务，使用新的事务进行处理(buyBook()的事务)</p>
</li>
<li><p>2.事务的隔离级别isolation:在并发的情况下，操作数据的一种规定</p>
<ul>
<li>读未提交：脏读(读出数据后，可能未提交的回滚了),针对一个表中的一条数据的一个字段</li>
<li>读已提交：不可重复读(数据提交且不回滚，那么读出的数据不一致),针对一个表中的一条数据的一个字段</li>
<li>可重复读：幻读(但可以往表中新添数据，使读完之后和表中数据不一致),针对表里的一行数据</li>
<li>串行化(单线程)：性能低，消耗大</li>
</ul>
</li>
<li><p>3.timeout:在事务强制回滚前最多可以执行(等待)的时间</p>
</li>
<li><p>4.readOnly:当前事务中的一系列的操作是否为只读</p>
<ul>
<li>若设置为只读，不管事务中有没有写的操作，Mysql都会在请求访问数据的时候，不加锁，提高性能。</li>
<li>但是如果有写的操作时，建议一定不能设置为只读</li>
</ul>
</li>
<li><p>5.rollbackFor|rollbackForClassName|noRollbackFor|noRollbackForClassName:设置事务回滚的条件</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Transactional</span>: 对方法中所有的操作作为一个事务进行管理</span></span><br><span class="line"><span class="comment">     * 在方法上使用，只对方法有效果</span></span><br><span class="line"><span class="comment">     * 在类上使用，对类中所有的方法都有效果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Transactional</span> 中可以设置的属性:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1.事务的传播方式propagation:A方法和B方法都有事务，当A在调用B时，会将A中的事务传播给B方法，B方法对于事务的的处理方式就是事务的传播行为</span></span><br><span class="line"><span class="comment">     * Propagation.REQUIRED(默认值):必须使用调用者的事务,即checkOut()的事务</span></span><br><span class="line"><span class="comment">     * Propagation.REQUIRES_NEW:将调用者的事务挂起，不使用调用者的事务，使用新的事务进行处理(buyBook()的事务)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2.事务的隔离级别isolation:在并发的情况下，操作数据的一种规定</span></span><br><span class="line"><span class="comment">     *      读未提交：脏读(读出数据后，可能未提交的回滚了),针对一个表中的一条数据的一个字段</span></span><br><span class="line"><span class="comment">     *      读已提交：不可重复读(数据提交且不回滚，那么读出的数据不一致),针对一个表中的一条数据的一个字段</span></span><br><span class="line"><span class="comment">     *      可重复读：幻读(但可以往表中新添数据，使读完之后和表中数据不一致),针对表里的一行数据</span></span><br><span class="line"><span class="comment">     *      串行化(单线程)：性能低，消耗大</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3.timeout:在事务强制回滚前最多可以执行(等待)的时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 4.readOnly:当前事务中的一系列的操作是否为只读</span></span><br><span class="line"><span class="comment">     * 若设置为只读，不管事务中有没有写的操作，Mysql都会在请求访问数据的时候，不加锁，提高性能。</span></span><br><span class="line"><span class="comment">     * 但是如果有写的操作时，建议一定不能设置为只读</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 5.rollbackFor|rollbackForClassName|noRollbackFor|noRollbackForClassName:设置事务回滚的条件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW,noRollbackFor = &#123;MyException.class,NullPointerException.class&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyBook</span><span class="params">(String bid, String uid)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            Thread.sleep(5000);</span></span><br><span class="line"><span class="comment">//        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        Integer price = bookDao.selectPrice(bid);</span><br><span class="line">        bookDao.updateSt(bid);</span><br><span class="line">        bookDao.updateBalance(uid,price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="五、注解版Spring（简略）"><a href="#五、注解版Spring（简略）" class="headerlink" title="五、注解版Spring（简略）"></a>五、注解版Spring（简略）</h1><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><ul>
<li>@autowired 默认类型优先</li>
<li>@Resource 可以和@autowired一样自动装配，默认用名称装配</li>
<li>@Inject 和@Autowired功能一样</li>
<li>@autowired 是spring定义的</li>
<li>@Resource @Inject 是java规范</li>
</ul>
<h2 id="给容器中注册组件"><a href="#给容器中注册组件" class="headerlink" title="给容器中注册组件"></a>给容器中注册组件</h2><ul>
<li>1.包扫描+组件注解：@Controller [自己写的类]</li>
<li>2.@Bean [导入的第三方包里面的组件]</li>
<li>3.@Import[快速给容器中导入一个组件]<ul>
<li>1.导入组件，id默认是全类名</li>
<li>2.ImportSelector:返回需要导入的组件的全类名数组</li>
<li>3.ImportBeanDefinitionRegistrar:手动注册bean到容器中</li>
</ul>
</li>
<li><p>4.Spring提供的FactoryBean(工厂Bean)</p>
<ul>
<li><p>1.默认获取到的是工厂bean调用的getObject创建的对象</p>
</li>
<li><p>2.要获取工厂Bean对象，需要在id前面加一个&amp;</p>
</li>
</ul>
</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li>1.自己手动指定</li>
<li>2.继承InitializingBean, DisposableBean</li>
<li><p>3.注解@PostConstruct,在bean创建完成并且属性赋值完成，来执行初始化方法</p>
<ul>
<li>.@PreDesdroy在容器销毁bean之前同志进行清理工作</li>
</ul>
</li>
<li><p>4.BeanPostProcessor bean的后置处理器</p>
<ul>
<li><p>postProcessBeforeInitialization:在初始化之前</p>
</li>
<li><p>postProcessAfterInitialization:在初始化之后</p>
</li>
<li><p>原理：</p>
</li>
<li><p>populateBean()给属性赋值</p>
</li>
<li><p>initializeBean初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">applyBeanPostProcessorBeforeInitialization</span><br><span class="line">invokeInitMethods</span><br><span class="line">applyBeanPostProcessorAfterInitialization</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>redis学习笔记</title>
    <url>/alex-next/2021/07/31/javaEE/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1-入门"><a href="#1-入门" class="headerlink" title="1.入门"></a>1.入门</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h3 id="五种数据结构"><a href="#五种数据结构" class="headerlink" title="五种数据结构"></a>五种数据结构</h3><ul>
<li><p>字符串</p>
<ul>
<li><p>常用操作</p>
<ul>
<li><p>set key value</p>
<ul>
<li>存入键值对</li>
</ul>
</li>
<li><p>mset key value [key value…]</p>
<ul>
<li>批量存储键值对</li>
</ul>
</li>
<li><p>setnx key value</p>
<ul>
<li>分布式锁，获取锁成功返回1，否则返回0</li>
</ul>
</li>
<li><p>get key</p>
<ul>
<li>获取value</li>
</ul>
</li>
<li><p>mget key [key…]</p>
<ul>
<li>批量获取value</li>
</ul>
</li>
<li><p>del key </p>
<ul>
<li>删除key</li>
</ul>
</li>
</ul>
</li>
<li><p>原子加减</p>
<ul>
<li><p>incr key</p>
<ul>
<li>key中存储的数字值加1</li>
</ul>
</li>
<li><p>decr key</p>
<ul>
<li>key中存储的数字值减1</li>
</ul>
</li>
<li><p>incrby key increment</p>
<ul>
<li>将key所储存的值加上increment</li>
</ul>
</li>
<li><p>decrby key increment</p>
<ul>
<li>将key所储存的值减去increment</li>
</ul>
</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li>文章阅读量</li>
<li>web集群session共享</li>
<li>分布式系统全局序列号</li>
</ul>
</li>
</ul>
</li>
<li><p>哈希</p>
<ul>
<li><p>记忆</p>
<ul>
<li>key类似对象，field类似属性，value类似属性值</li>
</ul>
</li>
<li><p>常用操作</p>
<ul>
<li><p>hset key field value</p>
<ul>
<li>存储一个哈希表的键值</li>
</ul>
</li>
<li><p>HSETNX  key  field  value</p>
<ul>
<li>分布式锁</li>
</ul>
</li>
<li><p>HMSET  key  field  value [field value …]</p>
<ul>
<li>批量存储</li>
</ul>
</li>
<li><p>HGET  key  field</p>
<ul>
<li>获取哈希表key对应的field键值</li>
</ul>
</li>
<li><p>HMGET  key  field  [field …]</p>
<ul>
<li>批量获取</li>
</ul>
</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li><p>电商购物车</p>
<ul>
<li><p>存储</p>
<ul>
<li>1）以用户id为key</li>
<li>2）商品id为field</li>
<li>3）商品数量为value</li>
</ul>
</li>
<li><p>操作</p>
<ul>
<li>添加商品：hset cart:1001 10088 1</li>
<li>增加数量：hincrby cart:1001 10088 1</li>
<li>商品总数：hlen cart:1001</li>
<li>删除商品：hdel cart:1001 10088</li>
<li>获取购物车所有商品：hgetall cart:1001</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>优缺点</p>
<ul>
<li><p>优点</p>
<ul>
<li>同类数据归类整合储存，方便数据管理</li>
<li>相比string操作消耗内存与cpu更小</li>
<li>相比string储存更节省空间</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>过期功能不能使用在field上，只能用在key上</li>
<li>Redis集群架构下不适合大规模使用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>列表</p>
<ul>
<li><p>常用操作</p>
<ul>
<li><p>LPUSH  key  value [value …]</p>
<ul>
<li>将一个或多个值value插入到key列表的表头(最左边)</li>
</ul>
</li>
<li><p>RPUSH  key  value [value …]</p>
<ul>
<li>将一个或多个值value插入到key列表的表尾(最右边)</li>
</ul>
</li>
<li><p>LPOP  key</p>
<ul>
<li>移除并返回key列表的头元素</li>
</ul>
</li>
<li><p>RPOP  key</p>
<ul>
<li>移除并返回key列表的尾元素</li>
</ul>
</li>
<li><p>LRANGE  key  start  stop</p>
<ul>
<li>返回列表key中指定区间内的元素，区间以偏移量start和stop指定</li>
</ul>
</li>
<li><p>BLPOP  key  [key …]  timeout</p>
<ul>
<li>从key列表表头弹出一个元素，若列表中没有元素，阻塞等待timeout秒,如果timeout=0,一直阻塞等待</li>
</ul>
</li>
<li><p>BRPOP  key  [key …]  timeout</p>
<ul>
<li>从key列表表尾弹出一个元素，若列表中没有元素，阻塞等待timeout秒,如果timeout=0,一直阻塞等待</li>
</ul>
</li>
</ul>
</li>
<li><p>常用数据结构</p>
<ul>
<li>Stack(栈) = LPUSH + LPOP</li>
<li>Queue(队列）= LPUSH + RPOP</li>
<li>Blocking MQ(阻塞队列）= LPUSH + BRPOP</li>
</ul>
</li>
<li><p>和Java的区别</p>
<ul>
<li>分布式多台电脑访问</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li><p>微信公众号推送消息流</p>
<ul>
<li>使用栈结构后进先出</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>集合</p>
<ul>
<li><p>常用操作</p>
<ul>
<li><p>SADD  key  member  [member …]</p>
<ul>
<li>往集合key中存入元素，元素存在则忽略，若key不存在则新建</li>
</ul>
</li>
<li><p>SREM  key  member  [member …]</p>
<ul>
<li>从集合key中删除元素</li>
</ul>
</li>
<li><p>SMEMBERS  key</p>
<ul>
<li>获取集合key中所有元素</li>
</ul>
</li>
<li><p>SCARD  key</p>
<ul>
<li>获取集合key的元素个数</li>
</ul>
</li>
<li><p>SISMEMBER  key  member</p>
<ul>
<li>判断member元素是否存在于集合key中</li>
</ul>
</li>
<li><p>SRANDMEMBER  key  [count]</p>
<ul>
<li>从集合key中选出count个元素，元素不从key中删除</li>
</ul>
</li>
<li><p>SPOP  key  [count]</p>
<ul>
<li>从集合key中选出count个元素，元素从key中删除</li>
</ul>
</li>
</ul>
</li>
<li><p>集合运算操作</p>
<ul>
<li><p>SINTER  key  [key …]</p>
<ul>
<li>交集运算</li>
</ul>
</li>
<li><p>SUNION  key  [key ..]</p>
<ul>
<li>并集运算</li>
</ul>
</li>
<li><p>SDIFF  key  [key …]</p>
<ul>
<li><p>差集运算</p>
<ul>
<li>集合A在集合B,C…中都没有的元素</li>
</ul>
</li>
</ul>
</li>
<li><p>SINTERSTORE  destination  key  [key ..]</p>
<ul>
<li>将交集结果存入新集合destination中</li>
</ul>
</li>
<li><p>SUNIONSTORE  destination  key  [key …]</p>
<ul>
<li>将并集结果存入新集合destination中</li>
</ul>
</li>
<li><p>SDIFFSTORE  destination  key  [key …]</p>
<ul>
<li>将差集结果存入新集合destination中</li>
</ul>
</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li><p>微信抽奖</p>
<ul>
<li><p>参加过得不能参加，适合不重复抽奖</p>
<ul>
<li>SADD key {userlD}</li>
</ul>
</li>
<li><p>抽取count名中奖者，适合重复抽奖</p>
<ul>
<li>SRANDMEMBER key [count] / SPOP key [count]</li>
</ul>
</li>
</ul>
</li>
<li><p>微信朋友圈点赞</p>
<ul>
<li>点赞过不能在点赞</li>
<li>取消点赞</li>
</ul>
</li>
<li><p>微博微信关注模型</p>
<ul>
<li><p>1) 诸葛老师关注的人: </p>
<ul>
<li>zhugeSet-&gt; {guojia, xushu}</li>
</ul>
</li>
<li><p>2) 杨过老师关注的人:</p>
<ul>
<li>yangguoSet—&gt; {zhuge, baiqi, guojia, xushu}</li>
</ul>
</li>
<li><p>3) 郭嘉老师关注的人: </p>
<ul>
<li>guojiaSet-&gt; {zhuge, yangguo, baiqi, xushu, xunyu)</li>
</ul>
</li>
<li><p>4) 我和杨过老师共同关注: </p>
<ul>
<li>SINTER zhugeSet yangguoSet—&gt; {guojia, xushu}</li>
</ul>
</li>
<li><p>5) 我关注的人也关注他(杨过老师): </p>
<ul>
<li>SISMEMBER guojiaSet yangguo </li>
<li>SISMEMBER xushuSet yangguo</li>
</ul>
</li>
<li><p>6) 我可能认识的人: </p>
<ul>
<li>SDIFF yangguoSet zhugeSet-&gt;(zhuge, baiqi}</li>
</ul>
</li>
</ul>
</li>
<li><p>集合操作实现电商商品筛选</p>
<ul>
<li><p>存储</p>
<ul>
<li>SADD  brand:huawei  P40</li>
<li>SADD  brand:xiaomi  mi-10</li>
<li>SADD  brand:iPhone iphone12</li>
<li>SADD os:android  P40  mi-10</li>
<li>SADD cpu:brand:intel  P40  mi-10</li>
<li>SADD ram:8G  P40  mi-10  iphone12</li>
</ul>
</li>
<li><p>操作</p>
<ul>
<li>SINTER  os:android  cpu:brand:intel  ram:8G -&gt;{P40，mi-10}</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>有序集合</p>
<ul>
<li><p>常用操作</p>
<ul>
<li><p>ZADD key score member [[score member]…]</p>
<ul>
<li>往有序集合key中加入带分值元素</li>
</ul>
</li>
<li><p>ZREM key member [member …]</p>
<ul>
<li>从有序集合key中删除元素</li>
</ul>
</li>
<li><p>ZSCORE key member</p>
<ul>
<li>返回有序集合key中元素member的分值</li>
</ul>
</li>
<li><p>ZINCRBY key increment member</p>
<ul>
<li>为有序集合key中元素member的分值加上increment </li>
</ul>
</li>
<li><p>ZCARD key</p>
<ul>
<li>返回有序集合key中元素个数</li>
</ul>
</li>
<li><p>ZRANGE key start stop [WITHSCORES]</p>
<ul>
<li>正序获取有序集合key从start下标到stop下标的元素</li>
</ul>
</li>
<li><p>ZREVRANGE key start stop [WITHSCORES]</p>
<ul>
<li>倒序获取有序集合key从start下标到stop下标的元素</li>
</ul>
</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li><p>排行榜</p>
<ul>
<li><p>1）点击新闻</p>
<ul>
<li>ZINCRBY  hotNews:20190819  1  守护香港</li>
</ul>
</li>
<li><p>2）展示当日排行前十</p>
<ul>
<li>ZREVRANGE  hotNews:20190819  0  9  WITHSCORES </li>
</ul>
</li>
<li><p>3）七日搜索榜单计算</p>
<ul>
<li>ZUNIONSTORE  hotNews:20190813-20190819  7 hotNews:20190813  hotNews:20190814… hotNews:20190819</li>
</ul>
</li>
<li><p>4）展示七日排行前十</p>
<ul>
<li>ZREVRANGE hotNews:20190813-20190819  0  9  WITHSCORES</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="其他高级命令"><a href="#其他高级命令" class="headerlink" title="其他高级命令"></a>其他高级命令</h3><ul>
<li><p>keys</p>
<ul>
<li>全量遍历键，效率低</li>
</ul>
</li>
<li><p>scan</p>
<ul>
<li>SCAN cursor [MATCH pattern] [COUNT count]</li>
<li><p>例子</p>
<ul>
<li>scan 0 match zhuge* count 3</li>
</ul>
</li>
<li><p>上述例子，是指从全量键中获取，并不一定是3个，可能比3个多，而且还要考虑多线程下增删改操作</p>
</li>
</ul>
</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p>Redis是单线程吗</p>
<ul>
<li>Redis 的单线程主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外 提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</li>
</ul>
</li>
<li><p>Redis不是单线程为什么还能这么快</p>
<ul>
<li>因为它所有数据都在内存中，所有的运算都是内存级别的运算</li>
</ul>
</li>
<li><p>Redis 单线程如何处理那么多的并发客户端连接</p>
<ul>
<li><p>NIO多路复用</p>
<ul>
<li>redis利用epoll来实现IO多路复用，将连接信息和事件放到队列中，依次放到 文件事件分派器，事件分派器将事件分发给事件处理器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-持久化、主从与哨兵集群架构"><a href="#2-持久化、主从与哨兵集群架构" class="headerlink" title="2.持久化、主从与哨兵集群架构"></a>2.持久化、主从与哨兵集群架构</h2><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><ul>
<li><p>RDB快照</p>
<ul>
<li>在默认情况下， Redis 将内存数据库快照保存在名字为 dump.rdb 的二进制文件中，也可以手动执行save或bgsave</li>
<li><p>save</p>
<ul>
<li>save是同步的，会阻塞客户端命令，影响Redis性能</li>
</ul>
</li>
<li><p>bgsave</p>
<ul>
<li>bgsave是异步的，使用copyonwrite机制</li>
</ul>
</li>
<li><p>save与bgsave对比</p>
</li>
<li><p>关闭RDB</p>
<ul>
<li>只需要把所有save 60 10000(60s内有10000个键被改动)注释掉</li>
</ul>
</li>
</ul>
</li>
<li><p>AOF</p>
<ul>
<li><p>AOF默认关闭，修改配置文件打开AOF</p>
<ul>
<li>appendonly yes</li>
</ul>
</li>
<li><p>可以配置多久将数据fsync到磁盘</p>
<ul>
<li><p>appendfsync always</p>
<ul>
<li>每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全。</li>
</ul>
</li>
<li><p>appendfsync everysec </p>
<ul>
<li>每秒 fsync 一次，足够快，并且在故障时只会丢失 1 秒钟的数据。</li>
</ul>
</li>
<li><p>appendfsync no</p>
<ul>
<li>从不 fsync ，将数据交给操作系统来处理。更快，也更不安全的选择。</li>
</ul>
</li>
<li><p>推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>RDB和AOF对比</p>
<ul>
<li>RDB更快是因为RDB是二进制存储的</li>
</ul>
</li>
<li><p>混合持久化</p>
<ul>
<li><p>redis4.0之后，其实就是AOF使用二进制存储</p>
</li>
<li><p>开启</p>
<ul>
<li><h1 id="aof‐use‐rdb‐preamble-yes"><a href="#aof‐use‐rdb‐preamble-yes" class="headerlink" title="aof‐use‐rdb‐preamble yes"></a>aof‐use‐rdb‐preamble yes</h1></li>
</ul>
</li>
</ul>
</li>
<li><p>Redis数据备份策略</p>
<ul>
<li><ol>
<li>写crontab定时调度脚本，每小时都copy一份rdb或aof的备份到一个目录中去，仅仅保留最近48 小时的备份 </li>
</ol>
</li>
<li><ol>
<li>每天都保留一份当日的数据备份到一个目录中去，可以保留最近1个月的备份</li>
</ol>
</li>
<li><ol>
<li>每次copy备份的时候，都把太旧的备份给删了 </li>
</ol>
</li>
<li><ol>
<li>每天晚上将当前机器上的备份复制一份到其他机器上，以防机器损坏</li>
</ol>
</li>
</ul>
</li>
<li><p>细节</p>
<ul>
<li>RDB和AOF若同时开启，RDB和AOF只要满足相应条件，都会各自备份</li>
</ul>
</li>
</ul>
<h3 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h3><ul>
<li><p>工作原理</p>
<ul>
<li><p>全量复制</p>
<ul>
<li>1.slave发送psync同步数据与master建立socket连接</li>
<li>2.master收到psync执行bgsave生成最新rdb数据</li>
<li>2.2做rdb之后缓存写命令</li>
<li>3.master发送给slave  rdb数据</li>
<li>4.slave清空老数据并加载rdb文件(会在slave生成一份rdb文件)</li>
<li>5.master发给slave做rdb之后repl buffer中的写命令</li>
<li>6.slave将执行buffer中的写命令</li>
<li>7.master通过socket长连接持续给从节点发送写命令</li>
</ul>
</li>
<li><p>部分复制(断点续传)</p>
<ul>
<li>1.slave断开连接(故障)</li>
<li>2.master会在repl backlog buffer中缓存最近的写命令和slave的复制数据下标offset</li>
<li>3.之后slave和master在此建立socket连接</li>
<li>4.slave发送psync</li>
<li>5.slave的offset若在repl backlog buffer中，从缓存中取offset之后的数据一次性同步给slave，否则会全量更新</li>
<li>6.master通过socket长连接持续吧写命令发给从节点</li>
</ul>
</li>
<li><p>细节</p>
<ul>
<li>如果master收到了多 个slave并发连接请求，它只会进行一次持久化，而不是一个连接一次，然后再把这一份持久化的数据发送 给多个并发连接的slave</li>
<li><p>主从复制风暴(多个从节点同时复制主节点导致主节点压力过大)</p>
<ul>
<li>解决方案：让部分从节点与从节点(与主节点同步)同步数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>操作</p>
<ul>
<li><p>master结点配置文件不变</p>
</li>
<li><p>slave结点配置文件</p>
<ul>
<li><p>1.复制一份redis.conf文件(修改初始配置)</p>
</li>
<li><p>2.修改基本配置</p>
<ul>
<li><p>端口号</p>
<ul>
<li>port 6380</li>
</ul>
</li>
<li><p>pidfile文件</p>
<ul>
<li>只有linux有</li>
<li>pidfile /var/run/redis_6380.pid # 把pid进程号写入pidfile配置的文件</li>
</ul>
</li>
<li><p>日志文件</p>
<ul>
<li>logfile “6380.log”</li>
</ul>
</li>
<li><p>修改工作目录</p>
<ul>
<li>windows从cmd出来默认把用户目录当做工作目录</li>
<li>dir ./data</li>
</ul>
</li>
<li><p>注释bind</p>
<ul>
<li><p>windows试过不用注释掉(因为这次是在一台电脑上测试的，若是多台机器上测试要注释掉)</p>
</li>
<li><h1 id="bind-127-0-0-1"><a href="#bind-127-0-0-1" class="headerlink" title="bind 127.0.0.1"></a>bind 127.0.0.1</h1><ul>
<li>若是在一台机器上，这样配置没有问题；若主从结点在不同机器上用127.0.0.1访问不了其他节点，必须要用对外的ip地址</li>
</ul>
</li>
</ul>
</li>
<li><p>修改dbfilename或工作目录都行</p>
<ul>
<li>dbfilename dump-6380.rdb</li>
</ul>
</li>
</ul>
</li>
<li><p>3.配置主从复制</p>
<ul>
<li><p>replicaof 127.0.0.1 6379</p>
<ul>
<li>从本机6379的redis实例复制数据，Redis 5.0之前使用slaveof</li>
</ul>
</li>
<li><p>replica‐read‐only yes</p>
<ul>
<li>配置从节点只读</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>启动从结点</p>
<ul>
<li>redis-server ./conf/redis-6380.conf</li>
</ul>
</li>
<li><p>连接从节点</p>
<ul>
<li>redis‐cli ‐p 6380</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="哨兵高可用架构"><a href="#哨兵高可用架构" class="headerlink" title="哨兵高可用架构"></a>哨兵高可用架构</h3><ul>
<li><p>原理</p>
<ul>
<li><p>sentinel哨兵权限</p>
<ul>
<li>sentinel哨兵是特殊的redis服务，不提供读写服务，主要用来监控redis实例节点</li>
</ul>
</li>
<li><p>访问数据步骤</p>
<ul>
<li>哨兵架构下client端第一次从哨兵找出redis的主节点，后续就直接访问redis的主节点，不会每次都通过 sentinel代理访问redis的主节点</li>
<li>当redis的主节点发生变化，哨兵会第一时间感知到，并且将新的redis 主节点通知给client端(这里面redis的client端一般都实现了订阅功能，订阅sentinel发布的节点变动消息)</li>
</ul>
</li>
</ul>
</li>
<li><p>实验操作</p>
<ul>
<li><p>sentinel结点配置文件</p>
<ul>
<li><p>windows配置</p>
<ul>
<li>复制一份redis.conf文件(修改初始配置)</li>
<li><p>端口号</p>
<ul>
<li>port 26380</li>
</ul>
</li>
<li><p>pidfile文件</p>
<ul>
<li>只有linux有</li>
<li>pidfile /var/run/redis_6380.pid # 把pid进程号写入pidfile配置的文件</li>
</ul>
</li>
<li><p>daemonize yes</p>
<ul>
<li>只有linux有</li>
<li>用来指定redis是否要用守护线程的方式启动</li>
</ul>
</li>
<li><p>日志文件</p>
<ul>
<li>logfile “6380.log”</li>
</ul>
</li>
<li><p>修改工作目录</p>
<ul>
<li>windows从cmd出来默认把用户目录当做工作目录</li>
<li>dir ./data</li>
</ul>
</li>
<li><p>修改sentinel monitor</p>
<ul>
<li>sentinel monitor mymaster 192.168.0.60 6379 2</li>
</ul>
</li>
</ul>
</li>
<li><p>windows配置</p>
<ul>
<li><p>新建sentinel.conf文件</p>
</li>
<li><p>port 26379</p>
<ul>
<li><h1 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h1></li>
</ul>
</li>
<li><p>sentinel monitor mymaster 127.0.0.1 6379 2</p>
<ul>
<li><h1 id="哨兵监听的主服务器-后面的2表示主机挂掉以后进行投票，只需要2票就可以从机编程主机"><a href="#哨兵监听的主服务器-后面的2表示主机挂掉以后进行投票，只需要2票就可以从机编程主机" class="headerlink" title="哨兵监听的主服务器    后面的2表示主机挂掉以后进行投票，只需要2票就可以从机编程主机"></a>哨兵监听的主服务器 <master名称> <master的ip> <master端口号> 后面的2表示主机挂掉以后进行投票，只需要2票就可以从机编程主机</master端口号></master的ip></master名称></h1></li>
</ul>
</li>
<li><p>sentinel down-after-milliseconds mymaster 5000</p>
<ul>
<li><h1 id="指定了Sentinel认为Redis实例已经失效所需的毫秒数。"><a href="#指定了Sentinel认为Redis实例已经失效所需的毫秒数。" class="headerlink" title="指定了Sentinel认为Redis实例已经失效所需的毫秒数。"></a>指定了Sentinel认为Redis实例已经失效所需的毫秒数。</h1></li>
</ul>
</li>
<li><h1 id="sentinel-failover-timeout-mymaster-18000"><a href="#sentinel-failover-timeout-mymaster-18000" class="headerlink" title="sentinel failover-timeout mymaster 18000"></a>sentinel failover-timeout mymaster 18000</h1><ul>
<li><h1 id="如果在该时间（ms）内未能完成failover操作，则认为该failover失败"><a href="#如果在该时间（ms）内未能完成failover操作，则认为该failover失败" class="headerlink" title="如果在该时间（ms）内未能完成failover操作，则认为该failover失败"></a>如果在该时间（ms）内未能完成failover操作，则认为该failover失败</h1></li>
</ul>
</li>
<li><h1 id="sentinel-notification-script"><a href="#sentinel-notification-script" class="headerlink" title="sentinel notification-script  "></a>sentinel notification-script <master-name> <script-path></script-path></master-name></h1><ul>
<li><h1 id="指定sentinel检测到该监控的redis实例指向的实例异常时，调用的报警脚本。该配置项可选，但是很常用"><a href="#指定sentinel检测到该监控的redis实例指向的实例异常时，调用的报警脚本。该配置项可选，但是很常用" class="headerlink" title="指定sentinel检测到该监控的redis实例指向的实例异常时，调用的报警脚本。该配置项可选，但是很常用"></a>指定sentinel检测到该监控的redis实例指向的实例异常时，调用的报警脚本。该配置项可选，但是很常用</h1></li>
</ul>
</li>
<li><p>dir ./data/s26380</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>启动</p>
<ul>
<li><p>redis</p>
<ul>
<li>src/redis‐sentinel sentinel‐26379.conf</li>
</ul>
</li>
<li><p>windows</p>
<ul>
<li>redis-server ./conf/sentinel-26379.conf —sentinel</li>
</ul>
</li>
</ul>
</li>
<li><p>实验结果</p>
<ul>
<li>启动一个循环往主结点中丢数据的程序，然后，将主节点手动关闭，可以观察到在报错过了3-5s后，又开始往redis中放数据(sentinel选举出了新的master结点)</li>
<li><p>主节点挂掉的话</p>
<ul>
<li>会修改相应sentinel的conf文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Jedis-RedisTemplate"><a href="#Jedis-RedisTemplate" class="headerlink" title="Jedis/RedisTemplate"></a>Jedis/RedisTemplate</h3><ul>
<li><p>lua脚本事务</p>
<ul>
<li><p>减少网络开销</p>
<ul>
<li>本来5次网络请求的操作，可以用一个请求完成，原先5次请求的逻辑放在redis服务器 上完成。使用脚本，减少了网络往返时延。这点跟管道类似</li>
</ul>
</li>
<li><p>原子操作</p>
<ul>
<li>Redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。管道不是原子的，不过 redis的批量操作命令(类似mset)是原子的</li>
</ul>
</li>
<li><p>替代redis的事务功能</p>
</li>
</ul>
</li>
<li><p>管道</p>
<ul>
<li>客户端可以一次性发送多个请求而不用等待服务器的响应(不然每条命令都需要连接(比较耗时))</li>
<li>管道中前面命令失败，后面命令 不会有影响，继续执行</li>
</ul>
</li>
<li><p>RedisTemplate</p>
<ul>
<li>StringRedisTemplate继承自RedisTemplate，在redis命令窗口查看不会是/xx,/xx的形式</li>
<li>RedisTemplate与Redis命令对应参考</li>
</ul>
</li>
</ul>
<h3 id="实验注意"><a href="#实验注意" class="headerlink" title="实验注意"></a>实验注意</h3><ul>
<li>redis-server要在安装目录下执行，否则用的不是安装目录下的配置文件，直接win+R运行，当前的工作目录就是用户文件夹</li>
<li>windows实验的时候点击开启redis的黑窗口可能阻塞该进程</li>
</ul>
<h2 id="3-Redis-Cluster集群、原理"><a href="#3-Redis-Cluster集群、原理" class="headerlink" title="3.Redis Cluster集群、原理"></a>3.Redis Cluster集群、原理</h2><h3 id="集群实验"><a href="#集群实验" class="headerlink" title="集群实验"></a>集群实验</h3><ul>
<li><p>集群配置</p>
<ul>
<li><p>1.复制redis.conf</p>
</li>
<li><p>2.修改配置文件</p>
<ul>
<li><p>daemonize yes</p>
<ul>
<li>windows无</li>
</ul>
</li>
<li><p>port 8001</p>
</li>
<li><p>pidfile /var/run/redis_8001.pid</p>
<ul>
<li>windows无</li>
</ul>
</li>
<li><p>dir /usr/local/redis‐cluster/8001/</p>
</li>
<li><p>cluster‐enabled yes</p>
</li>
<li><p>cluster‐config‐file nodes‐8001.conf</p>
<ul>
<li>集群节点信息文件，这里800x最好和port对应上</li>
</ul>
</li>
<li><p>cluster‐node‐timeout 10000</p>
</li>
<li><h1 id="bind-127-0-0-1-1"><a href="#bind-127-0-0-1-1" class="headerlink" title="bind 127.0.0.1"></a>bind 127.0.0.1</h1><ul>
<li>bind绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip，代表允许客户端通 过机器的哪些网卡ip去访问，内网一般可以不配置bind，注释掉即可</li>
<li>若是在一台机器上，这样配置没有问题；若主从结点在不同机器上用127.0.0.1访问不了其他节点，必须要用对外的ip地址</li>
</ul>
</li>
<li><p>protected‐mode no</p>
<ul>
<li>关闭保护模式</li>
</ul>
</li>
<li><p>appendonly yes</p>
</li>
<li><p>设置密码</p>
<ul>
<li>requirepass zhuge</li>
<li>masterauth zhuge</li>
</ul>
</li>
</ul>
</li>
<li><p>开启结点</p>
<ul>
<li>redis-server ./cluster_conf/8001/redis-8001.conf</li>
</ul>
</li>
<li><p>3.创建集群</p>
<ul>
<li><p>细节</p>
<ul>
<li>在创建集群之前，要先把所有节点启动起来</li>
<li>不创建集群的话，所有节点只是独立的</li>
</ul>
</li>
<li><p>windows</p>
<ul>
<li>redis-cli —cluster create —cluster-replicas 1 127.0.0.1:8001 127.0.0.1:8002 127.0.0.1:8003 127.0.0.1:8004 127.0.0.1:8005 127.0.0.1:8006</li>
<li>‐‐cluster‐replicas后的1表示为每个master配置1个从节点</li>
</ul>
</li>
<li><p>linux</p>
<ul>
<li>/usr/local/redis‐5.0.3/src/redis-cli -a zhuge —cluster create —cluster-replicas 1 192.168.0.61:8001 192.168.0.62:8002 192.168.0.63:8003 192.168.0.61:8004 192.168.0.62:8005 192. 168.0.63:8006</li>
</ul>
</li>
</ul>
</li>
<li><p>4.验证</p>
<ul>
<li>redis-cli -c -p 8001</li>
<li>cluster nodes</li>
<li>cluster info</li>
</ul>
</li>
</ul>
</li>
<li><p>水平扩展</p>
<ul>
<li><p>水平扩展</p>
<ul>
<li>不关闭集群的情况下增加结点</li>
</ul>
</li>
<li><p>步骤</p>
<ul>
<li>复制修改redis.conf同集群配置</li>
<li><p>开启结点(8007,8008)</p>
<ul>
<li>redis-server ./cluster_conf/8007/redis-8007.conf</li>
</ul>
</li>
<li><p>配置水平扩展的集群主节点</p>
<ul>
<li>redis-cli —cluster add-node 127.0.0.1:8007 127.0.0.1:8001</li>
<li>add-node第一个是要添加的，第二个是已知的结点(要连上这个网络分区，随便选一个此网络分区的结点即可)</li>
</ul>
</li>
<li><p>给新的集群主节点分配槽位</p>
<ul>
<li>redis-cli —cluster reshard 127.0.0.1:8007(任意改网络分区的节点)</li>
<li>细节</li>
</ul>
</li>
<li><p>添加从节点8008</p>
<ul>
<li><p>redis-cli —cluster add-node 127.0.0.1:8008 127.0.0.1:8001</p>
<ul>
<li>加入该网络分区</li>
</ul>
</li>
<li><p>redis-cli进入8008</p>
<ul>
<li>cluster replicate 2728a594a0498e98e4b83a537e19f9a0a3790f38 #后面这串id为8007的节点id</li>
</ul>
</li>
</ul>
</li>
<li><p>删除结点参考文件</p>
</li>
</ul>
</li>
<li><p>图解</p>
</li>
</ul>
</li>
<li><p>细节</p>
<ul>
<li>集群信息都保存在了nodes-8002.conf中，关闭之后重新启动，不需要再创建集群</li>
</ul>
</li>
</ul>
<h3 id="集群原理"><a href="#集群原理" class="headerlink" title="集群原理"></a>集群原理</h3><ul>
<li><p>槽位定位</p>
<ul>
<li>Redis Cluster 将所有数据划分为 16384 个 slots(槽位)，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中。</li>
<li>Cluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384 进行取模 来得到具体槽位。</li>
</ul>
</li>
<li><p>集群结点通信机制</p>
<ul>
<li>redis cluster节点间采取gossip协议进行通信</li>
<li><p>gossip通知</p>
<ul>
<li>meet </li>
<li>ping</li>
<li>pong</li>
<li>fail</li>
</ul>
</li>
</ul>
</li>
<li><p>redis集群选举原理</p>
<ul>
<li>1.slave发现自己的master变为FAIL </li>
<li>2.将自己记录的集群currentEpoch加1，并广播FAILOVER_AUTH_REQUEST 信息</li>
<li>3.其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个 epoch只发送一次ack </li>
<li>4.尝试failover的slave收集master返回的FAILOVER_AUTH_ACK </li>
<li>5.slave收到超过半数master的ack后变成新Master(这里解释了集群为什么至少需要三个主节点，如果只有两个，当其中一个挂了，只剩一个主节点是不能选举成功的)</li>
<li>6.slave广播Pong消息通知其他集群节点</li>
<li><p>细节</p>
<ul>
<li><p>从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟</p>
<ul>
<li>DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms</li>
<li>SLAVE_RANK表示此slave已经从master复制数据的总量的rank</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>集群相关问题</p>
<ul>
<li><p>网络抖动</p>
<ul>
<li>突然之间部分连接变得不可访问，然后很快又恢复正常</li>
<li><p>为解决这种问题，Redis Cluster 提供了一种选项cluster­node­timeout，表示当某个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切换。</p>
<ul>
<li>如果没有这个选项，网络抖动会导致主从频 繁切换 (数据的重新复制</li>
</ul>
</li>
</ul>
</li>
<li><p>脑裂问题</p>
<ul>
<li>redis集群没有过半同意机制会有脑裂问题</li>
<li><p>产生结果</p>
<ul>
<li>网络分区导致脑裂后多个主节点对外提供写服务(人话：主节点一开始挂了，之后选举出了新主节点，然后老主节点(没有过半机制可能会被选上)恢复了，就发生脑裂现象)，一旦网络分区恢复， 会将其中一个主节点变为从节点，这时会有大量数据丢失</li>
</ul>
</li>
<li><p>解决方法</p>
<ul>
<li><p>min‐replicas‐to‐write 1</p>
<ul>
<li>写数据成功最少同步的slave数量，这个数量可以模仿大于半数机制配置，比如 集群总共三个节点可以配置1，加上leader就是2，超过了半数</li>
<li>会影响CAP中的可用性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>集群是否完整才能对外提供服务</p>
<ul>
<li>当redis.conf的配置cluster-require-full-coverage为no时，表示当负责一个插槽的主库下线且没有相应的从 库进行故障恢复时，集群仍然可用，如果为yes则集群不可用</li>
</ul>
</li>
<li><p>Redis集群为什么至少需要三个master节点，并且推荐节点数为奇数？</p>
<ul>
<li><p>至少需要三个master</p>
<ul>
<li>因为新master的选举需要大于半数的集群master节点同意才能选举成功，如果只有两个master节点，当其中一个挂了，是达不到选举新master的条件的</li>
</ul>
</li>
<li><p>节点数(master)为什么推荐奇数</p>
<ul>
<li>4个和3个master节点，都至多只能挂一个(3/4或2/3，因为要半数以上)，从资源利用上来说奇数个master更优</li>
</ul>
</li>
</ul>
</li>
<li><p>Redis集群对批量操作命令的支持</p>
<ul>
<li>redis集群只支持所有key落在同一slot的情况，如果有多个key一定要用mset命令在redis集群上操作，则可以在key的前面加上{XX}，这样参数数据分片hash计 算的只会是大括号里的值，这样能确保不同的key能落到同一slot里去</li>
<li><p>示例</p>
<ul>
<li>mset {user1}:1:name zhuge {user1}:1:age 18</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-C源码解读"><a href="#4-C源码解读" class="headerlink" title="4.C源码解读(*)"></a>4.C源码解读(*)</h2><h2 id="5-redis-6新特性"><a href="#5-redis-6新特性" class="headerlink" title="5.redis 6新特性(*)"></a>5.redis 6新特性(*)</h2><h2 id="6-缓存设计与性能优化"><a href="#6-缓存设计与性能优化" class="headerlink" title="6.缓存设计与性能优化"></a>6.缓存设计与性能优化</h2><h3 id="缓存设计的问题"><a href="#缓存设计的问题" class="headerlink" title="缓存设计的问题"></a>缓存设计的问题</h3><ul>
<li><p>缓存穿透</p>
<ul>
<li><p>含义</p>
<ul>
<li>大量请求的 key 是不合理的，根本不存在于缓存中，也不存在于数据库中 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</li>
</ul>
</li>
<li><p>产生原因</p>
<ul>
<li>自身业务代码或者数据出现问题。</li>
<li>一些恶意攻击、 爬虫等造成大量空命中</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li>1.缓存空对象</li>
<li>2.布隆过滤器</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存失效(击穿)</p>
<ul>
<li><p>含义</p>
<ul>
<li>请求的 key 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</li>
</ul>
</li>
<li><p>产生原因</p>
</li>
<li><p>解决方案</p>
<ul>
<li>设置热点数据永不过期或者过期时间比较长。</li>
<li>针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>
<li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存雪崩</p>
<ul>
<li><p>含义</p>
<ul>
<li>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</li>
</ul>
</li>
<li><p>产生原因</p>
</li>
<li><p>解决方案</p>
<ul>
<li><p>针对 Redis 服务不可用的情况</p>
<ul>
<li>1.采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>2.限流，避免同时处理大量的请求。</li>
</ul>
</li>
<li><p>针对热点缓存失效的情况</p>
<ul>
<li>1.设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>2.缓存永不失效（不太推荐，实用性太差）。</li>
<li>3.设置二级缓存。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>热点缓存key</p>
<ul>
<li><p>含义</p>
<ul>
<li>在缓存失效的瞬间， 有大量线程来重建缓存， 造成后端负载加大， 甚至可能会让应用崩溃。</li>
</ul>
</li>
<li><p>产生原因</p>
<ul>
<li>当前key是一个热点key（例如一个热门的娱乐新闻），并发量非常大。重建缓存不能在短时间完成， 可能是一个复杂计算， 例如复杂的SQL、 多次IO、 多个依赖等。</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li>利用互斥锁来解决，此方法只允许一个线程重建缓存， 其他线程等待重建缓存的线程执行完， 重新从缓存获取数据即可。</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存与数据库双写不一致</p>
<ul>
<li><p>含义</p>
<ul>
<li>缓存与数据库存在数据不一致问题</li>
</ul>
</li>
<li><p>产生原因</p>
<ul>
<li>大并发导致。。</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li>1、对于并发几率很小的数据(如个人维度的订单数据、用户数据等)，这种几乎不用考虑这个问题，很少会发生缓存不一致，可以给缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。</li>
<li>2、就算并发很高，如果业务上能容忍短时间的缓存数据不一致(如商品名称，商品分类菜单等)，缓存加上过期时间依然可以解决大部分业务对于缓存的要求。</li>
<li>3、如果不能容忍缓存数据不一致，可以通过加读写锁保证并发读写或写写的时候按顺序排好队，读读的时候相当于无锁。</li>
<li>4、也可以用阿里开源的canal通过监听数据库的binlog日志及时的去修改缓存，但是引入了新的中间件，增加了系统的复杂度。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="开发规范与性能优化"><a href="#开发规范与性能优化" class="headerlink" title="开发规范与性能优化"></a>开发规范与性能优化</h3>]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis笔记</title>
    <url>/alex-next/2020/07/31/javaEE/mybatis/</url>
    <content><![CDATA[<p>项目gitee地址</p>
<blockquote>
<p><a href="https://gitee.com/alexander1/mybatis-notes" target="_blank" rel="noopener">https://gitee.com/alexander1/mybatis-notes</a></p>
<h1 id="一、Mybatis入门"><a href="#一、Mybatis入门" class="headerlink" title="一、Mybatis入门"></a>一、Mybatis入门</h1></blockquote>
<h2 id="1、导入pom依赖"><a href="#1、导入pom依赖" class="headerlink" title="1、导入pom依赖"></a>1、导入pom依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2、mybatis-comfig-xml基本配置"><a href="#2、mybatis-comfig-xml基本配置" class="headerlink" title="2、mybatis-comfig.xml基本配置"></a>2、mybatis-comfig.xml基本配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//com.mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置文件修改--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"database.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置用于控制台输出sql日志。低版本的mybatis不支持logImpl --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"LOG4J"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        设置下划线命名转换为驼峰命名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        为类型设置类型别名</span></span><br><span class="line"><span class="comment">            type:java类型，若只设置type，默认的别名就是类型，且不区分大小写</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;typeAlias type="com.com.mybatis.pojo.User" alias="User"/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.mybatis.pojo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    设置连接数据库的环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatisnote?serverTimezone=GMT%2B8&amp;amp;useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF8"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;property name="username" value="root"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;property name="password" value="mysql"/&gt;--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;com.mybatis.driver&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;com.mybatis.url&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;com.mybatis.username&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;com.mybatis.password&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    引入映射文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"./mapper/UserMapper.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3、创建UserMapper接口（pojo类是User）"><a href="#3、创建UserMapper接口（pojo类是User）" class="headerlink" title="3、创建UserMapper接口（pojo类是User）"></a>3、创建UserMapper接口（pojo类是User）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(String uid)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、创建UserMapper-xml"><a href="#4、创建UserMapper-xml" class="headerlink" title="4、创建UserMapper.xml"></a>4、创建UserMapper.xml</h2><p>每个UserMapper.xml对应着一个UserMapper接口</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//com.mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.mybatis.mapper.UserMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserById"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">         select * from user where uid = #&#123;uid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="5、简单测试"><a href="#5、简单测试" class="headerlink" title="5、简单测试"></a>5、简单测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        InputStream is = Resources.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">//getMapper():会通过动态代理动态生成UserMapper的代理实现类</span></span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        System.out.println(mapper.getClass().getName());<span class="comment">//com.sun.proxy.$Proxy5</span></span><br><span class="line">        User user = mapper.getUserById(<span class="string">"1"</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、基本操作"><a href="#二、基本操作" class="headerlink" title="二、基本操作"></a>二、基本操作</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.增删的Integer表示受影响的行数，Boolean表示操作是否成功</span><br><span class="line"></span><br><span class="line">2.$&#123;&#125;底层用的是Statement,不可以防止sql注入,要注意单引号的问题</span><br><span class="line">#&#123;&#125;底层用的是PreparedStatement,可以防止sql注入，会自动加上单引号</span><br><span class="line"></span><br><span class="line">***********************************重要*************************************************</span><br><span class="line">不同的参数类型，$&#123;&#125;和#&#123;&#125;的不同取值方式：</span><br><span class="line">I.当传输参数为单个String或基本数据类型和包装类,即字面量</span><br><span class="line">#&#123;&#125;:可以以任意的名字获取参数值</span><br><span class="line">$&#123;&#125;:只能以$&#123;value&#125;或$&#123;_parameter&#125;</span><br><span class="line">II.当传输参数为javaBean时,#&#123;&#125;和$&#123;&#125;都可以通过属性名直接获取属性值，但要注意$&#123;&#125;的单引号问题</span><br><span class="line">III.当传输多个参数时,mybatis会默认将这些参数放在map集合中，</span><br><span class="line">两种方式：</span><br><span class="line">(1)键为arg0,arg1,arg2,arg3,arg4,...,argN-1</span><br><span class="line">(2)键为param1,param2,...,paramN</span><br><span class="line">#&#123;&#125;:#&#123;arg0&#125;、#&#123;arg1&#125;或者#&#123;param1&#125;、#&#123;param2&#125;</span><br><span class="line">$&#123;&#125;:$&#123;param1&#125;、$&#123;param2&#125;,注意单引号的问题</span><br><span class="line">IV.当传输map参数时,#&#123;&#125;和$&#123;&#125;都可以通过map的键直接获取属性值，但要注意$&#123;&#125;的单引号问题</span><br><span class="line">V.命名参数，可以通过@Param为map集合指定键的名字</span><br><span class="line">VI.当传输参数为List或Array,mybatis会将他们放在map中，</span><br><span class="line">List以list为键，Array以array为键</span><br><span class="line">***********************************重要*************************************************    </span><br><span class="line"></span><br><span class="line">3.useGeneratedKeys=&quot;true&quot; keyProperty=&quot;eid&quot;</span><br><span class="line">useGeneratedKeys默认为true,keyProperty将新添加的id赋值给eid</span><br><span class="line">useGeneratedKeys可以试用自动生成的主键</span><br><span class="line"></span><br><span class="line">注意：可以有注释但注释中不能有#+大括号，否则会报错</span><br><span class="line"></span><br><span class="line">mybatis的返回值的封装方式是先构造一个无参的对象，然后通过set方法一个一个的往里面set值，所以如果不提供无参构造方法，就会报上述错误，同样的，针对需要的属性值也必须提供get／set方法。</span><br></pre></td></tr></table></figure>
<h1 id="三、多对一多表查询"><a href="#三、多对一多表查询" class="headerlink" title="三、多对一多表查询"></a>三、多对一多表查询</h1><p>Emp.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">    Integer eid;</span><br><span class="line">    String ename;</span><br><span class="line">    Integer age;</span><br><span class="line">    String sex;</span><br><span class="line">    Dept dept;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dept.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dept</span> </span>&#123;</span><br><span class="line">    Integer did;</span><br><span class="line">    String dname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1、级联方式"><a href="#1、级联方式" class="headerlink" title="1、级联方式"></a>1、级联方式</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"empMap"</span> <span class="attr">type</span>=<span class="string">"emp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"eid"</span> <span class="attr">property</span>=<span class="string">"eid"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"ename"</span> <span class="attr">property</span>=<span class="string">"ename"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"age"</span> <span class="attr">property</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sex"</span> <span class="attr">property</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"did"</span> <span class="attr">property</span>=<span class="string">"dept.did"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dname"</span> <span class="attr">property</span>=<span class="string">"dept.dname"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getAllEmp"</span> <span class="attr">resultMap</span>=<span class="string">"empMap"</span>&gt;</span></span><br><span class="line">    select * from emp e left join dept d on e.did = d.did</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2、association"><a href="#2、association" class="headerlink" title="2、association"></a>2、association</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"empMap"</span> <span class="attr">type</span>=<span class="string">"emp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"eid"</span> <span class="attr">property</span>=<span class="string">"eid"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"ename"</span> <span class="attr">property</span>=<span class="string">"ename"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"age"</span> <span class="attr">property</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sex"</span> <span class="attr">property</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"dept"</span> <span class="attr">javaType</span>=<span class="string">"Dept"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"did"</span> <span class="attr">property</span>=<span class="string">"did"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dname"</span> <span class="attr">property</span>=<span class="string">"dname"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getAllEmp"</span> <span class="attr">resultMap</span>=<span class="string">"empMap"</span>&gt;</span></span><br><span class="line">    select * from emp e left join dept d on e.did = d.did</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3、引用其他的select语句的分步查询"><a href="#3、引用其他的select语句的分步查询" class="headerlink" title="3、引用其他的select语句的分步查询"></a>3、引用其他的select语句的分步查询</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    resultMap:引用其他的select语句的分布查询--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"empMapStep"</span> <span class="attr">type</span>=<span class="string">"Emp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"eid"</span> <span class="attr">property</span>=<span class="string">"eid"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"ename"</span> <span class="attr">property</span>=<span class="string">"ename"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"age"</span> <span class="attr">property</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sex"</span> <span class="attr">property</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        下面的column属性设置</span></span><br><span class="line"><span class="comment">     getEmpStep查出来的did给getDeptByDid当做参数查出dept</span></span><br><span class="line"><span class="comment">     这里的column就相当于getDeptByDid的parameter属性</span></span><br><span class="line"><span class="comment">     传进去的是getEmpStep查出来的did</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"dept"</span> <span class="attr">select</span>=<span class="string">"com.mybatis.mapper.DeptMapper.getDeptByDid"</span> <span class="attr">column</span>=<span class="string">"did"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpStep"</span> <span class="attr">resultMap</span>=<span class="string">"empMapStep"</span>&gt;</span></span><br><span class="line">    select eid,ename,age,sex,did from emp where eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>com.mybatis.mapper.DeptMapper.getDeptByDid：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getDeptByDid"</span> <span class="attr">resultType</span>=<span class="string">"dept"</span>&gt;</span></span><br><span class="line">    select did,dname from dept where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="四、一对多多表查询"><a href="#四、一对多多表查询" class="headerlink" title="四、一对多多表查询"></a>四、一对多多表查询</h1><p>Emp.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">    Integer eid;</span><br><span class="line">    String ename;</span><br><span class="line">    Integer age;</span><br><span class="line">    String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dept.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dept</span> </span>&#123;</span><br><span class="line">    Integer did;</span><br><span class="line">    String dname;</span><br><span class="line">    List&lt;Emp&gt; emps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1、Collection"><a href="#1、Collection" class="headerlink" title="1、Collection"></a>1、Collection</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"deptMap"</span> <span class="attr">type</span>=<span class="string">"Dept"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"did"</span> <span class="attr">property</span>=<span class="string">"did"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dname"</span> <span class="attr">property</span>=<span class="string">"dname"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    collection:处理一对多的类型</span></span><br><span class="line"><span class="comment">        ofType:list中放的类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"emps"</span> <span class="attr">ofType</span>=<span class="string">"Emp"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"eid"</span> <span class="attr">property</span>=<span class="string">"eid"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"ename"</span> <span class="attr">property</span>=<span class="string">"ename"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"age"</span> <span class="attr">property</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sex"</span> <span class="attr">property</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getDeptEmpsByDid"</span> <span class="attr">resultMap</span>=<span class="string">"deptMap"</span>&gt;</span></span><br><span class="line">    select d.did,d.dname,e.eid,e.ename,e.age,e.sex from dept d</span><br><span class="line">    left join emp e on d.did=e.did where d.did=#&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2、引用其他的select语句的分步查询"><a href="#2、引用其他的select语句的分步查询" class="headerlink" title="2、引用其他的select语句的分步查询"></a>2、引用其他的select语句的分步查询</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"deptMapStep"</span> <span class="attr">type</span>=<span class="string">"Dept"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"did"</span> <span class="attr">property</span>=<span class="string">"did"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dname"</span> <span class="attr">property</span>=<span class="string">"dname"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        column中的did表示getEmpListByDid要通过getOnlyDeptByDid查出的did进行查询--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        这里的column底层是map--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        fetchType设置局部懒加载属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"emps"</span> <span class="attr">select</span>=<span class="string">"com.mybatis.mapper.EmpDeptMapper.getEmpListByDid"</span> <span class="attr">column</span>=<span class="string">"&#123;myTestDid=did&#125;"</span> <span class="attr">fetchType</span>=<span class="string">"eager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getOnlyDeptByDid"</span> <span class="attr">resultMap</span>=<span class="string">"deptMapStep"</span>&gt;</span></span><br><span class="line">    select did,dname from dept where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpListByDid"</span> <span class="attr">resultType</span>=<span class="string">"Emp"</span>&gt;</span></span><br><span class="line">    select eid,ename,age,sex from emp where did = #&#123;myTestDid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="五、动态Sql"><a href="#五、动态Sql" class="headerlink" title="五、动态Sql"></a>五、动态Sql</h1><h2 id="1、trim（set，where）"><a href="#1、trim（set，where）" class="headerlink" title="1、trim（set，where）"></a>1、trim（set，where）</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpListByMoreCondition"</span> <span class="attr">resultType</span>=<span class="string">"Emp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"empColumns"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--where标签能去掉开头多余的and,但去除不了末尾多余的and</span></span><br><span class="line"><span class="comment">        trim截取并拼接</span></span><br><span class="line"><span class="comment">        prefix:在操作的sql语句前加入某些内容</span></span><br><span class="line"><span class="comment">        prefixOverrides:把操作的sql语句前的某些内容去掉 |:表示既要处理and,又要处理or</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"where"</span> <span class="attr">prefixOverrides</span>=<span class="string">"and|or"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"eid!=null"</span>&gt;</span>and eid=#&#123;eid&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ename!=null and ename!=''"</span>&gt;</span>and ename=#&#123;ename&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"age!=null"</span>&gt;</span>and age=#&#123;age&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--等于的时候只能是数值--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--       &lt;if test="sex==1 or sex==0"&gt;and sex=#&#123;sex&#125;&lt;/if&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2、choose"><a href="#2、choose" class="headerlink" title="2、choose"></a>2、choose</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpListByChoose"</span> <span class="attr">resultType</span>=<span class="string">"Emp"</span>&gt;</span></span><br><span class="line">    select eid,ename,age,sex from emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--when就是if或else if,otherwise就是else--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"eid!=null"</span>&gt;</span></span><br><span class="line">                eid=#&#123;eid&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"ename!=null and ename!=''"</span>&gt;</span></span><br><span class="line">                ename=#&#123;ename&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"age!=null"</span>&gt;</span></span><br><span class="line">                age=#&#123;age&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                sex=#&#123;sex&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3、foreach"><a href="#3、foreach" class="headerlink" title="3、foreach"></a>3、foreach</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        foreach对一个数组或集合进行遍历</span></span><br><span class="line"><span class="comment">        collection:指定要遍历的集合或数组</span></span><br><span class="line"><span class="comment">        item:设置别名</span></span><br><span class="line"><span class="comment">        close:设置循环体的结束内容</span></span><br><span class="line"><span class="comment">        open:设置循环体的开始内容</span></span><br><span class="line"><span class="comment">        separator:设置每一次循环之间的分隔符</span></span><br><span class="line"><span class="comment">        index:若遍历的是list,index代表下标;若遍历的是map,index代表键</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第二种方式    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteMoreByList"</span>&gt;</span></span><br><span class="line">    delete from emp where eid in</span><br><span class="line">    <span class="comment">&lt;!--默认:List以list为键，Array以array为键--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"eid"</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</span></span><br><span class="line">        #&#123;eid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertMoreByArray"</span>&gt;</span></span><br><span class="line">    insert into emp values</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"array"</span> <span class="attr">item</span>=<span class="string">"emp"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">        (null,#&#123;emp.ename&#125;,#&#123;emp.age&#125;,#&#123;emp.sex&#125;,1)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="4、sql，include"><a href="#4、sql，include" class="headerlink" title="4、sql，include"></a>4、sql，include</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    设置一段sql片段，可以被当前映射文件所有的sql语句所访问--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"empColumns"</span>&gt;</span></span><br><span class="line">    select eid,ename,age,sex,did from emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpListByMoreCondition"</span> <span class="attr">resultType</span>=<span class="string">"Emp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"empColumns"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--where标签能去掉开头多余的and,但去除不了末尾多余的and</span></span><br><span class="line"><span class="comment">            trim截取并拼接</span></span><br><span class="line"><span class="comment">            prefix:在操作的sql语句前加入某些内容</span></span><br><span class="line"><span class="comment">            prefixOverrides:把操作的sql语句前的某些内容去掉 |:表示既要处理and,又要处理or</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"where"</span> <span class="attr">prefixOverrides</span>=<span class="string">"and|or"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"eid!=null"</span>&gt;</span>and eid=#&#123;eid&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ename!=null and ename!=''"</span>&gt;</span>and ename=#&#123;ename&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"age!=null"</span>&gt;</span>and age=#&#123;age&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--等于的时候只能是数值--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--       &lt;if test="sex==1 or sex==0"&gt;and sex=#&#123;sex&#125;&lt;/if&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>详情：参考<a href="https://mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/index.html</a></p>
<h1 id="六、类型转换器"><a href="#六、类型转换器" class="headerlink" title="六、类型转换器"></a>六、类型转换器</h1><p>参考<a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers</a></p>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot源码学习</title>
    <url>/alex-next/2021/09/03/javaEE/springboot%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h1 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="为何springboot的jar包能直接运行"><a href="#为何springboot的jar包能直接运行" class="headerlink" title="为何springboot的jar包能直接运行"></a>为何springboot的jar包能直接运行</h3><h3 id="true依赖不会传播给子项目"><a href="#true依赖不会传播给子项目" class="headerlink" title="true依赖不会传播给子项目"></a><optional>true<optional>依赖不会传播给子项目</optional></optional></h3><h3 id="外置tomcat"><a href="#外置tomcat" class="headerlink" title="外置tomcat"></a>外置tomcat</h3><ul>
<li>SPI</li>
</ul>
<h2 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h2><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><ul>
<li><p>@AutoConfigurationPackage</p>
<ul>
<li>注册了一个保存当前配置类所在包的一个Bean</li>
</ul>
</li>
<li><p>使用了@Import导入了AutoConfigurationImportSelector</p>
<ul>
<li><p>AutoConfigurationGroup#process</p>
<ul>
<li><p>getAutoConfigurationEntry</p>
<ul>
<li><p>getCandidateConfigurations</p>
<ul>
<li>找出候选的自动配置类</li>
<li><p>SpringFactoriesLoader.loadFactoryNames</p>
<ul>
<li>会去所有jar包中从META-INF/spring.factories中读取到自动配置类</li>
</ul>
</li>
</ul>
</li>
<li><p>removeDuplicates</p>
<ul>
<li>去重</li>
</ul>
</li>
<li><p>getConfigurationClassFilter().filter</p>
<ul>
<li>过滤出当前项目需要的自动配置类</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>以HttpEncodingAutoConfiguration为例参考pdf文件</p>
<ul>
<li>application.properties 声明spring.application.name</li>
<li>通过@ConfigurationProperties注解绑定到对应的XxxxProperties配 置实体类上</li>
<li>然后再通过@EnableConfigurationProperties注解导入到Spring容器中</li>
</ul>
</li>
</ul>
<h3 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h3><h3 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h3><ul>
<li><p>@Import可以批量注入，可以导入不在扫描范围里的Bean，所以集成第三方框架一般都用@Import</p>
<ul>
<li><p>ImportSelector无法改变Bean的使用顺序，如Springboot中想要自定义某个默认的Bean(SqlSessionFactory)，就不能实现</p>
<ul>
<li>@ConditionalOnBean(SqlSessionFactory.class)存在了SqlSessionFactory，才注册当前bean</li>
<li><p>可以使用DeferredImportSelector，最后导入，延时加载+分组排序</p>
<ul>
<li>DeferredImportSelector最后导入的都是默认配置，但不会覆盖原有的，因为会结合@Conditional判断是否导入</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><h3 id="课上图"><a href="#课上图" class="headerlink" title="课上图"></a>课上图</h3><h2 id="idea启动原理"><a href="#idea启动原理" class="headerlink" title="idea启动原理"></a>idea启动原理</h2><h3 id="SpringApplication-run"><a href="#SpringApplication-run" class="headerlink" title="SpringApplication.run"></a>SpringApplication.run</h3><ul>
<li><p>new SpringApplication(primarySources)</p>
<ul>
<li>初始化</li>
<li><p>this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</p>
<ul>
<li>把启动类存入primarySources</li>
</ul>
</li>
<li><p>WebApplicationType.deduceFromClasspath();</p>
<ul>
<li>推断当前容器类型</li>
</ul>
</li>
<li><p>setInitializers(getSpringFactoriesInstances)</p>
<ul>
<li>从spring.factories读取初始化器</li>
</ul>
</li>
<li><p>setListeners(getSpringFactoriesInstances)</p>
<ul>
<li>从spring.factories读取监听器</li>
</ul>
</li>
</ul>
</li>
<li><p>run</p>
<ul>
<li><p>listeners.starting();</p>
<ul>
<li>发布ApplicationStartingEvent</li>
</ul>
</li>
<li><p>prepareEnvironment</p>
<ul>
<li><p>读取环境配置信息</p>
</li>
<li><p>configureEnvironment</p>
<ul>
<li><p>configurePropertySources</p>
<ul>
<li>读取SpringApplication.defaultProperties 和命令行参数</li>
</ul>
</li>
<li><p>configureProfiles</p>
<ul>
<li>根据环境变量中spring.profiles.active 和 SpringApplication.additionalProfiles 激活当前profile</li>
</ul>
</li>
</ul>
</li>
<li><p>ConfigurationPropertySources.attach(environment);</p>
<ul>
<li>将环境更新为@ConfigurationProperties的数据</li>
</ul>
</li>
<li><p>listeners.environmentPrepared(environment)</p>
<ul>
<li><p>发布ApplicationEnvironmentPreparedEvent事件，之后ConfigFileApplicationListener会读取配置文件(application.yml)</p>
<ul>
<li><ul>

* <li>file:./config/</li>

* <li>file:./config/{@literal *}/</li>

* <li>file:./</li>

* <li>classpath:config/</li>

* <li>classpath:</li>

* </ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>printBanner(environment);</p>
<ul>
<li>打印banner</li>
</ul>
</li>
<li><p>createApplicationContext</p>
<ul>
<li>实例化上下文对象</li>
</ul>
</li>
<li><p>prepareContext</p>
<ul>
<li><p>context.setEnvironment</p>
<ul>
<li>将环境信息存到上下文(Context)中</li>
</ul>
</li>
<li><p>logStartupInfo</p>
<ul>
<li>打印启动信息</li>
</ul>
</li>
<li><p>logStartupProfileInfo</p>
<ul>
<li>打印激活的profile信息</li>
</ul>
</li>
<li><p>load</p>
<ul>
<li>读取启动类为BeanDefinition</li>
</ul>
</li>
</ul>
</li>
<li><p>refreshContext</p>
<ul>
<li>调用spring的refresh方法，加载IOC容器</li>
<li><p>ServletWebServerApplicationContext#onrefresh</p>
<ul>
<li><p>createWebServer</p>
<ul>
<li>servletContext = getServletContext()</li>
<li><p>getWebServerFactory</p>
<ul>
<li>从IOC容器中获取ServletWebServerFactory</li>
</ul>
</li>
<li><p>getSelfInitializer()</p>
<ul>
<li>获取ServletContextInitializer的onStartup方法</li>
<li><p>return this::selfInitialize;</p>
<ul>
<li>servletContext.addServlet(name, this.servlet);</li>
<li><p>循环beans.onStartup(servletContext)</p>
<ul>
<li><p>RegistrationBean#onStartup</p>
<ul>
<li><p>register</p>
<ul>
<li><p>ServletRegistrationBean#addRegistration</p>
<ul>
<li>往servletContext添加了DispatcherServlet</li>
<li>servletContext.addServlet(name, this.servlet);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>getWebServer(getSelfInitializer())</p>
<ul>
<li>new Tomcat()</li>
<li><p>prepareContext</p>
<ul>
<li><p>configureContext</p>
<ul>
<li><p>new TomcatStarter(initializers)</p>
<ul>
<li>后续会调用TomcatStarter#onStartup，执行ServletContainerInitializer</li>
</ul>
</li>
<li><p>TomcatEmbeddedContext.addServletContainerInitializer</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>getTomcatWebServer</p>
<ul>
<li><p>this.tomcat.start();</p>
<ul>
<li>会去调用TomcatStarter的onStartup方法，从而循环回调Initializer的onStartup方法</li>
</ul>
</li>
<li><p>startDaemonAwaitThread</p>
<ul>
<li>没有访问就挂起线程，否则程序一下就会结束</li>
<li>this.tomcat.getServer().await()</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>afterRefresh</p>
<ul>
<li>待扩展</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="原理图-1"><a href="#原理图-1" class="headerlink" title="原理图"></a>原理图</h3><h2 id="外部tomcat启动springboot原理-SPI"><a href="#外部tomcat启动springboot原理-SPI" class="headerlink" title="外部tomcat启动springboot原理(SPI)"></a>外部tomcat启动springboot原理(SPI)</h2><h3 id="当servlet容器启动时候，就会去META-INF-services-文件夹中找到javax-servlet-ServletContainerInitializer"><a href="#当servlet容器启动时候，就会去META-INF-services-文件夹中找到javax-servlet-ServletContainerInitializer" class="headerlink" title="当servlet容器启动时候，就会去META-INF/services 文件夹中找到javax.servlet.ServletContainerInitializer"></a>当servlet容器启动时候，就会去META-INF/services 文件夹中找到javax.servlet.ServletContainerInitializer</h3><ul>
<li>ServletContainerInitializer类继承图(和ServletContextInitializer作用类似)</li>
</ul>
<h3 id="HandlesTypes-WebApplicationInitializer-class"><a href="#HandlesTypes-WebApplicationInitializer-class" class="headerlink" title="@HandlesTypes(WebApplicationInitializer.class)"></a>@HandlesTypes(WebApplicationInitializer.class)</h3><ul>
<li><p>会去找WebApplicationInitializer，即SpringBootServletInitializer，我们自己会去实现这么一个类</p>
<ul>
<li>SpringBootServletInitializer继承图</li>
</ul>
</li>
</ul>
<h3 id="SpringServletContainerInitializer-onStartup"><a href="#SpringServletContainerInitializer-onStartup" class="headerlink" title="SpringServletContainerInitializer#onStartup"></a>SpringServletContainerInitializer#onStartup</h3><ul>
<li>找到WebApplicationInitializer后传入onStartup</li>
<li><p>ReflectionUtils.accessibleConstructor(waiClass).newInstance()</p>
<ul>
<li>循环实例化WebApplicationInitializer</li>
</ul>
</li>
<li><p>执行自己的SpringBootServletInitializer#onStartup</p>
<ul>
<li><p>createRootApplicationContext</p>
<ul>
<li><p>configure(builder);</p>
<ul>
<li>传入自己的SpringbootApplication启动类</li>
<li>builder.sources(Application.class);</li>
</ul>
</li>
<li><p>builder.build();</p>
<ul>
<li>构建一个SpringApplication</li>
</ul>
</li>
<li><p>run(application);</p>
<ul>
<li>启动</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>AbstractDispatcherServletInitializer#onStartup</p>
<ul>
<li><p>servletContext.addServlet(servletName, dispatcherServlet)</p>
<ul>
<li>添加了一个DispatcherServlet</li>
</ul>
</li>
</ul>
</li>
<li><p>AbstractContextLoaderInitializer</p>
</li>
</ul>
<h2 id="jar包启动springboot原理-内置了tomcat"><a href="#jar包启动springboot原理-内置了tomcat" class="headerlink" title="jar包启动springboot原理(内置了tomcat)"></a>jar包启动springboot原理(内置了tomcat)</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li>1.加载META/MANIFEST.MF</li>
<li>2.运行JarLauncher(Main-Class: org.springframework.boot.loader.JarLauncher)</li>
<li><p>3.JarLauncher加载BOOT-INF/classes和BOOT-INF/lib</p>
<ul>
<li>Fat jar的启动Main函数是JarLauncher</li>
</ul>
</li>
<li><p>JarLauncher创建一个LaunchedURLClassLoader来加载/lib下面的jar，并以一 个新线程启动springboot应用类的Main函数。</p>
</li>
<li>4.找到Start-Class，即自己定义的SpringBoot启动类</li>
</ul>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p>Java没有提供任何标准的方式来加载嵌套的jar文件</p>
<ul>
<li>JarLauncher通过加载BOOT-INF/classes目录及BOOT-INF/lib目录下jar文件，实现了fat jar的启动。 </li>
<li>SpringBoot通过扩展JarFile、JarURLConnection及URLStreamHandler，实现了jar in jar中资源的加载。 </li>
<li>SpringBoot通过扩展URLClassLoader–LauncherURLClassLoader，实现了jar in jar中class文件的加载。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>halo博客</title>
    <url>/alex-next/2022/11/18/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/docker%E9%83%A8%E7%BD%B2halo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="拉取halo"><a href="#拉取halo" class="headerlink" title="拉取halo"></a>拉取halo</h2><p>docker pull halohub/halo:1.5.2</p>
<p>docker pull halohub/halo</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>mkdir ~/.halo2</p>
<p>vim application.yaml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8090</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Response data gzip.</span></span><br><span class="line"><span class="attr">  compression:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># H2 database configuration.</span></span><br><span class="line">    <span class="comment">#driver-class-name: org.h2.Driver</span></span><br><span class="line">    <span class="comment">#url: jdbc:h2:file:~/.halo/db/halo</span></span><br><span class="line">    <span class="comment">#username: admin</span></span><br><span class="line">    <span class="comment">#password: 123456</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># MySQL database configuration.</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://127.0.0.1:3306/blog?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># H2 database console configuration.</span></span><br><span class="line">  <span class="comment">#h2:</span></span><br><span class="line">    <span class="comment">#console:</span></span><br><span class="line">    <span class="comment">#  settings:</span></span><br><span class="line">     <span class="comment">#   web-allow-others: false</span></span><br><span class="line">    <span class="comment">#  path: /h2-console</span></span><br><span class="line">    <span class="comment">#  enabled: false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">halo:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Your admin client path is https://your-domain/&#123;admin-path&#125;</span></span><br><span class="line"><span class="attr">  admin-path:</span> <span class="string">admin</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># memory or level</span></span><br><span class="line"><span class="attr">  cache:</span> <span class="string">memory</span></span><br></pre></td></tr></table></figure>
<p>要事先安装好mysql</p>
<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>docker pull mysql:5.6</p>
<p>启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \   </span><br><span class="line">-d mysql:5.6</span><br><span class="line"></span><br><span class="line">密码用户名都是root</span><br></pre></td></tr></table></figure>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  -it -d \</span><br><span class="line">  --name halo \</span><br><span class="line">  -p 8090:8090 \</span><br><span class="line">  -v ~/.halo2:/root/.halo2 \</span><br><span class="line">  halohub/halo:latest \</span><br><span class="line">  --halo.external-url=http://localhost:8090/ \</span><br><span class="line">  --halo.security.initializer.superadminuser=admin \</span><br><span class="line">  --halo.security.initializer.superadminpassword=admin</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_33411202/article/details/124670673" target="_blank" rel="noopener">docker安装halo</a></p>
<p><a href="https://blog.csdn.net/qq_25482375/article/details/126250746" target="_blank" rel="noopener">docker安装mysql</a></p>
<p><a href="https://docs.halo.run/getting-started/install/docker" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      <categories>
        <category>工具配置</category>
      </categories>
  </entry>
  <entry>
    <title>hexo常用操作</title>
    <url>/alex-next/2021/04/18/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/hexo%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="hexo-操作"><a href="#hexo-操作" class="headerlink" title="hexo 操作"></a>hexo 操作</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo <span class="built_in">help</span>  <span class="comment"># 查看帮助</span></span><br><span class="line">hexo version  <span class="comment">#查看Hexo的版本</span></span><br><span class="line">hexo algolia  <span class="comment"># 更新search库</span></span><br><span class="line">hexo new <span class="string">"postName"</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo new post <span class="string">"title"</span>  <span class="comment"># 生成新文章：\source\_posts\title.md，可省略post</span></span><br><span class="line">hexo new page <span class="string">"pageName"</span> <span class="comment">#新建页面</span></span><br><span class="line">hexo clean <span class="comment">#清除部署緩存</span></span><br><span class="line">hexo n == hexo new <span class="comment">#新建文章</span></span><br><span class="line">hexo g == hexo generate <span class="comment">#生成静态页面至public目录</span></span><br><span class="line">hexo s == hexo server <span class="comment">#本地访问,开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class="line">hexo d == hexo deploy <span class="comment">#将.deploy目录部署到GitHub</span></span><br><span class="line">hexo d -g <span class="comment">#生成加部署</span></span><br><span class="line">hexo s -g <span class="comment">#生成加预览</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具配置</category>
      </categories>
  </entry>
  <entry>
    <title>部署springboot项目到服务器上</title>
    <url>/alex-next/2021/05/01/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/</url>
    <content><![CDATA[<h2 id="一、免费领取阿里云ECS服务器"><a href="#一、免费领取阿里云ECS服务器" class="headerlink" title="一、免费领取阿里云ECS服务器"></a>一、免费领取阿里云ECS服务器</h2><p>先进入阿里云官网</p>
<p><img alt="1" data-src="https://gitee.com/alexander1/pic/raw/master/搭建服务器/20210501192219.png"></p>
<p>然后看上面，开发者-&gt;成长计划</p>
<p><img alt="img" data-src="https://gitee.com/alexander1/pic/raw/master/搭建服务器/20210501192440.png"></p>
<p>进去后，点学生专享-&gt;免费领取</p>
<p><img alt="1" data-src="https://gitee.com/alexander1/pic/raw/master/搭建服务器/20210501192745.png"></p>
<p>然后点立即领取，要先做题，这些题都很简单。做完之后点领取(0元购买)，配置自己选择就行(我选的是ubuntu20.04)。</p>
<p>然后可以通过以下方式进入管理ECS面板。</p>
<p>拖到最后点击云服务器ECS</p>
<p><img alt="2" data-src="https://gitee.com/alexander1/pic/raw/master/搭建服务器/20210501193248.png"></p>
<p>点击管理控制台即可进入</p>
<p><img alt="3" data-src="https://gitee.com/alexander1/pic/raw/master/搭建服务器/20210501193806.png"></p>
<p>首次登录，需要先重置密码，点击管理-&gt;重置实例密码</p>
<p><img alt="4" data-src="https://gitee.com/alexander1/pic/raw/master/搭建服务器/20210501194007.png"></p>
<p>重置之后，便可以尝试本地连接ECS，使用xshell6连接。下载地址:<a href="https://xshell.en.softonic.com/" target="_blank" rel="noopener">https://xshell.en.softonic.com/</a></p>
<p><img alt="5" data-src="https://gitee.com/alexander1/pic/raw/master/搭建服务器/20210501194317.png"></p>
<p>然后输入用户名和刚才改过的密码就行。</p>
<p><img alt="6" data-src="https://gitee.com/alexander1/pic/raw/master/搭建服务器/20210501194516.png"></p>
<p>这样就算成功了!!!</p>
<h2 id="二、配置jdk"><a href="#二、配置jdk" class="headerlink" title="二、配置jdk"></a>二、配置jdk</h2><p>下载地址：<a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-downloads.html</a></p>
<p>我下载的是jdk1.8，下载前需要注册一个oracle账号</p>
<p><img alt="7" data-src="https://gitee.com/alexander1/pic/raw/master/搭建服务器/20210501195959.png"></p>
<p>选择linux版本，</p>
<p><img alt="8" data-src="https://gitee.com/alexander1/pic/raw/master/搭建服务器/20210501200754.png"></p>
<p>下载好后使用xftp6传到服务器上。</p>
<p>进入xshell ，先解压压缩包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u11-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
<p>更改etc/profile或~/.bashrc    (G直接到最后一行,gg到第一行)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/profile或</span><br><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>添加java的配置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/jdk1.8.0_291</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre</span><br></pre></td></tr></table></figure>
<p>使环境生效</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile或</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<h2 id="三、配置tomcat-可选"><a href="#三、配置tomcat-可选" class="headerlink" title="三、配置tomcat(可选)"></a>三、配置tomcat(可选)</h2><p>若部署jar包可以忽略这一步。</p>
<p>部署war包需要配置tomcat。</p>
<p>下载Tomcat，下载地址：<a href="https://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-90.cgi</a></p>
<p><img alt="9" data-src="https://gitee.com/alexander1/pic/raw/master/搭建服务器/20210501202527.png"></p>
<p>选择core下的linux版本</p>
<p>使用xftp传到服务器上</p>
<p>先将压缩包解压</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo tar -zxvf apache-tomcat-8.5.31.tar.gz</span><br></pre></td></tr></table></figure>
<p>开权限（主要是为了之后执行startup.sh开启执行权限）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo chmod 755 -R apache-tomcat-8.5.31</span><br></pre></td></tr></table></figure>
<p>进入startup.sh，</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim startup.sh</span><br></pre></td></tr></table></figure>
<p>配置环境</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#set java environment</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/jdk1.8.0_291</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:%&#123;JAVA_HOME&#125;/lib:%&#123;JRE_HOME&#125;/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#tomcat</span></span><br><span class="line"><span class="built_in">export</span> TOMCAT_HOME=/usr/apache-tomcat-9.0.45</span><br></pre></td></tr></table></figure>
<p>启动服务</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo ./startup.sh</span><br></pre></td></tr></table></figure>
<p>测试：在xshell 输入 </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl localhost:8080</span><br></pre></td></tr></table></figure>
<p>或在浏览器中输入  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">公网ip:8080</span><br></pre></td></tr></table></figure>
<h2 id="四、配置mysql数据库-可选"><a href="#四、配置mysql数据库-可选" class="headerlink" title="四、配置mysql数据库(可选)"></a>四、配置mysql数据库(可选)</h2><p>① 可以考虑使用阿里云的rds云数据库，就不用在本地装MySQL（略）</p>
<p>② 在本地装mysql (8.0.23)</p>
<p>mysql在ubuntu的apt软件包存储库中，先更新服务器的包索引再安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure>
<p>初始化配置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo mysql_secure_installation</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1</span><br><span class="line">VALIDATE PASSWORD PLUGIN can be used to test passwords...</span><br><span class="line">Press y|Y for Yes, any other key for No: N (我的选项)</span><br><span class="line"></span><br><span class="line">#2</span><br><span class="line">Please set the password for root here...</span><br><span class="line">New password: (输入密码)</span><br><span class="line">Re-enter new password: (重复输入)</span><br><span class="line"></span><br><span class="line">#3</span><br><span class="line">By default, a MySQL installation has an anonymous user,</span><br><span class="line">allowing anyone to log into MySQL without having to have</span><br><span class="line">a user account created for them...</span><br><span class="line">Remove anonymous users? (Press y|Y for Yes, any other key for No) : N (我的选项)</span><br><span class="line"></span><br><span class="line">#4</span><br><span class="line">Normally, root should only be allowed to connect from</span><br><span class="line">&apos;localhost&apos;. This ensures that someone cannot guess at</span><br><span class="line">the root password from the network...</span><br><span class="line">Disallow root login remotely? (Press y|Y for Yes, any other key for No) : Y (我的选项)</span><br><span class="line"></span><br><span class="line">#5</span><br><span class="line">By default, MySQL comes with a database named &apos;test&apos; that</span><br><span class="line">anyone can access...</span><br><span class="line">Remove test database and access to it? (Press y|Y for Yes, any other key for No) : N (我的选项)</span><br><span class="line"></span><br><span class="line">#6</span><br><span class="line">Reloading the privilege tables will ensure that all changes</span><br><span class="line">made so far will take effect immediately.</span><br><span class="line">Reload privilege tables now? (Press y|Y for Yes, any other key for No) : Y (我的选项)</span><br></pre></td></tr></table></figure>
<p>检查mysql 服务状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl status mysql.service</span><br></pre></td></tr></table></figure>
<p>之后，便可以使用根用户登陆了：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo mysql -u root -p</span><br></pre></td></tr></table></figure>
<p><img alt="2" data-src="https://gitee.com/alexander1/pic/raw/master/搭建服务器/20210501204830.png"></p>
<p>由于ubuntu默认只允许本地访问，可以进行如下配置：</p>
<p>可以先把绑定端口关掉</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line">注释掉<span class="built_in">bind</span>-address = 127.0.0.1， 即<span class="comment">#bind-address = 127.0.0.1</span></span><br><span class="line">重启服务</span><br><span class="line">sudo /etc/init.d/mysql restart</span><br><span class="line">查看端口状态</span><br><span class="line">netstat -apn |grep 3306</span><br><span class="line">此时应为：tcp6 0 0 :::3306 :::* LISTEN -</span><br></pre></td></tr></table></figure>
<p>修改用户表</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">当远程访问出现not allowed的提示消息时，说明远程用户无权限，则需要修改用户表：</span><br><span class="line">1. 登录数据库</span><br><span class="line">mysql -u root -p</span><br><span class="line">2. 选择数据库</span><br><span class="line">use mysql;</span><br><span class="line">3. 修改root用户可以在所有机器登录（root只是举例，%表示所有机器）</span><br><span class="line">update user <span class="built_in">set</span> host = <span class="string">'%'</span> <span class="built_in">where</span> user = <span class="string">'root'</span>;</span><br><span class="line">4. 重启服务</span><br><span class="line">sudo /etc/init.d/mysql restart</span><br></pre></td></tr></table></figure>
<p>若navicat连接mysql8+以上的版本，会报2059的错。原因为安装时选择了强加密规则caching_sha2_password，与之前的mysql5.7的mysql_native_password规则不同，navicate驱动目前不支持新加密规则。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">select user,plugin from user <span class="built_in">where</span> user=’root’;<span class="comment">#查看加密方式</span></span><br><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'123456'</span> PASSWORD EXPIRE NEVER;<span class="comment">#修改加密规则</span></span><br><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'%'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'123456'</span>;<span class="comment">#可以修改密码</span></span><br><span class="line">FLUSH PRIVILEGES;<span class="comment">#刷新</span></span><br></pre></td></tr></table></figure>
<h2 id="五、部署jar或war包"><a href="#五、部署jar或war包" class="headerlink" title="五、部署jar或war包"></a>五、部署jar或war包</h2><p>区别：</p>
<p>jar包的方式：不需要外置的tomcat，可以直接运行，如果关掉shell窗口服务就会停止，需要另外再配置</p>
<p>war包的方式：需要排除springboot自带的tomcat，关掉shell窗口服务不会停止。</p>
<h3 id="1-jar包"><a href="#1-jar包" class="headerlink" title="1.jar包"></a>1.jar包</h3><p><img alt="3" data-src="https://gitee.com/alexander1/pic/raw/master/搭建服务器/20210501212806.png"></p>
<p>在pom.xml中加入打包工具</p>
<p><img alt="4" data-src="https://gitee.com/alexander1/pic/raw/master/搭建服务器/20210501212851.png"></p>
<p>点击右上角边上maven，先clean，再package，生成出来的jar包在target文件夹下</p>
<p>然后丢到服务器上执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -jar covermanager-0.0.2-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<p>便可以运行了</p>
<h3 id="2-war包"><a href="#2-war包" class="headerlink" title="2.war包"></a>2.war包</h3><p>先让启动类继承<code>SpringBootServletInitializer</code>，并实现<code>configure</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovermanagerApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(CovermanagerApplication.class, args);</span><br><span class="line">		System.out.println(<span class="string">"******************************启动成功********************************"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder builder)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> builder.sources(CovermanagerApplication.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在依赖中排除springboot自带的tomcat</p>
<p><img alt="5" data-src="https://gitee.com/alexander1/pic/raw/master/搭建服务器/20210501213351.png"></p>
<p>然后如jar包一样，clean之后在package，生成的war包在target文件夹下</p>
<p>将war包解压缩，并将文件名改为ROOT</p>
<p><img alt="6" data-src="https://gitee.com/alexander1/pic/raw/master/搭建服务器/20210501213540.png"></p>
<p>进入服务器的tomcat的webapps中，删除原有的ROOT/</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/apache-tomcat-9.0.45/webapps/</span><br><span class="line">rm -r ROOT/</span><br></pre></td></tr></table></figure>
<p>将解压后的ROOT包利用xftp传到服务器的<code>/usr/apache-tomcat-9.0.45/webapps/</code>目录下</p>
<p>然后进入<code>/usr/apache-tomcat-9.0.45/bin/</code>启动tomcat服务器即可</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./startup.sh</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具配置</category>
      </categories>
  </entry>
  <entry>
    <title>JUC面试题</title>
    <url>/alex-next/2022/11/16/%E9%9D%A2%E8%AF%95%E9%A2%98/JUC%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="并发基础-理论"><a href="#并发基础-理论" class="headerlink" title="并发基础/理论"></a>并发基础/理论</h3><h4 id="1-并发编程的优缺点"><a href="#1-并发编程的优缺点" class="headerlink" title="1.并发编程的优缺点"></a>1.并发编程的优缺点</h4><p>优点<br>    充分利用多核CPU的计算能力<br>    方便进行业务拆分，提升系统并发能力和性能<br>缺点<br>    内存泄漏<br>    上下文切换<br>    线程安全<br>    死锁</p>
<h4 id="2-并发编程三要素是什么"><a href="#2-并发编程三要素是什么" class="headerlink" title="2.并发编程三要素是什么"></a>2.并发编程三要素是什么</h4><p>原子性<br>    线程切换带来的原子性问题<br>可见性<br>    线程缓存导致的可见性问题<br>有序性<br>    编译优化带来的有序性问题    </p>
<h4 id="3-并行和并发有什么区别"><a href="#3-并行和并发有什么区别" class="headerlink" title="3.并行和并发有什么区别"></a>3.并行和并发有什么区别</h4><p>并发<br>    多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行<br>并行<br>    单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”</p>
<h4 id="4-进程与线程的区别"><a href="#4-进程与线程的区别" class="headerlink" title="4.进程与线程的区别"></a>4.进程与线程的区别</h4><p>进程<br>    操作系统资源分配的基本单位<br>    有独立的代码和数据空间（程序上下文）<br>        程序之间的切换会有较大的开销<br>    每个独立的进程有程序运行的入口、顺序执行序列和程序出口<br>线程<br>    处理器任务调度和执行的基本单位<br>    同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC）<br>        线程之间切换的开销小<br>    但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行<br>同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的<br>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉</p>
<h5 id="4-1什么是上下文切换"><a href="#4-1什么是上下文切换" class="headerlink" title="4.1什么是上下文切换"></a>4.1什么是上下文切换</h5><p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换</p>
<h4 id="5-守护线程和用户线程有什么区别"><a href="#5-守护线程和用户线程有什么区别" class="headerlink" title="5.守护线程和用户线程有什么区别"></a>5.守护线程和用户线程有什么区别</h4><p>用户线程<br>    运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程<br>守护线程<br>    运行在后台，为其他前台线程服务。也可以说守护线程是 JVM 中非守护线程的 “佣人”。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作</p>
<h4 id="6-创建线程有哪几种方式"><a href="#6-创建线程有哪几种方式" class="headerlink" title="==6.创建线程有哪几种方式=="></a>==6.创建线程有哪几种方式==</h4><p>继承 Thread 类；<br>实现 Runnable 接口；<br>实现 Callable 接口；<br>使用 Executors 工具类创建线程池</p>
<h4 id="7-runnable-和-callable-有什么异同"><a href="#7-runnable-和-callable-有什么异同" class="headerlink" title="7.runnable 和 callable 有什么异同"></a>7.runnable 和 callable 有什么异同</h4><p>相同点<br>    都是接口<br>    都可以编写多线程程序<br>    都采用Thread.start()启动线程<br>不同点<br>    Runnable<br>        Runnable 接口 run 方法无返回值<br>        Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理<br>    Callable<br>        Callable 接口 call 方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果<br>        Callable 接口 call 方法允许抛出异常，可以获取异常信息</p>
<h4 id="8-线程的-run-和-start-有什么区别"><a href="#8-线程的-run-和-start-有什么区别" class="headerlink" title="8.线程的 run()和 start()有什么区别"></a>8.线程的 run()和 start()有什么区别</h4><p>start<br>    start() 方法用于启动线程<br>    而 start() 只能调用一次<br>    start()方法来启动一个线程，真正实现了多线程运行。调用start()方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， run()方法运行结束， 此线程终止。然后CPU再调度其它线程。<br>run<br>    run() 方法用于执行线程的运行时代码<br>    run() 可以重复调用<br>    run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p>
<h4 id="9-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法"><a href="#9-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法" class="headerlink" title="==9.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法=="></a>==9.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法==</h4><p>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。<br>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。<br>==总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。==</p>
<h4 id="10-sleep-和-wait-有什么区别"><a href="#10-sleep-和-wait-有什么区别" class="headerlink" title="10.sleep() 和 wait() 有什么区别"></a>10.sleep() 和 wait() 有什么区别</h4><p>两者都可以暂停线程的执行<br>区别<br>    类的不同：sleep() 是 Thread线程类的静态方法，wait() 是 Object类的方法。<br>    是否释放锁：sleep() 不释放锁；wait() 释放锁。<br>    用途不同：Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。<br>    用法不同：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。</p>
<h4 id="11-Thread-类中的-yield-方法有什么作用"><a href="#11-Thread-类中的-yield-方法有什么作用" class="headerlink" title="11.Thread 类中的 yield 方法有什么作用"></a>11.Thread 类中的 yield 方法有什么作用</h4><p>使当前线程从执行状态（运行状态）变为可执行态（就绪状态）<br>当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。 </p>
<h4 id="12-线程的-sleep-方法和-yield-方法有什么区别"><a href="#12-线程的-sleep-方法和-yield-方法有什么区别" class="headerlink" title="12.线程的 sleep()方法和 yield()方法有什么区别"></a>12.线程的 sleep()方法和 yield()方法有什么区别</h4><p>（1） sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；<br>（2） 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；<br>（3）sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；<br>（4）sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。</p>
<h4 id="13-如何停止一个正在运行的线程"><a href="#13-如何停止一个正在运行的线程" class="headerlink" title="13.如何停止一个正在运行的线程"></a>13.如何停止一个正在运行的线程</h4><p>1.使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。<br>2.使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。<br>3.使用interrupt方法中断线程。</p>
<h4 id="14-Java-中-interrupted-和-isInterrupted-方法的区别"><a href="#14-Java-中-interrupted-和-isInterrupted-方法的区别" class="headerlink" title="14.Java 中 interrupted 和 isInterrupted 方法的区别"></a>14.Java 中 interrupted 和 isInterrupted 方法的区别</h4><p>interrupt：用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。<br>    会在Thread.cpp底层执行LockSupport.unpark(t)，唤醒当前线程<br>interrupted：是静态方法，查看当前中断信号是true还是false并且清除中断信号。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了。<br>isInterrupted：查看当前中断信号是true还是false</p>
<h4 id="15-Java-如何实现多线程之间的通讯和协作"><a href="#15-Java-如何实现多线程之间的通讯和协作" class="headerlink" title="15.Java 如何实现多线程之间的通讯和协作"></a>15.Java 如何实现多线程之间的通讯和协作</h4><p>1.syncrhoized加锁的线程的Object类的wait()/notify()/notifyAll()<br>2.ReentrantLock类加锁的线程的Condition类的await()/signal()/signalAll()</p>
<h4 id="16-park-unpark和-wait-notify区别"><a href="#16-park-unpark和-wait-notify区别" class="headerlink" title="16.park/unpark和 wait/notify区别"></a>16.park/unpark和 wait/notify区别</h4><p>wait和notify方法必须和同步锁 synchronized一块使用。而park/unpark使用就比较灵活了，没有这个限制，可以在任何地方使用。<br>park/unpark 使用时没有先后顺序，都可以使线程不阻塞（前面代码已验证）。而wait必须在notify前先使用，如果先notify，再wait，则线程会一直等待。<br>notify只能随机释放一个线程，并不能指定某个特定线程，notifyAll是释放锁对象中的所有线程。而unpark方法可以唤醒指定的线程。<br>调用wait方法会使当前线程释放锁资源，但使用的前提是必须已经获得了锁。而park不会释放锁资源。</p>
<p><a href="https://blog.csdn.net/yemuxiaweiliang/article/details/120987740" target="_blank" rel="noopener">参考</a></p>
<h3 id="并发关键字"><a href="#并发关键字" class="headerlink" title="并发关键字"></a>并发关键字</h3><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><h5 id="1-synchronized-的作用"><a href="#1-synchronized-的作用" class="headerlink" title="1.synchronized 的作用"></a>1.synchronized 的作用</h5><p>在多线程的环境下，控制 synchronized     代码段不被多个线程同时执行<br>早期<br>    在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁是依赖于底层的操作系统的 Mutex Lock 来实现的，需要挂起或环形线程，线程间的切换涉及到从用户态转换为内核态，成本高，这是早期synchronized效率低下的原因<br>优化<br>    自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁</p>
<h5 id="2-说一下-synchronized-底层实现原理"><a href="#2-说一下-synchronized-底层实现原理" class="headerlink" title="==2.说一下 synchronized 底层实现原理=="></a>==2.说一下 synchronized 底层实现原理==</h5><p>首先要获取锁，而获取锁的过程就是monitorenter ，在执行完代码块之后，要释放锁，释放锁就是执行monitorexit指令。<br>Monitor在C++层面维护了ObjectMonitor的变量，有count计数器表示是否有线程竞争锁<br>==追问==<br>    ==为什么会有两个monitorexit呢==<br>        这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。<br>        因此最后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁<br>    ==synchronized可重入的原理==<br>        底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</p>
<h5 id="3-多线程中-synchronized-锁升级的原理是什么"><a href="#3-多线程中-synchronized-锁升级的原理是什么" class="headerlink" title="3.多线程中 synchronized 锁升级的原理是什么"></a>3.多线程中 synchronized 锁升级的原理是什么</h5><p>1.在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id<br>2.再次进入的时候会先判断 threadid 是否与其线程 id 一致<br>    如果一致则可以直接使用此对象<br>    如果不一致，则升级偏向锁为轻量级锁<br>3.通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁</p>
<p>不同线程竞争</p>
<p><img alt="JVM锁的膨胀升级" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JUC/20230119213935.jpg"></p>
<p>锁升级流程图</p>
<p><img alt="synchronized锁实现与升级过程" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JUC/20230119213956.png"></p>
<h5 id="4-synchronized怎么保证可见性、有序性、原子性"><a href="#4-synchronized怎么保证可见性、有序性、原子性" class="headerlink" title="==4.synchronized怎么保证可见性、有序性、原子性=="></a>==4.synchronized怎么保证可见性、有序性、原子性==</h5><p>原子性<br>可见性<br>    通过monitorenter/monitorexit的jvm字节码指令，在底层调用lock前缀指令开启内存屏障<br>有序性<br>    依然会发生重排序，只不过我们有同步代码块，可以保证只有一个线程执行同步代码中的代码。保证有序性</p>
<p><a href="https://blog.csdn.net/chenzengnian123/article/details/122686371" target="_blank" rel="noopener">参考</a></p>
<h5 id="5-synchronized-和-Lock-有什么区别"><a href="#5-synchronized-和-Lock-有什么区别" class="headerlink" title="5.synchronized 和 Lock 有什么区别"></a>5.synchronized 和 Lock 有什么区别</h5><p>首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类；<br>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。<br>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。<br>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p>
<h5 id="6-synchronized-和-ReentrantLock-的区别"><a href="#6-synchronized-和-ReentrantLock-的区别" class="headerlink" title="==6.synchronized 和 ReentrantLock 的区别=="></a>==6.synchronized 和 ReentrantLock 的区别==</h5><p><strong>都是可重入锁</strong><br><strong>区别</strong><br>    ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；<br>    ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；<br>    ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。<br>    二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的park 方法加锁，synchronized 操作的应该是对象头中 mark word<br>==ReentrantLock的新功能==<br>    等待可中断<br>        ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。<br>    可实现公平锁<br>        ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。<br>    可实现选择性通知（锁可以绑定多个条件）<br>        synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。</p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><h5 id="1-volatile-关键字的作用"><a href="#1-volatile-关键字的作用" class="headerlink" title="1.volatile 关键字的作用"></a>1.volatile 关键字的作用</h5><p>保证可见性和有序性(禁止指令重排)<br>和Atomic(CAS)结合保证原子性</p>
<h5 id="2-Java-中能创建-volatile-数组吗"><a href="#2-Java-中能创建-volatile-数组吗" class="headerlink" title="2.Java 中能创建 volatile 数组吗"></a>2.Java 中能创建 volatile 数组吗</h5><p>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了</p>
<h5 id="3-synchronized-和-volatile-的区别是什么"><a href="#3-synchronized-和-volatile-的区别是什么" class="headerlink" title="3.synchronized 和 volatile 的区别是什么"></a>3.synchronized 和 volatile 的区别是什么</h5><p>volatile 是变量修饰符；synchronized 可以修饰类、方法、变量。<br>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。==对于可见性来说，在JAVA底层都是调用了内存屏障，在硬件底层都是调用了Lock前缀指令从而触发了MESI协议保证了可见性。==</p>
<p><a href="https://blog.csdn.net/weixin_35688354/article/details/113452096" target="_blank" rel="noopener">参考</a></p>
<p>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。<br>volatile 标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化(指令重排)。</p>
<h5 id="4-volatile实现内存可见性、有序性原理"><a href="#4-volatile实现内存可见性、有序性原理" class="headerlink" title="==4.volatile实现内存可见性、有序性原理=="></a>==4.volatile实现内存可见性、有序性原理==</h5><p><a href="https://blog.csdn.net/it_lihongmin/article/details/109169260" target="_blank" rel="noopener">可见性</a><br>    硬件层面<br>        底层汇编会生成lock前缀指令，从而触发MESI缓存一致性协议，通过总线嗅探机制监听每个线程(工作内存)的变量是否改变<br>    JAVA层面<br>        内存屏障<br>有序性<br>    内存屏障(禁止指令重排)</p>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a><a href="https://cloud.tencent.com/developer/article/1379380" target="_blank" rel="noopener">final</a></h4><h3 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h3><h4 id="1-什么是-CAS"><a href="#1-什么是-CAS" class="headerlink" title="1.什么是 CAS"></a>1.什么是 CAS</h4><p>CAS 操作包含三个操作数 —— 内存位置(V)、预期原值(A)和新值(B)。<br>    如果内存地址里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。<br>    CAS是通过无限循环来获取数据的，如果在第一轮循环中，a 线程获取地址里面的值被b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执行。</p>
<h4 id="2-CAS-的会产生什么问题"><a href="#2-CAS-的会产生什么问题" class="headerlink" title="2.CAS 的会产生什么问题"></a>2.CAS 的会产生什么问题</h4><p>==ABA问题==<br>    描述<br>        比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。<br>    解决<br>        AtomicStampedReference每次更新加版本<br>==循环时间长开销大==<br>    描述<br>        对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized<br>    解决<br>        <a href="https://blog.csdn.net/qq_29373285/article/details/88566435" target="_blank" rel="noopener">LongAdder</a>：分段CAS操作<br>            默认一开始使用CAS单个cell作为base，当线程多了之后，开启多个cell单元，用于分担base的压力，之后需要值的时候返回base+所有cell的值<br>        示意图</p>
<p><img alt="img" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JUC/20230120163139"></p>
<h3 id="Lock基础-AQS"><a href="#Lock基础-AQS" class="headerlink" title="Lock基础(AQS)"></a>Lock基础(AQS)</h3><h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><h5 id="1-说下对同步器-AQS-的理解"><a href="#1-说下对同步器-AQS-的理解" class="headerlink" title="1.说下对同步器 AQS 的理解"></a>1.说下对同步器 AQS 的理解</h5><p>​    AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。<br>​    AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，BlockingQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。</p>
<h5 id="2-AQS-的原理是什么"><a href="#2-AQS-的原理是什么" class="headerlink" title="2.AQS 的原理是什么"></a>2.AQS 的原理是什么</h5><p>​    核心思想<br>​        如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。<br>​        如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中<br>​    AQS 使用一个 int 成员变量 (state) 来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS (unsafe类)对该同步状态进行原子操作实现对其值的修改<br>​    CLH中每个结点还有一个waitSatus用于表示下一个结点中的线程的声明状态</p>
<h5 id="3-AQS-对资源的共享模式有哪些"><a href="#3-AQS-对资源的共享模式有哪些" class="headerlink" title="3.AQS 对资源的共享模式有哪些"></a>3.AQS 对资源的共享模式有哪些</h5><p>​    Exclusive（独占）<br>​        ReentrantLock，又可分为公平锁和非公平锁<br>​    Share（共享）<br>​        多个线程可同时执行，如：CountDownLatch、Semaphore、 CyclicBarrier、ReadWriteLock</p>
<h5 id="4-AQS-底层使用了模板方法模式，你能说出几个需要重写的方法吗"><a href="#4-AQS-底层使用了模板方法模式，你能说出几个需要重写的方法吗" class="headerlink" title="4.AQS 底层使用了模板方法模式，你能说出几个需要重写的方法吗"></a>4.AQS 底层使用了模板方法模式，你能说出几个需要重写的方法吗</h5><p>​    tryAcquire(int)<br>​        独占方式。尝试获取资源，成功则返回 true，失败则返回 false。<br>​    tryRelease(int)<br>​        独占方式。尝试释放资源，成功则返回 true，失败则返回 false。<br>​    tryAcquireShared(int)<br>​        共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br>​    tryReleaseShared(int)<br>​        共享方式。尝试释放资源，成功则返回 true，失败则返回 false。                     </p>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><h5 id="1-CountDownLatch-怎么用？应用场景是什么？"><a href="#1-CountDownLatch-怎么用？应用场景是什么？" class="headerlink" title="1.CountDownLatch 怎么用？应用场景是什么？"></a>1.CountDownLatch 怎么用？应用场景是什么？</h5><p>​    核心API<br>​        countDown<br>​            计数器减一<br>​        await<br>​            等到计数器为0再唤醒当前线程<br>​    应用场景<br>​        当所有的数据处理完成后，再去执行后面的操作<br>​        多个线程需要等待其他线程的工作之后，再进行其后续工作。</p>
<h5 id="2-CountDownLatch-和-CyclicBarrier-的不同之处？"><a href="#2-CountDownLatch-和-CyclicBarrier-的不同之处？" class="headerlink" title="2.CountDownLatch 和 CyclicBarrier 的不同之处？"></a>2.CountDownLatch 和 CyclicBarrier 的不同之处？</h5><p>​    CountDownLatch 是计数器，只能使用一次，而 CyclicBarrier 的计数器提供 reset 功能，可以多次使用<br>​    含义不同<br>​        CountDownLatch: 一个或者多个线程(主线程)，等待其他多个线程完成某件事情之后才能执行<br>​        CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。<br>​    <a href="https://blog.csdn.net/liangyihuai/article/details/83106584" target="_blank" rel="noopener">参考</a></p>
<h5 id="3-CountDownLatch-类中主要的方法？"><a href="#3-CountDownLatch-类中主要的方法？" class="headerlink" title="3.CountDownLatch 类中主要的方法？"></a>3.CountDownLatch 类中主要的方法？</h5><p>​    countDown<br>​        计数器减一，如果计数达到零，释放所有等待的线程。<br>​    await<br>​        等到计数器为0再唤醒当前线程<br>​    getCount<br>​        返回当前计数</p>
<h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><h5 id="1-谈谈对-BlockingQueue-的理解？分别有哪些实现类"><a href="#1-谈谈对-BlockingQueue-的理解？分别有哪些实现类" class="headerlink" title="1.谈谈对 BlockingQueue 的理解？分别有哪些实现类"></a>1.谈谈对 BlockingQueue 的理解？分别有哪些实现类</h5><p>​    阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。<br>​    实现类<br>​        ArrayBlockingQueue 由数组支持的有界队列<br>​        LinkedBlockingQueue 由链接节点支持的可选有界队列<br>​        PriorityBlockingQueue 由优先级堆支持的无界优先级队列<br>​        DelayQueue 由优先级堆支持的、基于时间的调度队列</p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><h5 id="1-什么是ConcurrentHashMap"><a href="#1-什么是ConcurrentHashMap" class="headerlink" title="1.什么是ConcurrentHashMap"></a>1.什么是ConcurrentHashMap</h5><p>​    ConcurrentHashMap是Java中的一个线程安全且高效的HashMap实现<br>​    JDK1.8后，ConcurrentHashMap抛弃了原有的Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。</p>
<h5 id="2-Java-中-ConcurrentHashMap-的并发度是什么"><a href="#2-Java-中-ConcurrentHashMap-的并发度是什么" class="headerlink" title="2.Java 中 ConcurrentHashMap 的并发度是什么"></a>2.Java 中 ConcurrentHashMap 的并发度是什么</h5><p>​    ConcurrentHashMap 把实际 map 划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是 ConcurrentHashMap 类构造函数的一个可选参数，默认值为 16，这样在多线程情况下就能避免争用</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><h5 id="1-谈谈对-CopyOnWriteArrayList-的理解"><a href="#1-谈谈对-CopyOnWriteArrayList-的理解" class="headerlink" title="1.谈谈对 CopyOnWriteArrayList 的理解"></a>1.谈谈对 CopyOnWriteArrayList 的理解</h5><p>​    特性<br>​        适用场景为读多写少<br>​        不能读取实时性的数据，但能保证最终数据一致性<br>​        空间换时间<br>​    原理<br>​        内部维护了一个Object[]数组，通过getArray/setArray来获取/赋值<br>​        修改<br>​            如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。</p>
<h5 id="2-CopyOnWriteArrayList-是什么，可以用于什么应用场景"><a href="#2-CopyOnWriteArrayList-是什么，可以用于什么应用场景" class="headerlink" title="2.CopyOnWriteArrayList 是什么，可以用于什么应用场景"></a>2.CopyOnWriteArrayList 是什么，可以用于什么应用场景</h5><p>​    读多写少</p>
<h5 id="3-CopyOnWriteArrayList有哪些优缺点"><a href="#3-CopyOnWriteArrayList有哪些优缺点" class="headerlink" title="3.CopyOnWriteArrayList有哪些优缺点"></a>3.CopyOnWriteArrayList有哪些优缺点</h5><p>​    缺点<br>​        1. 由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。<br>​        2. 不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的，虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。<br>​        3. 由于实际使用中可能没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次 add/set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。<br>​    优点<br>​        读写分离，读和写分开<br>​        适合读多写少</p>
<h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><h5 id="1-谈谈对ConcurrentLinkedQueue理解"><a href="#1-谈谈对ConcurrentLinkedQueue理解" class="headerlink" title="1.谈谈对ConcurrentLinkedQueue理解"></a>1.谈谈对ConcurrentLinkedQueue理解</h5><p>​    高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列</p>
<h4 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h4><h5 id="1-谈谈对-ConcurrentSkipListMap-的理解"><a href="#1-谈谈对-ConcurrentSkipListMap-的理解" class="headerlink" title="1.谈谈对 ConcurrentSkipListMap 的理解"></a>1.谈谈对 ConcurrentSkipListMap 的理解</h5><p><a href="https://blog.csdn.net/hbtj_1216/article/details/114228578" target="_blank" rel="noopener">参考</a></p>
<p>​    特点<br>​        高并发场景<br>​        key是有序的<br>​        添加、删除、查找操作都是基于跳表结构（Skip List）实现的<br>​        key和value都不能为null<br>​    跳表<br>​        跳表由很多层组成；<br>​        每一层都是一个有序的链表；<br>​        最底层的链表包含所有元素；<br>​        对于每一层的任意一个节点，不仅有指向其下一个节点的指针，也有指向其下一层的指针；<br>​        如果一个元素出现在Level n层的链表中，则它在Level n层以下的链表也都会出现。</p>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h5 id="1-ThreadLocal-是什么？有哪些使用场景"><a href="#1-ThreadLocal-是什么？有哪些使用场景" class="headerlink" title="1.ThreadLocal 是什么？有哪些使用场景"></a>1.ThreadLocal 是什么？有哪些使用场景</h5><p>​    ThreadLocal 是一个本地线程副本变量工具类，在每个线程中都创建了一个 ThreadLocalMap 对象<br>​    使用场景<br>​        为每个线程分配一个 JDBC 连接 Connection。这样就可以保证每个线程的都在各自的 Connection 上进行数据库的操作，不会出现 A 线程关了 B线程正在使用的 Connection</p>
<h5 id="2-什么是线程局部变量"><a href="#2-什么是线程局部变量" class="headerlink" title="2.什么是线程局部变量"></a>2.什么是线程局部变量</h5><p>​    线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。</p>
<h5 id="3-ThreadLocal造成内存泄漏的原因"><a href="#3-ThreadLocal造成内存泄漏的原因" class="headerlink" title="3.ThreadLocal造成内存泄漏的原因"></a>3.ThreadLocal造成内存泄漏的原因</h5><p>​    ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。<br>​    所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。<br>​    这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露</p>
<h5 id="4-ThreadLocal内存泄漏解决方案"><a href="#4-ThreadLocal内存泄漏解决方案" class="headerlink" title="4.ThreadLocal内存泄漏解决方案"></a>4.ThreadLocal内存泄漏解决方案</h5><p>​    每次使用完ThreadLocal，都调用它的remove()方法，清除数据</p>
<h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h5><p>​    ThreadLocal的 key 是弱引用，那么在 ThreadLocal.get()的时候，发生GC之后，key 是否为null？<br>​    ThreadLocal中ThreadLocalMap的数据结构？<br>​    ThreadLocalMap的Hash 算法？<br>​    ThreadLocalMap中Hash 冲突如何解决？<br>​    ThreadLocalMap的扩容机制？<br>​    ThreadLocalMap中过期 key 的清理机制？探测式清理和启发式清理流程？<br>​    ThreadLocalMap.set()方法实现原理？<br>​    ThreadLocalMap.get()方法实现原理？<br>​    项目中ThreadLocal使用情况？遇到的坑？</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="1-什么是线程池？有哪几种创建方式"><a href="#1-什么是线程池？有哪几种创建方式" class="headerlink" title="1.什么是线程池？有哪几种创建方式"></a>1.什么是线程池？有哪几种创建方式</h4><p>​    线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。<br>​    Executors<br>​        newSingleThreadExecutor：创建一个单线程的线程池。<br>​        newFixedThreadPool：创建固定大小的线程池。<br>​        newCachedThreadPool：创建一个可缓存的线程池。<br>​        newScheduledThreadPool：创建一个大小无限的线程池。<br>​    new ThreadPoolExecutor</p>
<h4 id="2-线程池有什么优点"><a href="#2-线程池有什么优点" class="headerlink" title="2.线程池有什么优点"></a>2.线程池有什么优点</h4><p>​    降低资源消耗<br>​        重用存在的线程，减少对象创建销毁的开销<br>​    提高响应速度<br>​        可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要等到线程创建就能立即执行<br>​    提高线程的可管理性<br>​        线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控<br>​    附加功能<br>​        提供定时执行、定期执行、单线程、并发数控制等功能</p>
<h4 id="3-线程池都有哪些状态"><a href="#3-线程池都有哪些状态" class="headerlink" title="3.线程池都有哪些状态"></a>3.线程池都有哪些状态</h4><p><img alt="1" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JUC/20230120182934.png"></p>
<p>​    RUNNING<br>​        这是最正常的状态，接受新的任务，处理等待队列中的任务<br>​    SHUTDOWN<br>​        不接受新的任务提交，但是会继续处理等待队列中的任务<br>​    STOP<br>​        不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程<br>​    TIDYING<br>​        所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()<br>​    TERMINATED<br>​        terminated()方法结束后，线程池的状态就会变成这个</p>
<h4 id="4-在-Java-中-Executor-和-Executors-的区别"><a href="#4-在-Java-中-Executor-和-Executors-的区别" class="headerlink" title="4.在 Java 中 Executor 和 Executors 的区别"></a>4.在 Java 中 Executor 和 Executors 的区别</h4><p>​    Executor是线程池的顶层接口<br>​    Executors定义了一堆用户可以直接使用的线程池，但不推荐</p>
<h4 id="5-线程池中-submit-和-execute-方法有什么区别"><a href="#5-线程池中-submit-和-execute-方法有什么区别" class="headerlink" title="==5.线程池中 submit() 和 execute() 方法有什么区别=="></a>==5.线程池中 submit() 和 execute() 方法有什么区别==</h4><p>​    接收参数<br>​        execute()只能执行 Runnable 类型的任务。submit()可以执行 Runnable 和 Callable 类型的任务<br>​    返回值<br>​        submit()方法可以返回持有计算结果的 Future 对象，而execute()没有<br>​    异常处理<br>​        submit()方便Exception处理</p>
<h4 id="6-Executors和ThreaPoolExecutor创建线程池的区别-为什么不推荐Executors"><a href="#6-Executors和ThreaPoolExecutor创建线程池的区别-为什么不推荐Executors" class="headerlink" title="6.Executors和ThreaPoolExecutor创建线程池的区别(为什么不推荐Executors)"></a>6.Executors和ThreaPoolExecutor创建线程池的区别(为什么不推荐Executors)</h4><p>​    Executors 各个方法的弊端<br>​        newFixedThreadPool 和 newSingleThreadExecutor:<br>​            ==主要问题是允许请求的队列长度为 Integer.MAX_VALUE，堆积的请求处理队列可能会耗费非常大的内存==，甚至 OOM<br>​        newCachedThreadPool 和 newScheduledThreadPool:<br>​            主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM<br>​    ThreaPoolExecutor创建线程池方式只有一种，就是走它的构造函数，参数自己指定</p>
<h4 id="7-ThreadPoolExecutor构造函数重要参数分析"><a href="#7-ThreadPoolExecutor构造函数重要参数分析" class="headerlink" title="==7.ThreadPoolExecutor构造函数重要参数分析=="></a>==7.ThreadPoolExecutor构造函数重要参数分析==</h4><p>​    corePoolSize<br>​        核心线程数，线程数定义了最小可以同时运行的线程数量。<br>​    maximumPoolSize<br>​        线程池中允许存在的工作线程的最大数量<br>​    workQueue<br>​        当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在队列中<br>​    keepAliveTime<br>​        线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；<br>​    unit<br>​        keepAliveTime 参数的时间单位。<br>​    threadFactory<br>​        为线程池提供创建新线程的线程工厂<br>​    handler<br>​        线程池任务队列超过 maxinumPoolSize 之后的拒绝策略</p>
<h4 id="建议不同类别的业务用不同的线程池"><a href="#建议不同类别的业务用不同的线程池" class="headerlink" title="建议不同类别的业务用不同的线程池"></a>建议不同类别的业务用不同的线程池</h4><p>​    一般建议是不同的业务使用不同的线程池，配置线程池的时候根据当前业务的情况对当前线程池进行配置，因为不同的业务的并发以及对资源的使用情况都不同，重心优化系统性能瓶颈相关的业务。<br>​    否则，父子线程可能会互相死锁</p>
<h4 id="线程池架构-原理-流程"><a href="#线程池架构-原理-流程" class="headerlink" title="线程池架构(原理/流程)"></a>线程池架构(原理/流程)</h4><p><img alt="4" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JUC/20230120183334.png"></p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis面试题</title>
    <url>/alex-next/2022/10/18/%E9%9D%A2%E8%AF%95%E9%A2%98/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1、什么是Mybatis？"><a href="#1、什么是Mybatis？" class="headerlink" title="1、什么是Mybatis？"></a>1、什么是Mybatis？</h3><blockquote>
<p>1.Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。</p>
<p>2.MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p>
<p>3.通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。（从执行sql到返回result的过程）。</p>
</blockquote>
<h3 id="2、-和-的区别是什么？"><a href="#2、-和-的区别是什么？" class="headerlink" title="2、#{}和${}的区别是什么？"></a><strong>2、#{}和${}的区别是什么？</strong></h3><blockquote>
<p> {}是预编译处理，${}是字符串替换。</p>
<p> Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</p>
<p> Mybatis在处理${}时，就是把${}替换成变量的值。</p>
<p> 使用#{}可以有效的防止SQL注入，提高系统安全性。</p>
</blockquote>
<h3 id="3、简述-MyBatis-的插件运行原理，以及如何编写一个插件。"><a href="#3、简述-MyBatis-的插件运行原理，以及如何编写一个插件。" class="headerlink" title="3、简述 MyBatis 的插件运行原理，以及如何编写一个插件。"></a>3、简述 MyBatis 的插件运行原理，以及如何编写一个插件。</h3><p>MyBatis 仅可以编写针对 <code>ParameterHandler</code> 、 <code>ResultSetHandler</code> 、 <code>StatementHandler</code> 、 <code>Executor</code> 这 4 种接口的插件，MyBatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 <code>InvocationHandler</code> 的 <code>invoke()</code> 方法，当然，只会拦截那些你指定需要拦截的方法。</p>
<p>实现 MyBatis 的 <code>Interceptor</code> 接口并复写 <code>intercept()</code> 方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>
<p><img alt="MyBatis插件过程" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Mybatis/20230131112919.png"></p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM面试题</title>
    <url>/alex-next/2022/10/30/%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><h4 id="1-简述java类加载机制"><a href="#1-简述java类加载机制" class="headerlink" title="1.简述java类加载机制"></a>1.简述java类加载机制</h4><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，准备，解析和初始化，最终形成可以被虚拟机直接使用的java类型</p>
<p><img alt="2" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109171002.png"></p>
<h4 id="2-描述一下JVM加载Class文件的原理机制"><a href="#2-描述一下JVM加载Class文件的原理机制" class="headerlink" title="2.描述一下JVM加载Class文件的原理机制"></a>2.描述一下JVM加载Class文件的原理机制</h4><p>默认隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中<br>        显式装载， 通过class.forname()等方法，显式加载需要的类<br>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p>
<h4 id="3-什么是类加载器，类加载器有哪些"><a href="#3-什么是类加载器，类加载器有哪些" class="headerlink" title="3.什么是类加载器，类加载器有哪些"></a>3.什么是类加载器，类加载器有哪些</h4><p>类加载器负责动态加载Java类到Java虚拟机的内存空间中</p>
<p>类加载器有：</p>
<p>启动类加载器<br>    用来加载java核心类库，无法被java程序直接引用<br>扩展类加载器<br>    它用来加载 Java 的扩展库<br>系统类加载器<br>    它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类<br>用户自定义类加载器<br>    通过继承 java.lang.ClassLoader类的方式实现</p>
<h4 id="4-说一下类装载的执行过程"><a href="#4-说一下类装载的执行过程" class="headerlink" title="==4.说一下类装载的执行过程=="></a>==4.说一下类装载的执行过程==</h4><p>加载：根据查找路径找到相应的 class 文件然后导入<br>    双亲委派<br>验证：检查加载的 class 文件的正确性，如开头CAFEBABE<br>准备：给类中的静态变量分配内存空间，赋予默认值<br>解析：虚拟机将常量池中的符号引用替换成直接引用的过程(也就是得到类或者字段、方法在内存中的指针或者偏移量)<br>初始化：对静态变量和静态代码块执行初始化工作(初始化为用户自定义的值)</p>
<h4 id="5-什么是双亲委派模型"><a href="#5-什么是双亲委派模型" class="headerlink" title="==5.什么是双亲委派模型=="></a>==5.什么是双亲委派模型==</h4><p><strong>步骤</strong><br>    1.首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接 返回。<br>     2.如果此类没有加载过(在内存中)，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用parent.loadClass(name, false);）(扩展类加载器再向上委托便是bootstrap类加载器来加载)。<br>    3.如果父加载器及bootstrap类加载器都没有找到指定的类，那么向下委托看当前加载器的路径下有没有改class文件(一般都会回到当前类加载器的 findClass方法来完成类加载)。<br>        注意AppClassLoader和ExtClassLoader的findClass方法均在URLClassLoader中实现<br>细节</p>
<blockquote>
<p>双亲委派机制</p>
<p>向上委托主要是判断要加载的类有没有被加载到内存，如果已被加载到内存，就没必要继续向上委托。</p>
<p>而父类向下委托则是判断自己的类路径中有没有该类，有的话直接加载进内存。</p>
</blockquote>
<p>==为什么要设计双亲委派机制==<br>    1.沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心API库被随意篡改<br>    2.避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证被加载类的唯一性<br>模型图参考</p>
<p><img alt="2" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109175409.png"></p>
<h4 id="6-如何判断两个class对象是否相同？"><a href="#6-如何判断两个class对象是否相同？" class="headerlink" title="6.如何判断两个class对象是否相同？"></a>6.如何判断两个class对象是否相同？</h4><p>1.类的完整类名必须一致，包括包名<br>2.加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</p>
<h4 id="7-怎么实现一个自定义的类加载器"><a href="#7-怎么实现一个自定义的类加载器" class="headerlink" title="7.怎么实现一个自定义的类加载器"></a>7.怎么实现一个自定义的类加载器</h4><p>自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，<br>        一个是 loadClass(String, boolean)，实现了双亲委派机制<br>        还有一个方法是findClass，默认实现是空 方法，所以我们自定义类加载器主要是重写findClass方法<br>                重写findClass方法实际上就是为了实现defineClass方法，将类路径的类加载进来。</p>
<h4 id="8-怎么打破双亲委派模型"><a href="#8-怎么打破双亲委派模型" class="headerlink" title="8.怎么打破双亲委派模型"></a>8.怎么打破双亲委派模型</h4><p>自己写一个类加载器继承ClassLoader<br>主要重写 loadClass() 方法，把原来双亲委派的部分去掉<br>重写 findClass() 方法</p>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><h4 id="自增-操作数栈"><a href="#自增-操作数栈" class="headerlink" title="==自增/操作数栈=="></a>==自增/操作数栈==</h4><p><img alt="1" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109195634.png"></p>
<p>结果<br>    i=4,j=1,k=11<br>分析<br>    1.i=i++<br>        将i=1读入操作数栈，i自增(此时i=2)存在局部变量表，接着赋值，将操作数栈的i覆盖局部变量表的i，最后i=1<br>    2.j = i++<br>        将i=1读入操作数栈，i自增(操作之后i=2)存在局部变量表，接着赋值，将操作数栈的i覆盖局部变量表的j，最后j=1,i=2<br>    3.k=i+ ++i <em> i++<br>        将i=2读入操作数栈，++i(操作之后i=3)存在局部变量表，将i=3(乘号前的)压入栈中，紧接着将i=3(乘号后的)压入栈中，i++(操作之后i=4)存在局部变量表；计算乘法操作(3</em>3=9)后，与一开始的入栈的2相加得11，赋值给局部变量表的k。最后k=11，i=4</p>
<p>总结<br>    赋值运算，最后计算；赋值运算就是将对应操作数栈的数，移到局部变量表中<br>    i++和++i的区别就是<br>        压入操作数栈和修改局部变量表中的值(+1操作)顺序的区别(无论如何这两步操作是紧接在一起的)<br>        i++自增直接修改局部变量表中的值，不经过操作数栈；++i自增直接修改局部变量表中的值，之后再把局部变量表的i放入操作数栈<br><a href="https://www.bilibili.com/video/BV1Eb411P7bP/?vd_source=3c18550954067ac625f4410f0e243609" target="_blank" rel="noopener">来源</a></p>
<h4 id="1-介绍下-Java-内存区域（运行时数据区）"><a href="#1-介绍下-Java-内存区域（运行时数据区）" class="headerlink" title="==1.介绍下 Java 内存区域（运行时数据区）=="></a>==1.介绍下 Java 内存区域（运行时数据区）==</h4><p>运行时数据区<br>    Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域<br>==五大区域==<br>    程序计数器<br>        当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成<br>    虚拟机栈(线程栈)<br>        用于存储局部变量表、操作数栈、动态链接、方法出口等信息<br>    本地方法栈<br>        与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的<br>        局部变量表<br>            存基本数据类型和对象引用<br>        操作数栈<br>            方法调用的中转站<br>        动态链接<br>            动态链接的作用就是为了将符号引用转换为调用方法的直接引用(与类装载解析阶段是将静态方法的符号引用转换为直接引用不同)<br>        方法出口<br>            return 或异常<br>    堆<br>        Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存<br>    方法区<br>        用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据<br>线程共享<br>    堆<br>    方法区<br>线程私有<br>    程序计数器<br>    虚拟机栈<br>    本地方法栈<br>参考</p>
<p><img alt="3" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109200014.png"></p>
<h4 id="2-Java-对象的创建过程"><a href="#2-Java-对象的创建过程" class="headerlink" title="==2.Java 对象的创建过程=="></a>==2.Java 对象的创建过程==</h4><p>1.类加载检查<br>    虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个 符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程<br>2.分配内存</p>
<p>​    参考图</p>
<p>​    <img alt="4" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109200515.png"></p>
<p>​    内存分配方式<br>​        指针碰撞：类比顺序链表，依次分配内存<br>​        空闲链表：类比单链表，哪有空间就存哪<br>​        用哪种方式取决于Java 堆内存是否规整，而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”(不规整)，还是”标记-整理”(规整)或复制算法(规整)<br>​    创建对象可能频繁，产生并发问题<br>​        CAS<br>​            因为冲突失败就重试，直到成功为止<br>​        TLAB(本地线程分配缓冲)<br>​            为每一个线程预先在 Eden 区分配一块内存(这样就不会冲突)，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配<br>3.初始化<br>​    将分配到的内存空间都初始化为零值<br>​    这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用<br>4.设置对象头<br>​    mark word</p>
<p>​    <img alt="5" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109200437.png"></p>
<p>​        主要存的是自身运行时数据<br>​            对象的哈希码<br>​            对象的GC分代年龄<br>​            锁状态信息等<br>​    Klass Pointer类型指针：对象指向它的类元数据的指针<br>​        对象是哪个类的实例<br>​        如何才能找到类的元数据信息<br>​    数组长度(4字节，只有数组对象才有)<br>5.执行<init>方法<br>​    对象按照程序员的意愿对属性进行赋值</init></p>
<h4 id="3-对象的访问定位的两种方式"><a href="#3-对象的访问定位的两种方式" class="headerlink" title="3.对象的访问定位的两种方式"></a>3.对象的访问定位的两种方式</h4><p>​    对象的访问定位方式由虚拟机实现而定<br>​    句柄访问<br>​        引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。<br>​    直接指针<br>​        速度更快，节省了一次指针定位的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。</p>
<h4 id="4-说一下-JVM-的主要组成部分及其作用"><a href="#4-说一下-JVM-的主要组成部分及其作用" class="headerlink" title="4.说一下 JVM 的主要组成部分及其作用"></a>4.说一下 JVM 的主要组成部分及其作用</h4><p><img alt="6" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109204100.png"></p>
<p>类加载子系统<br>    步骤<br>        加载<br>        验证<br>        准备<br>        解析<br>        初始化<br>    类加载器（ClassLoader）再把字节码加载到内存中(JVM可以直接使用的java类)<br>运行时数据区<br>    Q.1<br>执行引擎<br>    即时编译器JIT</p>
<p>​        <img alt="7" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109204230.png"></p>
<p>​        前端编译(javac命令)为.class文件<br>​        解释执行，运行到不同平台上<br>​    垃圾回收器<br>本地库接口<br>本地方法库</p>
<h4 id="5-说一下堆栈的区别"><a href="#5-说一下堆栈的区别" class="headerlink" title="5.说一下堆栈的区别"></a>5.说一下堆栈的区别</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>==存储内容==</th>
<th>==程序可见度==</th>
<th>作用</th>
<th>存储结构</th>
<th>内存大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>堆</td>
<td>主要存放对象实例</td>
<td>线程共享</td>
<td>主要用于存储对象信息</td>
<td>物理地址分配对象不连续，速度慢</td>
<td>分配不连续，在运行期确认，大小不固定，大小远远大于栈</td>
</tr>
<tr>
<td>栈</td>
<td>存放基本数据类型和对象的引用</td>
<td>线程私有</td>
<td>运行时的单位，解决程序运行时的问题</td>
<td>使用数据结构—栈，物理地址分配连续，速度快</td>
<td>分配连续，在编译期确认，大小固定</td>
</tr>
</tbody>
</table>
</div>
<h4 id="6-深拷贝和浅拷贝"><a href="#6-深拷贝和浅拷贝" class="headerlink" title="6.深拷贝和浅拷贝"></a>6.深拷贝和浅拷贝</h4><p>浅拷贝<br>    引用数据类型在堆中是同一个<br>深拷贝<br>    引用数据类型会创建一个新的对象放到堆中<br>对于基本数据类型都一样，因为基本数据类型存在虚拟机栈中</p>
<h4 id="7-谈谈你对内存分配的理解？大对象怎么分配？"><a href="#7-谈谈你对内存分配的理解？大对象怎么分配？" class="headerlink" title="==7.谈谈你对内存分配的理解？大对象怎么分配？=="></a>==7.谈谈你对内存分配的理解？大对象怎么分配？==</h4><p>1.根据逃逸分析，判断对象不会逃逸，就在栈上分配<br>2.判断如果是大对象，直接进老年代<br>3.判断TLAB(本地线程分配缓存)是否满了<br>细节</p>
<p>​    1.大对象直接进老年代</p>
<p>​    2.Eden区满了(事实上有个阈值)，就会回收(99%的对象都会变成垃圾)，存活的放到幸存区<br>​        若幸存区存不下，直接进老年代<br>​    3.长期存活的对象进老年代<br>​        分代年龄阈值可以通过-XX:MaxTenuringThreshold 来设置<br>​    4.对象动态年龄判断<br>​        例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会 把年龄n(含)以上的对象都放入老年代。<br>​        -XX:TargetSurvivorRatio可以指定<br>​    5.老年代空间担保机制</p>
<p>​        <img alt="7" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109211752.png"></p>
<p>​        ==确保minorGC之后，老年代能够装下年轻代中的所有对象==<br>内存分配流程图</p>
<p><img alt="6" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109211655.png"></p>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h4 id="1-如何判断对象是否死亡（两种方法）"><a href="#1-如何判断对象是否死亡（两种方法）" class="headerlink" title="1.如何判断对象是否死亡（两种方法）"></a>1.如何判断对象是否死亡（两种方法）</h4><p>引用计数法<br>    有一个地方引用它，计数器+1；引用失效，计数器-1；计数器为0<br>    问题<br>        不能解决循环引用的问题，引发内存泄漏<br>==可达性分析算法==<br>    以GCRoot为起点，向下搜索标记引用链，最后未标记的就是垃圾<br>    GCRoot<br>        虚拟机栈(栈帧中的本地变量表)中引用的对象<br>        本地方法栈(Native 方法)中引用的对象<br>        方法区中类静态属性引用的对象<br>        方法区中常量引用的对象<br>        所有被同步锁持有的对象</p>
<h4 id="2-简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。-很少见"><a href="#2-简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。-很少见" class="headerlink" title="2.简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。(很少见)"></a>2.简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。(很少见)</h4><p>强引用<br>    编程中一般对象所使用的引用<br>软引用<br>    软引用可用来实现内存敏感的高速缓存<br>弱引用<br>虚引用<br>    虚引用主要用来跟踪对象被垃圾回收的活动<br>虚引用与软引用和弱引用的区别<br>    虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<h4 id="3-如何判断一个常量是废弃常量"><a href="#3-如何判断一个常量是废弃常量" class="headerlink" title="3.如何判断一个常量是废弃常量"></a>3.如何判断一个常量是废弃常量</h4><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量</p>
<h4 id="4-如何判断一个类是无用的类"><a href="#4-如何判断一个类是无用的类" class="headerlink" title="4.如何判断一个类是无用的类"></a>4.如何判断一个类是无用的类</h4><p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。<br>加载该类的 ClassLoader 已经被回收。<br>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
<h4 id="5-垃圾收集有哪些算法，各自的特点？"><a href="#5-垃圾收集有哪些算法，各自的特点？" class="headerlink" title="==5.垃圾收集有哪些算法，各自的特点？=="></a>==5.垃圾收集有哪些算法，各自的特点？==</h4><p>1.复制算法</p>
<p><img alt="2" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230111215622.png"></p>
<p>2.标记清除算法</p>
<p><img alt="3" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230111215624.png"></p>
<p>3.标记整理算法</p>
<p><img alt="4" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230111215626.png"></p>
<h4 id="6-HotSpot-为什么要分为新生代和老年代？"><a href="#6-HotSpot-为什么要分为新生代和老年代？" class="headerlink" title="==6.HotSpot 为什么要分为新生代和老年代？=="></a>==6.HotSpot 为什么要分为新生代和老年代？==</h4><p>将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>​    新生代<br>​            每次收集都会有大量对象(近99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可 以完成每次垃圾收集<br>​    老年代<br>​            对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集</p>
<h4 id="7-常见的垃圾回收器有哪些？"><a href="#7-常见的垃圾回收器有哪些？" class="headerlink" title="==7.常见的垃圾回收器有哪些？=="></a>==7.常见的垃圾回收器有哪些？==</h4><p><img alt="1" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230111211416.png"></p>
<h5 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1.Serial 收集器"></a>1.Serial 收集器</h5><p>​    单线程，串行<br>​    新生代采用标记-复制算法，老年代采用标记-整理算法</p>
<h5 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2.ParNew 收集器"></a>2.ParNew 收集器</h5><p>​    Serial 收集器的多线程版本，其他和Serial一样<br>​    只能用于新生代，采用标记-复制算法<br>​    可以和CMS收集器配合使用</p>
<h5 id="3-Parallel-收集器"><a href="#3-Parallel-收集器" class="headerlink" title="3.Parallel 收集器"></a>3.Parallel 收集器</h5><p>​    新生代采用复制算法，老年代采用标记-整理算法<br>​    关注点是吞吐量（高效率的利用CPU）</p>
<h5 id="4-CMS收集器"><a href="#4-CMS收集器" class="headerlink" title="4.CMS收集器"></a>4.CMS收集器</h5><p>​    只能用于老年代，使用标记清除算法<br>​    步骤<br>​        初始标记<br>​            STW<br>​            记录gc roots直接能引用的对象，很快<br>​        并发标记<br>​            三色标记算法<br>​        重新标记<br>​            STW<br>​            主要使用三色标记中的增量更新做重新标记<br>​        并发清理<br>​            开启用户线程，同时GC线程开始对未标记的区域做清扫<br>​        并发重置<br>​            重置本次GC过程中的标记数据<br>​    并发标记时漏标使用增量更新</p>
<h5 id="5-G1"><a href="#5-G1" class="headerlink" title="5.G1"></a>5.G1</h5><h6 id="并发标记时漏标使用原始快照-SATB"><a href="#并发标记时漏标使用原始快照-SATB" class="headerlink" title="并发标记时漏标使用原始快照(SATB)"></a>并发标记时漏标使用原始快照(SATB)</h6><h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6><p>​        可预测的停顿<br>​            这是 G1 相对于 CMS 的一个大优势<br>​        空间整合<br>​            与 CMS 的“标记-清理”算法不同<br>​            G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。<br>​        分代收集<br>​            虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念<br>​        并行与并发<br>​            G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。<br>​            部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。<br>​        有优先级的回收策略<br>​            在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字 Garbage-First的由来)<br>​                比如一个Region花200ms能回收10M垃圾，另外一个Region花50ms能回收20M垃圾，在回收时间有限情况下，G1当然会优先选择后面这个Region回收。</p>
<h6 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h6><p>​        初始标记<br>​            同CMS<br>​        并发标记<br>​            同CMS<br>​        最终标记<br>​            同CMS重新标记<br>​        筛选回收<br>​            会STW<br>​            首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划<br>​                例：老年代此时有1000个 Region都满了，但是因为根据预期停顿时间，本次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得 知，可能回收其中800个Region刚好需要200ms，那么就只会回收800个Region(Collection Set，要回收的集合)，尽量把GC导致的停顿时间控制在我们指定的范围内。<br>​                可以用JVM参数 -XX:MaxGCPauseMillis指定GC停顿时间<br>​            不管是年轻代或是老 年代，回收算法主要用的是复制算法<br>​                将一个region中的存活对象复制到另一个region中，这种不会像CMS那样 回收完因为有很多内存碎片还需要整理一次，G1采用复制算法回收几乎不会有太多内存碎片</p>
<h6 id="G1-垃圾收集分类"><a href="#G1-垃圾收集分类" class="headerlink" title="G1 垃圾收集分类"></a>G1 垃圾收集分类</h6><p>​        Young GC<br>​            YoungGC并不是说现有的Eden区放满了就会马上触发，而是接近参数 -XX:MaxGCPauseMills 设定的值<br>​        Mixed GC<br>​            老年代的堆占有率达到参数(-XX:InitiatingHeapOccupancyPercent)设定的值则触发<br>​            回收所有的 Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区<br>​        Full GC<br>​            Mixed GC使用复制算法发现没有足够的空region就会触发<br>​            STW，使用Serial单线程<br>​    回收流程图</p>
<p><img alt="9" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/JVM/20230109220816.png"></p>
<h6 id="JDK8默认"><a href="#JDK8默认" class="headerlink" title="JDK8默认"></a>JDK8默认</h6><p>​    Parallel Scavenge收集器(新生代)和Parallel Old收集器(老年代)</p>
<h4 id="8-介绍一下-CMS-G1-收集器。"><a href="#8-介绍一下-CMS-G1-收集器。" class="headerlink" title="==8.介绍一下 CMS,G1 收集器。=="></a>==8.介绍一下 CMS,G1 收集器。==</h4><p>参考Q.7</p>
<h4 id="9-Minor-Gc-和-Full-GC-有什么不同呢？"><a href="#9-Minor-Gc-和-Full-GC-有什么不同呢？" class="headerlink" title="==9.Minor Gc 和 Full GC 有什么不同呢？=="></a>==9.Minor Gc 和 Full GC 有什么不同呢？==</h4><p>Minor GC<br>    指发生在新生代的垃圾收集<br>    采用复制算法<br>    频繁<br>Full GC<br>    指发生在老年代的垃圾收集<br>    “标记-清除”或“标记-整理”算法<br>    相比Minor GC没那么频繁</p>
<h4 id="10-Java会存在内存泄漏吗？请简单描述"><a href="#10-Java会存在内存泄漏吗？请简单描述" class="headerlink" title="10.Java会存在内存泄漏吗？请简单描述"></a>10.Java会存在内存泄漏吗？请简单描述</h4><p>简单使用一个hashmap，于是不断往里面放缓存数据，但是很少考虑这个map的容量问题，结果这个缓存map越来越大，一直占用着老年代的很多空间，时间长了就会导致full gc非常频繁，这就是一种内存泄漏<br>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收</p>
<h4 id="11-简述Java垃圾回收机制"><a href="#11-简述Java垃圾回收机制" class="headerlink" title="11.简述Java垃圾回收机制"></a>11.简述Java垃圾回收机制</h4><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。<br>在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p>
<h4 id="12-什么是浮动垃圾"><a href="#12-什么是浮动垃圾" class="headerlink" title="12.什么是浮动垃圾"></a>12.什么是浮动垃圾</h4><p>产生时机<br>    并发标记时，三色算法多标<br>    并发清理时，有对象变成垃圾<br>    这两个时机异曲同工</p>
<h4 id="13-什么是内存碎片？如何解决"><a href="#13-什么是内存碎片？如何解决" class="headerlink" title="13.什么是内存碎片？如何解决"></a>13.什么是内存碎片？如何解决</h4><p>概念<br>    由于不同 Java 对象存活时间是不一定的，因此，在程序运行一段时间以后，如果不进行内存整理，就会出现零散的内存碎片。<br>产生的问题<br>    会导致无法分配大块的内存空间<br>    程序运行效率降低<br>解决<br>    “复制”算法<br>    “标记-整理”算法</p>
<h4 id="14-为什么G1用SATB？CMS用增量更新？"><a href="#14-为什么G1用SATB？CMS用增量更新？" class="headerlink" title="14.为什么G1用SATB？CMS用增量更新？"></a>14.为什么G1用SATB？CMS用增量更新？</h4><p>SATB相对增量更新效率会高(当然SATB可能造成更多的浮动垃圾)，因为不需要在重新标记阶段再次深度扫描 被删除引用对象<br>而CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的region，CMS就一块老年代区域，重新深度扫描对象的话G1的代价会比CMS高<br>所以G1选择SATB不深度扫描对象，只是简单标记，等到下一轮GC 再深度扫描。</p>
<h4 id="15-如何选择垃圾收集器"><a href="#15-如何选择垃圾收集器" class="headerlink" title="==15.如何选择垃圾收集器=="></a>==15.如何选择垃圾收集器==</h4><ol>
<li>优先调整堆的大小让服务器自己来选择 </li>
<li>如果内存小于100M，使用串行收集器 </li>
<li>如果是单核，并且没有停顿时间的要求，串行或JVM自己选择 </li>
<li>如果允许停顿时间超过1秒，选择并行或者JVM自己选 </li>
<li>如果响应时间最重要，并且不能超过1秒，使用并发收集器 </li>
<li>4G以下可以用parallel，4-8G可以用ParNew+CMS，8G以上可以用G1，几百G以上用ZGC</li>
</ol>
<h4 id="16-尽量避免内存泄漏的方法"><a href="#16-尽量避免内存泄漏的方法" class="headerlink" title="16.尽量避免内存泄漏的方法"></a>16.尽量避免内存泄漏的方法</h4><p>1.尽量不要使用 static 成员变量，减少生命周期；<br>2.及时关闭资源；<br>3.不用的对象，可以手动设置为 null。</p>
<h4 id="17-新生代和老年代分别采用什么垃圾回收算法，为什么"><a href="#17-新生代和老年代分别采用什么垃圾回收算法，为什么" class="headerlink" title="==17.新生代和老年代分别采用什么垃圾回收算法，为什么=="></a>==17.新生代和老年代分别采用什么垃圾回收算法，为什么==</h4><p>新生代<br>    复制算法<br>    每次收集都会有大量对象(近99%)死去，只需要付出少量对象的复制成本就可 以完成每次垃圾收集。<br>老年代<br>    “标记-清除”或“标记-整理”算法<br>    老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以不能使用复制算法</p>
<h3 id="调优实战"><a href="#调优实战" class="headerlink" title="调优实战"></a>调优实战</h3><h3 id="真实面试题"><a href="#真实面试题" class="headerlink" title="真实面试题"></a>真实面试题</h3><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/414173543" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/414173543</a></p>
</blockquote>
<h4 id="头条一面-GC"><a href="#头条一面-GC" class="headerlink" title="头条一面(GC)"></a>头条一面(GC)</h4><h5 id="JVM-从-GC-角度看，堆的分区情况"><a href="#JVM-从-GC-角度看，堆的分区情况" class="headerlink" title="JVM 从 GC 角度看，堆的分区情况"></a><strong>JVM 从 GC 角度看，堆的分区情况</strong></h5><h5 id="为什么要将堆内存分为两块而不是直接一个老年代就行？"><a href="#为什么要将堆内存分为两块而不是直接一个老年代就行？" class="headerlink" title="为什么要将堆内存分为两块而不是直接一个老年代就行？"></a><strong>为什么要将堆内存分为两块而不是直接一个老年代就行？</strong></h5><h5 id="那为什么新生代还需要继续细分"><a href="#那为什么新生代还需要继续细分" class="headerlink" title="那为什么新生代还需要继续细分?"></a><strong>那为什么新生代还需要继续细分?</strong></h5><h5 id="Survivor-区会进行垃圾回收吗？"><a href="#Survivor-区会进行垃圾回收吗？" class="headerlink" title="Survivor 区会进行垃圾回收吗？"></a><strong>Survivor 区会进行垃圾回收吗？</strong></h5><h5 id="直接分成1块Eden区和1块s区不行吗？"><a href="#直接分成1块Eden区和1块s区不行吗？" class="headerlink" title="直接分成1块Eden区和1块s区不行吗？"></a><strong>直接分成1块Eden区和1块s区不行吗？</strong></h5><h4 id="美团一面-GC"><a href="#美团一面-GC" class="headerlink" title="美团一面(GC)"></a><strong>美团一面</strong>(GC)</h4><h5 id="说下JVM的垃圾回收算法"><a href="#说下JVM的垃圾回收算法" class="headerlink" title="说下JVM的垃圾回收算法"></a><strong>说下JVM的垃圾回收算法</strong></h5><h4 id="滴滴一面-GC"><a href="#滴滴一面-GC" class="headerlink" title="滴滴一面(GC)"></a><strong>滴滴一面</strong>(GC)</h4><h5 id="你知道哪几种垃圾回收器，各自的优缺点"><a href="#你知道哪几种垃圾回收器，各自的优缺点" class="headerlink" title="你知道哪几种垃圾回收器，各自的优缺点"></a><strong>你知道哪几种垃圾回收器，各自的优缺点</strong></h5><h4 id="字节一面-GC"><a href="#字节一面-GC" class="headerlink" title="字节一面(GC)"></a><strong>字节一面</strong>(GC)</h4><h5 id="CMS回收停顿了几次，为什么要停顿两次"><a href="#CMS回收停顿了几次，为什么要停顿两次" class="headerlink" title="CMS回收停顿了几次，为什么要停顿两次"></a><strong>CMS回收停顿了几次，为什么要停顿两次</strong></h5><h5 id="为什么要STW"><a href="#为什么要STW" class="headerlink" title="为什么要STW"></a><strong>为什么要STW</strong></h5><h5 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a><strong>三色标记算法</strong></h5><h5 id="cms-清理步骤"><a href="#cms-清理步骤" class="headerlink" title="cms 清理步骤"></a><strong>cms 清理步骤</strong></h5><h5 id="cms-为什么要停顿两次"><a href="#cms-为什么要停顿两次" class="headerlink" title="cms 为什么要停顿两次"></a><strong>cms 为什么要停顿两次</strong></h5><h4 id="字节二面-other"><a href="#字节二面-other" class="headerlink" title="字节二面(other)"></a><strong>字节二面</strong>(other)</h4><h5 id="JVM各区域间是如何协同工作的"><a href="#JVM各区域间是如何协同工作的" class="headerlink" title="JVM各区域间是如何协同工作的"></a><strong>JVM各区域间是如何协同工作的</strong></h5><h5 id="堆、栈、方法区之间数据存储怎么协调的"><a href="#堆、栈、方法区之间数据存储怎么协调的" class="headerlink" title="堆、栈、方法区之间数据存储怎么协调的"></a><strong>堆、栈、方法区之间数据存储怎么协调的</strong></h5><h5 id="双亲委派机制了解吗"><a href="#双亲委派机制了解吗" class="headerlink" title="双亲委派机制了解吗"></a><strong>双亲委派机制了解吗</strong></h5><h5 id="内存分配策略了解吗"><a href="#内存分配策略了解吗" class="headerlink" title="内存分配策略了解吗"></a><strong>内存分配策略了解吗</strong></h5><h5 id="为什么要引入元空间"><a href="#为什么要引入元空间" class="headerlink" title="为什么要引入元空间"></a><strong>为什么要引入元空间</strong></h5><h5 id="方法区，元空间，永久代之间关系"><a href="#方法区，元空间，永久代之间关系" class="headerlink" title="方法区，元空间，永久代之间关系"></a><strong>方法区，元空间，永久代之间关系</strong></h5><h5 id="System-gc-和-Runtime-getRuntime-gc-会做什么事情"><a href="#System-gc-和-Runtime-getRuntime-gc-会做什么事情" class="headerlink" title="System.gc() 和 Runtime. getRuntime(). gc()会做什么事情"></a><strong>System.gc() 和 Runtime. getRuntime(). gc()会做什么事情</strong></h5><h4 id="蚂蚁金服一面-GC"><a href="#蚂蚁金服一面-GC" class="headerlink" title="蚂蚁金服一面(GC)"></a><strong>蚂蚁金服一面</strong>(GC)</h4><h5 id="说下G1-收集器"><a href="#说下G1-收集器" class="headerlink" title="说下G1 收集器"></a><strong>说下G1 收集器</strong></h5><h4 id="京东二面-调优"><a href="#京东二面-调优" class="headerlink" title="京东二面(调优)"></a><strong>京东二面</strong>(调优)</h4><h5 id="讲下-jvm-调优思路"><a href="#讲下-jvm-调优思路" class="headerlink" title="讲下 jvm 调优思路"></a><strong>讲下 jvm 调优思路</strong></h5><h4 id="阿里一面-GC"><a href="#阿里一面-GC" class="headerlink" title="阿里一面(GC)"></a><strong>阿里一面</strong>(GC)</h4><h5 id="什么情况下触发垃圾回收"><a href="#什么情况下触发垃圾回收" class="headerlink" title="什么情况下触发垃圾回收"></a><strong>什么情况下触发垃圾回收</strong></h5><h4 id="美团一面-调优"><a href="#美团一面-调优" class="headerlink" title="美团一面(调优)"></a><strong>美团一面</strong>(调优)</h4><h5 id="有在⼯作时间中使⽤过-jstat-jmap-mat⼯具吗？能给⼀个实际的例⼦说明⼀下吗"><a href="#有在⼯作时间中使⽤过-jstat-jmap-mat⼯具吗？能给⼀个实际的例⼦说明⼀下吗" class="headerlink" title="有在⼯作时间中使⽤过 jstat, jmap, mat⼯具吗？能给⼀个实际的例⼦说明⼀下吗"></a><strong>有在⼯作时间中使⽤过 jstat, jmap, mat⼯具吗？能给⼀个实际的例⼦说明⼀下吗</strong></h5><h4 id="问题-GC"><a href="#问题-GC" class="headerlink" title="问题(GC)"></a>问题(GC)</h4><h5 id="增加-Eden-区，Minor-GC-的间隔变长了，会不会导致-Minor-GC-的时间增加"><a href="#增加-Eden-区，Minor-GC-的间隔变长了，会不会导致-Minor-GC-的时间增加" class="headerlink" title="增加 Eden 区，Minor GC 的间隔变长了，会不会导致 Minor GC 的时间增加"></a><strong>增加 Eden 区，Minor GC 的间隔变长了，会不会导致 Minor GC 的时间增加</strong></h5>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql面试题</title>
    <url>/alex-next/2022/10/15/%E9%9D%A2%E8%AF%95%E9%A2%98/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="说一下-MySQL-执行一条查询语句的内部执行过程？"><a href="#说一下-MySQL-执行一条查询语句的内部执行过程？" class="headerlink" title="说一下 MySQL 执行一条查询语句的内部执行过程？"></a>说一下 MySQL 执行一条查询语句的内部执行过程？</h4><ul>
<li>客户端先通过连接器连接到 MySQL 服务器。</li>
<li>连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。</li>
<li>分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。</li>
<li>优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。</li>
<li>优化器执行完就进入执行器，执行器就开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。</li>
</ul>
<p><img alt="1" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Mysql/20230130185311.png"></p>
<h4 id="常用的存储引擎-InnoDB-和-MyISAM-有什么区别？"><a href="#常用的存储引擎-InnoDB-和-MyISAM-有什么区别？" class="headerlink" title="常用的存储引擎 InnoDB 和 MyISAM 有什么区别？"></a>常用的存储引擎 InnoDB 和 MyISAM 有什么区别？</h4><p>InnoDB 和 MyISAM 最大的区别是 InnoDB 支持事务，而 MyISAM 不支持事务，它们主要区别如下：、</p>
<ul>
<li>InnoDB 支持崩溃后安全恢复，MyISAM 不支持崩溃后安全恢复；</li>
<li>InnoDB 支持行级锁，MyISAM 不支持行级锁，只支持到表锁；</li>
<li>InnoDB 支持外键，MyISAM 不支持外键；</li>
<li>MyISAM 性能比 InnoDB 高；</li>
<li>MyISAM 支持 FULLTEXT 类型的全文索引，InnoDB 不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，并且效果更好；</li>
<li>InnoDB 主键查询性能高于 MyISAM。</li>
<li>InnoDB使用的是聚集索引，MyISAM使用的是非聚集索引</li>
</ul>
<h4 id="一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？"><a href="#一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？" class="headerlink" title="一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？"></a>一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？</h4><p>如果这张表的引擎是 MyISAM，那么 ID=4，如果是 InnoDB 那么 ID=2（MySQL 8 之前的版本）。</p>
<h4 id="limit-3-2-的含义是什么？"><a href="#limit-3-2-的含义是什么？" class="headerlink" title="limit 3,2 的含义是什么？"></a>limit 3,2 的含义是什么？</h4><p>去除前三条数据之后查询两条信息。</p>
<h4 id="count-column-和-count-有什么区别？"><a href="#count-column-和-count-有什么区别？" class="headerlink" title="count(column) 和 count(*) 有什么区别？"></a>count(column) 和 count(*) 有什么区别？</h4><p>count(column) 和 count() 最大区别是统计结果可能不一致，count(column) 统计不会统计列值为 null 的数据，而 count() 则会统计所有信息，所以最终的统计结果可能会不同。</p>
<h4 id="在-InnoDB-引擎中-count-、count-1-、count-主键-、count-字段-哪个性能最高？"><a href="#在-InnoDB-引擎中-count-、count-1-、count-主键-、count-字段-哪个性能最高？" class="headerlink" title="在 InnoDB 引擎中 count(*)、count(1)、count(主键)、count(字段) 哪个性能最高？"></a>在 InnoDB 引擎中 count(*)、count(1)、count(主键)、count(字段) 哪个性能最高？</h4><p>count(字段)&lt;count(主键 id)&lt;count(1)≈count(*) 题目解析：</p>
<ul>
<li><p>对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p>
</li>
<li><p>对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p>
</li>
<li><p>对于 count(字段) 来说，如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</p>
</li>
<li><p>对于 count(*) 来说，并不会把全部字段取出来，而是专门做了优化，不取值，直接按行累加。</p>
</li>
</ul>
<p>所以最后得出的结果是：count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)。</p>
<h3 id="索引底层原理"><a href="#索引底层原理" class="headerlink" title="索引底层原理"></a>索引底层原理</h3><h4 id="何为索引？有什么作用"><a href="#何为索引？有什么作用" class="headerlink" title="何为索引？有什么作用"></a>何为索引？有什么作用</h4><p>​    索引是一种能帮助 MySQL 提高查询效率的排好序的数据结构<br>​    索引的作用就相当于书的目录</p>
<h4 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h4><p>​    优点<br>​        ==快速访问数据表中的特定信息，提高检索速度。<br>​        创建唯一性索引，保证数据表中每一行数据的唯一性。==<br>​        加速表与表之间的连接。<br>​        使用分组和排序进行数据检索时，可以显著减少查询中分组和排序的时间<br>​    缺点<br>​        创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。<br>​        索引需要使用物理文件存储，也会耗费一定空间<br>​    ==追问==<br>​        <strong>==使用索引一定能提高查询性能吗==</strong><br>​            大多数情况下，索引查询都是比全表扫描要快的。<br>​            但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升</p>
<h4 id="为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键？"><a href="#为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键？" class="headerlink" title="为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键？"></a>为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键？</h4><p>​    为什么必须要有主键<br>​        如果设置了主键，就会使用主键作为聚集索引。<br>​        如果你没有创建主键，他会寻找一个不为null的字段作为主键索引。<br>​        如果还是没有则会隐式的创建一个字段作为主键。<br>​    为什么使用整型<br>​        1.整型比较比字符串要快，因为字符串要逐个比较ASCII值，节省硬盘空间；整型容易比较大小进行排序<br>​    为什么要求自增<br>​        mysql为了维护索引的有序性，使得新增的主键会在B+tree叶子节点中最后末尾添加，使得树分叉概率变小<br>​        换句话说，如果不是自增的，B+树会自己做调整，分裂出新节点，效率不如自增</p>
<h4 id="为什么非主键索引结构叶子节点存储的是主键值？"><a href="#为什么非主键索引结构叶子节点存储的是主键值？" class="headerlink" title="为什么非主键索引结构叶子节点存储的是主键值？"></a>为什么非主键索引结构叶子节点存储的是主键值？</h4><p>​    1.节省存储空间<br>​    2.一致性：若非主键索引也存了完整的数据记录，那么非主键索引和主键索引的索引文件要保证数据一致性的问题</p>
<h4 id="B树和B-树区别"><a href="#B树和B-树区别" class="headerlink" title="==B树和B+树区别=="></a>==B树和B+树区别==</h4><p>​    共同点<br>​        节点中的数据索引从左到右递增排列<br>​    B树所有节点都存索引和数据，B+树只有叶子结点存数据<br>​    B+树叶子结点用指针连接<br>​        与范围查找相关如rol&gt;20:B+树可以顺着找到的结点找下去，而B树只能从根节点重新找<br>​    按照B树，一个结点1KB的数据，一页能放16个结点，树的高度要远远大于3</p>
<h4 id="为什么用B-树不用B树"><a href="#为什么用B-树不用B树" class="headerlink" title="==为什么用B+树不用B树=="></a>==为什么用B+树不用B树==</h4><p>​    按照B树，一个结点1KB的数据，一页能放16个结点，树的高度要远远大于3<br>​    与范围查找相关，如rol&gt;20:B+树可以顺着找到的结点找下去，而B树只能从根节点重新找</p>
<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="什么是前缀索引？"><a href="#什么是前缀索引？" class="headerlink" title="什么是前缀索引？"></a>什么是前缀索引？</h4><p>前缀索引也叫局部索引，比如给身份证的前 10 位添加索引，类似这种给某列部分信息添加索引的方式叫做前缀索引。</p>
<h4 id="为什么要用前缀索引？"><a href="#为什么要用前缀索引？" class="headerlink" title="为什么要用前缀索引？"></a>为什么要用前缀索引？</h4><p>前缀索引能有效减小索引文件的大小，让每个索引页可以保存更多的索引值，从而提高了索引查询的速度。但前缀索引也有它的缺点，不能在 order by 或者 group by 中触发前缀索引，也不能把它们用于覆盖索引。</p>
<h4 id="什么情况下适合使用前缀索引？"><a href="#什么情况下适合使用前缀索引？" class="headerlink" title="什么情况下适合使用前缀索引？"></a>什么情况下适合使用前缀索引？</h4><p>当字符串本身可能比较长，而且前几个字符就开始不相同，适合使用前缀索引；相反情况下不适合使用前缀索引，比如，整个字段的长度为 20，索引选择性为 0.9，而我们对前 10 个字符建立前缀索引其选择性也只有 0.5，那么我们需要继续加大前缀字符的长度，但是这个时候前缀索引的优势已经不明显，就没有创建前缀索引的必要了。</p>
<h4 id="以下-or-查询有什么问题吗？该如何优化？"><a href="#以下-or-查询有什么问题吗？该如何优化？" class="headerlink" title="以下 or 查询有什么问题吗？该如何优化？"></a>以下 or 查询有什么问题吗？该如何优化？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where num=10 or num=20;</span><br></pre></td></tr></table></figure>
<p>答：如果使用 or 查询会使 MySQL 放弃索引而全表扫描，可以改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where num=10 union select * from t where num=20;</span><br></pre></td></tr></table></figure>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务是什么？"><a href="#事务是什么？" class="headerlink" title="事务是什么？"></a>事务是什么？</h4><p>事务是一系列的数据库操作，是数据库应用的基本单位。MySQL 事务主要用于处理操作量大，复杂度高的数据。</p>
<h4 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h4><p>在 MySQL 中只有 InnDB 引擎支持事务，它的四个特性如下：</p>
<ul>
<li>原子性（Atomic）：要么全部执行，要么全部不执行；</li>
<li>一致性（Consistency）：事务的执行使得数据库从一种正确状态转化为另一种正确状态；</li>
<li>隔离性（Isolation）：在事务正确提交之前，不允许把该事务对数据的任何改变提供给其他事务；</li>
<li>持久性（Durability）：事务提交后，其结果永久保存在数据库中。</li>
</ul>
<p>==原子性，持久性侧重于研究事务本身不同，隔离性研究的是不同事务之间的相互影响。==</p>
<p>ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。</p>
<h4 id="并发事务一般有哪些问题？"><a href="#并发事务一般有哪些问题？" class="headerlink" title="并发事务一般有哪些问题？"></a>并发事务一般有哪些问题？</h4><ul>
<li><p>更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题，最后的更新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本，每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。 最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改，如果在前一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题。</p>
</li>
<li><p>脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务完成并提交前， 这条记录的数据就处于不一致状态； 这时， 另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些脏数据，并据此做进一步的处理，就会产生未提交的数据依赖关系，这种现象被形象地叫做脏读。</p>
</li>
<li><p>不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读” 。</p>
</li>
<li><p>幻读（Phantom Reads）： 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读” 。</p>
</li>
</ul>
<h4 id="MySQL-中有几种事务隔离级别？分别是什么？"><a href="#MySQL-中有几种事务隔离级别？分别是什么？" class="headerlink" title="MySQL 中有几种事务隔离级别？分别是什么？"></a>MySQL 中有几种事务隔离级别？分别是什么？</h4><p>MySQL 中有四种事务隔离级别，它们分别是：</p>
<ul>
<li><p>read uncommited：未提交读，读到未提交数据；</p>
</li>
<li><p>read committed：读已提交，也叫不可重复读，两次读取到的数据不一致；</p>
</li>
<li><p>repetable read：可重复读；</p>
</li>
<li><p>serializable：串行化，读写数据都会锁住整张表，数据操作不会出错，但并发性能极低，开发中很少用到。</p>
</li>
</ul>
<p>==MySQL 默认使用 REPEATABLE-READ 的事务隔离级别。==</p>
<h4 id="幻读和不可重复读的区别？"><a href="#幻读和不可重复读的区别？" class="headerlink" title="幻读和不可重复读的区别？"></a>幻读和不可重复读的区别？</h4><ul>
<li>不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）。</li>
<li>幻读的重点在于新增或者删除：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）。</li>
</ul>
<h4 id="并发事务有什么问题-隔离性-？应该如何解决？"><a href="#并发事务有什么问题-隔离性-？应该如何解决？" class="headerlink" title="==并发事务有什么问题(隔离性)？应该如何解决？=="></a>==并发事务有什么问题(隔离性)？应该如何解决？==</h4><p>并发事务可能造成：脏读、不可重复读和幻读等问题 ，这些问题其实都是数据库读一致性问题，==必须由数据库提供一定的事务隔离机制来解决==，解决方案如下：</p>
<ul>
<li>加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。</li>
<li>提供数据多版本并发控制（MultiVersion Concurrency Control，简称 MVCC 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取，从用户的角度来看，好象是数据库可以提供同一数据的多个版本。</li>
</ul>
<h4 id="什么是-MVCC？"><a href="#什么是-MVCC？" class="headerlink" title="什么是 MVCC？"></a>什么是 MVCC？</h4><p>MVCC 全称是多版本并发控制系统，InnoDB 和 Falcon 存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决幻读问题。</p>
<h4 id="MVCC-是怎么工作的？-事务隔离性的实现原理"><a href="#MVCC-是怎么工作的？-事务隔离性的实现原理" class="headerlink" title="MVCC 是怎么工作的？(事务隔离性的实现原理)"></a>MVCC 是怎么工作的？(事务隔离性的实现原理)</h4><blockquote>
<p>==在读已提交和可重复读隔离级别下实现==</p>
<p>自己的总结：MVCC机制的实现就是通过read-view机制与undo版本链比对机制，使得不同的事务会根据数据版本链对比规则读取 同一条数据在版本链上的不同版本数据。</p>
<p>read view机制：这个视图由执行查询时所有未提交事务id数组（数组里最小的id为min_id）和已创建的最大事务id（max_id）组成，事务里的任何sql查询结果需要从对应 版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。</p>
</blockquote>
<p>InnoDB 的 MVCC 是通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动新增，事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较。</p>
<h4 id="MySQL-事务实现原理是什么？"><a href="#MySQL-事务实现原理是什么？" class="headerlink" title="MySQL 事务实现原理是什么？"></a>MySQL 事务实现原理是什么？</h4><p><a href="https://blog.csdn.net/weixin_43337246/article/details/117968344" target="_blank" rel="noopener">事务的ACID实现原理</a></p>
<p>事务的实现是基于数据库的存储引擎，不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有InnoDB 和 NDB。 InnoDB 是高版本 MySQL 的默认的存储引擎，因此就以 InnoDB 的事务实现为例，InnoDB 是通过多版本并发控制（MVCC，Multiversion Concurrency Control ）解决不可重复读问题，加上间隙锁（也就是并发控制）解决幻读问题。因此 InnoDB 的 RR 隔离级别其实实现了串行化级别的效果，而且保留了比较好的并发性能。事务的隔离性是通过锁实现，==而事务的原子性、一致性和持久性则是通过事务日志实现==。</p>
<p>原子性：InnoDB能够实现回滚的主要原因就是靠undo log： 当事务对数据库进行修改的时候，InnoDB会生成对应的undo log ；如果此时事务执行失败或者调动了 rollback，导致事务出现回滚情况，可以利用undo log中的信息将数据回滚到修改前的样子。</p>
<p>持久性：BufferPool缓存机制+redo log + binlog</p>
<p>一致性：一致性是事物追求的最终目标，前面提到的原子性，隔离性，持久性都是为了保证数据库的一致性。此外除了数据库底层的保障，一致性的实现也需要应用层的保障。数据库通过原子性、隔离性、持久性来保证一致性。</p>
<p>隔离性：MVCC解决写+读；解锁解决写+写</p>
<h4 id="REPEATABLE-READ（可重读）隔离级别下-MVCC-如何工作？"><a href="#REPEATABLE-READ（可重读）隔离级别下-MVCC-如何工作？" class="headerlink" title="REPEATABLE READ（可重读）隔离级别下 MVCC 如何工作？"></a>REPEATABLE READ（可重读）隔离级别下 MVCC 如何工作？</h4><ul>
<li>SELECT：InnoDB 会根据以下条件检查每一行记录：第一，InnoDB 只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行要么是在开始事务之前已经存在要么是事务自身插入或者修改过的。第二，行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除。</li>
<li>INSERT：InnoDB 为新插入的每一行保存当前系统版本号作为行版本号。</li>
<li>DELETE：InnoDB 为删除的每一行保存当前系统版本号作为行删除标识。</li>
<li>UPDATE：InnoDB 为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识保存这两个版本号，使大多数操作都不用加锁。它不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。</li>
</ul>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h4 id="redo-log-和-binlog-有什么区别？"><a href="#redo-log-和-binlog-有什么区别？" class="headerlink" title="redo log 和 binlog 有什么区别？"></a>redo log 和 binlog 有什么区别？</h4><p>redo log（重做日志）和 binlog（归档日志）都是 MySQL 的重要的日志，它们的区别如下：</p>
<ul>
<li><p>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”。</p>
</li>
<li><p>binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</p>
</li>
<li><p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p>
</li>
<li><p>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p>
</li>
</ul>
<p>最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统，也就是 redo log 来实现 crash-safe 能力。</p>
<h4 id="如何解决-bin-log-与-redo-log-的一致性问题？"><a href="#如何解决-bin-log-与-redo-log-的一致性问题？" class="headerlink" title="==如何解决 bin log 与 redo log 的一致性问题？=="></a>==如何解决 bin log 与 redo log 的一致性问题？==</h4><p>其实就是BufferBool那一块的内容</p>
<p>所谓两阶段提交，其实就是把 redo log 的写入拆分成了两个步骤：prepare 和 commit。<br>首先，存储引擎将执行更新好的新数据存到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 <code>prepare</code> 状态。然后告知执行器执行完成了，随时可以提交事务<br>然后执行器生成这个操作的 bin log，并把 bin log 写入磁盘<br>最后执行器调用存储引擎的提交事务接口，存储引擎把刚刚写入的 redo log 状态改成提交（<code>commit</code>）状态，更新完成</p>
<p>如果数据库在写入 redo log(prepare) 阶段之后、写入 binlog 之前，发生了崩溃：<br>此时 redo log 里面的事务处于 prepare 状态，binlog 还没写，之后从库进行同步的时候，无法执行这个操作，但是实际上主库已经完成了这个操作，所以为了主备一致，MySQL 崩溃时会在主库上回滚这个事务<br>而如果数据库在写入 binlog 之后，redo log 状态修改为 commit 前发生崩溃，此时 redo log 里面的事务仍然是 prepare 状态，binlog 存在并完整，这样之后就会被从库同步过去，但是实际上主库并没有完成这个操作，所以为了主备一致，即使在这个时刻数据库崩溃了，主库上事务仍然会被正常提交。</p>
<p><img alt="img" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Mysql/20230130202826.png"></p>
<h4 id="一条-SQL-更新语句是如何执行的？"><a href="#一条-SQL-更新语句是如何执行的？" class="headerlink" title="一条 SQL 更新语句是如何执行的？"></a>一条 SQL 更新语句是如何执行的？</h4><p>同上</p>
<h4 id="讲一下-redo-log-redo-log-两阶段提交原理"><a href="#讲一下-redo-log-redo-log-两阶段提交原理" class="headerlink" title="讲一下 redo log / redo log 两阶段提交原理"></a>讲一下 redo log / redo log 两阶段提交原理</h4><p>同上</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="MySQL-的优化手段都有哪些？"><a href="#MySQL-的优化手段都有哪些？" class="headerlink" title="MySQL 的优化手段都有哪些？"></a>MySQL 的优化手段都有哪些？</h4><p>MySQL 的常见的优化手段有以下五种：</p>
<h5 id="①-查询优化"><a href="#①-查询优化" class="headerlink" title="① 查询优化"></a>① 查询优化</h5><ul>
<li><p>避免 SELECT *，只查询需要的字段。</p>
</li>
<li><p>小表驱动大表，即小的数据集驱动大的数据集，比如，当 B 表的数据集小于 A 表时，用 in 优化 exist，两表执行顺序是先查 B 表，再查 A 表，查询语句：select * from A where id in (select id from B) 。</p>
</li>
<li><p>一些情况下，可以使用连接代替子查询，因为使用 join 时，MySQL 不会在内存中创建临时表。</p>
</li>
</ul>
<h5 id="②-优化索引的使用"><a href="#②-优化索引的使用" class="headerlink" title="② 优化索引的使用"></a>② 优化索引的使用</h5><ul>
<li><p>尽量使用主键查询，而非其他索引，因为主键查询不会触发回表查询。</p>
</li>
<li><p>不做列运算，把计算都放入各个业务系统实现</p>
</li>
<li><p>查询语句尽可能简单，大语句拆小语句，减少锁时间</p>
</li>
<li><p>不使用 select * 查询</p>
</li>
<li><p>or 查询改写成 in 查询</p>
</li>
<li><p>不用函数和触发器</p>
</li>
<li><p>避免 %xx 查询</p>
</li>
<li><p>少用 join 查询</p>
</li>
<li><p>使用同类型比较，比如 ‘123’ 和 ‘123’、123 和 123</p>
</li>
<li><p>尽量避免在 where 子句中使用 != 或者 &lt;&gt; 操作符，查询引用会放弃索引而进行全表扫描</p>
</li>
<li><p>列表数据使用分页查询，每页数据量不要太大</p>
</li>
<li><p>用 exists 替代 in 查询</p>
</li>
<li><p>避免在索引列上使用 is null 和 is not null</p>
</li>
<li><p>尽量使用主键查询</p>
</li>
<li><p>避免在 where 子句中对字段进行表达式操作</p>
</li>
<li><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型</p>
</li>
</ul>
<h5 id="③-表结构设计优化"><a href="#③-表结构设计优化" class="headerlink" title="③ 表结构设计优化"></a>③ 表结构设计优化</h5><ul>
<li><p>使用可以存下数据最小的数据类型。</p>
</li>
<li><p>使用简单的数据类型，int 要比 varchar 类型在 MySQL 处理简单。</p>
</li>
<li><p>尽量使用 tinyint、smallint、mediumint 作为整数类型而非 int。</p>
</li>
<li><p>尽可能使用 not null 定义字段，因为 null 占用 4 字节空间。</p>
</li>
<li><p>尽量少用 text 类型，非用不可时最好考虑分表。</p>
</li>
<li><p>尽量使用 timestamp，而非 datetime。</p>
</li>
<li><p>单表不要有太多字段，建议在 20 个字段以内。</p>
</li>
</ul>
<h5 id="④-表拆分"><a href="#④-表拆分" class="headerlink" title="④ 表拆分"></a>④ 表拆分</h5><p>当数据库中的数据非常大时，查询优化方案也不能解决查询速度慢的问题时，我们可以考虑拆分表，让每张表的数据量变小，从而提高查询效率。 <strong>a）垂直拆分</strong>：是指数据表列的拆分，把一张列比较多的表拆分为多张表，比如，用户表中一些字段经常被访问，将这些字段放在一张表中，另外一些不常用的字段放在另一张表中，插入数据时，使用事务确保两张表的数据一致性。 垂直拆分的原则：</p>
<ul>
<li><p>把不常用的字段单独放在一张表；</p>
</li>
<li><p>把 text，blob 等大字段拆分出来放在附表中；</p>
</li>
<li><p>经常组合查询的列放在一张表中。</p>
</li>
</ul>
<p><strong>b）水平拆分</strong>：指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。</p>
<p>通常情况下，我们使用取模的方式来进行表的拆分，比如，一张有 400W 的用户表 users，为提高其查询效率我们把其分成 4 张表 users1，users2，users3，users4，然后通过用户 ID 取模的方法，同时查询、更新、删除也是通过取模的方法来操作。</p>
<h5 id="⑤-读写分离"><a href="#⑤-读写分离" class="headerlink" title="⑤ 读写分离"></a>⑤ 读写分离</h5><p>一般情况下对数据库而言都是“读多写少”，换言之，数据库的压力多数是因为大量的读取数据的操作造成的，我们可以采用数据库集群的方案，使用一个库作为主库，负责写入数据；其他库为从库，负责读取数据。这样可以缓解对数据库的访问压力。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ学习记录</title>
    <url>/alex-next/2021/08/12/%E9%9D%A2%E8%AF%95%E9%A2%98/RabbitMQ%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC面试题</title>
    <url>/alex-next/2022/12/24/%E9%9D%A2%E8%AF%95%E9%A2%98/SpringMVC%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="67-如何解决get-post乱码问题"><a href="#67-如何解决get-post乱码问题" class="headerlink" title="67.如何解决get/post乱码问题"></a>67.如何解决get/post乱码问题</h3><p>​    确保前端没问题<br>​    post请求乱码问题<br>​        配置CharacterEncodingFilter过滤器</p>
<p><img alt="43" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125203418.png"></p>
<p>​    get中文乱码</p>
<p><img alt="44" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125203426.png"></p>
<h3 id="68-SpringMVC的控制器是不是单例模式，如果是，有什么问题，怎么解决"><a href="#68-SpringMVC的控制器是不是单例模式，如果是，有什么问题，怎么解决" class="headerlink" title="68.SpringMVC的控制器是不是单例模式，如果是，有什么问题，怎么解决"></a>68.SpringMVC的控制器是不是单例模式，如果是，有什么问题，怎么解决</h3><p>​    Q.17,18<br>​    默认单例<br>​    如果声明在类成员变量中<br>​        如果在类中声明成员变量，并且有读写操作(有状态)，线程不安全，但是成员变量声明在方法中(无状态)，单例bean是安全的<br>​    解决<br>​        1.设置为多例<br>​            每个线程都会创建不同的对象<br>​        2.成员变量放到ThreadLocal中<br>​            成员变量会绑定在各自的线程上，不共享<br>​        3.同步锁synchronized<br>​            并行变成了串行，会影响系统吞吐量<br>​    题外话<br>​        HttpServletRequest HttpSession  Spring底层已经放到IOC容器里了，可以直接自动注入</p>
<h3 id="69-描述SpringMVC的工作流程-DispatcherServlet的工作流程"><a href="#69-描述SpringMVC的工作流程-DispatcherServlet的工作流程" class="headerlink" title="==69.描述SpringMVC的工作流程(DispatcherServlet的工作流程)=="></a>==69.描述SpringMVC的工作流程(DispatcherServlet的工作流程)==</h3><p>​    1.请求到DispatcherServlet<br>​    2.请求处理器映射器HandlerMapping<br>​        返回映射器执行链(包含拦截器)<br>​    3.HandlerAdapter<br>​        因为controller多种实现方式<br>​    4.handler真正调用后端方法<br>​        返回ModelAndView<br>​    5.请求视图解析器ViewReslover，动态拼接.html，.jsp等<br>​        返回view<br>​    6.解析视图(jsp，thymeleaf)<br>​    7.响应给用户<br>​    参考</p>
<p><img alt="46" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125203651.png"></p>
<p>​    图解</p>
<p><img alt="45" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125204154.png"></p>
<h3 id="70-SpringMVC中处理ajax请求原理"><a href="#70-SpringMVC中处理ajax请求原理" class="headerlink" title="==70.SpringMVC中处理ajax请求原理=="></a>==70.SpringMVC中处理ajax请求原理==</h3><p>​    1.加入Jackson.jar<br>​    2.配置json的消息转换器HttpMessageConverter接口<br>​    3.接收ajax方法上加@ResponseBody<br>​    图解</p>
<p><img alt="47" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125203654.png"></p>
<p>​        请求的是json，就直接返回了，viewReslover和解析视图都没有<br>​    参考</p>
<p><img alt="48" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125204206.png"></p>
<h3 id="71-Spring和SpringMVC为什么需要父子容器"><a href="#71-Spring和SpringMVC为什么需要父子容器" class="headerlink" title="==71.Spring和SpringMVC为什么需要父子容器=="></a>==71.Spring和SpringMVC为什么需要父子容器==</h3><p>​    划分框架边界<br>​    规范整体架构(SSM)<br>​    方便子容器的切换<br>​    为了节省重复bean创建<br>​        两个子容器依赖父容器，bean创建到父容器<br>​    参考</p>
<p><img alt="49" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125204428.png"></p>
<h3 id="72-是否可以把SpringMVC所有Bean交给Spring容器管理"><a href="#72-是否可以把SpringMVC所有Bean交给Spring容器管理" class="headerlink" title="72.是否可以把SpringMVC所有Bean交给Spring容器管理"></a>72.是否可以把SpringMVC所有Bean交给Spring容器管理</h3><p>​    如果交给父容器管理，处理器映射器HandlerMapping初始化时候会根据beanDefinition解析@RequestMapping，并没有调用父容器的getBean，就找不到对应的HandlerMethod<br>​    参考</p>
<p><img alt="50" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125204549.png"></p>
<h3 id="73-是否可以吧Spring的Bean都交给SpringMVC管理"><a href="#73-是否可以吧Spring的Bean都交给SpringMVC管理" class="headerlink" title="73.是否可以吧Spring的Bean都交给SpringMVC管理"></a>73.是否可以吧Spring的Bean都交给SpringMVC管理</h3><p>​    可以，因为子容器可以获取父容器，而父容器拿不到子容器的bean<br>​    参考</p>
<p><img alt="51" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125204617.png"></p>
<h3 id="74-如何实现零配置的SpringMVC，原理是什么"><a href="#74-如何实现零配置的SpringMVC，原理是什么" class="headerlink" title="==74.如何实现零配置的SpringMVC，原理是什么=="></a>==74.如何实现零配置的SpringMVC，原理是什么==</h3><p>​    零配置<br>​        无web.xml，spring.xml，spring-mvc.xml<br>​    实现<br>​        省略web.xml<br>​            1.Servlet3.0后<br>​                @WebServlet<br>​                @WebListener<br>​                @WebFilter<br>​            ==2.使用SPI==<br>​        省略spring.xml和springmvc.xml<br>​            自定义一个类实现AbstractAnnotationConfigDispatcherServletInitializer，此类实现了WebApplicationInitializer，在里面配置spring和springmvc配置类的位置<br>​    参考代码<br>​        spring-tuling-webmvc<br>​        spring-web<br>​    参考</p>
<p><img alt="52" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125204646.png"></p>
<h3 id="75-SpringMVC的拦截器和过滤器有什么区别，执行顺序"><a href="#75-SpringMVC的拦截器和过滤器有什么区别，执行顺序" class="headerlink" title="==75.SpringMVC的拦截器和过滤器有什么区别，执行顺序=="></a>==75.SpringMVC的拦截器和过滤器有什么区别，执行顺序==</h3><p>​    区别</p>
<p><img alt="53" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125204950.png"></p>
<p>​    执行顺序<br>​        filter<br>​        servlet<br>​        interceptor<br>​        controller<br>​        依次进来，依次出去</p>
<p><img alt="54" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125205001.png"></p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis面试题</title>
    <url>/alex-next/2023/01/13/%E9%9D%A2%E8%AF%95%E9%A2%98/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="1-为什么要用-Redis-为什么要用缓存？"><a href="#1-为什么要用-Redis-为什么要用缓存？" class="headerlink" title="1.为什么要用 Redis/为什么要用缓存？"></a>1.为什么要用 Redis/为什么要用缓存？</h4><p><strong>高性能</strong></p>
<p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。</p>
<p><strong>这样有什么好处呢？</strong> 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p>
<p><strong>高并发</strong></p>
<p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。</p>
<h4 id="2-Redis-除了做缓存，还能做什么？"><a href="#2-Redis-除了做缓存，还能做什么？" class="headerlink" title="2.Redis 除了做缓存，还能做什么？"></a>2.Redis 除了做缓存，还能做什么？</h4><p><strong>分布式锁</strong> ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：<a href="https://javaguide.cn/distributed-system/distributed-lock.html" target="_blank" rel="noopener">分布式锁详解open in new window</a> 。</p>
<p><strong>限流</strong> ：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：<a href="https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA" target="_blank" rel="noopener">《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》open in new window</a>。</p>
<p><strong>消息队列</strong> ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</p>
<p><strong>复杂业务场景</strong> ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="1-Redis-常用的数据结构有哪些？"><a href="#1-Redis-常用的数据结构有哪些？" class="headerlink" title="1.Redis 常用的数据结构有哪些？"></a>1.Redis 常用的数据结构有哪些？</h4><ul>
<li><strong>5 种基础数据结构</strong> ：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li>
<li><strong>3 种特殊数据结构</strong> ：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</li>
</ul>
<h4 id="2-String-的应用场景有哪些？"><a href="#2-String-的应用场景有哪些？" class="headerlink" title="2.String 的应用场景有哪些？"></a>2.String 的应用场景有哪些？</h4><ul>
<li>常规数据（比如 session、token、、序列化后的对象）的缓存；</li>
<li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li>
<li>分布式锁(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)；</li>
</ul>
<h4 id="3-String-还是-Hash-存储对象数据更好呢？"><a href="#3-String-还是-Hash-存储对象数据更好呢？" class="headerlink" title="3.String 还是 Hash 存储对象数据更好呢？"></a>3.String 还是 Hash 存储对象数据更好呢？</h4><ul>
<li>String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</li>
<li>String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</li>
</ul>
<p>在绝大部分情况，我们建议使用 String 来存储对象数据即可！</p>
<h4 id="4-购物车信息用-String-还是-Hash-存储更好呢"><a href="#4-购物车信息用-String-还是-Hash-存储更好呢" class="headerlink" title="4.购物车信息用 String 还是 Hash 存储更好呢?"></a>4.购物车信息用 String 还是 Hash 存储更好呢?</h4><p>由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：</p>
<ul>
<li>用户 id 为 key</li>
<li>商品 id 为 field，商品数量为 value</li>
</ul>
<p><img alt="3" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Redis/20230131143501.png"><br>操作<br>    添加商品：hset cart:1001 10088 1<br>    增加数量：hincrby cart:1001 10088 1<br>    商品总数：hlen cart:1001<br>    删除商品：hdel cart:1001 10088<br>    获取购物车所有商品：hgetall cart:1001</p>
<h4 id="5-使用-Redis-实现一个排行榜怎么做？"><a href="#5-使用-Redis-实现一个排行榜怎么做？" class="headerlink" title="5.使用 Redis 实现一个排行榜怎么做？"></a>5.使用 Redis 实现一个排行榜怎么做？</h4><p>Redis 中有一个叫做 <code>sorted set</code> 的数据结构经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</p>
<p>相关的一些 Redis 命令: <code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</p>
<p><img alt="8" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Redis/20230131143757.png"></p>
<h4 id="6-使用-Set-实现抽奖系统需要用到什么命令？"><a href="#6-使用-Set-实现抽奖系统需要用到什么命令？" class="headerlink" title="6.使用 Set 实现抽奖系统需要用到什么命令？"></a>6.使用 Set 实现抽奖系统需要用到什么命令？</h4><ul>
<li><code>SPOP key count</code> ： 随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li>
<li><code>SRANDMEMBER key count</code> : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li>
</ul>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><h4 id="1-Redis是单线程吗"><a href="#1-Redis是单线程吗" class="headerlink" title="1.Redis是单线程吗"></a>1.Redis是单线程吗</h4><p>​    Redis 的单线程主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外 提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</p>
<h4 id="2-Redis不是单线程为什么还能这么快"><a href="#2-Redis不是单线程为什么还能这么快" class="headerlink" title="2.Redis不是单线程为什么还能这么快"></a>2.Redis不是单线程为什么还能这么快</h4><p>​    因为它所有数据都在内存中，所有的运算都是内存级别的运算</p>
<h4 id="3-Redis-单线程如何处理那么多的并发客户端连接"><a href="#3-Redis-单线程如何处理那么多的并发客户端连接" class="headerlink" title="3.Redis 单线程如何处理那么多的并发客户端连接"></a>3.Redis 单线程如何处理那么多的并发客户端连接</h4><p>​    NIO多路复用<br>​        redis利用epoll来实现IO多路复用，将连接信息和事件放到队列中，依次放到 文件事件分派器，事件分派器将事件分发给事件处理器</p>
<p><img alt="10" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Redis/20230131144326.png"></p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="1-Redis-给缓存数据设置过期时间有啥用？"><a href="#1-Redis-给缓存数据设置过期时间有啥用？" class="headerlink" title="1.Redis 给缓存数据设置过期时间有啥用？"></a>1.Redis 给缓存数据设置过期时间有啥用？</h4><p>1.<strong>有助于缓解内存的消耗</strong></p>
<p>2.自动判断过期数据并删除，比传统数据库要方便</p>
<h4 id="2-过期的数据的删除策略了解么？"><a href="#2-过期的数据的删除策略了解么？" class="headerlink" title="2.过期的数据的删除策略了解么？"></a>2.过期的数据的删除策略了解么？</h4><p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p>
<p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p>
<ol>
<li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ol>
<p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p>
<p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p>
<p>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制。</strong></p>
<h4 id="3-Redis-内存淘汰机制了解么？"><a href="#3-Redis-内存淘汰机制了解么？" class="headerlink" title="3.Redis 内存淘汰机制了解么？"></a>3.Redis 内存淘汰机制了解么？</h4><blockquote>
<p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p>
</blockquote>
<p>Redis 提供 6 种数据淘汰策略：</p>
<p><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p>
<p><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p>
<p><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p>
<p><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</p>
<p><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</p>
<p><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</p>
<p>4.0 版本后增加以下两种：</p>
<p><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</p>
<p><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</p>
<h3 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h3><h4 id="1-怎么保证-Redis-挂掉之后再重启数据可以进行恢复"><a href="#1-怎么保证-Redis-挂掉之后再重启数据可以进行恢复" class="headerlink" title="1.怎么保证 Redis 挂掉之后再重启数据可以进行恢复"></a>1.怎么保证 Redis 挂掉之后再重启数据可以进行恢复</h4><h4 id="2-什么是-RDB-持久化？"><a href="#2-什么是-RDB-持久化？" class="headerlink" title="2.什么是 RDB 持久化？"></a>2.什么是 RDB 持久化？</h4><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p>快照持久化是 Redis 默认采用的持久化方式，在 <code>redis.conf</code> 配置文件中默认有此下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br></pre></td></tr></table></figure>
<h4 id="3-RDB-创建快照时会阻塞主线程吗？"><a href="#3-RDB-创建快照时会阻塞主线程吗？" class="headerlink" title="3.RDB 创建快照时会阻塞主线程吗？"></a>3.RDB 创建快照时会阻塞主线程吗？</h4><p>Redis 提供了两个命令来生成 RDB 快照文件：</p>
<ul>
<li><code>save</code> : 主线程执行，会阻塞主线程；</li>
<li><code>bgsave</code> : 子线程执行，不会阻塞主线程，默认选项。</li>
</ul>
<h4 id="4-什么是-AOF-持久化？"><a href="#4-什么是-AOF-持久化？" class="headerlink" title="4.什么是 AOF 持久化？"></a>4.什么是 AOF 持久化？</h4><p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p>
<p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code></p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appendfsync always    <span class="comment">#每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span></span><br><span class="line">appendfsync everysec  <span class="comment">#每秒钟同步一次，显式地将多个写命令同步到硬盘</span></span><br><span class="line">appendfsync no        <span class="comment">#让操作系统决定何时进行同步</span></span><br></pre></td></tr></table></figure>
<p>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<h4 id="5-AOF-日志是如何实现的？"><a href="#5-AOF-日志是如何实现的？" class="headerlink" title="5.AOF 日志是如何实现的？"></a>5.AOF 日志是如何实现的？</h4><p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。</p>
<p><img alt="AOF 记录日志过程" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Redis/20230131155723.png"></p>
<p><strong>为什么是在执行完命令之后记录日志呢？</strong></p>
<ul>
<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>
<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>
</ul>
<p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p>
<ul>
<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>
<li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li>
</ul>
<h4 id="6-如何选择-RDB-和-AOF？"><a href="#6-如何选择-RDB-和-AOF？" class="headerlink" title="6.如何选择 RDB 和 AOF？"></a>6.如何选择 RDB 和 AOF？</h4><p>关于 RDB 和 AOF 的优缺点，官网上面也给了比较详细的说明<a href="https://redis.io/docs/manual/persistence/" target="_blank" rel="noopener">Redis persistenceopen in new window</a>，这里结合自己的理解简单总结一下。</p>
<p><strong>RDB 比 AOF 优秀的地方</strong> ：</p>
<ul>
<li>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会必 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</li>
<li>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。</li>
</ul>
<p><strong>AOF 比 RDB 优秀的地方</strong> ：</p>
<ul>
<li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li>
<li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。</li>
<li>AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li>
</ul>
<h4 id="7-AOF-重写了解吗？"><a href="#7-AOF-重写了解吗？" class="headerlink" title="7.AOF 重写了解吗？"></a>7.AOF 重写了解吗？</h4><p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p>
<p>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p>
<p>在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p>
<p>Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="1-什么是-bigkey？有什么危害？怎么发现？如何解决？"><a href="#1-什么是-bigkey？有什么危害？怎么发现？如何解决？" class="headerlink" title="1.什么是 bigkey？有什么危害？怎么发现？如何解决？"></a>1.什么是 bigkey？有什么危害？怎么发现？如何解决？</h4><p><strong>是什么</strong>：简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。：</p>
<p><strong>危害</strong>：除了会消耗更多的内存空间，bigkey 对性能也会有比较大的影响。因此，我们应该尽量避免写入 bigkey！</p>
<p><strong>发现</strong>：</p>
<blockquote>
<p> <strong>1、使用 Redis 自带的 <code>--bigkeys</code> 参数来查找。</strong></p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;  C:\Users\alex&gt;redis-cli --bigkeys</span><br><span class="line">&gt;  </span><br><span class="line">&gt;  <span class="comment"># Scanning the entire keyspace to find biggest keys as well as</span></span><br><span class="line">&gt;  <span class="comment"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span></span><br><span class="line">&gt;  <span class="comment"># per 100 SCAN commands (not usually needed).</span></span><br><span class="line">&gt;  </span><br><span class="line">&gt;  [00.00%] Biggest string found so far <span class="string">'zhuge10'</span> with 2 bytes</span><br><span class="line">&gt;  [00.00%] Biggest string found so far <span class="string">'groupLeapfrog'</span> with 478 bytes</span><br><span class="line">&gt;  [62.50%] Biggest string found so far <span class="string">'storeLeapfrog'</span> with 555 bytes</span><br><span class="line">&gt;  </span><br><span class="line">&gt;  -------- summary -------</span><br><span class="line">&gt;  </span><br><span class="line">&gt;  Sampled 16 keys <span class="keyword">in</span> the keyspace!</span><br><span class="line">&gt;  Total key length <span class="keyword">in</span> bytes is 120 (avg len 7.50)</span><br><span class="line">&gt;  </span><br><span class="line">&gt;  Biggest string found <span class="string">'storeLeapfrog'</span> has 555 bytes</span><br><span class="line">&gt;  </span><br><span class="line">&gt;  0 lists with 0 items (00.00% of keys, avg size 0.00)</span><br><span class="line">&gt;  0 hashs with 0 fields (00.00% of keys, avg size 0.00)</span><br><span class="line">&gt;  16 strings with 1053 bytes (100.00% of keys, avg size 65.81)</span><br><span class="line">&gt;  0 streams with 0 entries (00.00% of keys, avg size 0.00)</span><br><span class="line">&gt;  0 sets with 0 members (00.00% of keys, avg size 0.00)</span><br><span class="line">&gt;  0 zsets with 0 members (00.00% of keys, avg size 0.00)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p> 从这个命令的运行结果，我们可以看出：这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构 top 1 bigkey（占用内存最大的 string 数据类型，包含元素最多的复合数据类型）。</p>
<p> <strong>2、分析 RDB 文件</strong></p>
<p> 通过分析 RDB 文件来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。</p>
<p> 网上有现成的代码/工具可以直接拿来使用：</p>
<ul>
<li><a href="https://github.com/sripathikrishnan/redis-rdb-tools" target="_blank" rel="noopener">redis-rdb-toolsopen in new window</a> ：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li>
<li><a href="https://github.com/weiyanwei412/rdb_bigkeys" target="_blank" rel="noopener">rdb_bigkeysopen in new window</a> : Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li>
</ul>
</blockquote>
<h4 id="2-大量-key-集中过期问题"><a href="#2-大量-key-集中过期问题" class="headerlink" title="2.大量 key 集中过期问题"></a>2.大量 key 集中过期问题</h4><p>我在上面提到过：对于过期 key，Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 策略。</p>
<p>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</p>
<p>如何解决呢？下面是两种常见的方法：</p>
<p>1.给 key 设置随机过期时间。</p>
<p>2.开启 lazy-free（惰性删除/延迟释放）。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</p>
<p>个人建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间。</p>
<h3 id="生产问题"><a href="#生产问题" class="headerlink" title="生产问题"></a>生产问题</h3><h4 id="1-什么是缓存穿透？解决方法？"><a href="#1-什么是缓存穿透？解决方法？" class="headerlink" title="1.什么是缓存穿透？解决方法？"></a>1.什么是缓存穿透？解决方法？</h4><p>含义：缓存穿透说简单点就是大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<p>示意图：</p>
<p><img alt="缓存穿透" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Redis/20230131225232.png"></p>
<p>产生原因：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p>
<p>解决方法：最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<p><strong>1）缓存无效 key</strong></p>
<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p>
<p>如果用 Java 代码展示的话，差不多是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInclNullById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    Object cacheValue = cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        Object storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2）布隆过滤器</strong></p>
<blockquote>
<p>对于恶意攻击，向服务器请求大量不存在的数据造成的缓存穿透，还可以用布隆过滤器先做一次过滤，对于不</p>
<p>存在的数据布隆过滤器一般都能够过滤掉，不让请求再往后端发送。当布隆过滤器说<strong>某个值存在时，这个值可</strong></p>
<p><strong>能不存在；当它说不存在时，那就肯定不存在。</strong></p>
</blockquote>
<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p>加入布隆过滤器之后的缓存处理流程图如下。</p>
<p><img alt="加入布隆过滤器之后的缓存处理流程图" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Redis/20230201110610.png"></p>
<p><strong>布隆过滤器的原理</strong>：</p>
<p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p>
<p>1.使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</p>
<p>2.根据得到的哈希值，在位数组中把对应下标的值置为 1。</p>
<p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p>
<p>1.对给定元素再次进行相同的哈希计算；</p>
<p>2.得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p>
<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率。</p>
<h4 id="2-什么是缓存击穿？怎么解决？"><a href="#2-什么是缓存击穿？怎么解决？" class="headerlink" title="2.什么是缓存击穿？怎么解决？"></a>2.什么是缓存击穿？怎么解决？</h4><p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<p><img alt="缓存击穿" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Redis/20230201142053.png"></p>
<p>举个例子 ：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p>
<h5 id="有哪些解决办法？"><a href="#有哪些解决办法？" class="headerlink" title="有哪些解决办法？"></a>有哪些解决办法？</h5><ul>
<li>设置热点数据永不过期或者过期时间比较长。</li>
<li>针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>
<li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。</li>
</ul>
<h4 id="3-缓存穿透和缓存击穿有什么区别？"><a href="#3-缓存穿透和缓存击穿有什么区别？" class="headerlink" title="3.缓存穿透和缓存击穿有什么区别？"></a>3.缓存穿透和缓存击穿有什么区别？</h4><p>缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。</p>
<p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。</p>
<h4 id="4-什么是缓存雪崩？解决方法？"><a href="#4-什么是缓存雪崩？解决方法？" class="headerlink" title="4.什么是缓存雪崩？解决方法？"></a>4.什么是缓存雪崩？解决方法？</h4><p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>
<p>另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p>
<p><img alt="缓存雪崩" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Redis/20230201142448.png"></p>
<p>举个例子 ：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p>
<h5 id="有哪些解决办法？-1"><a href="#有哪些解决办法？-1" class="headerlink" title="有哪些解决办法？"></a>有哪些解决办法？</h5><p><strong>针对 Redis 服务不可用的情况：</strong></p>
<p>1.采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</p>
<p>2.限流，避免同时处理大量的请求。</p>
<p><strong>针对热点缓存失效的情况：</strong></p>
<p>==1.设置不同的失效时间比如随机设置缓存的失效时间。==</p>
<p>2.缓存永不失效（不太推荐，实用性太差）。</p>
<p>3.设置二级缓存。</p>
<h4 id="5-缓存雪崩和缓存击穿有什么区别？"><a href="#5-缓存雪崩和缓存击穿有什么区别？" class="headerlink" title="5.缓存雪崩和缓存击穿有什么区别？"></a>5.缓存雪崩和缓存击穿有什么区别？</h4><p>缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期）。</p>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><h4 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis Sentinel"></a><strong>Redis Sentinel</strong></h4><h5 id="什么是-Sentinel？-有什么用？"><a href="#什么是-Sentinel？-有什么用？" class="headerlink" title="什么是 Sentinel？ 有什么用？"></a>什么是 Sentinel？ 有什么用？</h5><h5 id="Sentinel-如何检测节点是否下线？主观下线与客观下线的区别"><a href="#Sentinel-如何检测节点是否下线？主观下线与客观下线的区别" class="headerlink" title="Sentinel 如何检测节点是否下线？主观下线与客观下线的区别?"></a>Sentinel 如何检测节点是否下线？主观下线与客观下线的区别?</h5><h5 id="Sentinel-是如何实现故障转移的？"><a href="#Sentinel-是如何实现故障转移的？" class="headerlink" title="Sentinel 是如何实现故障转移的？"></a>Sentinel 是如何实现故障转移的？</h5><h5 id="为什么建议部署多个-sentinel-节点（哨兵集群）？"><a href="#为什么建议部署多个-sentinel-节点（哨兵集群）？" class="headerlink" title="为什么建议部署多个 sentinel 节点（哨兵集群）？"></a>为什么建议部署多个 sentinel 节点（哨兵集群）？</h5><h5 id="Sentinel-如何选择出新的-master（选举机制）"><a href="#Sentinel-如何选择出新的-master（选举机制）" class="headerlink" title="Sentinel 如何选择出新的 master（选举机制）?"></a>Sentinel 如何选择出新的 master（选举机制）?</h5><h5 id="如何从-Sentinel-集群中选择出-Leader-？"><a href="#如何从-Sentinel-集群中选择出-Leader-？" class="headerlink" title="如何从 Sentinel 集群中选择出 Leader ？"></a>如何从 Sentinel 集群中选择出 Leader ？</h5><h5 id="Sentinel-可以防止脑裂吗？"><a href="#Sentinel-可以防止脑裂吗？" class="headerlink" title="Sentinel 可以防止脑裂吗？"></a>Sentinel 可以防止脑裂吗？</h5><h4 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a><strong>Redis Cluster</strong></h4><h5 id="为什么需要-Redis-Cluster？解决了什么问题？有什么优势？"><a href="#为什么需要-Redis-Cluster？解决了什么问题？有什么优势？" class="headerlink" title="为什么需要 Redis Cluster？解决了什么问题？有什么优势？"></a>为什么需要 Redis Cluster？解决了什么问题？有什么优势？</h5><h5 id="Redis-Cluster-是如何分片的？"><a href="#Redis-Cluster-是如何分片的？" class="headerlink" title="Redis Cluster 是如何分片的？"></a>Redis Cluster 是如何分片的？</h5><h5 id="为什么-Redis-Cluster-的哈希槽是-16384-个"><a href="#为什么-Redis-Cluster-的哈希槽是-16384-个" class="headerlink" title="为什么 Redis Cluster 的哈希槽是 16384 个?"></a>为什么 Redis Cluster 的哈希槽是 16384 个?</h5><h5 id="如何确定给定-key-的应该分布到哪个哈希槽中？"><a href="#如何确定给定-key-的应该分布到哪个哈希槽中？" class="headerlink" title="如何确定给定 key 的应该分布到哪个哈希槽中？"></a>如何确定给定 key 的应该分布到哪个哈希槽中？</h5><h5 id="Redis-Cluster-支持重新分配哈希槽吗？"><a href="#Redis-Cluster-支持重新分配哈希槽吗？" class="headerlink" title="Redis Cluster 支持重新分配哈希槽吗？"></a>Redis Cluster 支持重新分配哈希槽吗？</h5><h5 id="Redis-Cluster-扩容缩容期间可以提供服务吗？"><a href="#Redis-Cluster-扩容缩容期间可以提供服务吗？" class="headerlink" title="Redis Cluster 扩容缩容期间可以提供服务吗？"></a>Redis Cluster 扩容缩容期间可以提供服务吗？</h5><h5 id="Redis-Cluster-中的节点是怎么进行通信的？"><a href="#Redis-Cluster-中的节点是怎么进行通信的？" class="headerlink" title="Redis Cluster 中的节点是怎么进行通信的？"></a>Redis Cluster 中的节点是怎么进行通信的？</h5>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot面试题</title>
    <url>/alex-next/2022/12/24/%E9%9D%A2%E8%AF%95%E9%A2%98/Springboot%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="76-谈谈你对SpringBoot的理解，它有哪些特性"><a href="#76-谈谈你对SpringBoot的理解，它有哪些特性" class="headerlink" title="76.谈谈你对SpringBoot的理解，它有哪些特性"></a>76.谈谈你对SpringBoot的理解，它有哪些特性</h3><p>​    快速开发Spring应用的脚手架，简化Spring的初始搭建及配置<br>​    1.无配置集成，开箱即用<br>​    2.基于JavaConfig<br>​    3.内置Web容器，无需web.xml，jar文件就能启动web应用<br>​    4.管理了第三方依赖版本，减少版本冲突<br>​    5.自带监控功能<br>​    参考</p>
<p><img alt="55" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125205315.png"></p>
<h3 id="77-Spring和SpringBoot的关系和区别"><a href="#77-Spring和SpringBoot的关系和区别" class="headerlink" title="77.Spring和SpringBoot的关系和区别"></a>77.Spring和SpringBoot的关系和区别</h3><p>​    关系<br>​        Springboot是Spring生态的产品<br>​    Spring Framework<br>​        是一个容器框架<br>​    Springboot是一个快速开发Spring的脚手架</p>
<h3 id="78-Springboot的核心注解"><a href="#78-Springboot的核心注解" class="headerlink" title="78.Springboot的核心注解"></a>78.Springboot的核心注解</h3><p>​    @SpringBootApplication<br>​        @SpringBootConfiguration<br>​        @EnableAutoConfiguration<br>​    @Conditional<br>​        @ConditionalOnBean<br>​        @ConditionalOnClass<br>​        @ConditionalExpression<br>​        @ConditionalOnMissingBean<br>​    参考</p>
<p><img alt="56" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125205344.png"></p>
<h3 id="79-Springboot的自动配置原理"><a href="#79-Springboot的自动配置原理" class="headerlink" title="==79.Springboot的自动配置原理=="></a>==79.Springboot的自动配置原理==</h3><p>​    1.@SpringBootApplication<br>​        导入@SpringBootConfiguration标注当前类是配置类<br>​        导入@EnableAutoConfiguration，自动配置<br>​    2.@EnableAutoConfiguation引入了@Import<br>​    3.Spring容器启动(SpringBoot.run)加载IOC容器会解析@Import注解<br>​    4.@Import导入了一个DeferredImportSelector<br>​        会使Springboot的自动配置类顺序在最后，方便我们扩展和覆盖<br>​            @ConditionalOnBean<br>​                配置了某个Bean，就帮我们把剩下的组件配置好<br>​            @ConditionalOnMissingBean<br>​                如果我们没有配置，就自动帮我们配置，如DispatcherServlet<br>​    5.读取所有/META-INF/spring.factories文件(类似API)<br>​    6.过滤出所有AutoConfigurationClass(初筛)<br>​    7.通过@Conditional排除无效的自动配置类</p>
<h3 id="80-为什么SpringBoot的jar可以直接运行"><a href="#80-为什么SpringBoot的jar可以直接运行" class="headerlink" title="==80.为什么SpringBoot的jar可以直接运行=="></a>==80.为什么SpringBoot的jar可以直接运行==</h3><p>​    1.spring-boot-maven-plugin可以把程序打包成一个可执行的jar包<br>​    2.打包后，生成了一个Fat jar，包含了应用以来的jar包和Springboot loader相关的类<br>​    3.java -jar会去jar中(jvm规范)找MANIFEST.MF，找真正的启动类(Main-Class)<br>​    4.Fat jar的启动函数是JarLauncher，它负责创建一个LaunchedURLClassLoader来加载lib下面的jar，并以一个新线程去启动应用启动类的Main函数(MANIFEST.MF中的Start-Class)</p>
<h3 id="81-SpringBoot的启动原理"><a href="#81-SpringBoot的启动原理" class="headerlink" title="==81.SpringBoot的启动原理=="></a>==81.SpringBoot的启动原理==</h3><p>​    1.运行main方法，构造函数初始化信息，从spring.factories读取监听器，初始化器<br>​    2.运行run方法，读取环境变量、配置信息<br>​    3.创建springApplication上下文：ServletWebServerApplicationContext<br>​    4,预初始化上下文<br>​        将启动类作为配置类进行读取，将配置注册为BeanDefinition<br>​    5.调用refresh加载ioc容器<br>​        invokeBeanFactoryBeanProcessor<br>​            @Import加载所有自动配置类<br>​        onRefresh：常见内置servlet容器<br>​    6.在这个过程中springboot会调用很多监听器对外进行扩展</p>
<h3 id="82-SpringBoot内置Tomcat原理"><a href="#82-SpringBoot内置Tomcat原理" class="headerlink" title="==82.SpringBoot内置Tomcat原理=="></a>==82.SpringBoot内置Tomcat原理==</h3><p>​    1.依赖spring-boot-starter-web依赖会在Springboot中添加ServletWebServerFactoryAutoConfiguration   servlet自动配置类<br>​    2.该自动配置类通过@Import导入了一个Web容器工厂(默认tomcat)<br>​    3.在加载IOC容器时，解析@Import，onRefresh(会拿到tomcat容器工厂)创建内置tomcat并启动<br>​        new tomcat()<br>​        启动tomcat<br>​        挂起线程<br>​    SpringMVC中的DispatcherServlet也是自动配置类导入进来的</p>
<h3 id="83-SpringBoot外部tomcat启动原理"><a href="#83-SpringBoot外部tomcat启动原理" class="headerlink" title="==83.SpringBoot外部tomcat启动原理=="></a>==83.SpringBoot外部tomcat启动原理==</h3><p>​    SPI<br>​        当servlet容器启动时候，就会去META-INF/services 文件夹中找到javax.servlet.ServletContainerInitializer<br>​        执行官方的SpringServletContainerInitializer(继承了ServletContainerInitializer)<br>​        执行自己的SpringBootServletInitializer#onStartup(继承了WebApplicationInitializer)<br>​            启动SpringBoot</p>
<h3 id="84-自定义Starter的过程"><a href="#84-自定义Starter的过程" class="headerlink" title="==84.自定义Starter的过程=="></a>==84.自定义Starter的过程==</h3><p>​    导入spring-boot-configuration-processor，配置文件绑定就会有提示<br>​        可以自定义XXXProperties文件，外部使用就能直接配置在.properties，.yml文件中<br>​    自定义XXXAutoCOnfiguration自动导入(开启)配置类<br>​    一定要在resources文件夹下创建META/spring.factories指定自动配置类<br>​    maven install</p>
<h3 id="85-SpringBoot读取配置文件原理是什么，加载顺序是怎样的"><a href="#85-SpringBoot读取配置文件原理是什么，加载顺序是怎样的" class="headerlink" title="85.SpringBoot读取配置文件原理是什么，加载顺序是怎样的"></a>85.SpringBoot读取配置文件原理是什么，加载顺序是怎样的</h3><p>​    通过事件监听的方式读取配置文件<br>​        ConfigFIleApplicationListener监听器<br>​    读取顺序<br>​        file:./config<br>​            file:路径就是项目的target文件夹:../target/<br>​        file:./config/{@literal *}<br>​            /target/config/xxx/        任意文件夹<br>​        file:./<br>​        classpath:config/<br>​        classpath:<br>​        细节<br>​            优先级从高到低，高优先级没有可以从低优先级互补</p>
<h3 id="86-SpringBoot默认日志实现框架是什么，怎么切换成别的"><a href="#86-SpringBoot默认日志实现框架是什么，怎么切换成别的" class="headerlink" title="86.SpringBoot默认日志实现框架是什么，怎么切换成别的"></a>86.SpringBoot默认日志实现框架是什么，怎么切换成别的</h3><p>​    ==默认实现框架==<br>​        logback<br>​        参考</p>
<p><img alt="57" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125210316.png"></p>
<p>​            log4j到logback原理<br>​                1.log4j-api通过log4j-to-slf4j适配器转换为slf4j<br>​                2.slf4j通过logback-classic桥接器最终使用logback输出<br>​        springboot默认提供了jul和log4j到slf4j的适配器<br>​    ==怎么切换==<br>​        切换为log4j2<br>​            添加slf4j对应的桥接器<br>​                排除logback桥接器<br>​                加入log4j2桥接器<br>​                参考</p>
<p><img alt="58" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125210416.png"></p>
<p>​        切换为log4j<br>​            排除logback桥接器<br>​            加入log4j的桥接器<br>​            参考</p>
<p><img alt="59" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125210421.png"></p>
<h3 id="87-平时开发的时候怎么在SpringBoot的基础上做扩展"><a href="#87-平时开发的时候怎么在SpringBoot的基础上做扩展" class="headerlink" title="87.平时开发的时候怎么在SpringBoot的基础上做扩展"></a>87.平时开发的时候怎么在SpringBoot的基础上做扩展</h3><p>​    查看XXXAutoConfiguration<br>​        重点关注@ConditionalOnXXX<br>​    深入看源码</p>
<h3 id="88-微服务架构的优缺点"><a href="#88-微服务架构的优缺点" class="headerlink" title="88.微服务架构的优缺点"></a>88.微服务架构的优缺点</h3><p>​    优点<br>​        分工协作<br>​            提高开发效率和敏捷性<br>​            单个服务启动快<br>​            专人处理专事，专注自己的服务<br>​        并发能力<br>​            充分利用服务器资源(并发量高的模块多部署几台服务器)<br>​        维护能力<br>​            根据功能垂直拆分，责任更加分明，维护更加精准<br>​        容错<br>​            弱依赖的服务出现故障，可以进行熔断(隔离)依然不影响主业务正常使用<br>​        扩展<br>​            新服务可以采用任意新技术<br>​    缺点<br>​        ==分布式==<br>​            分布式系统较难编程(远程调用速度很慢，并且总是面临失败的风险)，对开发人员技术要求高<br>​        ==最终一致性==<br>​            对于分布式系统，保持强一致性非常困难，所以每个人都必须管理最终一致性<br>​        ==运维复杂度==<br>​        隐式接口<br>​            服务和服务通过接口来联系，当一个服务更改接口格式时，所有涉及此接口的服务都要做调整<br>​        重复劳动<br>​            很多服务用到同一功能，但这一功能并没有大到提供一个服务的程度，不同服务团队都会单独开发这一功能</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring面试题</title>
    <url>/alex-next/2022/11/28/%E9%9D%A2%E8%AF%95%E9%A2%98/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.processon.com/view/link/5f5075c763768959e2d109df" target="_blank" rel="noopener">spring笔记整体脑图</a></p>
<p><a href="https://www.processon.com/view/link/5f18298a7d9c0835d38a57c0" target="_blank" rel="noopener">bean定义注册流程</a></p>
<p><a href="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124162059.jpg" target="_blank" rel="noopener">springioc加载整体流程图</a></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="1-谈谈你理解的Spring是什么"><a href="#1-谈谈你理解的Spring是什么" class="headerlink" title="1.谈谈你理解的Spring是什么"></a>1.谈谈你理解的Spring是什么</h4><p>​    不止是IOC和AOP的容器框架，Spring还是一个生态圈<br>​        生态圈<br>​            springboot<br>​            spring集成的各种框架<br>​        <a href="https://blog.csdn.net/weixin_37711738/article/details/90020123" target="_blank" rel="noopener">IOC</a><br>​            控制反转：将对象的控制权交给spring，把应用从复杂的对象依赖关系管理中解放出来<br>​        AOP<br>​            无缝地给方法增强<br>​    标准答案</p>
<p><img alt="1" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124155639.png"></p>
<h4 id="2-Spring的优缺点是什么"><a href="#2-Spring的优缺点是什么" class="headerlink" title="2.Spring的优缺点是什么"></a>2.Spring的优缺点是什么</h4><p>​    思路<br>​        先总结Spring的特性：IOC、AOP、声明式事务、集成框架、JDBCTemplate、restTemplate(远程调用)、邮件(JavaMail)、异步调用<br>​    优点<br>​        IOC<br>​            集中管理了对象，是对象和对象之间的耦合性降低，更方便地维护对象(如：以前单例需要使用设计模式、懒加载)<br>​        AOP<br>​            不修改代码的情况下，对业务代码进行增强，减少重复代码，提高开发效率，维护方便<br>​        声明式事务<br>​            只需要@Transactional，提高开发效率<br>​        方便程序测试<br>​            结合junit非常方便测试<br>​        方便集成各种框架<br>​            拥有非常强大的粘合度、集成能力非常强，只需要简单配置就可以集成第三方框架<br>​        降低JAVAEE API使用难度<br>​            简化开发，封装了很多代码<br>​        java源码学习范例<br>​            Spring底层实现：反射、设计模式值得学习<br>​    缺点<br>​        应用层面没有缺点<br>​        简化开发，如果想深入底层了解非常困难<br>​        源码缺点：由于spring大而全，代码量非常庞大，一百多万行，想深入源码带来一定困难</p>
<h4 id="3-什么是SpringIOC容器，有什么用，优点是什么"><a href="#3-什么是SpringIOC容器，有什么用，优点是什么" class="headerlink" title="3.什么是SpringIOC容器，有什么用，优点是什么"></a>3.什么是SpringIOC容器，有什么用，优点是什么</h4><p>​    IOC<br>​        控制反转：原来需要new，耦合度高，不方便维护，引入IOC将创建对象的控制权交给Spring<br>​        现在如果要使用，只需要DI(依赖注入)@Autowired就可以使用对象了<br>​    优点<br>​        集中管理了对象，方便维护。降低耦合度</p>
<h4 id="4-IOC的实现机制是什么"><a href="#4-IOC的实现机制是什么" class="headerlink" title="==4.IOC的实现机制是什么=="></a>==4.IOC的实现机制是什么==</h4><p>​    工厂+反射<br>​        简单工厂：beanFactory.getBean，只有简单工厂需要一个一个if</p>
<p><img alt="2" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124155946.png">            </p>
<p>​        反射的方式</p>
<p><img alt="3" data-src="E:\desktop\自学\MyNote\面试题\spring图\3.png"></p>
<h4 id="5-IOC和DI的区别是什么"><a href="#5-IOC和DI的区别是什么" class="headerlink" title="5.IOC和DI的区别是什么"></a>5.IOC和DI的区别是什么</h4><p>​    IOC<br>​        控制反转：原来需要new，耦合度高，不方便维护，引入IOC将创建对象的控制权交给Spring<br>​        现在如果要使用，只需要DI(依赖注入)@Autowired就可以使用对象了<br>​        是一种设计思想<br>​    DI<br>​        DI是实现IOC的重要一环<br>​    bean和对象<br>​        对象是自己new的，bean是IOC里的</p>
<h4 id="6-紧耦合和松耦合有什么区别？如何编写松耦合代码"><a href="#6-紧耦合和松耦合有什么区别？如何编写松耦合代码" class="headerlink" title="6.紧耦合和松耦合有什么区别？如何编写松耦合代码"></a>6.紧耦合和松耦合有什么区别？如何编写松耦合代码</h4><p>​    紧耦合<br>​        类之间高度依赖<br>​    松耦合<br>​        松耦合是通过促进单一职责和接口分离、依赖倒置的设计原则来实现<br>​        单一职责</p>
<p><img alt="4" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124162413.png">        接口分离</p>
<p><img alt="5" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124162418.png">        </p>
<p>​    依赖倒置</p>
<p><img alt="6" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124162407.png"></p>
<h4 id="9-BeanFactory和ApplicationContext有什么区别"><a href="#9-BeanFactory和ApplicationContext有什么区别" class="headerlink" title="==9.BeanFactory和ApplicationContext有什么区别=="></a>==9.BeanFactory和ApplicationContext有什么区别==</h4><p>​    共同点<br>​        都可以作为容器，管理bean的生命周期<br>​    不同点<br>​        ApplicationContext相当于是4s店，不生产bean，而BeanFactory是工厂<br>​        ApplicationContext做的事情更多<br>​            会帮我们配置的bean注册进来<br>​            加载环境变量<br>​            支持国际化<br>​            事件监听<br>​            注册对外扩展点</p>
<h4 id="10-BeanFactory和FactoryBean有什么区别"><a href="#10-BeanFactory和FactoryBean有什么区别" class="headerlink" title="==10.BeanFactory和FactoryBean有什么区别=="></a>==10.BeanFactory和FactoryBean有什么区别==</h4><p>​    beanFactory是一个工厂，bean容器，管理bean的生命周期<br>​    FactoryBean是一个bean，由beanFactory生产管理<br>​        它是一个特殊的bean，是一个接口<br>​        使用FactoryBean#getObject()获取FactoryBean产生的对象，相当于工厂设计模式<br>​        细节<br>​            想要获取原本的实例，可以加上“&amp;”<br>​            被FactoryBean修饰后，会变成懒加载</p>
<h4 id="13-什么是Spring-Bean，JavaBean和SpringBean和对象的区别"><a href="#13-什么是Spring-Bean，JavaBean和SpringBean和对象的区别" class="headerlink" title="13.什么是Spring Bean，JavaBean和SpringBean和对象的区别"></a>13.什么是Spring Bean，JavaBean和SpringBean和对象的区别</h4><p>​    SpringBean<br>​        被Spring管理的对象<br>​    JavaBean<br>​        java的实体类</p>
<h4 id="14-配置Bean有哪几种方式"><a href="#14-配置Bean有哪几种方式" class="headerlink" title="14.配置Bean有哪几种方式"></a>14.配置Bean有哪几种方式</h4><p>​    xml<br>​    @Component(@Controller,@Service,@Repository)<br>​        前提：配置@Component-scan<br>​        Spring帮我们使用反射调用构造方法<br>​    @Bean<br>​        可以自己控制实例化过程<br>​    @Import<br>​        三种方式<br>​            ImportSelector接口<br>​            ImportBeanDefinitionRegistrar接口<br>​            @ImportResource<br>​        ==可以批量导入，可以导入不在扫描范围内的Bean==</p>
<h4 id="15-Spring支持的Bean的作用域"><a href="#15-Spring支持的Bean的作用域" class="headerlink" title="15.Spring支持的Bean的作用域"></a>15.Spring支持的Bean的作用域</h4><p>​    @Scope<br>​        单例<br>​        多例<br>​        request<br>​            一个请求创建一个bean<br>​        session<br>​            一次会话创建一个bean<br>​        application<br>​            一个全局应用共享一个bean<br>​        request、session和application在web应用才有<br>​    类比<a href="https://blog.csdn.net/ning_576555615/article/details/48494785" target="_blank" rel="noopener">JavaWeb四大作用域</a></p>
<h4 id="16-单例Bean的优势"><a href="#16-单例Bean的优势" class="headerlink" title="16.单例Bean的优势"></a>16.单例Bean的优势</h4><p>​    单例设计模式优势同<br>​    性能优势<br>​        减少生成实例消耗<br>​            spring通过反射或cglib生成bean<br>​            分配对象内存<br>​        减少jvm垃圾<br>​        能够快速从缓存中获取bean<br>​    参考答案</p>
<p><img alt="12" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124193641.png"></p>
<h4 id="17-Spring的bean是线程安全吗"><a href="#17-Spring的bean是线程安全吗" class="headerlink" title="==17.Spring的bean是线程安全吗=="></a>==17.Spring的bean是线程安全吗==</h4><p>​    单例bean的情况<br>​        如果在类中声明成员变量，并且有读写操作(有状态)，线程不安全，但是成员变量声明在方法中(无状态)，单例bean是安全的</p>
<h4 id="18-Spring如何处理线程并发问题"><a href="#18-Spring如何处理线程并发问题" class="headerlink" title="==18.Spring如何处理线程并发问题=="></a>==18.Spring如何处理线程并发问题==</h4><p>​    接Q.17<br>​    1.设置为多例<br>​        每个线程都会创建不同的对象<br>​    2.成员变量放到ThreadLocal中<br>​        成员变量会绑定在各自的线程上，不共享<br>​    3.同步锁synchronized<br>​        并行变成了串行，会影响系统吞吐量</p>
<h4 id="33-Spring有哪几种配置方式"><a href="#33-Spring有哪几种配置方式" class="headerlink" title="33.Spring有哪几种配置方式"></a>33.Spring有哪几种配置方式</h4><p>​    1.xml<br>​        spring诞生就有的<br>​        spring-xml  <bean><br>​    2.注解<br>​        Spring2.5<br>​        spring.xml  <component-scan>  @Component  @Autowired<br>​    3.java配置<br>​        javaConfig  Spring3.0+<br>​        @Configuration  @Bean</component-scan></bean></p>
<h4 id="34-JavaConfig是如何替代spring-xml的"><a href="#34-JavaConfig是如何替代spring-xml的" class="headerlink" title="==34.JavaConfig是如何替代spring.xml的=="></a>==34.JavaConfig是如何替代spring.xml的==</h4><p>​    应用<br>​        xml<br>​            ClassPathXmlApplicationContext<br>​            spring.xml<br>​            <bean scope lazy><br>​            <component-scan><br>​            引入外部属性配置文件<br>​                <contetx:property-placeholder location="db.properties"><br>​            <property value="${password}"><br>​            <import>指定其他配置文件<br>​        javaconfig<br>​            AnnotationConfigApplicationContext<br>​            @Configuration<br>​            @Bean @Scope @Lazy<br>​            @ComponentScan<br>​            @PropertySource(“classpath:db.properties”)<br>​            @Value(“${password}”)<br>​            @Import比较灵活<br>​    源码<br>​        Q.28<br>​        BeanFactory.getBean是一样的<br>​        参考</import></property></contetx:property-placeholder></component-scan></bean></p>
<p><img alt="25" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124194042.png"></p>
<h4 id="42-Configuration的作用及解析原理"><a href="#42-Configuration的作用及解析原理" class="headerlink" title="==42.@Configuration的作用及解析原理=="></a>==42.@Configuration的作用及解析原理==</h4><p>​    1.代替spring.xml配置文件<br>​    2.没有@Configuration也可以配置@Bean<br>​    ==3.@Configuration加与不加有什么区别==<br>​        加了@Configuration会为配置类创建Cglib代理，保证配置类@Bean方法调用Bean的单例，@Bean方法的调用就会通过getBean获取    </p>
<p>​    <img alt="28" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124210616.png"></p>
<p>​    原理<br>​        1.创建Spring上下文会注册ConfigurationClassPostProcessor<br>​        2.调用invokeBeanFactoryPostProcessors,就会调用ConfigurationClassPostProcessor就会解析各种注解(@Component，@Bean)<br>​        3.ConfigurationClassPostProcessor#postProcessBeanFactory会给配置类创建cglib动态代理</p>
<p><img alt="6" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124211115.png"></p>
<h4 id="64-Spring事件监听机制"><a href="#64-Spring事件监听机制" class="headerlink" title="64.Spring事件监听机制"></a>64.Spring事件监听机制</h4><p>​    观察者模式<br>​        事件<br>​        监听器<br>​        多播器<br>​    异步事件<br>​        多线程</p>
<h4 id="65-Spring中都用到了哪些设计模式"><a href="#65-Spring中都用到了哪些设计模式" class="headerlink" title="==65.Spring中都用到了哪些设计模式=="></a>==65.Spring中都用到了哪些设计模式==</h4><p>​    简单工厂<br>​        Beanfactory.getBean<br>​    工厂方法<br>​        FactoryBean.getObject<br>​    单例模式<br>​        Bean实例<br>​    适配器模式<br>​        SpringMVC的HandlerAdapter<br>​    装饰器模式<br>​        BeanWrapper<br>​    代理模式<br>​        AOP、事务<br>​    观察者模式<br>​        事件监听<br>​    策略模式<br>​        excludeFilters、includeFilters    @ComponentScan<br>​    模板方法模式<br>​        Spring几乎所有外接扩展(beanPostProcessor)<br>​    责任链模式<br>​        AOP、事务调用</p>
<h4 id="66-Spring是如何整合Mybatis管理Mapper接口的"><a href="#66-Spring是如何整合Mybatis管理Mapper接口的" class="headerlink" title="66.Spring是如何整合Mybatis管理Mapper接口的"></a>66.Spring是如何整合Mybatis管理Mapper接口的</h4><p>​    ==难点：给Mapper接口加上@Component由于注册BeanDefinition时不会注册接口类(参考解析@Component)且生产bean的时候也不会去生产接口的实例==<br>​    1.Mybatis提供mapper的jdk动态代理<br>​        注册BeanDefinition时不会注册接口类<br>​    2.实现BeanDefinitionRegistryPostProcessor动态注册BeanDefinition<br>​    3.实现自定义扫描器，重写ClassPathBeanDefinitionScanner排除接口的方法(isCandidateComponent)<br>​        批量扫描BeanDefinition<br>​    4.修改BeanDefinition的BeanClass替换为JDK动态代理实例(FactoryBean);偷天换日<br>​        生产bean的时候也不会去生产接口的实例<br>​    5.通过FactoryBean的工厂方法设计模式自由控制bean的实例化过程(getObject)<br>​<br>​    ==Spring注册BeanDefinition时不会注册接口类==</p>
<p>​    参考</p>
<p>​    <img alt="42" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124201403.png"></p>
<h3 id="IOC加载流程"><a href="#IOC加载流程" class="headerlink" title="IOC加载流程"></a>IOC加载流程</h3><h4 id="11-SpringIOC容器的加载过程"><a href="#11-SpringIOC容器的加载过程" class="headerlink" title="==11.SpringIOC容器的加载过程=="></a>==11.SpringIOC容器的加载过程==</h4><p>​    其实就是Bean的创建过程<br>​    new ApplicationContext()<br>​    invokeBeanFactoryPostProcessors<br>​        扫描包(@Component,@Import,@ComponentScan)，解析类信息，使用BeanDefinition存储类信息，注册为bean定义<br>​        使用beanDefinitionMap缓存起来<br>​    国际化、扩展点、监听器<br>​    finishBeanFactoryInitialization<br>​        判断是否符合生产标准<br>​            是单例<br>​            不是懒加载<br>​            不是抽象类<br>​        推断构造方法(spring通过构造方法反射)<br>​        通过反射实例化对象(纯静态)<br>​        需要属性赋值，则注入属性(@Autowired,@ByName…)<br>​        初始化<br>​            生命周期方法回调<br>​            需要动态代理，则创建动态代理<br>​        加入一级缓存<br>​    参考答案<br>​    <img alt="8" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124201613.png"></p>
<p><img alt="9" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124201616.png"></p>
<h4 id="12-SpringIOC有哪些扩展点，在什么时候调用"><a href="#12-SpringIOC有哪些扩展点，在什么时候调用" class="headerlink" title="==12.SpringIOC有哪些扩展点，在什么时候调用=="></a>==12.SpringIOC有哪些扩展点，在什么时候调用==</h4><p>​    1.实现BeanFactoryPostProcessor<br>​    2.实现BeanDefinitionRegistryPostProcessor</p>
<p>​    <img alt="10" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124204411.png"></p>
<p>​    3.BeanPostProcessor：bean的生命周期调用9次<br>​    4.初始化调用</p>
<p>​    <img alt="11" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124204415.png"></p>
<p>​    5.FactoryBean</p>
<h4 id="24-Spring在加载过程中Bean哪有几种形态"><a href="#24-Spring在加载过程中Bean哪有几种形态" class="headerlink" title="==24.Spring在加载过程中Bean哪有几种形态=="></a>==24.Spring在加载过程中Bean哪有几种形态==</h4><p>​    概念态<br>​    定义态<br>​    纯静态<br>​    成熟态<br>​    参考</p>
<p><img alt="17" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124204510.png"></p>
<h4 id="注册BeanDefinition"><a href="#注册BeanDefinition" class="headerlink" title="注册BeanDefinition"></a>注册BeanDefinition</h4><h5 id="8-BeanDefinition的作用"><a href="#8-BeanDefinition的作用" class="headerlink" title="==8.BeanDefinition的作用=="></a>==8.BeanDefinition的作用==</h5><p>​    主要负责存储bean的定义信息：决定Bean的生产方式<br>​        如对象的路径名、懒加载、单例、自动装配方式<br>​    先根据用户配置生成BeanDefinition，然后生成Bean</p>
<h5 id="28-描述BeanDefinition的加载过程"><a href="#28-描述BeanDefinition的加载过程" class="headerlink" title="28.描述BeanDefinition的加载过程"></a>28.描述BeanDefinition的加载过程</h5><p>​    BeanDefinitionReader读取配置文件<br>​    ConfigurationClassParser解析加了@Configuation的配置文件<br>​        解析@Component等注解<br>​    @ComponentScan为例ClassPathBeanDefinitionScanner#doScan<br>​        扫描包路径下的所有.class文件，扫描是否包含@Service,@Component注解<br>​    注册beanDefinition</p>
<h5 id="31-spring启动时，为什么先加载BeanFactoryPostProcessor"><a href="#31-spring启动时，为什么先加载BeanFactoryPostProcessor" class="headerlink" title="31.spring启动时，为什么先加载BeanFactoryPostProcessor"></a>31.spring启动时，为什么先加载BeanFactoryPostProcessor</h5><p>​    1.因为BeanDefinition会在IOC容器加载的时候先注册，而BeanFactoryPostProcessor就是在beanDefinition注册完后做扩展的<br>​    2.解析配置类的组件(生成BeanDefinition)ConfigurationClassPostProcessor实现了BeanFactoryPostProcessor(准确的来说是BeanDefinitionRegistryPostProcessor)，所以要先去加载BeanFactoryPostProcessor</p>
<h5 id="解析注解-系统的BeanDefinitionRegistryPostProcessor"><a href="#解析注解-系统的BeanDefinitionRegistryPostProcessor" class="headerlink" title="解析注解(系统的BeanDefinitionRegistryPostProcessor)"></a>解析注解(系统的BeanDefinitionRegistryPostProcessor)</h5><h6 id="45-为什么-ComponentScan不设置basePackage也会扫描"><a href="#45-为什么-ComponentScan不设置basePackage也会扫描" class="headerlink" title="45.为什么@ComponentScan不设置basePackage也会扫描"></a>45.为什么@ComponentScan不设置basePackage也会扫描</h6><p>​    因为Spring在解析@ComponentScan的时候，如果没设置basePackage，会将当前配置类所在包作为扫描路径</p>
<h6 id="35-Controller-Component-Repository-Service有什么区别"><a href="#35-Controller-Component-Repository-Service有什么区别" class="headerlink" title="35.@Controller,@Component,@Repository,@Service有什么区别"></a>35.@Controller,@Component,@Repository,@Service有什么区别</h6><p>​    元注解都是@Component<br>​    三层分别使用三个注解，代码阅读性更强，每个注解职责更清晰</p>
<h6 id="36-Import可以有几种用法"><a href="#36-Import可以有几种用法" class="headerlink" title="36.@Import可以有几种用法"></a>36.@Import可以有几种用法</h6><p>​    Q.14<br>​    @Import直接指定类<br>​        配置类按配置类解析，普通类解析为bean<br>​    ImportSelector.class<br>​        看一次性注册多个，返回一个String[]{}类的完整类路径，但不能干预实例化过程<br>​        DeferredImportSelector<br>​            延迟加载<br>​    ImportBeanDefinitionRegistrar<br>​        可以一次性注册多个<br>​        需要自己去创建注册beanDefinition，可以使用BeanDefinitionRegistry动态注册</p>
<h6 id="43-Bean的方法调用怎么保证单例"><a href="#43-Bean的方法调用怎么保证单例" class="headerlink" title="==43.@Bean的方法调用怎么保证单例=="></a>==43.@Bean的方法调用怎么保证单例==</h6><p>​    同@Configuration加与不加有什么区别<br>​        加了@Configuration会为配置类创建Cglib代理，保证配置类@Bean方法调用Bean的单例，@Bean方法的调用就会通过getBean获取<br>​    原理<br>​        1.创建Spring上下文会注册ConfigurationClassPostProcessor<br>​        2.调用invokeBeanFactoryPostProcessors,就会调用ConfigurationClassPostProcessor就会解析各种注解(@Component，@Bean)<br>​        3.ConfigurationClassPostProcessor#postProcessBeanFactory会给配置类创建cglib动态代理<br>​    参考</p>
<p><img alt="29" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124212108.png"></p>
<h6 id="32-Bean的生产顺序-BeanDefinition的注册顺序-是由什么决定的"><a href="#32-Bean的生产顺序-BeanDefinition的注册顺序-是由什么决定的" class="headerlink" title="==32.Bean的生产顺序(BeanDefinition的注册顺序)是由什么决定的=="></a>==32.Bean的生产顺序(BeanDefinition的注册顺序)是由什么决定的==</h6><p>​    bean的创建顺序由BeanDefinition的注册顺序来决定的，当然依赖关系也会影响Bean的创建顺序<br>​    ==追问：BeanDefinition的注册顺序是由什么决定的==<br>​        主要由注解的解析顺序决定<br>​            @Configuration<br>​            @Import导入的@Configuration<br>​            @Component<br>​            @Import—-class<br>​            @Import—-@Configuration—-@Bean<br>​            @Bean<br>​            @Import—-ImportBeanDefinitionRegistrar<br>​            自己实现的BeanDefinitionRegistryPostProcessor<br>​            后加载的会覆盖前面的<br>​        细节(@Order)</p>
<h6 id="44-将第三方的类配置成bean有哪些方式"><a href="#44-将第三方的类配置成bean有哪些方式" class="headerlink" title="==44.将第三方的类配置成bean有哪些方式=="></a>==44.将第三方的类配置成bean有哪些方式==</h6><p>​    Q.32<br>​    @Bean<br>​    @Import<br>​        Q.36<br>​        @Import直接导入类<br>​        ImportSelector<br>​        ImportBeanDefinitionRegistrar<br>​            可以自定义BeanDefinition<br>​    自己实现的BeanDefinitionRegistryPostProcessor</p>
<h5 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h5><h6 id="29-如何在所有BeanDefinition注册完后做扩展"><a href="#29-如何在所有BeanDefinition注册完后做扩展" class="headerlink" title="29.如何在所有BeanDefinition注册完后做扩展"></a>29.如何在所有BeanDefinition注册完后做扩展</h6><p>​        Q.12<br>​        BeanFactoryPostProcessor可以</p>
<h4 id="创建Bean"><a href="#创建Bean" class="headerlink" title="创建Bean"></a>创建Bean</h4><h5 id="7-BeanFactory的作用"><a href="#7-BeanFactory的作用" class="headerlink" title="==7.BeanFactory的作用=="></a>==7.BeanFactory的作用==</h5><p>​    Spring非常核心的一个顶层接口<br>​    主要职责：生产Bean<br>​    Spring容器(管理着Bean的生命周期 )<br>​    答案</p>
<p><img alt="7" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124212501.png"></p>
<h5 id="25-解释Spring框架中Bean的生命周期"><a href="#25-解释Spring框架中Bean的生命周期" class="headerlink" title="==25.解释Spring框架中Bean的生命周期=="></a>==25.解释Spring框架中Bean的生命周期==</h5><p>​    Bean的生命周期<br>​        从创建到销毁的过程<br>​    四大步<br>​        实例化<br>​            Q.19<br>​            推断构造函数，通过反射实例化<br>​            静态工厂、实例工厂<br>​        属性赋值<br>​            Q.22<br>​            解析自动装配(byName,byType)：DI体现<br>​            会出现循环依赖<br>​        初始化<br>​            调用XXXAware回调<br>​            调用初始化生命周期回调<br>​                Q.23<br>​            如果bean实现了AOP，创建动态代理<br>​        销毁<br>​            在spring容器关闭的时候进行调用<br>​            调用销毁生命周期回调<br>​    参考</p>
<p><img alt="18" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124212912.png"></p>
<h5 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h5><h6 id="19-Spring实例化Bean有几种方式"><a href="#19-Spring实例化Bean有几种方式" class="headerlink" title="19.Spring实例化Bean有几种方式"></a>19.Spring实例化Bean有几种方式</h6><p>​        1.构造器(反射)<br>​            存到BeanDefinition.beanClass<br>​            然后反射<br>​        2.静态工厂<br>​            factory-method指定的静态方法</p>
<p><img alt="13" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124213008.png"></p>
<p>​        3.实例工厂方式<br>​            factory-bean+factory-method<br>​            @Bean底层用的就是此方式</p>
<p><img alt="14" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124213016.png"></p>
<p>​        4.FactoryBean<br>​            getObject()</p>
<h5 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h5><h6 id="20-什么是bean的自动装配-装配"><a href="#20-什么是bean的自动装配-装配" class="headerlink" title="20.什么是bean的自动装配(装配)"></a>20.什么是bean的自动装配(装配)</h6><p>​    手动装配<br>​        <property></property>一个一个指定<br>​    自动装配<br>​        根据@Autowired、@Resource注入</p>
<h6 id="21-自动注入有什么限制-需要注意"><a href="#21-自动注入有什么限制-需要注意" class="headerlink" title="21.自动注入有什么限制(需要注意)"></a>21.自动注入有什么限制(需要注意)</h6><p>​    一定要声明set方法<br>​    可以使用<property><constructor>覆盖<br>​    不能自动装配简单的属性，如基本数据类型、字符串和类。但是手动注入(&lt;property&gt;,@Value)可以注入基本数据类型<br>​    模糊特性：自动装配不如显示装配精确</constructor></property></p>
<h6 id="22-自动装配方式有几种"><a href="#22-自动装配方式有几种" class="headerlink" title="22.自动装配方式有几种"></a>22.自动装配方式有几种</h6><p>​    no<br>​        默认<br>​        需要自己在xml里面配置<property ref><br>​    byName<br>​        根据setXXX的名字，不是属性名<br>​    byType<br>​        根据set方法传入的类型<br>​    constructor<br>​    autodetect<br>​        spring3.0后弃用<br>​    参考答案</property></p>
<p><img alt="15" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124213249.png"></p>
<h6 id="26-Spring如何解决bean的循环依赖"><a href="#26-Spring如何解决bean的循环依赖" class="headerlink" title="==26.Spring如何解决bean的循环依赖(*)=="></a>==26.Spring如何解决bean的循环依赖(<em>*</em>)==</h6><p>采用了三级缓存<br>    一级缓存<br>        存储完整的bean<br>        方便以后直接getBean获取对象<br>    二级缓存<br>        存储纯静态的bean<br>        ==避免多重循环依赖(b和c都依赖a),重复创建动态代理==<br>        ==保证多线程下bean的完整性==<br>    三级缓存<br>        存储了bean动态代理的一个函数接口<br>        ==不会立即调用：如果立即调用，不管bean是否是循环依赖，都会在实例化后创建proxy，但是正常bean，spring还是希望遵循生命周期在初始化创建动态代理；只有循环依赖，才会在实例化后创建动态代理==<br>        延时获取：提高性能，因为并不是所有的Bean都存在循环引用，所以当真正调用时再缓存该单例到二级缓存<br>        提高扩展性：采用bean的后置处理器方式可以提高扩展性<br>夺命连环问<br>    1.二级缓存能不能解决循环依赖<br>        a.如果只想解决循环依赖死循环：一级缓存就可以解决，但并发情况下会获取到不完整的bean<br>        b.二级缓存也可以解决循环依赖：可以避免重复循环依赖多次创建aop动态代理<br>    <a href="https://blog.csdn.net/weixin_48777366/article/details/123645686" target="_blank" rel="noopener">2.spring有没有解决多例bean的循环依赖</a><br>        没有解决，会报错BeanCurrentlyInCreationException<br>        a.多例bean不会使用缓存进行存储(多例bean 每次使用都需要重新创建)<br>        b.不缓存早期对象就无法解决循环依赖<br>    <a href="https://baijiahao.baidu.com/s?id=1676046519501587416&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">3.Spring有没有解决构造函数参数bean的循环依赖</a><br>        没有解决，beforeSingletonCreation报错？<br>            构造器会在实例化时候调用，一二三级缓存还没有<br>        可以通过@Lazy解决<br>            不会立即创建Bean，等到用到的时候才会创建<br>    参考答案</p>
<p>​    <img alt="21" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124214018.png"></p>
<p>参考</p>
<p><img alt="19" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124214141.png"></p>
<p>循环依赖图解</p>
<p><img alt="循环依赖课上图" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124214138.png"></p>
<h6 id="27-Spring如何在并发下避免获取不完整的Bean"><a href="#27-Spring如何在并发下避免获取不完整的Bean" class="headerlink" title="==27.Spring如何在并发下避免获取不完整的Bean=="></a>==27.Spring如何在并发下避免获取不完整的Bean==</h6><p>​    双重检查锁：2个同步锁(锁对象都是一级缓存)<br>​        1.getSingleton(A,boolean)</p>
<p>​        <img alt="23" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124214314.png"></p>
<p>​        2.getSingleton(A,objectFactory)</p>
<p>​    <img alt="22" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124214324.png"></p>
<p>​    追问<br>​        一级缓存为什么不加入锁<br>​            性能问题，其他线程可能要从一级缓存中获取bean<br>​    循环依赖图解(同Q.26)</p>
<h6 id="37-如何让自动注入没有找到依赖Bean时不会报错"><a href="#37-如何让自动注入没有找到依赖Bean时不会报错" class="headerlink" title="37.如何让自动注入没有找到依赖Bean时不会报错"></a>37.如何让自动注入没有找到依赖Bean时不会报错</h6><p>​    @Autowired(required = false)</p>
<h6 id="38-如何让自动注入找到多个依赖Bean不会报错"><a href="#38-如何让自动注入找到多个依赖Bean不会报错" class="headerlink" title="38.如何让自动注入找到多个依赖Bean不会报错"></a>38.如何让自动注入找到多个依赖Bean不会报错</h6><p>​    @Primary<br>​        设置此bean时主要的，优先级最高</p>
<h6 id="39-Autowired有什么作用"><a href="#39-Autowired有什么作用" class="headerlink" title="39.@Autowired有什么作用"></a>39.@Autowired有什么作用</h6><p>​    @Autowired对比byName,byType能更细粒度的注入属性(byName,byType会给所有set方法注入)<br>​    ==@Autowired默认按类型，按类型找到多个再按照名称，并且不需要提供get/set方法==</p>
<h6 id="属性注入方式"><a href="#属性注入方式" class="headerlink" title="属性注入方式"></a>属性注入方式</h6><p>​    set注入<br>​        在pupulateBean注入<br>​    构造器注入<br>​        在实例化的时候就实现了注入<br>​    @Autowired注入<br>​        @Autowired对比byName,byType能更细粒度的注入属性(byName,byType会给所有set方法注入)<br>​        @Autowired默认按类型，按类型找到多个再按照名称，并且不需要提供get/set方法</p>
<h6 id="40-Autowired和-Resource的区别"><a href="#40-Autowired和-Resource的区别" class="headerlink" title="40.@Autowired和@Resource的区别"></a>40.@Autowired和@Resource的区别</h6><p>​    @Autowired<br>​        是spring提供的<br>​        @Autowired默认按类型，按类型找到多个再按照名称，并且不需要提供get/set方法<br>​    @Resource<br>​        jdk提供<br>​        @esource默认按名字，按名字找到多个再按照类型</p>
<h6 id="41-Autowired注解自动装配底层原理"><a href="#41-Autowired注解自动装配底层原理" class="headerlink" title="==41.@Autowired注解自动装配底层原理=="></a>==41.@Autowired注解自动装配底层原理==</h6><p>​    通过BeanPostProcessor进行解析的<br>​        1.创建spring上下文时候注册AutowiredAnnotationBeanPostProcessor<br>​        2.实例化后预解析@Autowired类型、名称、属性等信息；在属性注入时，去IOC根据缓存的元数据信息返回注入bean<br>​    参考</p>
<p>​    <img alt="26" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124214837.png"></p>
<p>​    图解</p>
<p><img alt="27" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124214846.png"></p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><h6 id="23-Bean有哪些生命周期回调方法，有哪几种实现方式"><a href="#23-Bean有哪些生命周期回调方法，有哪几种实现方式" class="headerlink" title="==23.Bean有哪些生命周期回调方法，有哪几种实现方式=="></a>==23.Bean有哪些生命周期回调方法，有哪几种实现方式==</h6><p>​    初始化(从前到后)<br>​        @PostConstruct<br>​        InitializingBean接口<br>​        @Bean的init-method<br>​    销毁(从前到后)<br>​        @PreDestroy<br>​        DisposableBean接口<br>​        @Bean的destroy-method<br>​    参考</p>
<p><img alt="16" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124215050.png"></p>
<h5 id="30-如何在所有bean创建完后做扩展"><a href="#30-如何在所有bean创建完后做扩展" class="headerlink" title="==30.如何在所有bean创建完后做扩展=="></a>==30.如何在所有bean创建完后做扩展==</h5><p>​    哪里才算所有的Bean创建完<br>​        循环所有BeanDefinition执行getBean之后，所有bean就创建完了<br>​    1.SmartInitializingSingleton<br>​        finishBeanFactoryInitialization<br>​            preInstantiateSingletons<br>​                遍历完所有BeanDefinition之后<br>​    2.监听ContextRefreshedEvent事件<br>​        finishRefresh<br>​        注：注解形式解析类其实实现了SmartInitializingSingleton</p>
<p><img alt="24" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230124215207.png"></p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="46-什么是AOP，能做什么"><a href="#46-什么是AOP，能做什么" class="headerlink" title="46.什么是AOP，能做什么"></a>46.什么是AOP，能做什么</h4><p>​    面向切面编程<br>​        用于与业务无关，但对多个对象产生影响的公共行为和逻辑。减少系统中的重复代码，降低了模块间的耦合度，提高了系统的可维护性<br>​        可用于权限认证、日志、事务</p>
<h4 id="47-解释Spring-AOP常见的概念名词"><a href="#47-解释Spring-AOP常见的概念名词" class="headerlink" title="47.解释Spring AOP常见的概念名词"></a>47.解释Spring AOP常见的概念名词</h4><p>​    切面Aspect<br>​        自己定义的切面类(@Aspectj)，管理了切点和通知<br>​    连接点Join point<br>​        指的就是被增强的业务方法(自己写的业务逻辑)<br>​    通知advice<br>​        就是需要增强到业务方法中的公共代码<br>​            前置通知<br>​            后置通知<br>​            环绕通知<br>​            异常通知<br>​            返回通知<br>​    切点Pointcut<br>​        通过切点表达式决定哪些方法需要被增强<br>​    目标对象<br>​        增强的对象，业务逻辑类的对象<br>​    顾问(Advisor)<br>​        Pointcut和Advice的一个结合<br>​        应用层面无需关心<br>​    织入Weaving<br>​        Aspectj独有<br>​        Spring aop织入方式：动态代理</p>
<h4 id="48-Spring通知有哪些类型"><a href="#48-Spring通知有哪些类型" class="headerlink" title="48.Spring通知有哪些类型"></a>48.Spring通知有哪些类型</h4><p>​    类型<br>​        前置通知<br>​        后置通知<br>​        环绕通知<br>​        异常通知<br>​        返回通知<br>​    执行顺序<br>​        spring5.2.7之前<br>​            后置通知在返回通知和异常通知之前<br>​        spring5.2.7之后<br>​            正常:around(before)-&gt; before -&gt; around(proceed方法体执行) -&gt; afterReturning -&gt; after -&gt; around(after)<br>​            异常:around(before)-&gt; before -&gt; around(proceed方法体执行) -&gt; AfterThrowing -&gt; after</p>
<h4 id="49-Spring-AOP和Aspectj-AOP有什么区别"><a href="#49-Spring-AOP和Aspectj-AOP有什么区别" class="headerlink" title="49.Spring AOP和Aspectj AOP有什么区别"></a>49.Spring AOP和Aspectj AOP有什么区别</h4><p>​    联系<br>​        Spring AOP提供了AspectJ的支持，但只能用到AspectJ的切点解析和匹配(@Aspect、@Before)<br>​        @Aspect、@Before等都是AspectJ发明的<br>​    区别<br>​        Spring<br>​            动态代理<br>​                使用接口：jdk<br>​                没有接口：cglib<br>​            在容器启动的时候生成代理实例<br>​                方法调用上也会增加栈的深度<br>​        AspectJ<br>​            静态代理<br>​                编译的时候动态修改.class文件<br>​            实际代码运行前(编译时)完成织入</p>
<p><img alt="30" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125160735.png"></p>
<h4 id="50-JDK动态代理和CGLIB动态代理"><a href="#50-JDK动态代理和CGLIB动态代理" class="headerlink" title="50.JDK动态代理和CGLIB动态代理"></a>50.JDK动态代理和CGLIB动态代理</h4><p>​    JDK动态代理<br>​        实现了接口<br>​        JDK在运行时为目标类生成一个动态代理类$proxy*.class<br>​        该代理类会实现目标类接口，并且代理类会实现接口所有的方法增强代码。<br>​        ==调用时，通过代理类先去  调用  处理类进行增强，在通过反射方式进行调用目标方法==<br>​    CGLIB动态代理<br>​        没有实现接口<br>​        使用ASM在运行时动态生成目标类的子类。会生成多个<br>​        会重写父类所有的方法增强代码<br>​        调用时，通过代理类进行增强，再  直接调用  父类对应的方法进行调用目标方法<br>​            如果某个类被标记为final，不能被继承，也无法做CGLIB动态代理<br>​            ==除了生成目标子类代理类，还有一个FastClass(路由类)，可以让(不是必须，Spring没使用)本类方法调用重复增强，不像jdk代理只能增强一次==<br>​    jdk生成动态代理快，调用慢(反射)，cglib生成慢(ASM多个类)，调用快<br>​        老版本cglib快，目前jdk快<br>​    参考</p>
<p><img alt="31" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125162016.png"></p>
<h4 id="51-JavaConfig如何启用AOP，如何强制使用cglib"><a href="#51-JavaConfig如何启用AOP，如何强制使用cglib" class="headerlink" title="51.JavaConfig如何启用AOP，如何强制使用cglib"></a>51.JavaConfig如何启用AOP，如何强制使用cglib</h4><p>​    启用AOP<br>​        @EnableAspectJAutoProxy<br>​            强制CGLIB<br>​                proxyTargetClass = true<br>​            在线程中暴露代理对象<br>​                exposeProxy = true<br>​                底层就会把代理对象存到ThreadLocal(绑定到当前线程上)中</p>
<h4 id="52-介绍AOP有几种实现方式"><a href="#52-介绍AOP有几种实现方式" class="headerlink" title="52.介绍AOP有几种实现方式"></a>52.介绍AOP有几种实现方式</h4><p>​    spring1.2<br>​        基于接口<br>​    spring2.0<br>​        xml<br>​    spring2.0<br>​        注解<br>​    AspectJ</p>
<h4 id="53-什么情况下AOP会失效，怎么解决"><a href="#53-什么情况下AOP会失效，怎么解决" class="headerlink" title="53.什么情况下AOP会失效，怎么解决"></a>53.什么情况下AOP会失效，怎么解决</h4><p>​    Q.51<br>​    失效原因<br>​        内部调用(方法内部调用另一个方法，事务相关!!!)不会触发AOP，必须走代理<br>​        方法是private，必须是public<br>​        目标类没有配置为bean<br>​        切点表达式不正确<br>​        Q.73<br>​    解决<br>​        从本类中自动注入当前bean(IOC存的就是代理类)<br>​        在线程中暴露代理对象<br>​            exposeProxy = true<br>​            底层就会把代理对象存到ThreadLocal(绑定到当前线程上)中</p>
<h4 id="54-Spring-AOP在哪里创建的动态代理"><a href="#54-Spring-AOP在哪里创建的动态代理" class="headerlink" title="==54.Spring AOP在哪里创建的动态代理=="></a>==54.Spring AOP在哪里创建的动态代理==</h4><p>​    1.普通bean<br>​        初始化后，使用beanPostProcessor创建<br>​    2.循环依赖<br>​        在属性注入的时候<br>​    参考</p>
<p><img alt="32" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125200212.png"></p>
<h4 id="55-描述AOP的完整实现流程"><a href="#55-描述AOP的完整实现流程" class="headerlink" title="==55.描述AOP的完整实现流程=="></a>==55.描述AOP的完整实现流程==</h4><p>​    @EnableAspectJAutoProxy会通过@Import注册一个BeanPostProcessor处理AOP<br>​    1.解析切面<br>​        实例化之前第一个BeanPostProcessor<br>​    2.创建代理<br>​        初始化后调用BeanPostProcessor拿到之前缓存的advisor，根据advisor的pointcut匹配当前bean是否命中<br>​    3.调用代理<br>​        拿到动态代理对象，判断是否是需要增强的方法<br>​        如果是需要增强的方法，就拿到所有的advisors<br>​        转换为Interceptor，通过责任链调用<br>​    参考</p>
<p><img alt="33" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125200314.png"></p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="56-事务四大特性"><a href="#56-事务四大特性" class="headerlink" title="56.事务四大特性"></a>56.事务四大特性</h4><p>​    原子性<br>​        要么都成功要么都失败<br>​    一致性<br>​        A转账给B，执行前执行后数据一致<br>​    隔离性<br>​        事务执行时，不被其他事务操作干扰<br>​    持久性<br>​        事务一旦提交，改变就是永久性的；遇到故障，也不会丢失提交事务的操作<br>​    参考</p>
<p><img alt="34" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125201452.png"></p>
<h4 id="57-Spring支持的事务管理类型，Spring事务实现方式有哪些"><a href="#57-Spring支持的事务管理类型，Spring事务实现方式有哪些" class="headerlink" title="57.Spring支持的事务管理类型，Spring事务实现方式有哪些"></a>57.Spring支持的事务管理类型，Spring事务实现方式有哪些</h4><p>​    事务管理类型<br>​        编程式事务<br>​        声明式事务<br>​    实现方式<br>​        基于接口<br>​            基于TransactionInterceptor的声明式事务<br>​            基于TransactionProxyFactoryBean的声明式事务<br>​        基于<tx>和<aop>命名空间的声明式事务<br>​        基于@Transactional全注解方式<br>​        参考</aop></tx></p>
<p><img alt="35" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125201634.png"></p>
<h4 id="58-说一下Spring的事务传播行为"><a href="#58-说一下Spring的事务传播行为" class="headerlink" title="==58.说一下Spring的事务传播行为=="></a>==58.说一下Spring的事务传播行为==</h4><p>​    ==事务的传播行为指的是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行==<br>​    事务传播行为</p>
<p><img alt="36" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125201859.png"></p>
<h4 id="59-说一下Spring的事务隔离级别"><a href="#59-说一下Spring的事务隔离级别" class="headerlink" title="==59.说一下Spring的事务隔离级别=="></a>==59.说一下Spring的事务隔离级别==</h4><p>​    并发产生的问题<br>​        脏读<br>​            事务A读取了事务B未提交的数据<br>​        不可重复读<br>​            事务A两次读取数据(一条数据)不一致<br>​        幻读<br>​            事务A两次统计数据条数(针对整张表)不一致<br>​    隔离级别<br>​        读未提交<br>​        读已提交<br>​        可重复读<br>​            行锁<br>​        串行化<br>​            表锁</p>
<h4 id="60-Spring事务实现原理"><a href="#60-Spring事务实现原理" class="headerlink" title="==60.Spring事务实现原理=="></a>==60.Spring事务实现原理==</h4><p>​    基于AOP，和AOP相似<br>​    @EnableTransactionManagement<br>​    1.解析切面<br>​        实例化之前第一个beanPostProcessor解析Spring事务自定义的advisor信息<br>​    2.创建代理<br>​        bean的初始化后beanPostProcessor，匹配(方法、类上、接口或父类上有没有@Transactional)<br>​    3.调用代理<br>​        创建数据库连接Connection，修改数据库连接属性autoCommit=false！！！<br>​        执行目标方法，执行sql<br>​        执行完后，有异常回滚，没异常提交</p>
<h4 id="61-Spring事务传播行为实现原理"><a href="#61-Spring事务传播行为实现原理" class="headerlink" title="==61.Spring事务传播行为实现原理=="></a>==61.Spring事务传播行为实现原理==</h4><p>​    源码在调用事务中<br>​    思路：connection存在ThreadLocal中，事务进来会判断是否已经有connection，有说明是内嵌事务；之后判断事务隔离级别<br>​        TransactionInfo.newTransaction用于判断融入(内嵌事务不提交)还是创建新事务(内嵌事务提交)<br>​        融入:TransactionInfo.newTransaction=false<br>​            无需暂存，直接用外部事务ThreadLocal中的信息<br>​        创建新事务:TransactionInfo.newTransaction=false<br>​            执行前暂存外部事务connection，隔离级别等各种事务信息<br>​            执行后把事务信息存到ThreadLocal中<br>​        细节<br>​            根据TransactionInfo.newTransaction判断是否要提交<br>​            当前执行的事务都有一个connection存到了ThreadLocal中<br>​    参考</p>
<p><img alt="37" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125202657.png"></p>
<p>​    融入</p>
<p><img alt="38" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125202700.png"></p>
<p>​    创建新事务</p>
<p><img alt="39" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125202703.png"></p>
<h4 id="62-Spring多线程事务能否保证事务的一致性"><a href="#62-Spring多线程事务能否保证事务的一致性" class="headerlink" title="==62.Spring多线程事务能否保证事务的一致性=="></a>==62.Spring多线程事务能否保证事务的一致性==</h4><p>​    事务信息存在ThreadLocal中，多个线程是存在多个ThreadLocal中，所以一个线程永远只能有一个事务；因此不能保证多线程事务一致性<br>​    解决<br>​        编程式事务<br>​        分布式事务<br>​    参考</p>
<p><img alt="40" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125203043.png"></p>
<h4 id="63-Spring事务的失效原因"><a href="#63-Spring事务的失效原因" class="headerlink" title="63.Spring事务的失效原因"></a>63.Spring事务的失效原因</h4><p>​    Q.53<br>​<br>​    自己捕获了异常<br>​    Q.73<br>​    内部调用</p>
<p>参考</p>
<p><img alt="41" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/Spring/20230125203228.png"></p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础面试题</title>
    <url>/alex-next/2022/12/24/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h4 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a>操作系统基础</h4><h5 id="1-什么是操作系统"><a href="#1-什么是操作系统" class="headerlink" title="1.什么是操作系统"></a>1.什么是操作系统</h5><p>操作系统是管理计算机硬件和软件资源的程序，是计算机的基石<br>操作系统本质上是一个运行在计算机上的软件程序，用于管理计算机硬件和软件资源<br>操作系统存在屏蔽了硬件层的复杂性<br>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性</p>
<h5 id="2-什么是系统调用呢"><a href="#2-什么是系统调用呢" class="headerlink" title="==2.什么是系统调用呢=="></a>==2.什么是系统调用呢==</h5><p>用户态和系统态<br>    用户态<br>        用户态运行的进程可以直接读取用户程序的数据<br>    系统态<br>        可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制<br>系统调用<br>    我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了<br>系统调用按功能分类<br>    设备管理<br>        完成设备的请求或释放，以及设备启动等功能。<br>    文件管理<br>        完成文件的读、写、创建及删除等功能。<br>    进程控制<br>        完成进程的创建、撤销、阻塞及唤醒等功能。<br>    进程通信<br>        完成进程之间的消息传递或信号传递等功能。<br>    内存管理<br>        完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</p>
<h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><h5 id="1-进程和线程的区别"><a href="#1-进程和线程的区别" class="headerlink" title="1.进程和线程的区别"></a>1.进程和线程的区别</h5><p>进程是资源分配的最小单位<br>    线程是 CPU 调度的最小单位<br>创建进程或撤销进程，系统都要为之分配或回收资源，操作系统开销远大于创建或撤销线程时的开销<br>不同进程地址空间相互独立，同一进程内的线程共享同一地址空间。一个进程的线程在另一个进程内是不可见的<br>进程间不会相互影响，而一个线程挂掉将可能导致整个进程挂掉<br>以JVM为例分析<br>    一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈</p>
<h5 id="2-进程有哪几种状态"><a href="#2-进程有哪几种状态" class="headerlink" title="2.进程有哪几种状态"></a>2.进程有哪几种状态</h5><p>创建<br>    进程正在被创建，尚未到就绪状态<br>就绪<br>    进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行<br>运行<br>    进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)<br>阻塞<br>    又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行<br>结束<br>    进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行<br>进程状态转换图</p>
<p><img alt="7" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/计算机基础/20230118163100.png"></p>
<h5 id="3-进程间的通信方式"><a href="#3-进程间的通信方式" class="headerlink" title="3.进程间的通信方式"></a>3.进程间的通信方式</h5><p>管道/匿名管道(Pipes)<br>    用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。<br>有名管道(Names Pipes)<br>    匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</p>
<p>信号(Signal)<br>    信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</p>
<p>==消息队列(Message Queuing)==<br>    消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。<br>==信号量(Semaphores)==<br>    信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。<br>    类比，Semaphore(AQS)<br>==共享内存(Shared memory)==<br>    使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。<br>    类比volatile<br>==套接字(Sockets)==<br>    此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。<br>信号(Signal)<br>    信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</p>
<h5 id="4-线程间的同步的方式"><a href="#4-线程间的同步的方式" class="headerlink" title="4.线程间的同步的方式"></a>4.线程间的同步的方式</h5><p>互斥量<br>    采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限<br>    同步锁(synchronized，ReentrantLock)<br>信号量<br>    它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量<br>    Semaphore(AQS)<br>事件<br>    通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作<br>    wait/notify<br>共享内存<br>    volatile关键字</p>
<h5 id="5-进程的调度算法"><a href="#5-进程的调度算法" class="headerlink" title="5.进程的调度算法"></a>5.进程的调度算法</h5><p>短作业优先(SJF)的调度算法<br>    从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。<br>时间片轮转调度算法<br>    时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。<br>多级反馈队列调度算法<br>    前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。<br>    短进程执行优先级最高，时间片小；长进程执行优先级低，时间片长。<br>    一个新进程进来先进入序数最小的队列(优先级最高，时间片最小)，拿到CPU时间片执行，时间皮用完，移到序数较大的队列中；以此类推<br>优先级调度<br>    为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。<br>先到先服务(FCFS)调度算法<br>    从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</p>
<h5 id="6-什么是死锁"><a href="#6-什么是死锁" class="headerlink" title="==6.什么是死锁=="></a>==6.什么是死锁==</h5><p>多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止</p>
<h5 id="7-死锁的四个必要条件是什么"><a href="#7-死锁的四个必要条件是什么" class="headerlink" title="==7.死锁的四个必要条件是什么=="></a>==7.死锁的四个必要条件是什么==</h5><p>互斥<br>    资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。<br>占有并等待<br>    一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。<br>非抢占<br>    资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。<br>循环等待<br>    有一组等待进程 {P0, P1,…, Pn}， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，……，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有<br>例：A有R1，等待R2;B有R2，等待R1</p>
<h5 id="8-解决死锁的方法"><a href="#8-解决死锁的方法" class="headerlink" title="==8.解决死锁的方法=="></a>==8.解决死锁的方法==</h5><p>预防<br>    概念<br>        采用某种策略，限制并发进程对资源的请求，从而使得死锁的必要条件在系统执行的任何时间上都不满足<br>    破坏互斥条件<br>        很多资源往往是不能同时访问的，不靠谱<br>    破坏非抢占条件<br>        会导致资源利用率下降，不靠谱<br>    破坏占有并等待条件<br>        静态分配策略<br>            在一开始就给线程分配执行所需要的所有资源<br>            可能有些资源要在执行比较靠后的时间采用，会严重降低资源利用率，不靠谱<br>    破坏循环等待条件<br>        层次分配策略<br>            在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源<br>            A有R1，等待R2;B有R2，等待R1，加入R2&gt;R1，那么B会先释放R2<br>避免<br>    概念<br>        系统在分配资源时，根据资源的使用情况提前做出预测，从而避免死锁的发生(允许存在四个必要条件)<br>    <a href="https://blog.csdn.net/qq_33414271/article/details/80245715" target="_blank" rel="noopener">银行家算法</a><br>        先 试探 分配给该进程资源<br>        然后通过 安全性算法 判断分配后系统是否处于安全状态<br>            若不安全则试探分配作废，让该进程继续等待<br>            若能够进入到安全的状态，则就 真的分配资源给该进程。<br>        缺点：需要不断做安全性检查，时间开销大<br>检测<br>    概念<br>        系统设有专门的机构，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。<br>    进程-资源分配图<br>        如果进程-资源分配图中无环路，则此时系统没有发生死锁<br>        如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁<br>        如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁<br>            如果能在进程-资源分配图中找出一个 既不阻塞又非独立的进程 ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 消除所有的边 ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 拓扑排序)<br>解除<br>    概念<br>        解除 是与检测相配套的一种措施，用于将进程从死锁状态下解脱出来<br>    立即结束所有进程的执行，重新启动操作系统<br>        这种方法简单，但以前所在的工作全部作废，损失很大。<br>    撤销涉及死锁的所有进程，解除死锁后继续运行<br>        这种方法能彻底打破死锁的循环等待条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。<br>    逐个撤销涉及死锁的进程，回收其资源直至死锁解除。<br>    抢占资源<br>        从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。<br>总结<br>    预防和避免像悲观锁，检测和解除像乐观锁</p>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><h5 id="1-操作系统的内存管理主要是做什么"><a href="#1-操作系统的内存管理主要是做什么" class="headerlink" title="1.操作系统的内存管理主要是做什么"></a>1.操作系统的内存管理主要是做什么</h5><p>主要负责内存的分配与回收<br>地址转换也就是将逻辑地址转换成相应的物理地址等功能</p>
<h5 id="2-常见的几种内存管理机制"><a href="#2-常见的几种内存管理机制" class="headerlink" title="2.常见的几种内存管理机制"></a>2.常见的几种内存管理机制</h5><p>连续分配管理方式<br>    为一个用户程序分配一个连续的内存空间<br>    块式管理<br>        将内存分为几个固定大小的块，每个块中只包含一个进程。<br>        如果程序运行需要内存的话，操作系统就分配给它一块，<br>        如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片<br>非连续分配管理方式<br>    允许一个程序使用的内存分布在离散或者说不相邻的内存中<br>    页式管理<br>        把主存分为大小相等且固定的一页一页的形式，页较小，相比于块式管理的划分粒度更小，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。<br>    段式管理<br>        页式管理虽然提高了内存利用率，但是页式管理其中的页并无任何实际意义。<br>        段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。<br>    段页式管理机制<br>        结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 段页式管理机制 中段与段之间以及段的内部的都是离散的。<br>    总结<br>        页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求</p>
<h5 id="3-快表和多级页表"><a href="#3-快表和多级页表" class="headerlink" title="3.快表和多级页表"></a>3.快表和多级页表</h5><p>快表<br>    在 页表方案 基础之上引入了 快表 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器<br>    步骤<br>        加入快表后,在地址转换时，首先在快表中查找，若找到就直接进行地址转换；<br>        未找到，则在主存页表继续查找，并把查到的页号和块号放入联想存储器中。<br>        快表的命中率很高，有效地提高了地址转换的速度。<br>    <a href="https://blog.csdn.net/SJ_Sniper/article/details/122838711" target="_blank" rel="noopener">参考</a><br>    快表命中率</p>
<p>​    <img alt="8" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/计算机基础/20230118180157.jpg"></p>
<p>多级页表<br>    为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。<br>    多级页表属于时间换空间的典型场景<br>    <a href="https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html" target="_blank" rel="noopener">参考</a><br>利用了程序的局部性原理</p>
<h5 id="4-分页机制和分段机制的共同点和区别"><a href="#4-分页机制和分段机制的共同点和区别" class="headerlink" title="4.分页机制和分段机制的共同点和区别"></a>4.分页机制和分段机制的共同点和区别</h5><p>共同点<br>    分页机制和分段机制都是为了提高内存利用率，减少内存碎片。<br>    页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。<br>区别<br>    页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。<br>    分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</p>
<h5 id="5-逻辑-虚拟-地址和物理地址"><a href="#5-逻辑-虚拟-地址和物理地址" class="headerlink" title="5.逻辑(虚拟)地址和物理地址"></a>5.逻辑(虚拟)地址和物理地址</h5><p>编程一般只有可能和逻辑地址打交道<br>逻辑地址<br>    在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定<br>物理地址<br>    物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址</p>
<h5 id="6-CPU-寻址了解吗-为什么需要虚拟地址空间"><a href="#6-CPU-寻址了解吗-为什么需要虚拟地址空间" class="headerlink" title="==6.CPU 寻址了解吗?为什么需要虚拟地址空间=="></a>==6.CPU 寻址了解吗?为什么需要虚拟地址空间==</h5><p>CPU寻址<br>    使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存<br>==为什么要有虚拟地址空间呢==<br>    没有虚拟地址空间的时候，程序直接访问和操作的都是物理内存，会有几个问题<br>        用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。<br>        想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃<br>        总结<br>            如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难</p>
<p>​    优势<br>​        程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。<br>​        程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。<br>​        不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</p>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><h5 id="1-什么是虚拟内存"><a href="#1-什么是虚拟内存" class="headerlink" title="1.什么是虚拟内存"></a>1.什么是虚拟内存</h5><p>概念<br>    虚拟内存是计算机系统内存管理的一种技术<br>    虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间<br>优势<br>    通过 虚拟内存 可以让程序可以拥有超过系统物理内存大小的可用内存空间。<br>    虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。</p>
<h5 id="2-局部性原理"><a href="#2-局部性原理" class="headerlink" title="==2.局部性原理=="></a>==2.局部性原理==</h5><p>局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。<br>时间局部性<br>    如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。<br>    产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。<br>    实现<br>        将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现</p>
<p>空间局部性<br>    一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。<br>    如数组<br>    实现<br>        使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现</p>
<h5 id="3-虚拟存储器"><a href="#3-虚拟存储器" class="headerlink" title="3.虚拟存储器"></a>3.虚拟存储器</h5><p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。<br>在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大得多的存储器</p>
<h5 id="4-虚拟内存的技术实现"><a href="#4-虚拟内存的技术实现" class="headerlink" title="==4.虚拟内存的技术实现=="></a>==4.虚拟内存的技术实现==</h5><p>请求分页存储管理<br>    ==建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能==<br>    步骤<br>        请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。<br>        假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中<br>请求分段存储管理<br>    建立在分段存储管理之上，增加了请求调段功能、分段置换功能。<br>请求段页式存储管理<br>要点<br>    一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；<br>    ==缺页中断==<br>        如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序；<br>    虚拟地址空间<br>        逻辑地址到物理地址的变换</p>
<h5 id="5-页面置换算法"><a href="#5-页面置换算法" class="headerlink" title="==5.页面置换算法=="></a>==5.页面置换算法==</h5><p>==为什么需要页面置换算法==<br>    地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断，若此时内存中没有空闲的页面，就会使用页面置换算法淘汰页面<br>OPT 页面置换算法（最佳页面置换算法）<br>    最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率<br>    但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法<br>FIFO页面置换算法（先进先出页面置换算法）<br>    总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。<br>LRU页面置换算法（最近最久未使用页面置换算法）<br>    LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。<br>LFU页面置换算法（最少使用页面置换算法）<br>    该置换算法选择在之前时期使用最少的页面作为淘汰页。</p>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h5 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1.OSI七层模型"></a>1.OSI七层模型</h5><p><img alt="1" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/计算机基础/20230118183256.png"></p>
<h5 id="2-TCP-IP四层模型"><a href="#2-TCP-IP四层模型" class="headerlink" title="2.TCP/IP四层模型"></a>2.TCP/IP四层模型</h5><p>应用层<br>    定义了信息交换的格式<br>传输层<br>    提供通用的数据传输服务<br>网络层<br>    提供通信服务<br>网络接口层<br>    封装成桢，无差别传输</p>
<h5 id="3-参考"><a href="#3-参考" class="headerlink" title="3.参考"></a>3.<a href="https://www.iamshuaidi.com/747.html" target="_blank" rel="noopener">参考</a></h5><h4 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h4><h5 id="1-TCP-三次握手"><a href="#1-TCP-三次握手" class="headerlink" title="==1.TCP 三次握手=="></a>==1.TCP 三次握手==</h5><p>详解</p>
<blockquote>
<p>​    人话概述<br>​        首先，我让信使运输一份信件给对方，对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。<br>​        于是他给我回信，我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以。<br>​        然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次，他若收到了，他便清楚了他的发件能力和我的收件能力是可以的。<br>​    第一次握手<br>​        客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。<br>​        人话<br>​            发送SYN，请求连接<br>​    第二次握手<br>​        服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。<br>​        人话<br>​            发送SYN和ACK，确认请求连接<br>​    第三次握手<br>​        客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。<br>​        人话<br>​            发送ACK，确认服务器的确认(主要让服务器明白)</p>
</blockquote>
<p>核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求</p>
<p>==追问==</p>
<blockquote>
<p>==为什么TCP连接的时候是3次？2次或4次不可以吗==<br>    2次不可以？<br>        2次的话服务器并不知道客户端是否已经收到自己的同步信号，可能这个同步信号会丢失(客户端接收有问题)，导致服务器和客户端的初始序号无法达成一致<br>    4次不可以？<br>        3次已经能满足可靠传输和传输效率了，4次多余<br>==第2次握手传回了ACK，为什么还要传回SYN==<br>    服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信。<br>==如果已经建立了连接，但是客户端突然出现故障了怎么办==<br>    TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。<br>==如果第1次握手中，客户端发给服务端的SYN丢了，怎么办==<br>    客户端会周期性超时重传，直到收到服务器的确认<br>==如果第2次握手中，服务器发给客户端的SYN+ACK丢了，怎么办==<br>    服务端会周期性超时重传SYN+ACK，直到收到客户端的确认<br>==如果第3次握手中，服务器发给客户端的确认(ACK)丢了，怎么办==<br>    首先，客户端不会为没有数据的ACK超时重传<br>    A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态<br>    这时，分三种情况<br>        双方都没数据，服务端会周期性超时重传SYN+ACK，直到收到客户端的确认<br>        若客户端有数据，服务端收到客户端的数据+ACK，自然会切换为Established状态<br>        若服务器有数据，发送不了，会周期性超时重传SYN+ACK，直到收到客户端的确认</p>
</blockquote>
<p>图解</p>
<p><img alt="2" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/计算机基础/20230118184004.png"></p>
<h5 id="2-TCP四次挥手"><a href="#2-TCP四次挥手" class="headerlink" title="==2.TCP四次挥手=="></a>==2.TCP四次挥手==</h5><p>详解</p>
<blockquote>
<p>人话概述<br>    第一次挥手 ： A 说“我没啥要说的了”<br>    第二次挥手 ：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话<br>    第三次挥手 ：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”<br>    第四次挥手 ：A 回答“知道了”，这样通话才算结束。<br>第一次挥手<br>    当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。<br>第二次挥手<br>    服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。<br>第三次挥手<br>    服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。<br>第四次挥手<br>    客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。</p>
</blockquote>
<p>追问</p>
<blockquote>
<p>==为什么TCP连接的时候是3次，关闭的时候却是4次==<br>    因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)<br>==为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手==<br>    因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。<br>==如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样==<br>    客户端没有收到 ACK 确认，服务器会重新发送 FIN 请求<br>==为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接==<br>    第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端没有因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN<br>    类比第三次握手时丢失ACK</p>
</blockquote>
<p>图解</p>
<p><img alt="3" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/计算机基础/20230118184012.png"></p>
<h5 id="3-TCP-与-UDP-的区别"><a href="#3-TCP-与-UDP-的区别" class="headerlink" title="==3.TCP 与 UDP 的区别=="></a>==3.TCP 与 UDP 的区别==</h5><p>是否面向连接<br>    UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。<br>是否是可靠传输<br>    远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。<br>是否有状态<br>    这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（这很渣男！）。<br>传输效率<br>    由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。<br>传输形式<br>    TCP 是面向字节流的，UDP 是面向报文的。<br>首部开销<br>    TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。<br>是否提供广播或多播服务<br>    TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</p>
<p>图解</p>
<p><img alt="4" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/计算机基础/20230118190231.png"></p>
<h5 id="4-什么时候选择-TCP-什么时候选-UDP"><a href="#4-什么时候选择-TCP-什么时候选-UDP" class="headerlink" title="4.什么时候选择 TCP,什么时候选 UDP"></a>4.什么时候选择 TCP,什么时候选 UDP</h5><p>UDP<br>    一般用于即时通信<br>        语音、 视频 、直播<br>TCP<br>    用于对传输准确性要求特别高的场景<br>        文件传输、发送和接收邮件、远程登录</p>
<h5 id="5-使用-TCP-的协议有哪些-使用-UDP-的协议有哪些"><a href="#5-使用-TCP-的协议有哪些-使用-UDP-的协议有哪些" class="headerlink" title="5.使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?"></a>5.使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?</h5><p>==TCP==<br>    HTTP 协议<br>        超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。<br>    HTTPS 协议<br>        更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议<br>    FTP 协议<br>        文件传输协议 FTP（File Transfer Protocol），提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。<br>    SMTP 协议<br>        简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，基于 TCP 协议，用来发送电子邮件。注意 ⚠️：接受邮件的协议不是 SMTP 而是 POP3 协议。<br>    POP3/IMAP 协议<br>        POP3 和 IMAP 两者都是负责邮件接收的协议。<br>    Telent 协议<br>        远程登陆协议，通过一个终端登陆到其他服务器。被一种称为 SSH 的非常安全的协议所取代。<br>    SSH 协议<br>        SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。<br>==UDP==<br>    DNS<br>        域名系统（DNS，Domain Name System）将人类可读的域名 (例如，www.baidu.com) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议。<br>    DHCP 协议<br>        动态主机配置协议，动态配置 IP 地址</p>
<h5 id="6-TCP-协议如何保证可靠传输"><a href="#6-TCP-协议如何保证可靠传输" class="headerlink" title="==6.TCP 协议如何保证可靠传输=="></a>==6.TCP 协议如何保证可靠传输==</h5><p>==基于数据块传输==<br>    应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。<br>对失序数据包重新排序以及去重<br>    TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。<br>校验和<br>    TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。<br>==超时重传==<br>    当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为已丢失并进行重传。<br>==流量控制==<br>    TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。<br>==拥塞控制==<br>    当网络拥塞时，减少数据的发送。</p>
<h5 id="7-TCP-如何实现流量控制"><a href="#7-TCP-如何实现流量控制" class="headerlink" title="7.TCP 如何实现流量控制"></a>7.TCP 如何实现流量控制</h5><p>TCP 利用滑动窗口实现流量控制<br>追问<br>    ==为什么需要流量控制==<br>        因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等<br>        如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 接收缓冲区(Receiving Buffers) 里（失序的数据包也会被存放在缓存区里）。<br>        如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。</p>
<h5 id="8-TCP-的拥塞控制是怎么实现的"><a href="#8-TCP-的拥塞控制是怎么实现的" class="headerlink" title="8.TCP 的拥塞控制是怎么实现的"></a>8.TCP 的拥塞控制是怎么实现的</h5><p>总结<br>    维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化，根据网络的拥塞程度使用四种不同的算法(慢开始、拥塞避免、快重传、快恢复)<br>追问<br>    ==拥塞控制和流量控制区别==<br>        拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。<br>        相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收</p>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h5 id="1-在浏览器中输入-url-地址-gt-gt-显示主页的过程"><a href="#1-在浏览器中输入-url-地址-gt-gt-显示主页的过程" class="headerlink" title="==1.在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程=="></a>==1.在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程==</h5><blockquote>
<p>1.使用DNS解析域名为IP地址<br>2.浏览器向web服务器发送HTTP请求<br>    若是HTTPS，还要使用SSL/TLS协议(握手)<br>3.与服务器建立TCP连接<br>    IP协议，OSPF协议(路由器间)<br>    ARP协议(IP地址转为MAC地址)<br>4.服务器发回HTML响应<br>5.浏览器开始显示HTML</p>
<p><img alt="5" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/计算机基础/20230118191216.jpg"></p>
</blockquote>
<p><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">参考</a></p>
<h5 id="2-HTTP-是不保存状态的协议-如何保存用户状态"><a href="#2-HTTP-是不保存状态的协议-如何保存用户状态" class="headerlink" title="2.HTTP 是不保存状态的协议, 如何保存用户状态"></a>2.HTTP 是不保存状态的协议, 如何保存用户状态</h5><p>Session + Cookie<br>token和session的区别<br>    <a href="https://blog.csdn.net/sinat_34191046/article/details/88740880" target="_blank" rel="noopener">token易扩展，session存在服务器中，但每台服务器session可能不同</a><br>    <a href="https://blog.csdn.net/u013451157/article/details/98478484" target="_blank" rel="noopener">token可以防止CSRF跨站请求伪造，因为浏览器访问默认不会带</a><br>    <a href="https://blog.csdn.net/weixin_44052462/article/details/122988438" target="_blank" rel="noopener">csrf原理</a></p>
<h5 id="3-HTTP-和-HTTPS-有什么区别"><a href="#3-HTTP-和-HTTPS-有什么区别" class="headerlink" title="==3.HTTP 和 HTTPS 有什么区别=="></a>==3.HTTP 和 HTTPS 有什么区别==</h5><p>端口号<br>    HTTP 默认是 80，HTTPS 默认是 443。<br>URL 前缀<br>    HTTP 的 URL 前缀是 <a href="http://，HTTPS" target="_blank" rel="noopener">http://，HTTPS</a> 的 URL 前缀是 https://。<br>安全性和资源消耗<br>     HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p>
<h5 id="4-HTTP1-0，1-1，2-0-的版本区别"><a href="#4-HTTP1-0，1-1，2-0-的版本区别" class="headerlink" title="4.HTTP1.0，1.1，2.0 的版本区别"></a>4.HTTP1.0，1.1，2.0 的版本区别</h5><p>1.0<br>    无状态(不记录请求记录)<br>    无连接(处理完之后立即断开TCP协议)<br>1.1<br>    开始默认使用Connection: keep-alive<br>        可以被多个请求复用<br>    管道机制<br>        在同一个TCP连接里面，客户端可以同时发送多个请求<br>2.0<br>    多路复用<br>        前提<br>            HTTP/2进行了二进制分帧<br>        在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应<br>    头部压缩<br>        使用encoder来减少需要传输的header大小</p>
<h5 id="5-token和session的区别"><a href="#5-token和session的区别" class="headerlink" title="==5.token和session的区别=="></a>==5.token和session的区别==</h5><p><a href="https://blog.csdn.net/sinat_34191046/article/details/88740880" target="_blank" rel="noopener">token易扩展，session存在服务器中，但每台服务器session可能不同</a><br><a href="https://blog.csdn.net/u013451157/article/details/98478484" target="_blank" rel="noopener">token可以防止CSRF跨站请求伪造，因为浏览器访问默认不会带</a><br>[csrf原理](</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA基础面试题</title>
    <url>/alex-next/2022/09/29/%E9%9D%A2%E8%AF%95%E9%A2%98/java%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="JAVA概述"><a href="#JAVA概述" class="headerlink" title="JAVA概述"></a>JAVA概述</h4><h5 id="1-JVM、JRE和JDK的关系"><a href="#1-JVM、JRE和JDK的关系" class="headerlink" title="1.JVM、JRE和JDK的关系"></a>1.JVM、JRE和JDK的关系</h5><blockquote>
<p>JDK包含JRE，JRE包含JVM</p>
<p>JDK=开发工具(java.exe,javac.exe等等)+JRE</p>
<p>JRE=核心类库(util,concurrent等等)+JVM</p>
</blockquote>
<h5 id="2-什么是跨平台性？原理是什么"><a href="#2-什么是跨平台性？原理是什么" class="headerlink" title="2.什么是跨平台性？原理是什么"></a>2.什么是跨平台性？原理是什么</h5><blockquote>
<p>跨平台性<br>    一次编译到处执行</p>
<p>原理<br>    Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序</p>
</blockquote>
<h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><h5 id="1-Java有哪些数据类型"><a href="#1-Java有哪些数据类型" class="headerlink" title="1.Java有哪些数据类型"></a>1.Java有哪些数据类型</h5><blockquote>
<p>基本数据类型<br>    数值型<br>        整数类型(byte,short,int,long)<br>        浮点类型(float,double)<br>    字符型(char)<br>    布尔型(boolean)</p>
<p>引用数据类型(String等)</p>
</blockquote>
<h5 id="2-用最有效率的方法计算-2-乘以-8"><a href="#2-用最有效率的方法计算-2-乘以-8" class="headerlink" title="2.用最有效率的方法计算 2 乘以 8"></a>2.用最有效率的方法计算 2 乘以 8</h5><blockquote>
<p>2&lt;&lt;3</p>
</blockquote>
<h5 id="3-float-f-3-4-是否正确"><a href="#3-float-f-3-4-是否正确" class="headerlink" title="3.float f=3.4;是否正确"></a>3.float f=3.4;是否正确</h5><blockquote>
<p>不正确<br>    3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失<br>    因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;</p>
</blockquote>
<h5 id="4-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#4-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="4.short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗"></a>4.short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</h5><blockquote>
<p>前者不对，后者对<br>由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型<br>因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换，所以后者对</p>
</blockquote>
<h5 id="5-访问修饰符-public-private-protected-以及不写（默认）时的区别"><a href="#5-访问修饰符-public-private-protected-以及不写（默认）时的区别" class="headerlink" title="==5.访问修饰符 public,private,protected,以及不写（默认）时的区别=="></a><strong>==5.访问修饰符 public,private,protected,以及不写（默认）时的区别==</strong></h5><blockquote>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/java基础/20230103193453.png"></p>
<p>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）<br>default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。<br>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</p>
<p>public : 对所有类可见。使用对象：类、接口、变量、方法</p>
</blockquote>
<h5 id="6-final-有什么用"><a href="#6-final-有什么用" class="headerlink" title="==6.final 有什么用=="></a>==6.final 有什么用==</h5><blockquote>
<p><strong>被final修饰的类不可以被继承</strong><br><strong>被final修饰的方法不可以被重写</strong><br><strong>被final修饰的变量不可以被改变</strong>，被final修饰不可变的是变量的引用(堆中的)，而不是引用本身(栈中的)，引用本身是可以改变的</p>
</blockquote>
<h5 id="7-final-finally-finalize区别"><a href="#7-final-finally-finalize区别" class="headerlink" title="7.final finally finalize区别"></a>7.final finally finalize区别</h5><blockquote>
<p>final可以修饰类、变量、方法<br>    参考Q.6<br>finally一般作用在try-catch代码块中，无论是否发生异常，finally的代码块都会执行<br>finalize是一个方法，属于Object类的一个方法<br>    当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断</p>
</blockquote>
<h5 id="8-在-Java-中，如何跳出当前的多重嵌套循环"><a href="#8-在-Java-中，如何跳出当前的多重嵌套循环" class="headerlink" title="8.在 Java 中，如何跳出当前的多重嵌套循环"></a>8.在 Java 中，如何跳出当前的多重嵌套循环</h5><blockquote>
<p>可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环</p>
</blockquote>
<h4 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h4><h5 id="1-重写和重载的区别？重载中方法的返回值可以相同吗？"><a href="#1-重写和重载的区别？重载中方法的返回值可以相同吗？" class="headerlink" title="1.重写和重载的区别？重载中方法的返回值可以相同吗？"></a>1.重写和重载的区别？重载中方法的返回值可以相同吗？</h5><blockquote>
<p>重写(override)⽅法原则<br>    1.⼦类的⽅法的名称必须和所覆盖的⽅法相同<br>    2.⼦类的⽅法的参数必须和所覆盖的⽅法相同<br>    3.⼦类的返回类型必须和所覆盖的⽅法相同 （除过⼦类中⽅法的返回类型是⽗类中返回类型的⼦类）<br>    4.⼦类抛出异常⼩于等于⽗类⽅法抛出异常<br>    5.⼦类访问权限⼤于等于⽗类⽅法访问权限<br>重载(overload)⽅法原则<br>    1.⽅法名必须相同<br>    2.⽅法的参数列表不相同（包括参数类型，参数个数，参数顺序）<br>    3.⽅法的返回类型和⽅法的修饰符可以不相同<br>总结<br>    方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性<br>    ⽅法重载的返回值类型可以不相同，⽅法重写的返回类型必须相同，否则编译报错</p>
</blockquote>
<h5 id="2-JAVA支持多继承吗，如果想要多继承怎么办？"><a href="#2-JAVA支持多继承吗，如果想要多继承怎么办？" class="headerlink" title="2.JAVA支持多继承吗，如果想要多继承怎么办？"></a>2.JAVA支持多继承吗，如果想要多继承怎么办？</h5><blockquote>
<p>不支持，可以考虑多实现、内部类、多层继承</p>
</blockquote>
<h5 id="3-抽象类和接口的区别，抽象类和接口可以实例化吗？"><a href="#3-抽象类和接口的区别，抽象类和接口可以实例化吗？" class="headerlink" title="3.抽象类和接口的区别，抽象类和接口可以实例化吗？"></a>3.抽象类和接口的区别，抽象类和接口可以实例化吗？</h5><blockquote>
<p>共同点：都不能实例化</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:left">声明</th>
<th style="text-align:left">实现</th>
<th style="text-align:left">构造器</th>
<th style="text-align:left">访问修饰符</th>
<th style="text-align:left">多继承</th>
<th style="text-align:left">字段声明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">抽象类</td>
<td style="text-align:left">抽象类使用abstract关键字声明</td>
<td style="text-align:left">子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td>
<td style="text-align:left">抽象类可以有构造器</td>
<td style="text-align:left">抽象类中的方法可以是任意访问修饰符</td>
<td style="text-align:left">一个类最多只能继承一个抽象类</td>
<td style="text-align:left">抽象类的字段声明可以是任意的</td>
</tr>
<tr>
<td style="text-align:center">接口</td>
<td style="text-align:left">接口使用interface关键字声明</td>
<td style="text-align:left">子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现</td>
<td style="text-align:left">接口不能有构造器</td>
<td style="text-align:left">接口方法默认修饰符是public。并且不允许定义为 private 或者 protected</td>
<td style="text-align:left">一个类可以实现多个接口</td>
<td style="text-align:left">接口的字段默认都是 static 和 final 的</td>
</tr>
</tbody>
</table>
</div>
<p>参考Q.5</p>
</blockquote>
<h5 id="4-String可以被继承吗"><a href="#4-String可以被继承吗" class="headerlink" title="4.String可以被继承吗"></a>4.String可以被继承吗</h5><blockquote>
<p>不能被继承,因为String类有final修饰符</p>
</blockquote>
<h5 id="5-抽象类和接口的对比"><a href="#5-抽象类和接口的对比" class="headerlink" title="5.抽象类和接口的对比"></a>5.抽象类和接口的对比</h5><blockquote>
<p>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。<br>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。<br>相同点<br>    接口和抽象类都不能实例化<br>    都位于继承的顶端，用于被其他实现或继承<br>    都包含抽象方法，其子类都必须覆写这些抽象方法</p>
</blockquote>
<h5 id="6-内部类的分类有哪些"><a href="#6-内部类的分类有哪些" class="headerlink" title="6.内部类的分类有哪些"></a>6.内部类的分类有哪些</h5><blockquote>
<p>静态内部类<br>成员内部类<br>局部内部类<br>匿名内部类<br>    就是没有名字的内部类，日常开发中使用的比较多</p>
</blockquote>
<h5 id="7-内部类的优点"><a href="#7-内部类的优点" class="headerlink" title="7.内部类的优点"></a>7.内部类的优点</h5><blockquote>
<p><strong>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</strong><br>内部类不为同一包的其他类所见，具有很好的封装性；<br>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。<br>匿名内部类可以很方便的定义回调。</p>
</blockquote>
<h5 id="8-局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final"><a href="#8-局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final" class="headerlink" title="==8.局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final=="></a>==8.局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final==</h5><blockquote>
<p>是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在(该匿名内部类作为返回值返回了)，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题<br><a href="https://blog.csdn.net/Angiexia/article/details/21244303?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164335989916780269832426%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164335989916780269832426&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-21244303.pc_search_insert_es_download&amp;utm_term=%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AA%E8%83%BD%E8%AE%BF%E9%97%AEfinal%E5%8F%98%E9%87%8F%E8%AF%A6%E7%BB%86%E4%BE%8B%E5%AD%90&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener">参考</a></p>
</blockquote>
<h5 id="9-String中equals与-的区别"><a href="#9-String中equals与-的区别" class="headerlink" title="9.String中equals与==的区别"></a>9.String中equals与==的区别</h5><blockquote>
<p>equals比较的是值比较<br>\==表示：<br>    引用数据类型比较引用地址<br>    基本数据类型比较值</p>
</blockquote>
<h5 id="10-hashCode-与-equals"><a href="#10-hashCode-与-equals" class="headerlink" title="==10.hashCode 与 equals=="></a>==10.hashCode 与 equals==</h5><blockquote>
<p>Object中的实现<br>    hashcode()<br>        本地方法，返回调用对象在内存堆上的独特值<br>    equals()<br>        this==obj<br>为什么散列表hash一定要重写hashcode和equals<br>    步骤<br>        先调用hashcode比较是否相等(是否在一个bucket中)<br>        如果Hashcode相等，再调用equals判断是否是一个对象(属性是否相同)<br>equals 方法被覆盖过，则 hashCode 方法也必须被覆盖<br>    若hashcode不重写，默认调用Object的，无论如何hashcode都不会相等</p>
<p>​    若equals不重写，默认调用Object的，除非是同一个对象，否则就算属性值相同也会返回false。</p>
<p>总结<br>    当我们需要将某一个类的对象存入散列表时（如 HashMap、HashTable 等），hashCode 和 equals 都必须重写</p>
<p><a href="https://blog.csdn.net/qq_46698411/article/details/119753966?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-119753966-blog-113819810.t0_layer_searchtargeting_s&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3" target="_blank" rel="noopener">原理</a>    <a href="https://blog.csdn.net/qq_43842093/article/details/117387063?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-117387063-blog-125721508.pc_relevant_aa&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3" target="_blank" rel="noopener">例子</a></p>
</blockquote>
<h5 id="11-值传递和引用传递有什么区别"><a href="#11-值传递和引用传递有什么区别" class="headerlink" title="11.值传递和引用传递有什么区别"></a>11.值传递和引用传递有什么区别</h5><blockquote>
<p>值传递<br>    传的是值的拷贝<br>引用传递<br>    传的是引用地址(即存在栈中的)</p>
</blockquote>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="1-说一下JAVA中的泛型"><a href="#1-说一下JAVA中的泛型" class="headerlink" title="1.说一下JAVA中的泛型?"></a>1.说一下JAVA中的泛型?</h5><blockquote>
<p>使用泛型参数，可以增强代码的可读性以及稳定性<br>泛型一般有三种使用方式:泛型类、泛型接口、泛型方法</p>
</blockquote>
<h5 id="2-Java-int-和Integer的区别，怎样比较int和Integer类型的值是否相等。"><a href="#2-Java-int-和Integer的区别，怎样比较int和Integer类型的值是否相等。" class="headerlink" title="==2.Java int 和Integer的区别，怎样比较int和Integer类型的值是否相等。=="></a>==2.Java int 和Integer的区别，怎样比较int和Integer类型的值是否相等。==</h5><blockquote>
<p>区别<br>    1.Integer是int的包装类，int则是java的一种基本数据类型<br>    2.Integer变量必须实例化后才能使用，而int变量不需要<br>    3.Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值<br>    4.Integer的默认值是null，int的默认值是0<br>int和Integer比较<br>    Integer会自动拆箱，相当于两个int比较<br>缓存机制<br>    如对于两个非new生成的Integer对象(值在-128~127之间，会从缓存中拿)<br>自动装箱和自动装箱<br>    装箱：将基本类型用它们对应的引用类型包装起来；<br>        Integer i = 10;  //装箱<br>        等价于Integer i = Integer.valueOf(10)<br>    拆箱：将包装类型转换为基本数据类型；<br>        int n = i;   //拆箱<br>        等价于int n = i.intValue()</p>
</blockquote>
<h5 id="3-java-中-IO-流分为几种"><a href="#3-java-中-IO-流分为几种" class="headerlink" title="3.java 中 IO 流分为几种"></a>3.java 中 IO 流分为几种</h5><blockquote>
<p>按照流的流向分，可以分为输入流和输出流；<br>按照操作单元划分，可以划分为字节流和字符流；<br>按照流的角色划分为节点流和处理流<br>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。<br>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流</p>
</blockquote>
<h5 id="4-BIO-NIO-AIO-有什么区别"><a href="#4-BIO-NIO-AIO-有什么区别" class="headerlink" title="4.BIO,NIO,AIO 有什么区别"></a>4.BIO,NIO,AIO 有什么区别</h5><blockquote>
<p>BIO<br>    Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低<br>NIO<br>    Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用<br>AIO<br>    实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制</p>
</blockquote>
<h5 id="5-什么是反射机制"><a href="#5-什么是反射机制" class="headerlink" title="5.什么是反射机制"></a>5.什么是反射机制</h5><blockquote>
<p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性</p>
</blockquote>
<h5 id="6-反射机制优缺点"><a href="#6-反射机制优缺点" class="headerlink" title="6.反射机制优缺点"></a>6.反射机制优缺点</h5><blockquote>
<p>优点： 运行期类型的判断，动态加载类，提高代码灵活度。<br>缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</p>
</blockquote>
<h5 id="7-获取反射的三种方法"><a href="#7-获取反射的三种方法" class="headerlink" title="7.获取反射的三种方法"></a>7.获取反射的三种方法</h5><blockquote>
<p>通过建立对象<br>    Student stu = new Student();<br>    Class classobj1 = stu.getClass();<br>所在通过路径-相对路径<br>    Class classobj2 = Class.forName(“fanshe.Student”)<br>通过类名<br>    Class classobj3 = Student.class</p>
</blockquote>
<h5 id="8-String的特性"><a href="#8-String的特性" class="headerlink" title="==8.String的特性=="></a>==8.String的特性==</h5><blockquote>
<p><strong>不变性</strong><br>    定义了final char value[]的成员变量<br>    但是引用自身(栈中)可以改变，但是引用指向的内容(堆中)不能变<br>字符串常量池<br>    位于堆内存，提高内存的使用率<br>final<br>    不可被继承</p>
</blockquote>
<h5 id="9-在使用-HashMap-的时候，用-String-做-key-有什么好处"><a href="#9-在使用-HashMap-的时候，用-String-做-key-有什么好处" class="headerlink" title="9.在使用 HashMap 的时候，用 String 做 key 有什么好处"></a>9.在使用 HashMap 的时候，用 String 做 key 有什么好处</h5><blockquote>
<p><strong>因为String的不变性</strong>，它的hashcode被缓存了下来，不需要被再次计算，速度比其他对象更快</p>
</blockquote>
<h5 id="10-String和StringBuffer、StringBuilder的区别是什么"><a href="#10-String和StringBuffer、StringBuilder的区别是什么" class="headerlink" title="==10.String和StringBuffer、StringBuilder的区别是什么=="></a>==10.String和StringBuffer、StringBuilder的区别是什么==</h5><blockquote>
<p>可变性<br>    <strong>String 是不可变的</strong><br>    StringBuilder与StringBuffer都继承自AbstractStringBuilder类，定义了char[] value，这两种对象都是可变的<br>线程安全性<br>    String中的对象是不可变的，也就可以理解为常量，线程安全<br>    StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的<br>    StringBuilder并没有对方法进行加同步锁，所以是非线程安全的<br>性能<br>    每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象<br>    StringBuffer和StringBuilder每次都会对对象本身进行操作，而不是生成新的对象并改变对象引用<br>总结<br>    如果要操作少量的数据用 =&gt; String<br>    单线程操作字符串缓冲区 下操作大量数据 =&gt; StringBuilder<br>    多线程操作字符串缓冲区 下操作大量数据 =&gt; StringBuffer</p>
</blockquote>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h4><h5 id="1-说说-List-Set-Queue-Map-四者的区别"><a href="#1-说说-List-Set-Queue-Map-四者的区别" class="headerlink" title="1.说说 List, Set, Queue, Map 四者的区别"></a>1.说说 List, Set, Queue, Map 四者的区别</h5><blockquote>
<p><img alt="2" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/java基础/20230104201918.png"></p>
<p>如上图所示</p>
<p>List<br>    存储的元素是有序的、可重复的。<br>Set<br>    存储的元素是无序的、不可重复的。<br>Queue<br>    按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。<br>Map<br>    使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</p>
</blockquote>
<h5 id="2-集合框架底层数据结构"><a href="#2-集合框架底层数据结构" class="headerlink" title="==2.集合框架底层数据结构=="></a>==2.集合框架底层数据结构==</h5><blockquote>
<p> Collection<br>     List<br>         Arraylist： Object数组<br>         Vector： Object数组<br>         LinkedList： 双向循环链表<br>     Set<br>         HashSet（无序，唯一）<br>             基于 HashMap 实现的，底层采用 HashMap 来保存元素<br>         LinkedHashSet<br>             LinkedHashSet 继承于HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。<br>         TreeSet（有序，唯一）<br>              红黑树(自平衡的排序二叉树。)<br> Map<br>     HashMap<br>         JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间<br>     LinkedHashMap<br>         LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。<br>     HashTable<br>         数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的<br>     TreeMap<br>         红黑树（自平衡的排序二叉树）</p>
</blockquote>
<h5 id="3-Java集合的快速失败机制-“fail-fast”"><a href="#3-Java集合的快速失败机制-“fail-fast”" class="headerlink" title="3.Java集合的快速失败机制 “fail-fast”"></a>3.Java集合的快速失败机制 “fail-fast”</h5><blockquote>
<p>是java集合的一种错误检测机制，如在增强for循环(foreach)中remove</p>
<p>会触发ConcurrentModificationException</p>
<p><a href="https://blog.csdn.net/weixin_50276625/article/details/115157076" target="_blank" rel="noopener">详解</a>   <a href="https://blog.csdn.net/feiying0canglang/article/details/124853294" target="_blank" rel="noopener">正确使用方法</a></p>
</blockquote>
<h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><h5 id="1-迭代器-Iterator-是什么"><a href="#1-迭代器-Iterator-是什么" class="headerlink" title="1.迭代器 Iterator 是什么"></a>1.迭代器 Iterator 是什么</h5><blockquote>
<p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例</p>
</blockquote>
<h5 id="2-Iterator-和-ListIterator-有什么区别"><a href="#2-Iterator-和-ListIterator-有什么区别" class="headerlink" title="2.Iterator 和 ListIterator 有什么区别"></a>2.Iterator 和 ListIterator 有什么区别</h5><blockquote>
<ul>
<li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li>
<li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li>
<li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li>
</ul>
</blockquote>
<h5 id="3-ArrayList-和-LinkedList-的区别是什么"><a href="#3-ArrayList-和-LinkedList-的区别是什么" class="headerlink" title="==3.ArrayList 和 LinkedList 的区别是什么=="></a>==3.ArrayList 和 LinkedList 的区别是什么==</h5><blockquote>
<p>区别</p>
<ul>
<li><p>数据结构实现<br>  ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</p>
</li>
<li><p>随机访问效率<br>  ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p>
</li>
<li>增加和删除效率<br>  在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li>
<li>内存空间占用<br>  LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li>
<li>线程安全<br>  ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全</li>
</ul>
<p>总结<br>使用ArrayList就行，LinkedList创作者自己都不用</p>
</blockquote>
<h5 id="4-ArrayList-和-Vector-的区别是什么"><a href="#4-ArrayList-和-Vector-的区别是什么" class="headerlink" title="==4.ArrayList 和 Vector 的区别是什么=="></a>==4.ArrayList 和 Vector 的区别是什么==</h5><blockquote>
<ul>
<li>线程安全<br>  Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li>
<li>性能<br>  ArrayList 在性能方面要优于 Vector。</li>
<li>扩容<br>  ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%</li>
</ul>
</blockquote>
<h5 id="5-多线程场景下如何使用-ArrayList"><a href="#5-多线程场景下如何使用-ArrayList" class="headerlink" title="==5.多线程场景下如何使用 ArrayList=="></a>==5.多线程场景下如何使用 ArrayList==</h5><blockquote>
<p>可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用</p>
</blockquote>
<h5 id="6-为什么-ArrayList-的-elementData-加上-transient-修饰"><a href="#6-为什么-ArrayList-的-elementData-加上-transient-修饰" class="headerlink" title="6.为什么 ArrayList 的 elementData 加上 transient 修饰"></a>6.为什么 ArrayList 的 elementData 加上 transient 修饰</h5><blockquote>
<p><strong>对于transient 修饰的成员变量，在类的实例对象的序列化处理过程中会被忽略。</strong></p>
<p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，<strong>这样既加快了序列化的速度，又减小了序列化之后的文件大小</strong></p>
</blockquote>
<h5 id="7-说一说-ArrayList-的扩容机制吧"><a href="#7-说一说-ArrayList-的扩容机制吧" class="headerlink" title="==7.说一说 ArrayList 的扩容机制吧=="></a>==7.说一说 ArrayList 的扩容机制吧==</h5><blockquote>
<p> 底层维护了一个数组，add()首先判断容量够不够，不够按照原容量的1.5倍扩容(System.arraycopy)，然后添加进数组</p>
</blockquote>
<h4 id="set接口"><a href="#set接口" class="headerlink" title="set接口"></a>set接口</h4><h5 id="1-list和set区别"><a href="#1-list和set区别" class="headerlink" title="1.list和set区别"></a>1.list和set区别</h5><blockquote>
<p>list<br>    有序容器(元素存入集合的顺序和取出的顺序一致)<br>    可重复<br>    检索效率高，删除插入效率低<br>set<br>    无序<br>    不可重复<br>    检索效率低，删除插入效率高</p>
</blockquote>
<h5 id="2-说一下-HashSet-的实现原理"><a href="#2-说一下-HashSet-的实现原理" class="headerlink" title="==2.说一下 HashSet 的实现原理=="></a>==2.说一下 HashSet 的实现原理==</h5><blockquote>
<p>基于HashMap实现，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT。参考HashMap。相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>
<p>HashSet部分源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">&gt; <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;  map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">&gt;  <span class="comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span></span><br><span class="line">&gt; 	<span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="3-HashSet和HashMap的区别"><a href="#3-HashSet和HashMap的区别" class="headerlink" title="3.HashSet和HashMap的区别"></a>3.HashSet和HashMap的区别</h5><blockquote>
<p>HashMap<br>    实现了Map接口<br>    存储键值对<br>    调用put（）向map中添加元素<br>    HashMap使用键（Key）计算Hashcode<br>    HashMap相对于HashSet较快，因为它是使用唯一的键获取对象<br>HashSet<br>    实现Set接口<br>    仅存储对象<br>    调用add（）方法向Set中添加元素<br>    HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false<br>    HashSet较HashMap来说比较慢</p>
<p><strong>==两者性能上的疑问解答：==</strong></p>
<p><strong>==它们都必须计算哈希码，但要考虑HashMap的键的性质 - 它通常是一个简单的字符串甚至是一个数字。计算它的哈希码比整个对象的默认哈希码计算快得多。如果HashMap的键与存储在HashSet中的键相同，那么性能就没有真正的区别。不同之处在于HashMap的关键是什么类型的对象。==</strong></p>
</blockquote>
<h4 id="map接口"><a href="#map接口" class="headerlink" title="==map接口=="></a>==map接口==</h4><h5 id="1-说一下-HashMap-的实现原理"><a href="#1-说一下-HashMap-的实现原理" class="headerlink" title="==1.说一下 HashMap 的实现原理=="></a>==1.说一下 HashMap 的实现原理==</h5><blockquote>
<p>JDK1.7<br>    计算key的hash，hash相同的话，比较key；key相同，覆盖原值，key不同，放入链表中；最后检查Map中元素个数是否大于阈值，是的话，扩容<br>    拉链法示意图</p>
<p>​    <img alt="3" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/java基础/20230104213314.png"></p>
<p>JDK1.8后<br>    1.在初始化的时候走resize()<br>    2.在插入值的时候判断是否是树节点，是的话，走红黑树插入流程，否则，走插入链表的流程，插入完之后，检查链表长度是否大于8，是的话，转换为红黑树，最后检查Map中元素个数是否大于阈值，是的话，扩容<br>    数组+链表+红黑树示意图</p>
<p>​    <img alt="4" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/java基础/20230104213326.png"></p>
</blockquote>
<h5 id="2-HashMap-JDK1-7与JDK1-8比较"><a href="#2-HashMap-JDK1-7与JDK1-8比较" class="headerlink" title="2.HashMap(JDK1.7与JDK1.8比较)"></a>2.HashMap(JDK1.7与JDK1.8比较)</h5><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>存储结构</th>
<th>初始化方式</th>
<th>hash值计算方式</th>
<th>插入数据方式</th>
<th>存放数据的规则</th>
<th>扩容后存储位置的计算方式</th>
<th>线程安全</th>
</tr>
</thead>
<tbody>
<tr>
<td>JDK1.7</td>
<td>数组 + 链表</td>
<td>单独函数：inflateTable()</td>
<td>扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算</td>
<td>头插法（先将原位置的数据移到后1位，再插入数据到该位置）</td>
<td>无冲突时，存放数组；冲突时，存放链表</td>
<td>全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td>
<td>不安全，多线程扩容时会形成环形链表</td>
</tr>
<tr>
<td>JDK1.8</td>
<td>数组 + 链表 + 红黑树</td>
<td>直接集成到了扩容函数resize()中</td>
<td>扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算</td>
<td>尾插法（直接插入到链表尾部/红黑树）</td>
<td>无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td>
<td>按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）</td>
<td>不安全，采用高低位拆分转移方式解决了多线程死循环问题。但仍是非线程安全的，多线程时可能会造成数据丢失问题</td>
</tr>
</tbody>
</table>
</div>
<h5 id="3-HashMap的put-具体流程-jdk1-8"><a href="#3-HashMap的put-具体流程-jdk1-8" class="headerlink" title="==3.HashMap的put()具体流程(jdk1.8)=="></a>==3.HashMap的put()具体流程(jdk1.8)==</h5><blockquote>
<p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；<br>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；<br>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；<br>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；<br>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；<br>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p>
<p>图解</p>
<p><img alt="5" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/java基础/20230104215122.png"></p>
</blockquote>
<h5 id="4-HashMap的扩容操作是怎么实现的"><a href="#4-HashMap的扩容操作是怎么实现的" class="headerlink" title="4.HashMap的扩容操作是怎么实现的"></a>4.HashMap的扩容操作是怎么实现的</h5><blockquote>
<p>①.在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；<br>②.每次扩展的时候，都是扩展2倍；<br>③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</p>
</blockquote>
<h5 id="5-HashMap是怎么解决哈希冲突的"><a href="#5-HashMap是怎么解决哈希冲突的" class="headerlink" title="==5.HashMap是怎么解决哈希冲突的=="></a>==5.HashMap是怎么解决哈希冲突的==</h5><blockquote>
<ol>
<li>使用链地址法（使用散列表）来链接拥有相同hash值的数据；</li>
<li>使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</li>
<li>引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</li>
</ol>
</blockquote>
<h5 id="6-为什么HashMap中String、Integer这样的包装类适合作为K"><a href="#6-为什么HashMap中String、Integer这样的包装类适合作为K" class="headerlink" title="6.为什么HashMap中String、Integer这样的包装类适合作为K"></a>6.为什么HashMap中String、Integer这样的包装类适合作为K</h5><blockquote>
<ol>
<li>都是final类型，即不可变性(hashCode() 值可以被缓存起来)，保证key的不可更改性，不会存在获取hash值不同的情况</li>
<li>内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</li>
</ol>
</blockquote>
<h5 id="7-HashMap-的长度为什么是2的幂次方"><a href="#7-HashMap-的长度为什么是2的幂次方" class="headerlink" title="7.HashMap 的长度为什么是2的幂次方"></a>7.HashMap 的长度为什么是2的幂次方</h5><blockquote>
<p>1.计算hashcode时，return h &amp; (length-1);因为要获取数组下标使用位运算，如果不是2的整数次幂，会出错<br>2.使用位运算，而不是用mod运算，是因为位运算效率比mod运算高得多，后续扩容效率更高。</p>
<p>==为什么是两次扰动呢?==<br>    加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的</p>
</blockquote>
<h5 id="8-加载因子为什么是0-75"><a href="#8-加载因子为什么是0-75" class="headerlink" title="8.加载因子为什么是0.75"></a>8.加载因子为什么是0.75</h5><blockquote>
<p>加载因子又叫负载因子，表示HashMap表中元素的填满的程度</p>
<p>时间和空间上比较均衡<br>目的:为了减少hash碰撞table长度会扩容一倍</p>
</blockquote>
<h5 id="9-HashMap与HashTable的区别"><a href="#9-HashMap与HashTable的区别" class="headerlink" title="==9.HashMap与HashTable的区别=="></a>==9.HashMap与HashTable的区别==</h5><blockquote>
<ol>
<li>线程安全</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;  HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>效率</p>
<p> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</p>
</li>
<li><p>对Null key 和Null value的支持</p>
<p> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</p>
</li>
<li><p>初始容量大小和每次扩充容量大小的不同 </p>
<p> ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。<br> ②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。</p>
</li>
<li><p>底层数据结构</p>
<p> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p>
</li>
<li><p>推荐使用</p>
<p> 在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</p>
</li>
</ol>
</blockquote>
<h5 id="10-ConcurrentHashMap-和-Hashtable-的区别"><a href="#10-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="==10.ConcurrentHashMap 和 Hashtable 的区别=="></a>==10.ConcurrentHashMap 和 Hashtable 的区别==</h5><blockquote>
<p>底层数据结构<br>    ConcurrentHashMap<br>         JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，<br>         JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。<br>    HashTable<br>        Hashtable 和 JDK1.8 之前(JDK1.7)的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；<br>实现线程安全的方式<br>    ConcurrentHashMap<br>         JDK1.7的 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分bucket</p>
<p>​    <img alt="7" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/java基础/20230106214911.png"></p>
<p>​        JDK1.8 使用 synchronized 和 CAS 来操作，每把锁只锁一个bucket</p>
<p>​        <img alt="8" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/java基础/20230106214926.png"></p>
<p>​    HashTable</p>
<p>​        示意图</p>
<p>​        <img alt="6" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/面试题/java基础/20230106214741.png"></p>
<p>​        给全表加synchronized锁，锁粒度太大</p>
</blockquote>
<h5 id="11-ConcurrentHashMap-底层具体实现"><a href="#11-ConcurrentHashMap-底层具体实现" class="headerlink" title="==11.ConcurrentHashMap 底层具体实现=="></a>==11.ConcurrentHashMap 底层具体实现==</h5><blockquote>
<p>JDK1.7<br>    Segment(ReentrantLock) + HashEntry<br>    会锁住多个HashEntry<br>JDK1.8<br>    Node + CAS + Synchronized</p>
<p>​            CAS体现在hash不冲突是自旋插入</p>
<p>​            Synchronized在hash冲突时，加上同步锁，保证线程安全</p>
<p>​    synchronized只锁定当前链表或红黑二叉树的首节点</p>
</blockquote>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/alex-next/2020/08/30/javaEE/design/</url>
    <content><![CDATA[<p>项目gitee地址</p>
<blockquote>
<p><a href="https://gitee.com/alexander1/design" target="_blank" rel="noopener">https://gitee.com/alexander1/design</a></p>
<h1 id="一、七大原则"><a href="#一、七大原则" class="headerlink" title="一、七大原则"></a>一、七大原则</h1></blockquote>
<h2 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>一个类只负责一项职责，如类A负责两个不同职责的时候，就需要将A的粒度分解为两个不同的类A1、A2</p>
<h3 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h3><p>1）、降低类的复杂度，一个类只负责一项职责</p>
<p>2）、提高类的可读性，可维护性</p>
<p>3）、降低变更引起的风险</p>
<p>4）、通常情况下，应当遵守单一职责原则，但是只要逻辑足够简单，可以违反单一职责原则，只在方法级别遵守单一职责原则。</p>
<h2 id="2、接口隔离原则"><a href="#2、接口隔离原则" class="headerlink" title="2、接口隔离原则"></a>2、接口隔离原则</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong><u>一个类对另一个类的依赖应该建立在最小的接口上，拆分接口</u></strong></p>
<p>需要使用那个接口，就实现哪个接口</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Segregation1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.depend1(<span class="keyword">new</span> B());<span class="comment">//A类通过接口依赖B类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span>,<span class="title">Interface2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B实现了operation1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B实现了operation2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B实现了operation3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span>,<span class="title">Interface3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"D实现了operation1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"D实现了operation4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"D实现了operation5"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;<span class="comment">//通过实现接口Interface1的类B</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span></span>&#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(Interface2 i)</span></span>&#123;</span><br><span class="line">        i.operation2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(Interface2 i)</span></span>&#123;</span><br><span class="line">        i.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;<span class="comment">//通过实现接口Interface1的类D</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span></span>&#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend4</span><span class="params">(Interface3 i)</span></span>&#123;</span><br><span class="line">        i.operation4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend5</span><span class="params">(Interface3 i)</span></span>&#123;</span><br><span class="line">        i.operation5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、依赖倒转原则"><a href="#3、依赖倒转原则" class="headerlink" title="3、依赖倒转原则"></a>3、依赖倒转原则</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>1）、高层模块不应该依赖低层模块，二者都应该依赖其抽象</p>
<p>2）、<strong>抽象不应该依赖细节，细节应该依赖抽象</strong></p>
<p>3）、<u><strong>依赖倒转（倒置）的中心思想是面向接口编程</strong></u></p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a><strong><u>实现方式</u></strong></h3><p>1）、通过构造方法传递</p>
<p>2）、通过接口传递实现依赖</p>
<p>3）、通过setter传递实现依赖</p>
<h3 id="注意事项和细节-1"><a href="#注意事项和细节-1" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h3><p>1）、低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好</p>
<p>2）、变量的声明类型尽量使抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化</p>
<p>3）、<strong><u>继承时遵循里氏替换原则</u></strong></p>
<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyInversion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.receive(<span class="keyword">new</span> WeiXin());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReceiver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">IReceiver</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"电子邮件信息：hello,world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加微信</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiXin</span> <span class="keyword">implements</span> <span class="title">IReceiver</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"微信"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式2：对接口进行依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(IReceiver iReceiver)</span></span>&#123;</span><br><span class="line">        System.out.println(iReceiver.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、里氏替换原则"><a href="#4、里氏替换原则" class="headerlink" title="4、里氏替换原则"></a>4、里氏替换原则</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>1）、所有引用基类的地方必须能透明地使用其子类的对象</p>
<p>2）、在使用继承时，<strong><u>在子类中尽量不要重写父类的方法</u></strong></p>
<p>3）、 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合、组合、依赖来解决问题。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>让原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉</p>
<h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Liskov</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        <span class="keyword">int</span> i = b.func3(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="comment">//把更加基础的方法和成员写到Base类中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1-num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">//组合</span></span><br><span class="line">    <span class="keyword">private</span> A a  = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a*b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a.func1(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、开闭原则"><a href="#5、开闭原则" class="headerlink" title="5、开闭原则"></a>5、开闭原则</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>1）、开闭原则是编程中最基础、最重要的设计原则</p>
<p>2）、对扩展开放（对提供方）、对修改关闭（使用方）。</p>
<p>3）、当软件需求变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p>
<p>4）、编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则。</p>
<h3 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于绘图的类[使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span></span>&#123;</span><br><span class="line">    <span class="comment">//接受Shape队形，然后根据type绘制不同的图形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span></span>&#123;</span><br><span class="line">        s.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m_type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Rectangle()&#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"矩形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Circle()&#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"圆形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形的类[提供方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Triangle()&#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"三角形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6、迪米特原则"><a href="#6、迪米特原则" class="headerlink" title="6、迪米特原则"></a>6、迪米特原则</h2><h3 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>1）、一个对象应该对其他对象保持最少的了解</p>
<p>2）、类和类的关系越密切，耦合度越大</p>
<p>3）、一个类对自己依赖的类知道的越少越好。对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部，对外除了提供public方法，不对外泄露任何信息。</p>
<p>4）、==只与直接朋友通信==</p>
<p>5）、直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。</p>
<p>​        其中称，==出现成员变量、方法参数、方法返回值中的类为直接的朋友==，而出现在局部变量中的类不是直接的朋友。就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</p>
<h3 id="注意事项和细节-2"><a href="#注意事项和细节-2" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h3><p>1）、核心是降低类之间的耦合</p>
<p>2）、注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类键（对象间）耦合关系，并不是要求完全没有依赖关系。</p>
<h3 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demeter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"============改进============"</span>);</span><br><span class="line">        SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">        schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学院的所有员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">            CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">            emp.setId(<span class="string">"学院员工id= "</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出学院员工信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取到学院员工</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">"------------学院员工------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学校总部的员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">            Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">            emp.setId(<span class="string">"学校总部员工id= "</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分析问题</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.将输出学院的员工的方法，封装到CollegeManager中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        sub.printEmployee();</span><br><span class="line">        <span class="comment">//获取到学校总部员工</span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">"------------学校总部员工------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==封装sub.printEmployee()方法的目的是为了下次调用的时候还要再次重写此方法。注重代码的封装。==</p>
<h2 id="7、合成复用原则"><a href="#7、合成复用原则" class="headerlink" title="7、合成复用原则"></a>7、合成复用原则</h2><h3 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>原则是尽量使用合成/聚合的方式，而不是使用继承</strong></p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>1）、找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</p>
<p>2）、==针对接口编程，而不是针对实现编程。==</p>
<p>3）、为了交互对象之间的松耦合设计而努力。</p>
<h1 id="二、UML类图"><a href="#二、UML类图" class="headerlink" title="二、UML类图"></a>二、UML类图</h1><p>1）、静态结构图：==类图==、对象图、包图。。</p>
<p>2）、动态行为图：交互图、状态图、活动图</p>
<p>3）、用例图</p>
<p>类图是描述类与类之间的关系</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="依赖关系（虚线箭头）"><a href="#依赖关系（虚线箭头）" class="headerlink" title="依赖关系（虚线箭头）"></a>依赖关系（虚线箭头）</h3><p>1）、类中用到了对方</p>
<p>2）、如果是类的成员属性</p>
<p>3）、如果是方法的返回类型</p>
<p>4）、是方法接受的参数类型</p>
<p>5）、方法中使用到（违反迪米特法则）</p>
<h3 id="泛化关系（实线三角形）"><a href="#泛化关系（实线三角形）" class="headerlink" title="泛化关系（实线三角形）"></a>泛化关系（实线三角形）</h3><p>1）、就是继承关系</p>
<p>2）、如果A类继承了B类，就说A和B存在泛化关系</p>
<p>3）、是依赖关系的特例</p>
<h3 id="实现关系（虚线三角形）"><a href="#实现关系（虚线三角形）" class="headerlink" title="实现关系（虚线三角形）"></a>实现关系（虚线三角形）</h3><p>1）、是依赖关系的特例</p>
<p>2）、如果A类实现了B类，就说A和B存在实现关系</p>
<h3 id="关联关系（直线）"><a href="#关联关系（直线）" class="headerlink" title="关联关系（直线）"></a>关联关系（直线）</h3><p>他是类与类之间的联系，有双向关系与单项关系</p>
<p>1）、是依赖关系的特例</p>
<h3 id="聚合关系（空心菱形）"><a href="#聚合关系（空心菱形）" class="headerlink" title="聚合关系（空心菱形）"></a>聚合关系（空心菱形）</h3><p>表示整体与部分的关系，<strong>整体与部分可以分开。</strong></p>
<p>1）、是关联关系的特例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Mouse mouse; <span class="comment">//鼠标可以和computer分离</span></span><br><span class="line">	<span class="keyword">private</span> Moniter moniter;<span class="comment">//显示器可以和Computer分离</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMouse</span><span class="params">(Mouse mouse)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.mouse = mouse;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoniter</span><span class="params">(Moniter moniter)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.moniter = moniter;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合关系（实心菱形）"><a href="#组合关系（实心菱形）" class="headerlink" title="组合关系（实心菱形）"></a>组合关系（实心菱形）</h3><p>整体与部分不可分开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Mouse mouse = <span class="keyword">new</span> Mouse(); <span class="comment">//鼠标可以和computer不能分离</span></span><br><span class="line">	<span class="keyword">private</span> Moniter moniter = <span class="keyword">new</span> Moniter();<span class="comment">//显示器可以和Computer不能分离</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMouse</span><span class="params">(Mouse mouse)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.mouse = mouse;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoniter</span><span class="params">(Moniter moniter)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.moniter = moniter;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、设计模式"><a href="#三、设计模式" class="headerlink" title="三、设计模式"></a>三、设计模式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>1）、创建型模式（如何创建对象）：==单例模式==、抽象工厂模式、原型模式、建造者模式、==工厂模式==</p>
<p>2）、结构型模式（软件结构上思考）：适配器模式、桥接模式、==装饰模式==、组合模式、外观模式、享元模式、==代理模式==</p>
<p>3）、行为型模式（方法上思考）：模板方法模式、命令模式、访问者模式、迭代器模式、==观察者模式==、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式</p>
<h2 id="1、-单例模式-（易）"><a href="#1、-单例模式-（易）" class="headerlink" title="1、==单例模式==（易）"></a>1、==单例模式==（易）</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>保证某个类只能==存在一个对象实例==，并且该类只提供一个取得其对象实例的方法（静态方法）</p>
<h3 id="1）、饿汉式（静态常量）"><a href="#1）、饿汉式（静态常量）" class="headerlink" title="1）、饿汉式（静态常量）"></a>1）、饿汉式（静态常量）</h3><p>优缺点说明：</p>
<p>1）、优点：写法简单，在类装载的时候就完成实例化。避免线程同步问题。</p>
<p>2）、缺点：在类装载的时候完成实例化，没有达到Lazy Loading的效果。</p>
<p>3）、结论：这种方式可用，可能造成内存浪费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态常量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.构造方法私有化，外部不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2）、饿汉式（静态代码块）"><a href="#2）、饿汉式（静态代码块）" class="headerlink" title="2）、饿汉式（静态代码块）"></a>2）、饿汉式（静态代码块）</h3><p>优缺点说明：与静态变量方式实现的相似</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.构造方法私有化，外部不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123; <span class="comment">//静态代码块中创建单例对象</span></span><br><span class="line">    	instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3）、懒汉式（线程不安全）"><a href="#3）、懒汉式（线程不安全）" class="headerlink" title="3）、懒汉式（线程不安全）"></a>3）、懒汉式（线程不安全）</h3><p>优缺点说明：</p>
<p>1）、起到了Lazy Loading 的效果，只能在单线程下才能使用</p>
<p>2）、在多线程的情况下，会存在多个实例</p>
<p>3）、结论：在多线程情况下，不能使用此方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当使用到该方法使，才去创建instance</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4）、懒汉式（线程安全，同步方法）"><a href="#4）、懒汉式（线程安全，同步方法）" class="headerlink" title="4）、懒汉式（线程安全，同步方法）"></a>4）、懒汉式（线程安全，同步方法）</h3><p>优缺点说明：</p>
<p>1）、解决了线程不安全的行为</p>
<p>2）、效率太低了，每次要获取实例的时候，执行getInstance（）都要进行同步。</p>
<p>3）、在实际开发中，不推荐使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当使用到该方法使，才去创建instance</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5）、懒汉式（线程不安全）"><a href="#5）、懒汉式（线程不安全）" class="headerlink" title="5）、懒汉式（线程不安全）"></a>5）、懒汉式（线程不安全）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当使用到该方法时，才去创建instance</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法是错误的，线程是不安全的</p>
<h3 id="6）、双重检查"><a href="#6）、双重检查" class="headerlink" title="6）、双重检查"></a>6）、双重检查</h3><p>优缺点说明：</p>
<p>1）、保证了线程安全</p>
<p>2）、避免反复进行方法</p>
<p>3）、延迟加载、效率较高</p>
<p>4）、结论：推荐使用这种方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//volatile通知其他线程singleton的情况</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7）、静态内部类"><a href="#7）、静态内部类" class="headerlink" title="7）、静态内部类"></a>7）、静态内部类</h3><p>优缺点说明：</p>
<p>1）、利用了类装载的机制来保证初始化实例时只有一个线程</p>
<p>2）、静态内部类方式在Singleton类被装载时不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载inner类，从而完成Singleton的实例化。</p>
<p>3）、类的静态属性只会在第一次加载类的时候初始化，JVM帮我们保证了线程的安全性，在类初始化时，别的线程是无法进入的。</p>
<p>4）、优点：避免了线程不安全，利用静态内部类特点是实现延迟加载，效率高。</p>
<p>5）、结论：推荐使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Singleton类装载的时候inner类不会被装载，只有调用getInstance的时候才会被装载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">inner</span></span>&#123;</span><br><span class="line">        <span class="comment">//装载类的时候线程是安全的，是JVM提供的</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inner.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8）、枚举"><a href="#8）、枚举" class="headerlink" title="8）、枚举"></a>8）、枚举</h3><p>优缺点说明：</p>
<p>1）、能避免多线程同步问题，而且能防止反序列化重新创建新的对象。</p>
<p>2）、结论：推荐使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ok~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项和细节说明"><a href="#注意事项和细节说明" class="headerlink" title="注意事项和细节说明"></a>注意事项和细节说明</h3><p>1）、单例模式保证了系统内存只存在一个对象，节省了系统资源，对于一些频繁创建销毁的对象，使用单例模式可以提高系统性能</p>
<p>2）、要想实例化单例类是，应该使用相应的获取对象的方法，而不是使用new</p>
<p>3）、使用场景：频繁使用的对象、创建对象耗时过多、耗费资源过多</p>
<p>​        如：工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂、JDK中Runtime类）</p>
<h2 id="2、-工厂模式-（难）"><a href="#2、-工厂模式-（难）" class="headerlink" title="2、==工厂模式==（难）"></a>2、==工厂模式==（难）</h2><h3 id="1）、简单工厂模式"><a href="#1）、简单工厂模式" class="headerlink" title="1）、简单工厂模式"></a>1）、简单工厂模式</h3><h4 id="传统方式的优缺点："><a href="#传统方式的优缺点：" class="headerlink" title="传统方式的优缺点："></a>传统方式的优缺点：</h4><p>1）、优点：比较好理解，简单易操作</p>
<p>2）、缺点：违反了设计模式的ocp原则，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码。???==持保留意见，看菜鸟教程的工厂模式OrderPizza其实已经是工厂模式了==</p>
<p>3）、比如增加pizza的种类，会修改许多相关的代码。</p>
<p>4）改进的思路分析</p>
<p>分析：如果在其他的地方也有创建Pizza的代码，就意味着，也需要修改OrderPizza；</p>
<p>思路：把创建Pizza对象封装到一个类中，这样有新的Pizza种类时，只需要修改改类就行，其他有创建到Pizza对象的代码就不需要修改了-&gt;简单工厂模式</p>
<h4 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h4><p>1）、简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式</p>
<p>2）、定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码）</p>
<p>3）、当用到大量的创建某种、某类或者某批对象时，就可以用到工厂模式。</p>
<p><img alt data-src="https://gitee.com/alexander1/pic/raw/master/design_parttern/20210830211634.png"></p>
<h3 id="2）、工厂方法模式"><a href="#2）、工厂方法模式" class="headerlink" title="2）、工厂方法模式"></a>2）、工厂方法模式</h3><h4 id="简单介绍-1"><a href="#简单介绍-1" class="headerlink" title="简单介绍"></a>简单介绍</h4><p>定义一个创建对象的抽象方法，由子类决定要实例化的类，工厂方法模式==将对象的实例化推迟到子类==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个抽象方法，让各个工厂子类自己实现</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        String orderType;<span class="comment">//订购披萨的类型</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            orderType = getType();</span><br><span class="line">            pizza = createPizza(orderType);</span><br><span class="line">            <span class="keyword">if</span> (pizza==<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"没有库存，订购失败"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出pizza制作过程</span></span><br><span class="line">            pizza.prepare();</span><br><span class="line">            pizza.bake();</span><br><span class="line">            pizza.cut();</span><br><span class="line">            pizza.box();</span><br><span class="line">        &#125;<span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法，可以获取披萨类</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader strin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            System.out.println(<span class="string">"input pizza 种类:"</span>);</span><br><span class="line">            String str = strin.readLine();</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个抽象方法，让各个工厂子类自己实现</p>
<p>Pizza类也是个抽象类，根据实际需要动态创建</p>
<p><img alt data-src="https://gitee.com/alexander1/pic/raw/master/design_parttern/20210830211640.png"></p>
<h3 id="3）、抽象工厂模式"><a href="#3）、抽象工厂模式" class="headerlink" title="3）、抽象工厂模式"></a>3）、抽象工厂模式</h3><h4 id="简单介绍-2"><a href="#简单介绍-2" class="headerlink" title="简单介绍"></a>简单介绍</h4><p>1）、定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类。</p>
<p>2）、抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。</p>
<p>3）、从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或者成为进一步的抽象）</p>
<p>4）、将工厂抽象成两层，AbsFactory（抽象工厂）和具体实现的工厂子类。</p>
<p>UML图：</p>
<p><img alt data-src="https://gitee.com/alexander1/pic/raw/master/design_parttern/20210830211642.png"></p>
<p>==抽象工厂模式就是对简单工厂模式在工厂Factory类上再次进行简单工厂模式==</p>
<h3 id="工厂模式总结"><a href="#工厂模式总结" class="headerlink" title="工厂模式总结"></a>工厂模式总结</h3><p>1）、将实例化对象的代码提取出来</p>
<p>2）、三种工厂模式</p>
<p>3）、设计模式的==依赖倒转==原则</p>
<p>4）、==工厂模式注重结果，建造者模式强调过程==</p>
<h2 id="3、-原型模式-（易）"><a href="#3、-原型模式-（易）" class="headerlink" title="3、==原型模式==（易）"></a>3、==原型模式==（易）</h2><h3 id="传统方式的优缺点"><a href="#传统方式的优缺点" class="headerlink" title="传统方式的优缺点"></a>传统方式的优缺点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Sheep sheep1 = <span class="keyword">new</span> Sheep(<span class="string">"tom"</span>, <span class="number">1</span>, <span class="string">"白色"</span>);</span><br><span class="line">    Sheep sheep2 = <span class="keyword">new</span> Sheep(sheep1.getName(), sheep1.getAge(), sheep1.getColor());</span><br><span class="line">    Sheep sheep3 = <span class="keyword">new</span> Sheep(sheep1.getName(), sheep1.getAge(), sheep1.getColor());</span><br><span class="line">    Sheep sheep4 = <span class="keyword">new</span> Sheep(sheep1.getName(), sheep1.getAge(), sheep1.getColor());</span><br><span class="line">    Sheep sheep5 = <span class="keyword">new</span> Sheep(sheep1.getName(), sheep1.getAge(), sheep1.getColor());</span><br><span class="line">    System.out.println(sheep1);</span><br><span class="line">    System.out.println(sheep2);</span><br><span class="line">    System.out.println(sheep3);</span><br><span class="line">    System.out.println(sheep4);</span><br><span class="line">    System.out.println(sheep5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）、优点：比较好理解，易操作</p>
<p>2）、在创建新对象是，总是需要重新获取原始对象的属性；如果创建的对象比较复杂，效率较低。</p>
<p>3）、总是需要重新初始化对象，而不是动态地获取对象运行时的状态，不够灵活。</p>
<p>4）、改进的思路：==Object类有一个clone()方法，该方法可以将一个java对象复制一份，但是需要实现clone的java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力=》原型模式==</p>
<h3 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>1）、原型模式是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。</p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>1）、字面量类型(String或基本数据类型和包装类)会进行值传递</p>
<p>2）、若是引用类型的成员变量，只是将成员变量的引用值复制给一个新的对象。这样改变原有的对象，会改变拷贝的其他对象。</p>
<p>3）、浅拷贝是使用默认clone()方法实现的</p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>1）、字面量类型和引用类型都会拷贝一份，</p>
<p>2）、实现方式1：重写clone方法</p>
<p>3）、实现方式2：通过对象序列化</p>
<p>4）、实现方式3：JSON实现</p>
<p>5）、实现方式4：Spring的BeanUtils</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepProtoType</span> <span class="keyword">implements</span> <span class="title">Serializable</span>,<span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> DeepCloneableTarget deepCloneableTarget;<span class="comment">//引用类型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeepProtoType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式1,重写clone</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object deep = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里完成对字面量的克隆</span></span><br><span class="line">            deep = <span class="keyword">super</span>.clone();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对引用类型，单独处理</span></span><br><span class="line">            DeepProtoType deepProtoType = (DeepProtoType)deep;</span><br><span class="line">            deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone();</span><br><span class="line">        &#125;<span class="keyword">catch</span> ( Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式2，序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建流对象</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        DeepProtoType o = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>);<span class="comment">//当前这个对象以对象流的方式输出(序列化)</span></span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">            o = (DeepProtoType)ois.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ois!=<span class="keyword">null</span>)ois.close();</span><br><span class="line">                <span class="keyword">if</span> (bis!=<span class="keyword">null</span>)bis.close();</span><br><span class="line">                <span class="keyword">if</span> (oos!=<span class="keyword">null</span>)oos.close();</span><br><span class="line">                <span class="keyword">if</span> (bos!=<span class="keyword">null</span>)bos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项和细节-3"><a href="#注意事项和细节-3" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h3><p>1）、创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，能提高效率。</p>
<p>2）、不用重新初始化对象，而是动态地获取对象运行时的状态</p>
<p>3）、原始对象发生改变（增加或减少属性），无需修改代码</p>
<p>4）、<strong>缺点</strong>：需要为每一个类配置一个克隆方法，这对全新的类来说不是很难，但对已有的类进行修改时，需要修改其源代码，违背了ocp原则。</p>
<h2 id="4、建造者模式（易）"><a href="#4、建造者模式（易）" class="headerlink" title="4、建造者模式（易）"></a>4、建造者模式（易）</h2><h3 id="传统方式分析："><a href="#传统方式分析：" class="headerlink" title="传统方式分析："></a>传统方式分析：</h3><p>1）、优点：好理解，易操作</p>
<p>2）、没有缓存层对象，程序的扩展和维护不好，这种设计方案吧产品和创建产品的过程封装在一起，耦合性增强了，</p>
<p>3）、解决方案：将产品和产品建造过程解耦=》建造者模式</p>
<h3 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>1）、可以将复杂对象的建造过程抽象出来，使这个抽象过程的不同实现方式可以构造出不同表现的对象。</p>
<p>2）、用户不需要知道内部的具体构建细节。==建造者模式是一步一步创建一个复杂对象的==，允许用户只通过制定复杂对象的类型和内容就可以构建他们。</p>
<p>3）、==作用：构建复杂对象！！！==</p>
<h3 id="四个角色"><a href="#四个角色" class="headerlink" title="四个角色"></a>四个角色</h3><p>1）、产品角色（Product）；一个具体的产品对象</p>
<p>2）、抽象建造者（Builder）；创建一个Product对象的各个部件指定的接口/抽象类</p>
<p>3）、具体建造者（ConcreteBuilder）；实现接口，构建和装配各个部件</p>
<p>4）、指挥者（Director）；构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用：1.隔离了客户与对象的生产过程，2.负责控制产品对象的生产过程。</p>
<h3 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h3><p>==利用静态内部类创建属性较多的对象：==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonBuilder</span></span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> PersonBuilder <span class="title">basicInfo</span><span class="params">(<span class="keyword">int</span> id,String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">            p.id = id;</span><br><span class="line">            p.name = name;</span><br><span class="line">            p.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> PersonBuilder <span class="title">appearance</span><span class="params">(<span class="keyword">int</span> weight,<span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">            p.weight=weight;</span><br><span class="line">            p.height=height;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> PersonBuilder <span class="title">score</span><span class="params">(<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">            p.score=score;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", weight="</span> + weight +</span><br><span class="line">                <span class="string">", height="</span> + height +</span><br><span class="line">                <span class="string">", score="</span> + score +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、策略模式（中）"><a href="#5、策略模式（中）" class="headerlink" title="5、策略模式（中）"></a>5、策略模式（中）</h2><h3 id="基本介绍-9"><a href="#基本介绍-9" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>意图：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p>
<p><strong>主要解决：</strong>==在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。==</p>
<p><strong>何时使用：</strong>一个系统有许多许多类，而区分它们的只是他们直接的行为。</p>
<p><strong>如何解决：</strong>将这些算法封装成一个一个的类，任意地替换。</p>
<p><strong>关键代码：</strong>实现同一个接口。</p>
<p><strong>应用实例：</strong> 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。</p>
<p><strong>优点：</strong> 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p>
<p><strong>缺点：</strong> 1、策略类会增多。 2、所有策略类都需要对外暴露。</p>
<p><strong>使用场景：</strong> 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p>
<p><strong>注意事项：</strong>如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p>
<h3 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h3><p>MyComparator.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyComparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1,T o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sorter2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//选择排序，每次选出最小的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] arr,MyComparator&lt;T&gt; myComparator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> minPos = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                minPos = myComparator.compare(arr[j],arr[minPos])&lt;<span class="number">0</span>?j:minPos;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr,i,minPos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        T temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Cat[] cats = &#123;<span class="keyword">new</span> Cat(<span class="number">3</span>,<span class="number">3</span>),<span class="keyword">new</span> Cat(<span class="number">5</span>,<span class="number">5</span>),<span class="keyword">new</span> Cat(<span class="number">1</span>,<span class="number">1</span>)&#125;;</span><br><span class="line">    Sorter2.sort(cats, <span class="keyword">new</span> MyComparator&lt;Cat&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Cat o1, Cat o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getHeight()-o2.getHeight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(Arrays.toString(cats));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==可以灵活地在sort方法里传入不同的比较策略==</p>
<h2 id="6、外观模式（易）"><a href="#6、外观模式（易）" class="headerlink" title="6、外观模式（易）"></a>6、外观模式（易）</h2><h3 id="基本介绍-10"><a href="#基本介绍-10" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>意图：</strong>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<p><strong>主要解决：</strong>降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。</p>
<p><strong>何时使用：</strong> 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 2、定义系统的入口。</p>
<p><strong>如何解决：</strong>客户端不与系统耦合，外观类与系统耦合。</p>
<p><strong>关键代码：</strong>在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。</p>
<p><strong>应用实例：</strong> 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。</p>
<p><strong>优点：</strong> 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。</p>
<p><strong>缺点：</strong>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p>
<p><strong>使用场景：</strong> 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。</p>
<p><strong>注意事项：</strong>在层次化结构中，可以使用外观模式定义系统中每一层的入口。</p>
<h3 id="案例-7"><a href="#案例-7" class="headerlink" title="案例"></a>案例</h3><p>==将调用放在外观类中，封装起来，集体调用==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeTheaterFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义各个子系统对象</span></span><br><span class="line">	<span class="keyword">private</span> TheaterLight theaterLight;</span><br><span class="line">	<span class="keyword">private</span> Popcorn popcorn;</span><br><span class="line">	<span class="keyword">private</span> Stereo stereo;</span><br><span class="line">	<span class="keyword">private</span> Projector projector;</span><br><span class="line">	<span class="keyword">private</span> Screen screen;</span><br><span class="line">	<span class="keyword">private</span> DVDPlayer dVDPlayer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HomeTheaterFacade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.theaterLight = TheaterLight.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.popcorn = Popcorn.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.stereo = Stereo.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.projector = Projector.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.screen = Screen.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.dVDPlayer = DVDPlayer.getInstanc();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//操作分成 4 步</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		popcorn.on();</span><br><span class="line">		popcorn.pop();</span><br><span class="line">		screen.down();</span><br><span class="line">		projector.on();</span><br><span class="line">		stereo.on();</span><br><span class="line">		dVDPlayer.on();</span><br><span class="line">		theaterLight.dim();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		dVDPlayer.play();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		dVDPlayer.pause();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		popcorn.off();</span><br><span class="line">		theaterLight.bright();</span><br><span class="line">		screen.up();</span><br><span class="line">		projector.off();</span><br><span class="line">		stereo.off();</span><br><span class="line">		dVDPlayer.off();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7、中介者模式（中）"><a href="#7、中介者模式（中）" class="headerlink" title="7、中介者模式（中）"></a>7、中介者模式（中）</h2><h3 id="基本介绍-11"><a href="#基本介绍-11" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>意图：</strong>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<p><strong>主要解决：</strong>对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</p>
<p><strong>何时使用：</strong>多个类相互耦合，形成了网状结构。</p>
<p><strong>如何解决：</strong>将上述网状结构分离为星型结构。</p>
<p><strong>关键代码：</strong>对象 Colleague 之间的通信封装到一个类中单独处理。</p>
<p><strong>应用实例：</strong> 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。</p>
<p><strong>优点：</strong> 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。</p>
<p><strong>缺点：</strong>中介者会庞大，变得复杂难以维护。</p>
<p><strong>使用场景：</strong> 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</p>
<p><strong>注意事项：</strong>不应当在职责混乱的时候使用。</p>
<h3 id="案例-8"><a href="#案例-8" class="headerlink" title="案例"></a>案例</h3><p>==通过构造中介者类处理类与类之间复杂的逻辑关系，方便用户调用。==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体的中介者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">	<span class="comment">//集合，放入所有的同事对象</span></span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;String, Colleague&gt; colleagueMap;</span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;String, String&gt; interMap;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConcreteMediator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		colleagueMap = <span class="keyword">new</span> HashMap&lt;String, Colleague&gt;();</span><br><span class="line">		interMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span><span class="params">(String colleagueName, Colleague colleague)</span> </span>&#123;</span><br><span class="line">		colleagueMap.put(colleagueName, colleague);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> Alarm) &#123;</span><br><span class="line">			interMap.put(<span class="string">"Alarm"</span>, colleagueName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> CoffeeMachine) &#123;</span><br><span class="line">			interMap.put(<span class="string">"CoffeeMachine"</span>, colleagueName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> TV) &#123;</span><br><span class="line">			interMap.put(<span class="string">"TV"</span>, colleagueName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> Curtains) &#123;</span><br><span class="line">			interMap.put(<span class="string">"Curtains"</span>, colleagueName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//具体中介者的核心方法</span></span><br><span class="line">	<span class="comment">//1. 根据得到消息，完成对应任务</span></span><br><span class="line">	<span class="comment">//2. 中介者在这个方法，协调各个具体的同事对象，完成任务</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetMessage</span><span class="params">(<span class="keyword">int</span> stateChange, String colleagueName)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//处理闹钟发出的消息</span></span><br><span class="line">		<span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> Alarm) &#123;</span><br><span class="line">			<span class="keyword">if</span> (stateChange == <span class="number">0</span>) &#123;</span><br><span class="line">				((CoffeeMachine) (colleagueMap.get(interMap</span><br><span class="line">						.get(<span class="string">"CoffeeMachine"</span>)))).StartCoffee();</span><br><span class="line">				((TV) (colleagueMap.get(interMap.get(<span class="string">"TV"</span>)))).StartTv();</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (stateChange == <span class="number">1</span>) &#123;</span><br><span class="line">				((TV) (colleagueMap.get(interMap.get(<span class="string">"TV"</span>)))).StopTv();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> CoffeeMachine) &#123;</span><br><span class="line">			((Curtains) (colleagueMap.get(interMap.get(<span class="string">"Curtains"</span>))))</span><br><span class="line">					.UpCurtains();</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> TV) &#123;<span class="comment">//如果TV发现消息</span></span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> Curtains) &#123;</span><br><span class="line">			<span class="comment">//如果是以窗帘发出的消息，这里处理...</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8、-装饰模式-（难）"><a href="#8、-装饰模式-（难）" class="headerlink" title="8、==装饰模式==（难）"></a>8、==装饰模式==（难）</h2><h3 id="基本介绍-12"><a href="#基本介绍-12" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>意图：</strong>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>
<p><strong>主要解决：</strong>一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p>
<p><strong>何时使用：</strong>在不想增加很多子类的情况下扩展类。</p>
<p><strong>如何解决：</strong>将具体功能职责划分，同时继承装饰者模式。</p>
<p><strong>关键代码：</strong> 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。</p>
<p><strong>应用实例：</strong> 1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</p>
<p><strong>优点：</strong>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
<p><strong>缺点：</strong>多层装饰比较复杂。</p>
<p><strong>使用场景：</strong> 1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p>
<p><strong>注意事项：</strong>可代替继承。</p>
<p><img alt data-src="https://gitee.com/alexander1/pic/raw/master/design_parttern/20210830211656.png"></p>
<h3 id="案例-9"><a href="#案例-9" class="headerlink" title="案例"></a>案例</h3><p>==给某些类加上”装备“。==</p>
<p>==装饰类的基类Decorator.java,<strong>需要继承和需要“装备”的类一样的接口</strong>。==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Drink drink = <span class="keyword">new</span> LongBlack();<span class="comment">//咖啡</span></span><br><span class="line">drink = <span class="keyword">new</span> Chocolate(drink);<span class="comment">//咖啡中需要有巧克力</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String des; <span class="comment">// 描述</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">private</span> Drink drink;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Drink drink)</span> </span>&#123; <span class="comment">//组合 这里就是为了把drink（被修饰）引进来！！</span></span><br><span class="line">        <span class="keyword">this</span>.drink = drink;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// obj.getDes() 输出被装饰者的信息</span></span><br><span class="line">        <span class="keyword">return</span> des + <span class="string">" "</span> + getPrice() + <span class="string">" &amp;&amp; "</span> + drink.getDes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDes</span><span class="params">(String des)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.des = des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// getPrice 自己价格</span></span><br><span class="line">        <span class="keyword">return</span> getPrice() + drink.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9、-责任链模式-（难）"><a href="#9、-责任链模式-（难）" class="headerlink" title="9、==责任链模式==（难）"></a>9、==责任链模式==（难）</h2><h3 id="基本介绍-13"><a href="#基本介绍-13" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>意图：</strong>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
<p><strong>主要解决：</strong>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p>
<p><strong>何时使用：</strong>在处理消息的时候以过滤很多道。</p>
<p><strong>如何解决：</strong>拦截的类都实现统一接口。</p>
<p><strong>关键代码：</strong>Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</p>
<p><strong>应用实例：</strong> 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 ==3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。==</p>
<p><strong>优点：</strong> 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。</p>
<p><strong>缺点：</strong> 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。</p>
<p><strong>使用场景：</strong> 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。</p>
<p><strong>注意事项：</strong>在 JAVA WEB 中遇到很多应用。</p>
<h3 id="案例-10"><a href="#案例-10" class="headerlink" title="案例"></a>案例</h3><p>处理request</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Msg msg = <span class="keyword">new</span> Msg();</span><br><span class="line">        msg.setMsg(<span class="string">":)&lt;script&gt;.asd996,www.baidu.com"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        new HTMLFilter().doFilter(msg);</span></span><br><span class="line"><span class="comment">//        new SensitiveFilter().doFilter(msg);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        List&lt;Filter&gt; filters = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        filters.add(new HTMLFilter());</span></span><br><span class="line"><span class="comment">//        filters.add(new SensitiveFilter());</span></span><br><span class="line"><span class="comment">//        for (Filter f:filters)&#123;</span></span><br><span class="line"><span class="comment">//            f.doFilter(msg);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        FilterChain fc = <span class="keyword">new</span> FilterChain();</span><br><span class="line">        fc.add(<span class="keyword">new</span> HTMLFilter()).add(<span class="keyword">new</span> SensitiveFilter());</span><br><span class="line"></span><br><span class="line">        FilterChain fc2 = <span class="keyword">new</span> FilterChain();</span><br><span class="line">        fc2.add(<span class="keyword">new</span> FaceFilter()).add(<span class="keyword">new</span> URLFilter());</span><br><span class="line"></span><br><span class="line">        fc.add(fc2);</span><br><span class="line">        fc.doFilter(msg);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Msg</span></span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        String msg;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Msg&#123;"</span> +</span><br><span class="line">                    <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">", msg='"</span> + msg + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Msg m)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HTMLFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Msg m)</span> </span>&#123;</span><br><span class="line">            String r = m.getMsg();</span><br><span class="line">            r = r.replace(<span class="string">'&lt;'</span>,<span class="string">'['</span>);</span><br><span class="line">            r = r.replace(<span class="string">'&gt;'</span>,<span class="string">']'</span>);</span><br><span class="line">            m.setMsg(r);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SensitiveFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Msg m)</span> </span>&#123;</span><br><span class="line">            String r = m.getMsg();</span><br><span class="line">            r = r.replace(<span class="string">"996"</span>,<span class="string">"007"</span>);</span><br><span class="line">            m.setMsg(r);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FaceFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Msg m)</span> </span>&#123;</span><br><span class="line">            String r = m.getMsg();</span><br><span class="line">            r = r.replace(<span class="string">":)"</span>,<span class="string">"^V^"</span>);</span><br><span class="line">            m.setMsg(r);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">URLFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Msg m)</span> </span>&#123;</span><br><span class="line">            String r = m.getMsg();</span><br><span class="line">            r = r.replace(<span class="string">"www.baidu.com"</span>,<span class="string">"www.bilibili.com"</span>);</span><br><span class="line">            m.setMsg(r);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">        List&lt;Filter&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FilterChain <span class="title">add</span><span class="params">(Filter f)</span></span>&#123;</span><br><span class="line">            filters.add(f);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Msg msg)</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (Filter f:filters)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!f.doFilter(msg))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>request,response,运用了程序自身的压栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletMain</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Request request = <span class="keyword">new</span> Request();</span><br><span class="line">        request.str = <span class="string">":)&lt;script&gt;.asd996,www.baidu.com"</span>;</span><br><span class="line">        Response response = <span class="keyword">new</span> Response();</span><br><span class="line">        response.str = <span class="string">"response="</span>;</span><br><span class="line">        FilterChain fc = <span class="keyword">new</span> FilterChain();</span><br><span class="line">        fc.add(<span class="keyword">new</span> HTMLFilter()).add(<span class="keyword">new</span> FaceFilter());</span><br><span class="line">        fc.doFilter(request,response,fc);</span><br><span class="line">        System.out.println(request.str);</span><br><span class="line">        System.out.println(response.str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Msg</span></span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        String msg;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Msg&#123;"</span> +</span><br><span class="line">                    <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">", msg='"</span> + msg + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Request request,Response response,FilterChain chain)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Request</span></span>&#123;</span><br><span class="line">        String str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Response</span></span>&#123;</span><br><span class="line">        String str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HTMLFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Request request,Response response,FilterChain chain)</span> </span>&#123;</span><br><span class="line">            request.str = request.str.replace(<span class="string">"996"</span>,<span class="string">"007"</span>);</span><br><span class="line">            chain.doFilter(request,response,chain);</span><br><span class="line">            response.str+=<span class="string">"--HTMLFilter"</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FaceFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Request request,Response response,FilterChain chain)</span> </span>&#123;</span><br><span class="line">            request.str = request.str.replace(<span class="string">":)"</span>,<span class="string">"^V^"</span>);</span><br><span class="line">            chain.doFilter(request,response,chain);</span><br><span class="line">            response.str+=<span class="string">"--FaceFilter"</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">        List&lt;Filter&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FilterChain <span class="title">add</span><span class="params">(Filter f)</span></span>&#123;</span><br><span class="line">            filters.add(f);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Request request,Response response,FilterChain chain)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index==filters.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Filter filter = filters.get(index);</span><br><span class="line">            index++;</span><br><span class="line">            filter.doFilter(request,response,chain);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10、-观察者模式-（难）"><a href="#10、-观察者模式-（难）" class="headerlink" title="10、==观察者模式==（难）"></a>10、==观察者模式==（难）</h2><h3 id="基本介绍-14"><a href="#基本介绍-14" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>意图：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p>
<p><strong>何时使用：</strong>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p>
<p><strong>如何解决：</strong>使用面向对象技术，可以将这种依赖关系弱化。</p>
<p><strong>关键代码：</strong>在抽象类里有一个 ArrayList 存放观察者们。</p>
<p><strong>应用实例：</strong> 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。==3、监听器Listener。（钩子函数）==</p>
<p><strong>优点：</strong> 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。</p>
<p><strong>缺点：</strong> 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li>
</ul>
<p><strong>注意事项：</strong> 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</p>
<h3 id="案例-11"><a href="#案例-11" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//被观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> cry;</span><br><span class="line"></span><br><span class="line">    List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wakeUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cry = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//根据事件的实际情况处理</span></span><br><span class="line">        WakeUpEvent event = <span class="keyword">new</span> WakeUpEvent(System.currentTimeMillis(),<span class="string">"bed"</span>,<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">for</span> (Observer o:observers)&#123;</span><br><span class="line">            o.actionOnWakeUp(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//事件也能有相应的继承体系</span></span><br><span class="line"><span class="comment">//根据事件的实际情况处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WakeUpEvent</span> <span class="keyword">implements</span> <span class="title">Event</span>&lt;<span class="title">Child</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> timestamp;</span><br><span class="line">    String loc;</span><br><span class="line">    Child source;<span class="comment">//事件源对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WakeUpEvent</span><span class="params">(<span class="keyword">long</span> timestamp,String loc,Child source)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timestamp = timestamp;</span><br><span class="line">        <span class="keyword">this</span>.loc = loc;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Child <span class="title">getSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察者（监听器、钩子函数）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dad</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dad..feeding..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionOnWakeUp</span><span class="params">(WakeUpEvent event)</span> </span>&#123;</span><br><span class="line">        feed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11、组合模式（易）"><a href="#11、组合模式（易）" class="headerlink" title="11、组合模式（易）"></a>11、组合模式（易）</h2><h3 id="基本介绍-15"><a href="#基本介绍-15" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>意图：</strong>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p><strong>主要解决：</strong>它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p>
<p><strong>何时使用：</strong> 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p>
<p><strong>如何解决：</strong>树枝和叶子实现统一接口，树枝内部组合该接口。</p>
<p><strong>关键代码：</strong>树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p>
<p><strong>应用实例：</strong> 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</p>
<p><strong>优点：</strong> 1、高层模块调用简单。 2、节点自由增加。</p>
<p><strong>缺点：</strong>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p>
<p><strong>使用场景：</strong>部分、整体场景，如树形菜单，文件、文件夹的管理。</p>
<p><strong>注意事项：</strong>定义时为具体类。</p>
<h3 id="案例-12"><a href="#案例-12" class="headerlink" title="案例"></a>案例</h3><p>==组合模式就是专门处理树状结构的==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LeafNode</span> <span class="keyword">extends</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        String content;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LeafNode</span><span class="params">(String content)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.content = content;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BranchNode</span> <span class="keyword">extends</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BranchNode</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">            nodes.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BranchNode root = <span class="keyword">new</span> BranchNode(<span class="string">"root"</span>);</span><br><span class="line">        BranchNode chapter1 = <span class="keyword">new</span> BranchNode(<span class="string">"chapter1"</span>);</span><br><span class="line">        BranchNode chapter2 = <span class="keyword">new</span> BranchNode(<span class="string">"chapter2"</span>);</span><br><span class="line">        Node c11 = <span class="keyword">new</span> LeafNode(<span class="string">"c11"</span>);</span><br><span class="line">        Node c12 = <span class="keyword">new</span> LeafNode(<span class="string">"c12"</span>);</span><br><span class="line">        BranchNode b21 = <span class="keyword">new</span> BranchNode(<span class="string">"section21"</span>);</span><br><span class="line">        Node c211 = <span class="keyword">new</span> LeafNode(<span class="string">"c211"</span>);</span><br><span class="line">        Node c212 = <span class="keyword">new</span> LeafNode(<span class="string">"c212"</span>);</span><br><span class="line"></span><br><span class="line">        root.add(chapter1);</span><br><span class="line">        root.add(chapter2);</span><br><span class="line">        chapter1.add(c11);</span><br><span class="line">        chapter1.add(c12);</span><br><span class="line">        chapter2.add(b21);</span><br><span class="line">        b21.add(c211);</span><br><span class="line">        b21.add(c212);</span><br><span class="line">        tree(root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tree</span><span class="params">(Node root,<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;depth;++i) System.out.print(<span class="string">"--"</span>);</span><br><span class="line">        root.p();</span><br><span class="line">        <span class="keyword">if</span> (root <span class="keyword">instanceof</span> BranchNode)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Node n:((BranchNode) root).nodes)&#123;</span><br><span class="line">                tree(n,depth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12、享元模式（易）"><a href="#12、享元模式（易）" class="headerlink" title="12、享元模式（易）"></a>12、享元模式（易）</h2><h3 id="基本介绍-16"><a href="#基本介绍-16" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>意图：</strong>运用共享技术有效地支持大量细粒度的对象。</p>
<p><strong>主要解决：</strong>在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p>
<p><strong>何时使用：</strong> 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。</p>
<p><strong>如何解决：</strong>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。</p>
<p><strong>关键代码：</strong>用 HashMap 存储这些对象。</p>
<p><strong>应用实例：</strong> 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。</p>
<p><strong>优点：</strong>大大减少对象的创建，降低系统的内存，使效率提高。</p>
<p><strong>缺点：</strong>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p>
<p><strong>使用场景：</strong> 1、系统有大量相似对象。 2、需要缓冲池的场景。3、==JVM常量池==</p>
<p><strong>注意事项：</strong> 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。</p>
<h3 id="案例-13"><a href="#案例-13" class="headerlink" title="案例"></a>案例</h3><p>==系统中有大量对象，避免重复创建，从对象池中获取对象。==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ColorPool colorPool = <span class="keyword">new</span> ColorPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            Color color = colorPool.getColor();</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=<span class="number">3</span>)color.setLiving(<span class="keyword">false</span>);</span><br><span class="line">            System.out.println(color.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ColorPool</span></span>&#123;</span><br><span class="line">        List&lt;Color&gt; colors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//静态代码域，在类的加载的时候调用一次，整个生命周期只会调用一次。</span></span><br><span class="line"><span class="comment">//        static &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//普通代码域，在类的每个对象创建的时候调用。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)colors.add(<span class="keyword">new</span> Color());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;colors.size();++i)&#123;</span><br><span class="line">                Color c = colors.get(i);</span><br><span class="line">                <span class="keyword">if</span> (!c.living)&#123;</span><br><span class="line">                    c.setLiving(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Color();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> living;<span class="comment">//true:正在使用   false:未使用</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span>  name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLiving</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> living;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLiving</span><span class="params">(<span class="keyword">boolean</span> living)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.living = living;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">463345942</span></span><br><span class="line"><span class="number">195600860</span></span><br><span class="line"><span class="number">1334729950</span></span><br><span class="line"><span class="number">1347137144</span>   &lt;===从第<span class="number">4</span>个开始用的都是ColorPool中的第<span class="number">4</span>个位置的Color,所以hash值相同</span><br><span class="line"><span class="number">1347137144</span></span><br><span class="line"><span class="number">1347137144</span></span><br><span class="line"><span class="number">1347137144</span></span><br><span class="line"><span class="number">1347137144</span></span><br><span class="line"><span class="number">1347137144</span></span><br><span class="line"><span class="number">1347137144</span></span><br></pre></td></tr></table></figure>
<h2 id="13、-代理模式-（难）"><a href="#13、-代理模式-（难）" class="headerlink" title="13、==代理模式==（难）"></a>13、==代理模式==（难）</h2><h3 id="基本介绍-17"><a href="#基本介绍-17" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>意图：</strong>为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><strong>主要解决：</strong>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p>
<p><strong>何时使用：</strong>想在访问一个类时做一些控制。</p>
<p><strong>如何解决：</strong>增加中间层。</p>
<p><strong>关键代码：</strong>实现与被代理类组合。</p>
<p><strong>应用实例：</strong> 1、==Windows 里面的快捷方式==。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、==spring aop==。</p>
<p><strong>优点：</strong> 1、职责清晰。 2、高扩展性。 3、智能化。</p>
<p><strong>缺点：</strong> 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p>
<p><strong>使用场景：</strong>按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。</p>
<p><strong>注意事项：</strong> 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p>
<h3 id="案例-14"><a href="#案例-14" class="headerlink" title="案例"></a>案例</h3><p><strong>静态代理</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainV2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> TankLogProxy(<span class="keyword">new</span> TankTimeProxy(<span class="keyword">new</span> Tank())).move();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Movable</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Tank</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"tank..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TankTimeProxy</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Movable m;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TankTimeProxy</span><span class="params">(Movable m)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.m = m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            m.move();</span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(end-start);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TankLogProxy</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Movable m;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TankLogProxy</span><span class="params">(Movable m)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.m = m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"start..."</span>);</span><br><span class="line">            m.move();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>动态代理</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态代理</span></span><br><span class="line"><span class="comment">//不知道要代理的对象类型，也不知道他所拥有的方法，所以要用动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainV3</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Movable</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tank</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"tank..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"test.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tank tank = <span class="keyword">new</span> Tank();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新版本</span></span><br><span class="line"><span class="comment">//        System.getProperties().put("jdk.proxy.ProxyGenerator.saveGeneratedFiles","true");</span></span><br><span class="line">        <span class="comment">//JDK1.8 必须要在main方法中</span></span><br><span class="line">        System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br><span class="line">        <span class="comment">//Proxy用哪个类加载器去加载,不一定要tank的,随便谁的类加载器都行</span></span><br><span class="line">        ClassLoader classLoader = tank.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">//Proxy需要继承那些接口</span></span><br><span class="line">        Class[] classes = &#123;Movable.class&#125;;</span><br><span class="line">        <span class="comment">//反射:通过二进制字节码分析类的属性和方法</span></span><br><span class="line">        <span class="comment">//创建动态代理对象,$Proxy0</span></span><br><span class="line">        Movable m = (Movable) Proxy.newProxyInstance(classLoader, classes, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@Author</span> alex</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">             * <span class="doctag">@Date</span> 20:02 2020/8/20</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@Param</span> [proxy, method, args] 生成的代理对象即m,调用的方法,调用方法的参数</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span> java.lang.Object</span></span><br><span class="line"><span class="comment">             **/</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(method.getName()+<span class="string">" start..."</span>);</span><br><span class="line">                Object invoke = method.invoke(tank, args);</span><br><span class="line">                System.out.println(method.getName()+<span class="string">" end..."</span>);</span><br><span class="line">                <span class="keyword">return</span> invoke;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//继承了Movable接口，move()方法里面调用了invoke()方法</span></span><br><span class="line">        m.move();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的动态代理类，即m,$Proxy0.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Movable接口里的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Movable接口里的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m4 = Class.forName(<span class="string">"设计模式.代理模式.MainV3$Movable"</span>).getMethod(<span class="string">"move"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"设计模式.代理模式.MainV3$Movable"</span>).getMethod(<span class="string">"test"</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以利用cglib实现动态代理，Spring-AOP用的就是cglib实现的AOP</p>
<h2 id="14、迭代器模式（易）"><a href="#14、迭代器模式（易）" class="headerlink" title="14、迭代器模式（易）"></a>14、迭代器模式（易）</h2><h3 id="基本介绍-18"><a href="#基本介绍-18" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>意图：</strong>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p>
<p><strong>主要解决：</strong>==不同的方式来遍历整个整合对象。==</p>
<p><strong>何时使用：</strong>遍历一个聚合对象。</p>
<p><strong>如何解决：</strong>把在元素之间游走的责任交给迭代器，而不是聚合对象。</p>
<p><strong>关键代码：</strong>定义接口：hasNext, next。</p>
<p><strong>应用实例：</strong>JAVA 中的 iterator。</p>
<p><strong>优点：</strong> 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</p>
<p><strong>缺点：</strong>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p>
<p><strong>使用场景：</strong> 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。</p>
<p><strong>注意事项：</strong>迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p>
<h3 id="案例-15"><a href="#案例-15" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span> <span class="keyword">implements</span> <span class="title">MyCollection</span> </span>&#123;</span><br><span class="line">    Object[] objs = <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyIterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyArrayListIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部迭代器类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayListIterator</span> <span class="keyword">implements</span> <span class="title">MyIterator</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> currentIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> !(currentIndex&gt;=size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> objs[currentIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (size==objs.length)&#123;</span><br><span class="line">            Object[] newObjs = <span class="keyword">new</span> Object[objs.length&lt;&lt;<span class="number">1</span>];</span><br><span class="line">            System.arraycopy(objs,<span class="number">0</span>,newObjs,<span class="number">0</span>,objs.length);</span><br><span class="line">            objs = newObjs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        objs[size] = obj;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="15、访问者模式（中）"><a href="#15、访问者模式（中）" class="headerlink" title="15、访问者模式（中）"></a>15、访问者模式（中）</h2><h3 id="基本介绍-19"><a href="#基本介绍-19" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>意图：</strong>主要将数据结构与数据操作分离。</p>
<p><strong>主要解决：</strong>稳定的数据结构和易变的操作耦合问题。</p>
<p><strong>何时使用：</strong>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。</p>
<p><strong>如何解决：</strong>在被访问的类里面加一个对外提供接待访问者的接口。</p>
<p><strong>关键代码：</strong>在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。</p>
<p><strong>应用实例：</strong>您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</p>
<p><strong>优点：</strong> 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。</p>
<p><strong>缺点：</strong> 1、具体元素对访问者公布细节，违反了迪米特原则。 2、==具体元素变更比较困难。== 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</p>
<p><strong>使用场景：</strong> 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。3、编译器抽象语法树AST</p>
<p><strong>注意事项：</strong>访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。</p>
<h3 id="案例-16"><a href="#案例-16" class="headerlink" title="案例"></a>案例</h3><p>Computer的部件一直增加的话，访问者模式不适合。访问者模式适用于Computer结构固定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ComputerPart</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor v)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CPU</span> <span class="keyword">implements</span> <span class="title">ComputerPart</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor v)</span> </span>&#123;</span><br><span class="line">            v.visitCPU(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Memory</span> <span class="keyword">implements</span> <span class="title">ComputerPart</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor v)</span> </span>&#123;</span><br><span class="line">            v.visitMemory(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">300</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Board</span> <span class="keyword">implements</span> <span class="title">ComputerPart</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor v)</span> </span>&#123;</span><br><span class="line">            v.visitBoard(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">visitCPU</span><span class="params">(CPU c)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">visitMemory</span><span class="params">(Memory M)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">visitBoard</span><span class="params">(Board B)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PersonVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> totalPrice = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCPU</span><span class="params">(CPU c)</span> </span>&#123;</span><br><span class="line">            totalPrice+=c.getPrice()*<span class="number">0.9</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMemory</span><span class="params">(Memory m)</span> </span>&#123;</span><br><span class="line">            totalPrice+=m.getPrice()*<span class="number">0.85</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitBoard</span><span class="params">(Board b)</span> </span>&#123;</span><br><span class="line">            totalPrice+=b.getPrice()*<span class="number">0.95</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CorpVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> totalPrice = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCPU</span><span class="params">(CPU c)</span> </span>&#123;</span><br><span class="line">            totalPrice+=c.getPrice()*<span class="number">0.91</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMemory</span><span class="params">(Memory m)</span> </span>&#123;</span><br><span class="line">            totalPrice+=m.getPrice()*<span class="number">0.851</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitBoard</span><span class="params">(Board b)</span> </span>&#123;</span><br><span class="line">            totalPrice+=b.getPrice()*<span class="number">0.915</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">        ComputerPart cpu = <span class="keyword">new</span> CPU();</span><br><span class="line">        ComputerPart memory = <span class="keyword">new</span> Memory();</span><br><span class="line">        ComputerPart board = <span class="keyword">new</span> Board();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor v)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cpu.accept(v);</span><br><span class="line">            <span class="keyword">this</span>.memory.accept(v);</span><br><span class="line">            <span class="keyword">this</span>.board.accept(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16、-适配器模式（Wrapper）-（易）"><a href="#16、-适配器模式（Wrapper）-（易）" class="headerlink" title="16、==适配器模式（Wrapper）==（易）"></a>16、==适配器模式（Wrapper）==（易）</h2><h3 id="基本介绍-20"><a href="#基本介绍-20" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>意图：</strong>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p><strong>主要解决：</strong>主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</p>
<p><strong>何时使用：</strong> 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</p>
<p><strong>如何解决：</strong>继承或依赖（推荐）。</p>
<p><strong>关键代码：</strong>适配器继承或依赖已有的对象，实现想要的目标接口。</p>
<p><strong>应用实例：</strong> 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。</p>
<p><strong>优点：</strong> 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。</p>
<p><strong>缺点：</strong> 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</p>
<p><strong>使用场景：</strong>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p>
<p><strong>注意事项：</strong>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p>
<h3 id="案例-17"><a href="#案例-17" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvancedMediaPlayer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VlcPlayer</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Playing vlc file. Name: "</span>+ fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//什么也不做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mp4Player</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//什么也不做</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Playing mp4 file. Name: "</span>+ fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">    MediaAdapter mediaAdapter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//播放 mp3 音乐文件的内置支持</span></span><br><span class="line">        <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"mp3"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Playing mp3 file. Name: "</span>+ fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//mediaAdapter 提供了播放其他文件格式的支持</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"vlc"</span>)</span><br><span class="line">                || audioType.equalsIgnoreCase(<span class="string">"mp4"</span>))&#123;</span><br><span class="line">            mediaAdapter = <span class="keyword">new</span> MediaAdapter(audioType);</span><br><span class="line">            mediaAdapter.play(audioType, fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Invalid media. "</span>+</span><br><span class="line">                               audioType + <span class="string">" format not supported"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaAdapter</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AdvancedMediaPlayer advancedMusicPlayer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MediaAdapter</span><span class="params">(String audioType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"vlc"</span>) )&#123;</span><br><span class="line">            advancedMusicPlayer = <span class="keyword">new</span> VlcPlayer();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (audioType.equalsIgnoreCase(<span class="string">"mp4"</span>))&#123;</span><br><span class="line">            advancedMusicPlayer = <span class="keyword">new</span> Mp4Player();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"vlc"</span>))&#123;</span><br><span class="line">            advancedMusicPlayer.playVlc(fileName);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"mp4"</span>))&#123;</span><br><span class="line">            advancedMusicPlayer.playMp4(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AudioPlayer audioPlayer = <span class="keyword">new</span> AudioPlayer();</span><br><span class="line"></span><br><span class="line">    audioPlayer.play(<span class="string">"mp3"</span>, <span class="string">"beyond the horizon.mp3"</span>);</span><br><span class="line">    audioPlayer.play(<span class="string">"mp4"</span>, <span class="string">"alone.mp4"</span>);</span><br><span class="line">    audioPlayer.play(<span class="string">"vlc"</span>, <span class="string">"far far away.vlc"</span>);</span><br><span class="line">    audioPlayer.play(<span class="string">"avi"</span>, <span class="string">"mind me.avi"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="17、桥接模式（易）"><a href="#17、桥接模式（易）" class="headerlink" title="17、桥接模式（易）"></a>17、桥接模式（易）</h2><h3 id="基本介绍-21"><a href="#基本介绍-21" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>意图：</strong>将抽象部分与实现部分分离，使它们都可以独立的变化。</p>
<p><strong>主要解决：</strong>在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。</p>
<p><strong>何时使用：</strong>实现系统可能有多个角度分类，每一种角度都可能变化。</p>
<p><strong>如何解决：</strong>把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。</p>
<p><strong>关键代码：</strong>抽象类依赖实现类。</p>
<p><strong>应用实例：</strong> 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。</p>
<p><strong>优点：</strong> 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。</p>
<p><strong>缺点：</strong>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p>
<p><strong>使用场景：</strong> 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、==一个类存在两个独立变化的维度，且这两个维度都需要进行扩展==。</p>
<p><strong>注意事项：</strong>对于两个独立变化的维度，使用桥接模式再适合不过了。</p>
<h3 id="案例-18"><a href="#案例-18" class="headerlink" title="案例"></a>案例</h3><p>==用聚合代替继承==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Gift</span></span>&#123;</span><br><span class="line">    GiftImpl impl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WarmGift</span> <span class="keyword">extends</span> <span class="title">Gift</span></span>&#123;<span class="comment">//物品的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WarmGift</span><span class="params">(GiftImpl impl)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WildGift</span> <span class="keyword">extends</span> <span class="title">Gift</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WildGift</span><span class="params">(GiftImpl impl)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GiftImpl</span> <span class="keyword">extends</span> <span class="title">Gift</span></span>&#123;&#125;<span class="comment">//具体的物品</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">extends</span> <span class="title">GiftImpl</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flower</span> <span class="keyword">extends</span> <span class="title">GiftImpl</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GG</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chase</span><span class="params">(MM mm)</span></span>&#123;</span><br><span class="line">        Gift g = <span class="keyword">new</span> WarmGift(<span class="keyword">new</span> Flower());</span><br><span class="line">        give(mm,g);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">give</span><span class="params">(MM mm,Gift g)</span></span>&#123;</span><br><span class="line">        System.out.println(g+<span class="string">"gived!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MM</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="18、命令模式（易）"><a href="#18、命令模式（易）" class="headerlink" title="18、命令模式（易）"></a>18、命令模式（易）</h2><h3 id="基本介绍-22"><a href="#基本介绍-22" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>意图：</strong>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p>
<p><strong>主要解决：</strong>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p>
<p><strong>何时使用：</strong>在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p>
<p><strong>如何解决：</strong>通过调用者调用接受者执行命令，顺序：调用者→命令→接受者。</p>
<p><strong>关键代码：</strong>定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口</p>
<p><strong>应用实例：</strong>struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。</p>
<p><strong>优点：</strong> 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。</p>
<p><strong>缺点：</strong>使用命令模式可能会导致某些系统有过多的具体命令类。</p>
<p><strong>使用场景：</strong>认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。</p>
<p><strong>注意事项：</strong>==系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作==，也可以考虑使用命令模式，见命令模式的扩展。</p>
<h3 id="案例-19"><a href="#案例-19" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;<span class="comment">//run</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InsertCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">        Content c;</span><br><span class="line">        String strToInsert = <span class="string">"www.baidu.com"</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InsertCommand</span><span class="params">(Content c)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.c = c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            c.msg = c.msg+strToInsert;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            c.msg = c.msg.substring(<span class="number">0</span>,c.msg.length()-strToInsert.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CopyCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">        Content c;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CopyCommand</span><span class="params">(Content c)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.c = c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            c.msg = c.msg+c.msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            c.msg = c.msg.substring(<span class="number">0</span>,c.msg.length()/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DeleteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Content c;</span><br><span class="line">        String deleted;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DeleteCommand</span><span class="params">(Content c)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.c = c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            deleted = c.msg.substring(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">            c.msg = c.msg.substring(<span class="number">5</span>,c.msg.length());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            c.msg = deleted+c.msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Content</span></span>&#123;</span><br><span class="line">        String msg = <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>责任链模式可以实现多次Command</p>
<h2 id="19、备忘录模式"><a href="#19、备忘录模式" class="headerlink" title="19、备忘录模式"></a>19、备忘录模式</h2><h3 id="基本介绍-23"><a href="#基本介绍-23" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>意图：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
<p><strong>主要解决：</strong>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p>
<p><strong>何时使用：</strong>很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。</p>
<p><strong>如何解决：</strong>通过一个备忘录类专门存储对象状态。</p>
<p><strong>关键代码：</strong>客户不与备忘录类耦合，与备忘录管理类耦合。</p>
<p><strong>应用实例：</strong> 1、后悔药。 ==2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理。==</p>
<p><strong>优点：</strong> 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。</p>
<p><strong>缺点：</strong>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p>
<p><strong>使用场景：</strong> 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。</p>
<p><strong>注意事项：</strong> 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。</p>
<h3 id="案例-20"><a href="#案例-20" class="headerlink" title="案例"></a>案例</h3><h2 id="20、模板方法（钩子函数）（易）"><a href="#20、模板方法（钩子函数）（易）" class="headerlink" title="20、模板方法（钩子函数）（易）"></a>20、模板方法（钩子函数）（易）</h2><h3 id="基本介绍-24"><a href="#基本介绍-24" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>意图：</strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p><strong>主要解决：</strong>一些方法通用，却在每一个子类都重新写了这一方法。</p>
<p><strong>何时使用：</strong>有一些通用的方法。</p>
<p><strong>如何解决：</strong>将这些通用算法抽象出来。</p>
<p><strong>关键代码：</strong>在抽象类实现，其他步骤在子类实现。</p>
<p><strong>应用实例：</strong> 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</p>
<p><strong>优点：</strong> 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。</p>
<p><strong>缺点：</strong>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p>
<p><strong>使用场景：</strong> 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。</p>
<p><strong>注意事项：</strong>为防止恶意操作，一般模板方法都加上 final 关键词。</p>
<h3 id="案例-21"><a href="#案例-21" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">F</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">            op1();</span><br><span class="line">            op2();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">op1</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">op2</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C1</span> <span class="keyword">extends</span> <span class="title">F</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">op1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"op1..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">op2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"op2..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        F f = <span class="keyword">new</span> C1();</span><br><span class="line">        f.m();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用固有的m()方法，子类实现op1(),op2()相应的功能</p>
<h2 id="21、-状态模式-（易）"><a href="#21、-状态模式-（易）" class="headerlink" title="21、==状态模式==（易）"></a>21、==状态模式==（易）</h2><h3 id="基本介绍-25"><a href="#基本介绍-25" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>意图：</strong>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p>
<p><strong>主要解决：</strong>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</p>
<p><strong>何时使用：</strong>代码中包含大量与对象状态有关的条件语句。</p>
<p><strong>如何解决：</strong>将各种具体的状态类抽象出来。</p>
<p><strong>关键代码：</strong>通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，==也可以用于消除 if…else 等条件选择语句==。==通过聚合状态接口实现==。</p>
<p><strong>应用实例：</strong> 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。</p>
<p><strong>优点：</strong> 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</p>
<p><strong>缺点：</strong> 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</p>
<p><strong>使用场景：</strong> 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。</p>
<p><strong>注意事项：</strong>在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。</p>
<p>==根据状态决定行为==</p>
<h3 id="案例-22"><a href="#案例-22" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MMState</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">smile</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MM</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    MMState state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.smile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.cry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HappyState</span> <span class="keyword">implements</span> <span class="title">MMState</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"happy..smile"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"happy...cry"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"happy...say"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SadState</span> <span class="keyword">implements</span> <span class="title">MMState</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sad..smile"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sad...cry"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sad...say"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="22、解释器模式"><a href="#22、解释器模式" class="headerlink" title="22、解释器模式"></a>22、解释器模式</h2><h3 id="基本介绍-26"><a href="#基本介绍-26" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>意图：</strong>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p>
<p><strong>主要解决：</strong>对于一些固定文法构建一个解释句子的解释器。</p>
<p><strong>何时使用：</strong>如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</p>
<p><strong>如何解决：</strong>构建语法树，定义终结符与非终结符。</p>
<p><strong>关键代码：</strong>构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。</p>
<p><strong>应用实例：</strong>编译器、运算表达式计算。</p>
<p><strong>优点：</strong> 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。</p>
<p><strong>缺点：</strong> 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。</p>
<p><strong>使用场景：</strong> 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。</p>
<p><strong>注意事项：</strong>可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。</p>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC学习笔记</title>
    <url>/alex-next/2022/04/24/javaEE/JUC%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="1-Java内存模型JMM"><a href="#1-Java内存模型JMM" class="headerlink" title="1.Java内存模型JMM"></a>1.Java内存模型JMM</h2><h3 id="JMM架构"><a href="#JMM架构" class="headerlink" title="JMM架构"></a>JMM架构</h3><ul>
<li><p>八大原子操作</p>
<ul>
<li>(1)lock:作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>
<li>(2)unlock:作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其它线程锁定。</li>
<li>(3)read:作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li>(4)load:作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>(5)use:作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时都会执行这个操作。</li>
<li>(6)assign:作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>(7)store:作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write使用。</li>
<li>(8)write:作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
</li>
</ul>
<h3 id="并发编程的三大问题"><a href="#并发编程的三大问题" class="headerlink" title="并发编程的三大问题"></a>并发编程的三大问题</h3><ul>
<li><p>原子性</p>
<p>  原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。<br>  public class Jmm04_CodeAtomic {</p>
<pre><code>private volatile static int counter = 0;
static Object object = new Object();

public static void main(String[] args) {

  for (int i = 0; i &lt; 10; i++) {
    Thread thread = new Thread(()-&gt;{
      for (int j = 0; j &lt; 1000; j++) {
        synchronized (object){
          counter++;//分三步- 读，自加，写回
        }
      }
    });
    thread.start();
  }

  try {
    Thread.sleep(3000);
  } catch (InterruptedException e) {
    e.printStackTrace();
  }

  System.out.println(counter);

}
</code></pre><p>  }</p>
</li>
<li><p>可见性</p>
<p>  是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。<br>  public class Jmm03_CodeVisibility {</p>
<pre><code>private static boolean initFlag = false;

private volatile static int counter = 0;

public static void refresh(){
  log.info(&quot;refresh data.......&quot;);
  initFlag = true;
  log.info(&quot;refresh data success.......&quot;);
}

public static void main(String[] args){
  Thread threadA = new Thread(()-&gt;{
    while (!initFlag){
      //System.out.println(&quot;runing&quot;);
      counter++;
    }
    log.info(&quot;线程：&quot; + Thread.currentThread().getName()

 + &quot;当前线程嗅探到initFlag的状态的改变&quot;);
   eadA&quot;);
       threadA.start();

  try {
    Thread.sleep(500);
  } catch (InterruptedException e) {
    e.printStackTrace();
  }

  Thread threadB = new Thread(()-&gt;{
    refresh();
  },&quot;threadB&quot;);
  threadB.start();
}
</code></pre><p>  }</p>
<ul>
<li><p>问题：在代码中不加volatile关键字，使用Integer,System.out.println()，volatile counter等方法也能做到volatile的效果，为什么？</p>
<ul>
<li>上下文切换，即initFlag变量和volatile修饰的counter变量在底层有可能放到了一个缓存行里，而counter被volatile修饰，会每次刷新，这时，initFlag也会跟着一起刷新。其他情况同理。<br>  ps:为什么空while循环不会刷新initFlag，因为空while循环会一直占着CPU。</li>
</ul>
</li>
</ul>
</li>
<li><p>有序性</p>
<p>  public static void main(String[] args) throws InterruptedException {</p>
<pre><code>  int i = 0;
  for (;;){
    i++;
    x = 0; y = 0;
    a = 0; b = 0;
    Thread t1 = new Thread(new Runnable() {
      public void run() {
        shortWait(10000);
        a = 1;
        x = b;
        UnsafeInstance.reflectGetUnsafe().fullFence();
        ///
        //
        //
      }
    });

    Thread t2 = new Thread(new Runnable() {
      public void run() {
        b = 1;
        UnsafeInstance.reflectGetUnsafe().fullFence();
        y = a;
      }
    });

    t1.start();
    t2.start();
    t1.join();
    t2.join();

    String result = &quot;第&quot; + i + &quot;次 (&quot; + x + &quot;,&quot; + y + &quot;）&quot;;
    if(x == 0 &amp;&amp; y == 0) {
      System.out.println(result);
      break;
    } else {
      log.info(result);
    }
  }

}
</code></pre><ul>
<li><p>指令重排：java语言规范规定JVM线程内部维持顺序化语义。即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致。但是这只是针对单线程而言。</p>
<ul>
<li>指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性</li>
</ul>
</li>
<li><p>指令重排≠有序性</p>
</li>
<li><p>指令重排的一个经典优化案例双重锁检查(DCL)</p>
<p>  public class Singleton {</p>
<pre><code>private static Singleton instance; // 不使用volatile关键字

// 双重锁检验
public static Singleton getInstance() {
  if (instance == null) { // 第7行
    synchronized (Singleton.class) {
      if (instance == null) {
        instance = new Singleton(); // 第10行
      }
    }
  }
  return instance;
}
</code></pre><p>  }</p>
<ul>
<li>对象的创建并不是一个原子操作，而是有分配空间，初始化和<init>，如果不禁止重排序，可能会初始化一个空对象</init></li>
</ul>
</li>
<li><p>Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有操作都是天然有序的。如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内似表现为串行的语义”，后半句是指“指令重排”现象和“工作内存与主内存同步延迟”现象。</p>
</li>
</ul>
</li>
</ul>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ul>
<li><p>volatile</p>
<ul>
<li><p>能解决哪些并发编程的三大问题</p>
<ul>
<li><p>可见性</p>
<ul>
<li>硬件层面：底层汇编会生成lock前缀指令，从而触发MESI缓存一致性协议，通过总线嗅探机制监听每个线程(工作内存)的变量是否改变</li>
<li><p>JAVA层面</p>
<ul>
<li>内存屏障</li>
</ul>
</li>
</ul>
</li>
<li><p>有序性(基于内存屏障)</p>
</li>
</ul>
</li>
<li><p>能禁止指令重排(基于内存屏障)</p>
<ul>
<li>Java是否能指令重排的规则(volatile读前写后不重排)</li>
</ul>
</li>
<li><p>及时可见性，可能某些操作比如System.out.println()也能做到可见性，但这种方式不是及时的</p>
</li>
</ul>
</li>
<li><p>synchronized</p>
<ul>
<li><p>能解决哪些并发编程的三大问题</p>
<ul>
<li>原子性</li>
<li><p>可见性</p>
<ul>
<li>通过monitorenter/monitorexit的jvm字节码指令，在底层调用lock前缀指令开启内存屏障</li>
</ul>
</li>
<li><p>有序性</p>
<ul>
<li>依然会发生重排序，只不过我们有同步代码块，可以保证只有一个线程执行同步代码中的代码。保证有序性</li>
</ul>
</li>
</ul>
</li>
<li><p>能保证有序性，但是不能像volatile一样禁止指令重排序，所以会产生DCL的问题</p>
</li>
</ul>
</li>
</ul>
<h3 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h3><ul>
<li>MESI协议状态切换图</li>
<li>java文件执行全流程</li>
</ul>
<h3 id="内存屏障-Java内部用于解决并发编程的三大问题"><a href="#内存屏障-Java内部用于解决并发编程的三大问题" class="headerlink" title="内存屏障(Java内部用于解决并发编程的三大问题)"></a>内存屏障(Java内部用于解决并发编程的三大问题)</h3><ul>
<li><p>硬件层面(Intel提供)</p>
<ul>
<li>lfence，是一种Load Barrier 读屏障</li>
<li>sfence, 是一种Store Barrier 写屏障</li>
<li>mfence, 是一种全能型的屏障，具备ifence和sfence的能力</li>
<li><p>Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对 CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。</p>
<ul>
<li>因为不同的内存屏障，需要不同的汇编指令，jvm内部对这些指令进行了简化，统一用lock前缀指令。</li>
</ul>
</li>
</ul>
</li>
<li><p>Java实现的内存屏障</p>
<ul>
<li>LoadLoad屏障： 对于这样的语句 Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。 </li>
<li>StoreStore屏障：对于这样的语句 Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。 </li>
<li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被执行前，保证Load1要读取的数据被读取完毕。 </li>
<li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。</li>
</ul>
</li>
</ul>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul>
<li><p>happens-before原则</p>
<ul>
<li><ol>
<li>程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执 行。</li>
</ol>
</li>
<li><ol>
<li>锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是 说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个 锁)。</li>
</ol>
</li>
<li><ol>
<li>volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简 单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的 值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的 线程总是能够看到该变量的最新值。</li>
</ol>
</li>
<li><ol>
<li>线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B 的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享 变量的修改对线程B可见</li>
</ol>
</li>
<li><ol>
<li>传递性 A先于B ，B先于C 那么A必然先于C</li>
</ol>
</li>
<li><ol>
<li>线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待 当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的 join方法成功返回后，线程B对共享变量的修改将对线程A可见。</li>
</ol>
</li>
<li><ol>
<li>线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到 中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</li>
</ol>
</li>
<li><ol>
<li>对象终结规则对象的构造函数执行，结束先于finalize()方法</li>
</ol>
</li>
</ul>
</li>
<li><p>as-if-serial：不管再怎么指令重排序，程序的执行结果被能被改变</p>
</li>
</ul>
<h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><ul>
<li>Java字节码指令是原子操作吗</li>
</ul>
<h3 id="如何查看字节码-第二节课-和汇编-第三节课52-54"><a href="#如何查看字节码-第二节课-和汇编-第三节课52-54" class="headerlink" title="如何查看字节码(第二节课)和汇编(第三节课52:54)"></a>如何查看字节码(第二节课)和汇编(第三节课52:54)</h3><h2 id="2-synchronized详解"><a href="#2-synchronized详解" class="headerlink" title="2.synchronized详解"></a>2.synchronized详解</h2><h3 id="解决线程并发安全问题，采用的是序列化访问临界资源"><a href="#解决线程并发安全问题，采用的是序列化访问临界资源" class="headerlink" title="解决线程并发安全问题，采用的是序列化访问临界资源"></a>解决线程并发安全问题，采用的是序列化访问临界资源</h3><ul>
<li>1.synchronized</li>
<li>2.lock</li>
</ul>
<h3 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h3><ul>
<li>synchronized关键字会被编译成字节码后会被翻译成monitorenter 和 monitorexit 两条指令分别在同步块逻辑代码的起始位置 与结束位置。</li>
<li><p>Monitor</p>
<ul>
<li><p>概念</p>
<ul>
<li>每一个Java对象自打娘胎里出来就带了一把 看不见的锁，它叫做内部锁或者Monitor锁。也就是通常说Synchronized的对象锁</li>
</ul>
</li>
<li><p>存储位置</p>
<ul>
<li>Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向），Synchronized锁便是通过这种方式 获取锁的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="不同粒度的锁在对象中的存储"><a href="#不同粒度的锁在对象中的存储" class="headerlink" title="不同粒度的锁在对象中的存储"></a>不同粒度的锁在对象中的存储</h3><ul>
<li>对象内存布局</li>
<li>在mark word中的存储</li>
</ul>
<h3 id="锁升级：不同线程竞争激烈的结果"><a href="#锁升级：不同线程竞争激烈的结果" class="headerlink" title="锁升级：不同线程竞争激烈的结果"></a>锁升级：不同线程竞争激烈的结果</h3><ul>
<li>锁升级过程</li>
</ul>
<h3 id="锁粗化：JIT编译器如果发现有代码里连续多次加锁释放锁的代码，会给合并为一个锁"><a href="#锁粗化：JIT编译器如果发现有代码里连续多次加锁释放锁的代码，会给合并为一个锁" class="headerlink" title="锁粗化：JIT编译器如果发现有代码里连续多次加锁释放锁的代码，会给合并为一个锁"></a>锁粗化：JIT编译器如果发现有代码里连续多次加锁释放锁的代码，会给合并为一个锁</h3><ul>
<li>synchronized(this) {}<br>  synchronized(this) {}synchronized(this) {}</li>
</ul>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><ul>
<li>依赖逃逸分析，如果一个锁对象在栈桢中为局部变量，不会被外部引用，会消除对应的锁</li>
</ul>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><ul>
<li><p>在main方法启动之后发现直接使用的轻量级锁，直接跳过了偏向锁，为什么？</p>
<ul>
<li>JVM会延迟启动偏向锁。JVM本身启动的时候，就会开启10多个线程，避免无谓的偏向锁-&gt;重量级锁的过程，会延迟启动偏向锁。</li>
</ul>
</li>
</ul>
<h2 id="3-AQS-AbstractQueuedSynchronizer-详解"><a href="#3-AQS-AbstractQueuedSynchronizer-详解" class="headerlink" title="3.AQS(AbstractQueuedSynchronizer)详解"></a>3.AQS(AbstractQueuedSynchronizer)详解</h2><h3 id="第一节"><a href="#第一节" class="headerlink" title="第一节"></a>第一节</h3><ul>
<li><p>大体框架</p>
<ul>
<li><p>queue队列(CLH同步队列)</p>
<p>  一个有头尾结点的双向链式队列</p>
</li>
<li><p>CAS</p>
<p>  protected final boolean tryAcquire(int acquires) {</p>
<pre><code>  final Thread current = Thread.currentThread();
  int c = getState();// 获取当前的信号量State
  if (c == 0) {// 若现在没有线程占用，则进入
      if (!hasQueuedPredecessors() &amp;&amp;  // 判断队列中是否有线程阻塞，这是公平锁和非公平锁的区别
          compareAndSetState(0, acquires)) {// CAS+轮询操作
          setExclusiveOwnerThread(current);
          return true;
      }
  }
  else if (current == getExclusiveOwnerThread()) {
      int nextc = c + acquires;
      if (nextc &lt; 0)
          throw new Error(&quot;Maximum lock count exceeded&quot;);
      setState(nextc);
      return true;
  }
  return false;
</code></pre><p>  }</p>
</li>
<li><p>LockSupport</p>
</li>
<li><p>自旋</p>
</li>
<li><p>伪代码</p>
<p>  ReentrantLock lock = new ReentrantLock();<br>  lock.lock();//加锁<br>  (while(true){// 自旋</p>
<pre><code>  if(CAS加锁成功){
      break;
  }
  Queue.add(Thread);// 加入队列
  LockSupport.park()// 阻塞
</code></pre><p>  })// lock.lock()的具体实现</p>
<p>  T0获取锁<br>  具体的业务逻辑</p>
<p>  lock.unlock();// 释放锁<br>  (Thread t = Queue.get();// 取出一个线程<br>  LockSupport.unpark(t);// 唤醒<br>  )// lock.unlock();具体实现</p>
</li>
</ul>
</li>
<li><p>AQS特性</p>
<ul>
<li>阻塞等待队列</li>
<li><p>共享/独占</p>
<ul>
<li>共享：多个线程可以同时执行，如Semaphore/CountDownLatch</li>
<li>独占：只有一个线程能执行，如ReentrantLock</li>
</ul>
</li>
<li><p>公平/非公平</p>
<ul>
<li>ReentrantLock类内部实现了Sync类，Sync类继承了AQS类；而FairSync和NonfairSync都继承Sync类</li>
<li>FairSync实现公平锁</li>
<li>NonfairSync实现非公平锁</li>
</ul>
</li>
<li><p>可重入</p>
<ul>
<li>当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的</li>
</ul>
</li>
<li><p>允许中断</p>
</li>
</ul>
</li>
</ul>
<h3 id="第二节"><a href="#第二节" class="headerlink" title="第二节"></a>第二节</h3><ul>
<li><p>AQS代码(独占方式)(ReentrantLock)详解</p>
<ul>
<li><p>可参考的md</p>
<ul>
<li>方法总结</li>
</ul>
</li>
<li><p>lock()实现:acquire(1)</p>
<p>  public final void acquire(int arg) {</p>
<pre><code>  if (!tryAcquire(arg) &amp;&amp;
      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
      selfInterrupt();
</code></pre><p>  }</p>
<ul>
<li><p>tryAcquire(arg):锁竞争具体逻辑</p>
<p>  protected final boolean tryAcquire(int acquires) {</p>
<pre><code>  final Thread current = Thread.currentThread();
  int c = getState();
  if (c == 0) {
      if (!hasQueuedPredecessors() &amp;&amp; // 公平锁判断下队列有没有阻塞线程
          compareAndSetState(0, acquires)) {
          setExclusiveOwnerThread(current);
          return true;
      }
  }
  else if (current == getExclusiveOwnerThread()) {
  // 可重入锁的体现，这里不存在并发安全问题
      int nextc = c + acquires;
      if (nextc &lt; 0)
          throw new Error(&quot;Maximum lock count exceeded&quot;);
      setState(nextc);
      return true;
  }
  return false;
</code></pre><p>  }</p>
</li>
<li><p>解释细节</p>
<ul>
<li>传1表示state锁的状态，后面上锁会给锁状态+1</li>
</ul>
</li>
<li><p>addWaiter(Node.EXCLUSIVE):将Thread放到队列中</p>
<p>  private Node addWaiter(Node mode) {</p>
<pre><code>  Node node = new Node(Thread.currentThread(), mode);
  // Try the fast path of enq; backup to full enq on failure
  Node pred = tail;
  if (pred != null) {
      node.prev = pred;
      if (compareAndSetTail(pred, node)) {
          pred.next = node;
          return node;
      }
  }
  enq(node);
  return node;
</code></pre><p>  }</p>
<ul>
<li><p>enq(node):队列为空或竞争入队会进入此方法</p>
<p>  private Node enq(final Node node) {</p>
<pre><code>  for (;;) {
      Node t = tail;
      if (t == null) { // Must initialize
          if (compareAndSetHead(new Node()))
              tail = head;
      } else {
          node.prev = t;
          if (compareAndSetTail(t, node)) {
              t.next = node;
              return t;
          }
      }
  }
</code></pre><p>  }</p>
<ul>
<li>入队要使用compareAndSetTail(t, node)，因为入队也可能存在并发问题</li>
</ul>
</li>
</ul>
</li>
<li><p>acquireQueued(addWaiter(Node.EXCLUSIVE),arg)</p>
<p>  final boolean acquireQueued(final Node node, int arg) {</p>
<pre><code>  boolean failed = true;
  try {
      boolean interrupted = false;
      for (;;) {
          final Node p = node.predecessor();
          if (p == head &amp;&amp; tryAcquire(arg)) {
              setHead(node);
              p.next = null; // help GC
              failed = false;
              return interrupted;
          }
          if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
              parkAndCheckInterrupt())
              interrupted = true;
      }
  } finally {
      if (failed)
          cancelAcquire(node);
  }
</code></pre><p>  }</p>
<ul>
<li><p>解释细节</p>
<ul>
<li>节点阻塞之前还得再尝试一次获取锁(因为线程阻塞唤醒比较耗费资源)</li>
<li>1.若能够获取到，节点出队，并且把head往后挪一个节点，新的头结点就是当前节点；</li>
<li><p>2.不能获取到，阻塞等待被唤醒</p>
<ul>
<li>1.首先第1轮循环、修改head的状态，修改成signal=-1标记处可以被唤醒.</li>
<li>2.第2轮循环，阻塞线程，并且需要判断线程是否是有中断信号唤醒的！</li>
</ul>
</li>
</ul>
</li>
<li><p>shouldParkAfterFailedAcquire(p, node)</p>
<p>  private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {</p>
<pre><code>  int ws = pred.waitStatus;
  if (ws == Node.SIGNAL)
      /*
       * This node has already set status asking a release
       * to signal it, so it can safely park.
       */
      return true;
  if (ws &gt; 0) {
      /*
       * Predecessor was cancelled. Skip over predecessors and
       * indicate retry.
       */
      do {
          node.prev = pred = pred.prev;
      } while (pred.waitStatus &gt; 0);
      pred.next = node;
  } else {
      /*
       * waitStatus must be 0 or PROPAGATE.  Indicate that we
       * need a signal, but don&#39;t park yet.  Caller will need to
       * retry to make sure it cannot acquire before parking.
       */
      compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
  }
  return false;
</code></pre><p>  }</p>
<ul>
<li><p>waitStatus节点的生命状态：信号量</p>
<ul>
<li>SIGNAL = -1 //可被唤醒</li>
<li>CANCELLED = 1 //代表出现异常，中断引起的，需要废弃结束</li>
<li>CONDITION = -2 // 等待condition唤醒</li>
<li>PROPAGATE = -3 // 传播</li>
<li>0 - 初始状态Init状态</li>
</ul>
</li>
<li><p>执行到此方法说明该线程要被阻塞，那么就要把waitstate设置为signal，下次才能被唤醒</p>
<p>  compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</p>
</li>
</ul>
</li>
<li><p>parkAndCheckInterrupt()：阻塞该线程</p>
<p>  private final boolean parkAndCheckInterrupt() {</p>
<pre><code>  LockSupport.park(this);
  return Thread.interrupted();
</code></pre><p>  }</p>
<ul>
<li>LockSupport.park(this)</li>
<li>Thread.interrupted()</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>unlock实现:release(1)</p>
<p>  public void unlock() {</p>
<pre><code>  sync.release(1);
</code></pre><p>  }<br>  public final boolean release(int arg) {</p>
<pre><code>  if (tryRelease(arg)) {
      Node h = head;
      if (h != null &amp;&amp; h.waitStatus != 0)
          unparkSuccessor(h);
      return true;
  }
  return false;
</code></pre><p>  }</p>
<ul>
<li><p>解释细节</p>
<ul>
<li>传1表示state锁的状态，后面上锁会给锁状态-1</li>
<li>与上锁时的shouldParkAfterFailedAcquire(p, node)方法对应，waitstate!=0才能执行unparkSuccessor(h)</li>
</ul>
</li>
<li><p>tryRelease(arg)</p>
<p>  protected final boolean tryRelease(int releases) {</p>
<pre><code>  int c = getState() - releases;
  if (Thread.currentThread() != getExclusiveOwnerThread())
      throw new IllegalMonitorStateException();
  boolean free = false;
  if (c == 0) {
      free = true;
      setExclusiveOwnerThread(null);
  }
  setState(c);
  return free;
</code></pre><p>  }</p>
<ul>
<li>给锁状态-1，由于可重入性，-1之后state依然不为0，那么持有锁的线程依旧是当前线程，返回false；否则返回true</li>
</ul>
</li>
<li><p>unparkSuccessor(h)</p>
<p>  private void unparkSuccessor(Node node) {</p>
<pre><code>  /*
   * If status is negative (i.e., possibly needing signal) try
   * to clear in anticipation of signalling.  It is OK if this
   * fails or if status is changed by waiting thread.
   */
  int ws = node.waitStatus;
  if (ws &lt; 0)
      compareAndSetWaitStatus(node, ws, 0);

  /*
   * Thread to unpark is held in successor, which is normally
   * just the next node.  But if cancelled or apparently null,
   * traverse backwards from tail to find the actual
   * non-cancelled successor.
   */
  Node s = node.next;
  if (s == null || s.waitStatus &gt; 0) {
      s = null;
      for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
          if (t.waitStatus &lt;= 0)
              s = t;
  }
  if (s != null)
      LockSupport.unpark(s.thread);
</code></pre><p>  }</p>
<ul>
<li><p>解释细节</p>
<ul>
<li>首先会用compareAndSetWaitStatus(node, ws, 0);将waitstate变为0，然后接着执行acquireQueued方法去抢锁(非公平锁)，如果失败，则将waitstate变为-1</li>
</ul>
</li>
<li><p>移除当前线程结点，获取队列中的下一个节点</p>
<p>  Node s = node.next;<br>  if (s == null || s.waitStatus &gt; 0) {</p>
<pre><code>  s = null;
  for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
      if (t.waitStatus &lt;= 0)
          s = t;
</code></pre><p>  }</p>
</li>
<li><p>LockSupport.unpark(s.thread)：释放锁，唤醒队列中的下一个进程</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第三节：阻塞队列"><a href="#第三节：阻塞队列" class="headerlink" title="第三节：阻塞队列"></a>第三节：阻塞队列</h3><ul>
<li><p>lockInterruptibly()</p>
<ul>
<li><p>中断的几个常用方法</p>
<ul>
<li><p>Thread.interrupted()：检测调用这个方法的线程是否已经中断，并将中断状态设置为false</p>
<p>  public static boolean interrupted()</p>
</li>
<li><p>void interrupt()：用于设置一个线程的中断状态为 true</p>
</li>
<li><p>boolean isInterrupted()：持有线程实例引用即可检测线程中断状态</p>
</li>
</ul>
</li>
<li><p>当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待(即阻塞)的情况下，是可以响应中断的。而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p>
</li>
</ul>
</li>
<li><p>lockSupport</p>
<ul>
<li>使用void interrupt()方法会给线程打上一个标记，即设置中断状态为true，那么LockSupport.park()会判断状态，若为true，便不能阻塞该线程，要使用LockSupport.park(Object)才行</li>
<li><p>LockSupport.unpark</p>
<ul>
<li>unpark只是给当前线程设置一个许可证。如果当前线程已经被阻塞了（即调用了park），则会转为不阻塞的状态。</li>
<li>park和unpark的调用顺序无所谓，只要unpark设置了这个许可证，park方法就可以在任意时刻消费许可证，从而不会阻塞方法。</li>
</ul>
</li>
<li><p>注意void interrupt()</p>
<ul>
<li>若线程处于活跃状态，该方法只能将线程中断状态变为true，并不能真正的中断线程，需要被调用的线程自己进行配合才行。</li>
<li>若线程处于阻塞状态，在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。</li>
<li>会在Thread.cpp底层执行LockSupport.unpark(t)，唤醒当前线程</li>
</ul>
</li>
</ul>
</li>
<li><p>阻塞队列BlockingQueue</p>
<ul>
<li><p>分类</p>
<ul>
<li>ArrayBlockingQueue 由数组支持的有界队列</li>
<li>LinkedBlockingQueue 由链接节点支持的可选有界队列</li>
<li>PriorityBlockingQueue 由优先级堆支持的无界优先级队列</li>
<li>DelayQueue 由优先级堆支持的、基于时间的调度队列</li>
</ul>
</li>
<li><p>数据结构</p>
<ul>
<li><p>ArrayBlockingQueue</p>
<ul>
<li>其中Condition类是AQS类的内部类</li>
</ul>
</li>
<li><p>实现实例</p>
<p>  package CODE.多线程;</p>
<p>  import java.util.concurrent.locks.Condition;<br>  import java.util.concurrent.locks.Lock;<br>  import java.util.concurrent.locks.ReentrantLock;</p>
<p>  //Conditon实现有界队列<br>  class BoundQueue<t><br>  {</t></p>
<pre><code>private Object[] items;
private int counts=0; //intems中元素个数
private Lock lock=new ReentrantLock();
private Condition fullCondition=lock.newCondition();
private Condition emptyCondition=lock.newCondition();
public BoundQueue(int size)
{
  items=new Object[size];
}

//向数组里添加元素，如果数组满，进入等待状态
public void add(T t,int addIndex) throws InterruptedException {
  try
  {
    lock.lock();
    //数组已满，添加线程需要进入等待状态
    while(counts==items.length)
    {
      System.out.println(&quot;数组已满，需要等待&quot;);
      fullCondition.await();
    }
    System.out.println(Thread.currentThread().getName()+&quot;在添加元素&quot;);
    items[addIndex]=t;
    counts++;
    //元素添加完毕，需要唤醒清空队列
    emptyCondition.signal();
  }finally {
    lock.unlock();
  }

}
//删除元素方法，如果当前数组为空，移除线程进入等待状态直到数组不为空
public T remove(int removeIndex) throws InterruptedException {
  try
  {
    lock.lock();
    while(counts==0)
    {
      System.out.println(&quot;数组已空，删除等待&quot;);
      emptyCondition.await();
    }
    Object x=items[removeIndex];
    System.out.println(Thread.currentThread().getName()+&quot;在删除元素&quot;);
    counts--;
    //唤醒添加线程
    fullCondition.signal();
    return (T)x; //从大类型到小类型需要强转
  }finally {
    lock.unlock();
  }
}
</code></pre><p>  }<br>  class MyThread implements Runnable<br>  {</p>
<pre><code>private BoundQueue boundQueue;
private int flag;
public MyThread(int flag,BoundQueue boundQueue)
{
  this.boundQueue=boundQueue;
  this.flag=flag;
}
public void run()
{
  if(flag==1)
  {
    try {
      boundQueue.add(&quot;asb&quot;,0);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }
  else
  {
    try {
      boundQueue.remove(1);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }
}
</code></pre><p>  }<br>  public class Bound {</p>
<pre><code>public static void main(String[] args) {
  BoundQueue&lt;String&gt; boundQueue=new BoundQueue&lt;&gt;(2);
  MyThread addthread=new MyThread(1,boundQueue);
  MyThread removethread=new MyThread(0,boundQueue);
  new Thread(removethread,&quot;删除线程1&quot;).start();
  new Thread(addthread,&quot;添加线程1&quot;).start();
  new Thread(addthread,&quot;添加线程2&quot;).start();
}
</code></pre><p>  }</p>
</li>
<li><p>同步队列(CLH)和阻塞队列</p>
<ul>
<li><p>同步队列(CLH)</p>
<ul>
<li>是一个有头尾结点的双向链式队列。(AQS源码)</li>
<li><p>个人理解</p>
<ul>
<li>同步队列可以类比Java线程的就绪态，满足执行条件(IO资源等)，但没拿到CPU时间片。</li>
</ul>
</li>
</ul>
</li>
<li><p>等待队列</p>
<ul>
<li>是一个无头结点单向的链式队列；</li>
<li><p>个人理解</p>
<ul>
<li>等待队列可以类比Java线程的阻塞态，不满足执行条件(生产者(队列满了)消费者(队列空了))</li>
</ul>
</li>
</ul>
</li>
<li><p>共同</p>
<ul>
<li>在ConditionObject 通过持有等待队列的头尾指针来管理等待队列。这个Node复用了AQS的Node类，也就是等待队列和同步队列的结点共用一个Node类。</li>
</ul>
</li>
</ul>
</li>
<li><p>condition类</p>
<ul>
<li><p>结构</p>
<ul>
<li>public class ConditionObject implements Condition, java.io.Serializable {<br> private transient Node firstWaiter;<br> private transient Node lastWaiter;<br> }</li>
<li>在ConditionObject 通过持有等待队列的头尾指针来管理等待队列。这个Node复用了AQS的Node类，也就是等待队列和同步队列的结点共用一个Node类。</li>
</ul>
</li>
<li><p>wait/notify和await/signal</p>
<ul>
<li>从整体上看Object的wait与notify是与对象监视器（synchronized同步代码块或者同步方法中）配合完成线程间的等待通知机制</li>
<li>而Condition的await和signal与Lock配合完成等待通知机制，前者是JVM底层级别（不可以看源码），后者是Java语言级别，具有更高的可控制性和扩展性（可以看源码）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ArrayBlockingQueue源码分析</p>
<ul>
<li><p>生产者以put()为例</p>
<p>  public void put(E e) throws InterruptedException {</p>
<pre><code>  checkNotNull(e);
  final ReentrantLock lock = this.lock;
  lock.lockInterruptibly();
  try {
      while (count == items.length)
          notFull.await();
      enqueue(e);
  } finally {
      lock.unlock();
  }
</code></pre><p>  }</p>
<ul>
<li><p>解释细节</p>
<ul>
<li>如果数组已满，生产者进程进入等待队列；否则，生产元素，唤醒消费者</li>
</ul>
</li>
<li><p>notFull.await();</p>
<p>  public final void await() throws InterruptedException {</p>
<pre><code>  if (Thread.interrupted())
      throw new InterruptedException();
  Node node = addConditionWaiter();
  int savedState = fullyRelease(node);
  int interruptMode = 0;
  while (!isOnSyncQueue(node)) {
      LockSupport.park(this);
      if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
          break;
  }
  if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
      interruptMode = REINTERRUPT;
  if (node.nextWaiter != null) // clean up if cancelled
      unlinkCancelledWaiters();
  if (interruptMode != 0)
      reportInterruptAfterWait(interruptMode);
</code></pre><p>  }</p>
<ul>
<li><p>解释细节</p>
<ul>
<li>1.当前线程释放lock，进入等待队列，并且唤醒同步队列中下一个结点；</li>
<li>2.当前线程被signal/signalAll后从等待队列移至同步队列，直到获取lock才从await方法返回或者在等待时被中断会做中断处理。</li>
</ul>
</li>
<li><p>addConditionWaiter();</p>
<p>  private Node addConditionWaiter() {</p>
<pre><code>  Node t = lastWaiter;
  // If lastWaiter is cancelled, clean out.
  if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {
      unlinkCancelledWaiters();
      t = lastWaiter;
  }
  Node node = new Node(Thread.currentThread(), Node.CONDITION);
  if (t == null)
      firstWaiter = node;
  else
      t.nextWaiter = node;
  lastWaiter = node;
  return node;
</code></pre><p>  }</p>
<ul>
<li><p>过程</p>
<ul>
<li>1.如果等待队列最后一个结点是取消状态，将这个线程移除；</li>
<li>2.将当前线程包装成Node结点，如果等待队列为空（firstWaiter为null），将firstWaiter指向新包装的Node结点，否则，将当前线程尾插到等待队列，更新lastWaiter（尾节点）。</li>
</ul>
</li>
<li><p>细节</p>
<ul>
<li>等待队列是一个无头结点单向的链式队列；</li>
<li>同步队列(CLH)是一个有头尾结点的双向链式队列。</li>
</ul>
</li>
<li><p>将当前线程添加到等待队列中</p>
</li>
</ul>
</li>
<li><p>fullyRelease(node)</p>
<p>  final int fullyRelease(Node node) {</p>
<pre><code>  boolean failed = true;
  try {
      int savedState = getState();
      if (release(savedState)) {
          failed = false;
          return savedState;
      } else {
          throw new IllegalMonitorStateException();
      }
  } finally {
      if (failed)
          node.waitStatus = Node.CANCELLED;
  }
</code></pre><p>  }</p>
<ul>
<li>当前线程结点尾插到等待队列后，会调用release()方法释放lock锁，唤醒同步队列(CLH)中下一个结点</li>
<li><p>tryRelease</p>
<ul>
<li>给锁状态-1，由于可重入性，-1之后state依然不为0，那么持有锁的线程依旧是当前线程，返回false；否则返回true</li>
</ul>
</li>
<li><p>unparkSuccessor</p>
<ul>
<li>唤醒一个CLH结点</li>
</ul>
</li>
</ul>
</li>
<li><p>isOnSyncQueue(node)</p>
<p>  final boolean isOnSyncQueue(Node node) {</p>
<pre><code>  if (node.waitStatus == Node.CONDITION || node.prev == null)
      return false;
  if (node.next != null) // If has successor, it must be on queue
      return true;
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>                    return findNodeFromTail(node);

                }

                - 如果在等待队列中，则阻塞该进程；后续有线程调用codition的signal或者signalAll方法该线程会进入到同步队列

        - enqueue(e);

            private void enqueue(E x) {
                // assert lock.getHoldCount() == 1;
                // assert items[putIndex] == null;
                final Object[] items = this.items;
                items[putIndex] = x;
                if (++putIndex == items.length)
                    putIndex = 0;
                count++;
                notEmpty.signal();
            }

            - notEmpty.signal();

                public final void signal() {
                //当前线程是否持有lock
                    if (!isHeldExclusively())
                        throw new IllegalMonitorStateException();
                //获取等待队列中第一个结点，第一个结点不为空，doSignal()
                    Node first = firstWaiter;
                    if (first != null)
                        doSignal(first);
                }

                - 当调用condition.signal()会使等待队列等待时间最長的线程结点也就是头结点移动到同步队列；当调用condition.signalAll()会使等待队列中所有结点移动到同步队列中。

                - doSignal(first);

                    private void doSignal(Node first) {
                        do {
                    //先将等待队列第一个结点指向下一个结点，如果为空，证明等待队列只有当前线程，那么将lastWaiter指向null
                            if ( (firstWaiter = first.nextWaiter) == null)
                                lastWaiter = null;
                            first.nextWaiter = null;
                        } 
                    //transferForSignal方法对该线程节点做真正的处理
                    while (!transferForSignal(first) &amp;&amp;
                                 (first = firstWaiter) != null);
                    }

                    - transferForSignal(first)

                        final boolean transferForSignal(Node node) {
                            /*
                             * If cannot change waitStatus, the node has been cancelled.
                             */
                        //首先将结点状态设置为0
                            if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
                                return false;

                            /*
                             * Splice onto queue and try to set waitStatus of predecessor to
                             * indicate that thread is (probably) waiting. If cancelled or
                             * attempt to set waitStatus fails, wake up to resync (in which
                             * case the waitStatus can be transiently and harmlessly wrong).
                             */

                        //将结点使用enq尾插到同步队列中
                            Node p = enq(node);
                            int ws = p.waitStatus;
                            if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
                                LockSupport.unpark(node.thread);
                            return true;
                        }

    - 消费者以take()为例

        public E take() throws InterruptedException {
            final ReentrantLock lock = this.lock;
            lock.lockInterruptibly();
            try {
                while (count == 0)
                    notEmpty.await();
                return dequeue();
            } finally {
                lock.unlock();
            }
        }

        - notEmpty.await();
        - dequeue();

- put()整体流程

    - 1.lock.lock

        - 一开始会AQS竞争锁
        - 没有争取到的先进入CLH队列，后续等待唤醒

    - 2.若不满足入队条件(如数组满了)(await)

        - 将执行权让出，进入等待队列

    - 3.后续singal方法唤醒该线程(数组不是满的了,符合执行条件,但可能多个线程都符合执行条件)

        - 将当前线程移入CLH队列，竞争锁

    - 4.执行业务逻辑
</code></pre><h3 id="第四节：Semaphore-共享模式-及相关AQS应用详解"><a href="#第四节：Semaphore-共享模式-及相关AQS应用详解" class="headerlink" title="第四节：Semaphore(共享模式)及相关AQS应用详解"></a>第四节：Semaphore(共享模式)及相关AQS应用详解</h3><ul>
<li><p>Semaphore</p>
<ul>
<li><p>使用场景：限流，如Hytrix</p>
</li>
<li><p>案例</p>
<p>  public static void main(String[] args) {</p>
<pre><code>  Semaphore semaphore = new Semaphore(3);

  for (int i = 0; i &lt; 10; i++) {
     new Thread(() -&gt;{
       try {
         semaphore.acquire();
         System.out.println(Thread.currentThread().getName() + &quot;\t 进入抢购秒杀页面，准备抢小米9&quot;);
         //停3秒后离开
         try {
           TimeUnit.SECONDS.sleep(3);
         } catch (InterruptedException e) {
           e.printStackTrace();
         }
         System.out.println(Thread.currentThread().getName() + &quot;\t 离开抢购秒杀页面，成功抢到小米9&quot;);
       } catch (InterruptedException e) {
         e.printStackTrace();
       }finally {
         semaphore.release();
       }
     },&quot;用户&quot; + String.valueOf(i)).start();
  }
}
</code></pre></li>
</ul>
</li>
<li><p>CountDownLatch</p>
<ul>
<li><p>使用场景</p>
<ul>
<li><p>多个线程需要等待其他线程的工作之后，再进行其后续工作。即让多个线程在同一个起跑线进行</p>
<ul>
<li><p>案例</p>
<p>  public static void main(String[] args) throws InterruptedException {</p>
<pre><code>  final CountDownLatch latch = new CountDownLatch(1);
  new Thread(() -&gt; {
    System.out.println(Thread.currentThread().getName() + &quot; Do some initial working.&quot;);
    try {
      Thread.sleep(1000);
      latch.await();
      System.out.println(Thread.currentThread().getName() + &quot; Do other working.&quot;);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }).start();

  new Thread(() -&gt; {
    System.out.println(Thread.currentThread().getName() + &quot; Do some initial working.&quot;);
    try {
      Thread.sleep(1000);
      latch.await();
      System.out.println(Thread.currentThread().getName() + &quot; Do other working.&quot;);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }).start();

  new Thread(() -&gt; {
    System.out.println(&quot;asyn prepare for some data.&quot;);
    try {
      Thread.sleep(2000);
      System.out.println(&quot;Data prepare for done.&quot;);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }finally {
      latch.countDown();
    }
  }).start();

}
</code></pre></li>
</ul>
</li>
<li><p>当线程池中指定的线程数执行完，再去执行后面的操作</p>
<ul>
<li><p>案例</p>
<p>  public static void main(String[] args) throws InterruptedException {</p>
<pre><code>  CountDownLatch countDownLatch = new CountDownLatch(6);

  for (int i = 0; i &lt; 6; i++) {
     new Thread(() -&gt;{
      System.out.println(&quot;\t\t&quot; + Thread.currentThread().getName() + &quot;处理完毕~~~&quot;);
      countDownLatch.countDown();
      System.out.println(&quot;非调用者线程-&quot; + Thread.currentThread().getName() + &quot;-还可以干点其他事&quot;);
     }, Country.forEach_Country(i + 1).getCountryName()).start();
  }

  countDownLatch.await();
  System.out.println(&quot;-----------------------------&quot;);
  System.out.println(&quot;\t 所有任务都已经处理完毕，可以往后执行了！&quot;);
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>CyclicBarrier</p>
<ul>
<li><p>和CountDownLatch类似，区别在于CyclicBarrier可以重复使用</p>
<ul>
<li><p>案例</p>
<p>  public static void main(String[] args) {</p>
<pre><code>  CyclicBarrier cyclicBarrier = new CyclicBarrier(7,() -&gt; System.out.println(&quot;收集到7颗龙珠,召唤神龙&quot;));

  for (int i = 0; i &lt; 7; i++) {
     final int temp = i + 1;
     new Thread(() -&gt;{
      System.out.println(Thread.currentThread().getName() + &quot;\t收集到第&quot; + temp + &quot;颗龙珠&quot;);
       try {
         int await = cyclicBarrier.await();
         System.out.println(&quot;还剩几个:&quot; + await);
       } catch (InterruptedException e) {
         e.printStackTrace();
       } catch (BrokenBarrierException e) {
         e.printStackTrace();
       }
     },&quot;线程&quot; + String.valueOf(i)).start();
  }
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>Exchanger(不常用)</p>
</li>
</ul>
<h2 id="4-Atomic类-amp-Unsafe类"><a href="#4-Atomic类-amp-Unsafe类" class="headerlink" title="4.Atomic类&amp;Unsafe类"></a>4.Atomic类&amp;Unsafe类</h2><h3 id="CAS-CompareAndSet"><a href="#CAS-CompareAndSet" class="headerlink" title="CAS(CompareAndSet)"></a>CAS(CompareAndSet)</h3><ul>
<li><p>相关Atomic类</p>
<ul>
<li><p>数组类型</p>
<ul>
<li>AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</li>
</ul>
</li>
<li><p>属性原子修改器（Updater）</p>
<ul>
<li>AtomicIntegerFieldUpdater、 AtomicLongFieldUpdater、AtomicReferenceFieldUpdater</li>
<li>此类方法封装了Unsafe类获取偏移量的操作</li>
</ul>
</li>
</ul>
</li>
<li><p>三大基本CAS</p>
<ul>
<li>compareAndSwapObject<br>  compareAndSwapInt<br>  compareAndSwapLong</li>
<li>基于硬件原语-CMPXCHG实现原子操作cas</li>
</ul>
</li>
<li><p>问题</p>
<ul>
<li><p>ABA问题</p>
<ul>
<li><p>描述：B从A那偷偷取钱，之后投资赚了钱，把钱又偷偷还给了A</p>
</li>
<li><p>解决</p>
<ul>
<li><p>每次修改的时候加个版本</p>
</li>
<li><p>使用AtomicStampedReference类</p>
<p>  static AtomicStampedReference<integer> num = new AtomicStampedReference&lt;&gt;(100,1);</integer></p>
<pre><code>public static void main(String[] args) {
  int stamp = num.getStamp();//初始版本号

  new Thread(() -&gt;{
    num.compareAndSet(100,101,num.getStamp(),num.getStamp() + 1);
    System.out.println(Thread.currentThread().getName() + &quot;\t 版本号&quot; + num.getStamp());
    num.compareAndSet(101,100,num.getStamp(),num.getStamp() + 1);
    System.out.println(Thread.currentThread().getName() + &quot;\t 版本号&quot; + num.getStamp());
  },&quot;线程A&quot;).start();
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>                new Thread(() -&gt;{
                  try {
                    TimeUnit.SECONDS.sleep(3);
                  } catch (InterruptedException e) {
                    e.printStackTrace();
                  }
                  boolean b = num.compareAndSet(100, 209, stamp, num.getStamp() + 1);
                  System.out.println(b + &quot;\t 当前版本号: \t&quot; + num.getStamp());
                  System.out.println(&quot;当前最新值 \t&quot; + num.getReference().toString());
                },&quot;线程B&quot;).start();
              }

- CAS 长时间一直不成功，会给 CPU 带来很大的开销

    - 解决

        - LongAdder：分段CAS操作

            - 默认一开始使用CAS单个cell作为base，当线程多了之后，开启多个cell单元，用于分担base的压力，之后需要值的时候返回base+所有cell的值

        - 示意图
</code></pre><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><ul>
<li><p>为我们提供了类似C、C++手动管理内存的能力，可能会造成内存泄漏</p>
</li>
<li><p>应用</p>
<ul>
<li>文件上传，并发量也比较高；可以用unsafe申请堆外内存</li>
</ul>
</li>
<li><p>案例</p>
<ul>
<li><p>//在AtomicInteger类中获取到value的偏移量，从而操作value<br>private static final Unsafe unsafe = Unsafe.getUnsafe();<br>private static final long valueOffset;</p>
<p>static {</p>
<pre><code>try {
    valueOffset = unsafe.objectFieldOffset
        (AtomicInteger.class.getDeclaredField(&quot;value&quot;));
} catch (Exception ex) { throw new Error(ex); }
</code></pre><p>}</p>
</li>
</ul>
</li>
</ul>
<h2 id="5-HashMap-amp-ConcurrentHashMap"><a href="#5-HashMap-amp-ConcurrentHashMap" class="headerlink" title="5.HashMap&amp;ConcurrentHashMap"></a>5.HashMap&amp;ConcurrentHashMap</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul>
<li><p>为什么初始容量必须是2的整数次幂</p>
<ul>
<li>1.计算hashcode时，return h &amp; (length-1);因为要获取数组下标使用位运算，如果不是2的整数次幂，会出错</li>
<li>2.使用位运算，而不是用mod运算，是因为位运算效率比mod运算高得多，后续扩容效率更高。</li>
</ul>
</li>
<li><p>加载因子为什么是0.75</p>
<ul>
<li>时间和空间上比较均衡</li>
<li>目的:为了减少hash碰撞table长度会扩容一倍</li>
</ul>
</li>
<li><p>1.7:数组+链表</p>
<ul>
<li><p>示意图</p>
</li>
<li><p>put()</p>
<p>  public V put(K key, V value) {</p>
<pre><code>   // 1.第一次put元素
  // 数组为空进行参数初始化-表示第一次put元素
  if (table == EMPTY_TABLE) {
    // 数组初始化/参数初始化
    // 第一次put时，threshold经过构造方法赋值为16
    inflateTable(threshold);
  }
  // 2.添加key为null的元素
  if (key == null)
    return putForNullKey(value);
    // 3.添加key非null的元素
  // 计算hash值
  int hash = hash(key);
  // 计算数组对应下标值
  int i = indexFor(hash, table.length);
  // 遍历数组下标为i的链表
  for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
    Object k;
    // hash冲突 &amp;&amp; key相同
    if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
      // 获取遍历节点元素值
      V oldValue = e.value;
      // 对value进行覆盖
      e.value = value;
      // value被覆盖时调用
      e.recordAccess(this);
      // 返回旧元素值
      return oldValue;
    }
  }
  // 操作次数++
  modCount++;
  // 添加Entry节点
  addEntry(hash, key, value, i);
  return null;
}
</code></pre><ul>
<li><p>indexFor():根据hashCode计算数组下标</p>
<p>  static int indexFor(int h, int length) {</p>
<pre><code>return h &amp; (length-1);
</code></pre><p>  }</p>
</li>
<li><p>addEntry():添加链表节点</p>
<p>  // 添加Entry节点</p>
<pre><code>void addEntry(int hash, K key, V value, int bucketIndex) {
  // map元素个数 &gt; 扩容阈值 &amp;&amp; 当前数组位置对应链表不为空
  if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
    // 将源数组中的元素值散列至新数组
    resize(2 * table.length);
    // 计算hash值 - 重新计算
    hash = (null != key) ? hash(key) : 0;
    // 计算对应新数组下标位置
    bucketIndex = indexFor(hash, table.length);
  }
  // 添加Eentry节点
  createEntry(hash, key, value, bucketIndex);
}
</code></pre><ul>
<li><p>resize():扩容</p>
<p>  // 将源数组中的元素值散列至新数组</p>
<pre><code>void resize(int newCapacity) {
  // 获取源数组
  Entry[] oldTable = table;
  // 获取源数组长度
  int oldCapacity = oldTable.length;
  // 数组长度最大值设置
  if (oldCapacity == MAXIMUM_CAPACITY) {
    threshold = Integer.MAX_VALUE;
    return;
  }
  // 创建长度为源数组长度2倍的新数组
  Entry[] newTable = new Entry[newCapacity];
  // 将源数组中的元素值散列至新数组
  transfer(newTable, initHashSeedAsNeeded(newCapacity));
  // 将新数组赋值至源数组
  table = newTable;
  // 重新计算扩容阈值
  threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
}
</code></pre><ul>
<li><p>transfer():挨个将链表节点复制到新数组链表上，同时重新计算hash值</p>
<p>  void transfer(Entry[] newTable, boolean rehash) {</p>
<pre><code>  // 获取新数组长度
  int newCapacity = newTable.length;
  // 遍历源数组，将元素按照一定规则散列至新数组
  // 外循环：遍历数组
  for (Entry&lt;K,V&gt; e : table) {
    // 内循环：遍历数组位置对应链表
    while(null != e) {
      // 获取当前节点下一个节点
      Entry&lt;K,V&gt; next = e.next;
      if (rehash) {
        // true：重新计算hash值
        e.hash = null == e.key ? 0 : hash(e.key);
      }
      // 获取对应新数组的下标值
      int i = indexFor(e.hash, newCapacity);
      // 下面三步一定要连起来去思考：
      // **前提条件，2次循环都作用于新数组同一下标位置的情况：
      // 第一次循环时，newTable[i]为空，先赋值给当前遍历节点的下个节点，再将当前遍历节点赋值给对应新下标的新数组，最后继续循环
      // 第二次循环时，newTable[i]为上次(存入同一下标位置对应新数组的链表)，然后赋值给当前遍历节点的下个节点(此节点实则为上一次遍历节点的下一个节点，
      //   从这里可以看出，HashMap1.7这里用的是头插法)，再将此链表赋值给同一下标位置的新数组中，最后不为空继续循环；
      e.next = newTable[i];
      newTable[i] = e;
      e = next;
    }
  }
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>1.8:数组+链表+红黑树</p>
<ul>
<li><p>红黑树</p>
<ul>
<li><p>为什么不用二叉平衡树</p>
<ul>
<li>在频繁需要写的场景中AVL效率不高</li>
<li>红黑树牺牲严格的平衡性，换来了写操作时少量的旋转操作</li>
</ul>
</li>
</ul>
</li>
<li><p>重要参数</p>
<ul>
<li>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; Hash表默认初始容量</li>
<li>MAXIMUM_CAPACITY = 1 &lt;&lt; 30; 最大Hash表容量</li>
<li>DEFAULT_LOAD_FACTOR = 0.75f；默认加载因子</li>
<li>TREEIFY_THRESHOLD = 8；链表转红黑树阈值</li>
<li>UNTREEIFY_THRESHOLD = 6；红黑树转链表阈值</li>
<li>MIN_TREEIFY_CAPACITY = 64；链表转红黑树时hash表最小容量阈值，达不到优先扩容。</li>
</ul>
</li>
<li><p>putVal()</p>
<p>  final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</p>
<pre><code>             boolean evict) {
  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
  if ((tab = table) == null || (n = tab.length) == 0)
      n = (tab = resize()).length;
  if ((p = tab[i = (n - 1) &amp; hash]) == null)
      tab[i] = newNode(hash, key, value, null);
  else {
      Node&lt;K,V&gt; e; K k;
      if (p.hash == hash &amp;&amp;
          ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
          e = p;
      else if (p instanceof TreeNode)
          e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
      else {
          for (int binCount = 0; ; ++binCount) {
              if ((e = p.next) == null) {
                  p.next = newNode(hash, key, value, null);
                  if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                      treeifyBin(tab, hash);
                  break;
              }
              if (e.hash == hash &amp;&amp;
                  ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                  break;
              p = e;
          }
      }
      if (e != null) { // existing mapping for key
          V oldValue = e.value;
          if (!onlyIfAbsent || oldValue == null)
              e.value = value;
          afterNodeAccess(e);
          return oldValue;
      }
  }
  ++modCount;
  if (++size &gt; threshold)
      resize();
  afterNodeInsertion(evict);
  return null;
</code></pre><p>  }</p>
<ul>
<li><p>treeifyBin()</p>
<p>  final void treeifyBin(Node<k,v>[] tab, int hash) {</k,v></p>
<pre><code>  int n, index; Node&lt;K,V&gt; e;
  if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
      resize();
  else if ((e = tab[index = (n - 1) &amp; hash]) != null) {
      TreeNode&lt;K,V&gt; hd = null, tl = null;
      do {
          TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);
          if (tl == null)
              hd = p;
          else {
              p.prev = tl;
              tl.next = p;
          }
          tl = p;
      } while ((e = e.next) != null);
      if ((tab[index] = hd) != null)
          hd.treeify(tab);
  }
</code></pre><p>  }</p>
<ul>
<li>若链表节点数目超过TREEIFY_THRESHOLD(默认为8)，转换为红黑树</li>
<li><p>resize();</p>
<ul>
<li>Node<k,v>[] table这个数组大小 小于MIN_TREEIFY_CAPACITY时选择扩容，反之，树形化</k,v></li>
</ul>
</li>
</ul>
</li>
<li><p>流程图</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ConcurrentHashMap-替代了HashTable-因为它的方法基本用Synchronized修饰"><a href="#ConcurrentHashMap-替代了HashTable-因为它的方法基本用Synchronized修饰" class="headerlink" title="ConcurrentHashMap(替代了HashTable,因为它的方法基本用Synchronized修饰)"></a>ConcurrentHashMap(替代了HashTable,因为它的方法基本用Synchronized修饰)</h3><ul>
<li><p>1.7基于ReentrantLock(Segment)实现分段锁</p>
<ul>
<li><p>put()</p>
<ul>
<li>第一次计算key的hash，找到Segment元素的位置；</li>
<li>判断当前Segment元素是否初始化，若没有初始化，则通过CAS进行初始化；</li>
<li>第二次计算key的hash，找到HashEntry数组的位置；</li>
<li>由于Segment继承了ReentrantLock锁，所以TryLock() 尝试获取锁，如果锁获取成功，将数据插入到HashEntry位置，如果遇到Hash冲突，则插入到链表的末端；如果锁被其他线程获取，那么就会以自旋的方式重新获取锁，超过指定的次数之后还获取不到的话，就会挂起，等待唤醒；</li>
</ul>
</li>
<li><p>锁粒度为Segment</p>
</li>
</ul>
</li>
<li><p>1.8CAS+基于synchronized实现分段锁</p>
<ul>
<li><p>put()</p>
<p>  final V putVal(K key, V value, boolean onlyIfAbsent) {</p>
<pre><code>  if (key == null || value == null) throw new NullPointerException();
  int hash = spread(key.hashCode());
  int binCount = 0;
  for (Node&lt;K,V&gt;[] tab = table;;) {
      Node&lt;K,V&gt; f; int n, i, fh;
      if (tab == null || (n = tab.length) == 0)
          tab = initTable();
      else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
          if (casTabAt(tab, i, null,
                       new Node&lt;K,V&gt;(hash, key, value, null)))
              break;                   // no lock when adding to empty bin
      }
      else if ((fh = f.hash) == MOVED)
          tab = helpTransfer(tab, f);
      else {
          V oldVal = null;
          synchronized (f) {
              if (tabAt(tab, i) == f) {
                  if (fh &gt;= 0) {
                      binCount = 1;
                      for (Node&lt;K,V&gt; e = f;; ++binCount) {
                          K ek;
                          if (e.hash == hash &amp;&amp;
                              ((ek = e.key) == key ||
                               (ek != null &amp;&amp; key.equals(ek)))) {
                              oldVal = e.val;
                              if (!onlyIfAbsent)
                                  e.val = value;
                              break;
                          }
                          Node&lt;K,V&gt; pred = e;
                          if ((e = e.next) == null) {
                              pred.next = new Node&lt;K,V&gt;(hash, key,
                                                        value, null);
                              break;
                          }
                      }
                  }
                  else if (f instanceof TreeBin) {
                      Node&lt;K,V&gt; p;
                      binCount = 2;
                      if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                     value)) != null) {
                          oldVal = p.val;
                          if (!onlyIfAbsent)
                              p.val = value;
                      }
                  }
              }
          }
          if (binCount != 0) {
              if (binCount &gt;= TREEIFY_THRESHOLD)
                  treeifyBin(tab, i);
              if (oldVal != null)
                  return oldVal;
              break;
          }
      }
  }
  addCount(1L, binCount);
  return null;
</code></pre><p>  }</p>
<ul>
<li><p>如果没有初始化就先调用initTable（）方法来进行初始化过程；</p>
<p>  if (tab == null || (n = tab.length) == 0)</p>
<pre><code>  tab = initTable();
</code></pre></li>
<li><p>如果没有hash冲突就直接CAS插入；</p>
<p>  else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {</p>
<pre><code>  if (casTabAt(tab, i, null,
               new Node&lt;K,V&gt;(hash, key, value, null)))
      break;                   // no lock when adding to empty bin
</code></pre><p>  }</p>
</li>
<li><p>如果还在进行扩容操作就先进行扩容；</p>
<p>  else if ((fh = f.hash) == MOVED)</p>
<pre><code>  tab = helpTransfer(tab, f);
</code></pre><ul>
<li>如果HashTable触发了扩容，就会把当前Node设置为ForwardingNode</li>
</ul>
</li>
<li><p>如果存在hash冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入；</p>
<p>  if (fh &gt;= 0) {</p>
<pre><code>  binCount = 1;
  for (Node&lt;K,V&gt; e = f;; ++binCount) {
      K ek;
      if (e.hash == hash &amp;&amp;
          ((ek = e.key) == key ||
           (ek != null &amp;&amp; key.equals(ek)))) {
          oldVal = e.val;
          if (!onlyIfAbsent)
              e.val = value;
          break;
      }
      Node&lt;K,V&gt; pred = e;
      if ((e = e.next) == null) {
          pred.next = new Node&lt;K,V&gt;(hash, key,
                                    value, null);
          break;
      }
  }
</code></pre><p>  }</p>
</li>
<li><p>最后一个如果该链表的数量大于阈值8，就要先转换成黑红树的结构，break再一次进入循环；</p>
<p>  else if (f instanceof TreeBin) {</p>
<pre><code>  Node&lt;K,V&gt; p;
  binCount = 2;
  if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                 value)) != null) {
      oldVal = p.val;
      if (!onlyIfAbsent)
          p.val = value;
  }
</code></pre><p>  }</p>
</li>
<li><p>如果添加成功就调用addCount（）方法统计size，并且检查是否需要扩容；</p>
<p>  if (binCount != 0) {</p>
<pre><code>  if (binCount &gt;= TREEIFY_THRESHOLD)
      treeifyBin(tab, i);
  if (oldVal != null)
      return oldVal;
  break;
</code></pre><p>  }</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>参考</p>
</li>
</ul>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><ul>
<li><p>特性</p>
<ul>
<li>适用场景为读多写少</li>
<li>不能读取实时性的数据，但能保证最终数据一致性</li>
<li>空间换时间</li>
</ul>
</li>
<li><p>add()</p>
<ul>
<li>public boolean add(E e) {<br>  final ReentrantLock lock = this.lock;<br>  lock.lock();<br>  try {<pre><code>  Object[] elements = getArray();
  int len = elements.length;
  Object[] newElements = Arrays.copyOf(elements, len + 1);
  newElements[len] = e;
  setArray(newElements);
  return true;
</code></pre>  } finally {<pre><code>  lock.unlock();
</code></pre>  }<br>  }</li>
<li>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</li>
<li>写操作需要加锁，防止并发写入时导致写入数据丢失。</li>
<li>写操作结束之后需要把原始数组指向新的复制数组。</li>
</ul>
</li>
</ul>
<h3 id="需要key有序"><a href="#需要key有序" class="headerlink" title="需要key有序"></a>需要key有序</h3><ul>
<li>TreeMap：线程不安全</li>
<li><p>ConcurrentSkipListMap:和索引结构类似</p>
<ul>
<li>时间复杂度O(logn)，和索引类似</li>
<li>参考</li>
</ul>
</li>
</ul>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><ul>
<li><p>1.ThreadLocal 是什么？有哪些使用场景</p>
<ul>
<li>ThreadLocal 是一个本地线程副本变量工具类，在每个线程中都创建了一个 ThreadLocalMap 对象</li>
<li><p>使用场景</p>
<ul>
<li>为每个线程分配一个 JDBC 连接 Connection。这样就可以保证每个线程的都在各自的 Connection 上进行数据库的操作，不会出现 A 线程关了 B线程正在使用的 Connection</li>
</ul>
</li>
</ul>
</li>
<li><p>2.什么是线程局部变量</p>
<ul>
<li>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。</li>
</ul>
</li>
<li><p>3.ThreadLocal造成内存泄漏的原因</p>
<ul>
<li>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。</li>
<li>所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</li>
<li>这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露</li>
</ul>
</li>
<li><p>4.ThreadLocal内存泄漏解决方案</p>
<ul>
<li>每次使用完ThreadLocal，都调用它的remove()方法，清除数据</li>
</ul>
</li>
<li><p>拓展</p>
<ul>
<li>ThreadLocal的 key 是弱引用，那么在 ThreadLocal.get()的时候，发生GC之后，key 是否为null？</li>
<li><p>ThreadLocal中ThreadLocalMap的数据结构？</p>
<ul>
<li>set时候会获取到每个Thread.ThreadLocalMap，往这个map中放值</li>
</ul>
</li>
<li><p>ThreadLocalMap的Hash 算法？</p>
</li>
<li>ThreadLocalMap中Hash 冲突如何解决？</li>
<li>ThreadLocalMap的扩容机制？</li>
<li>ThreadLocalMap中过期 key 的清理机制？探测式清理和启发式清理流程？</li>
<li>ThreadLocalMap.set()方法实现原理？</li>
<li>ThreadLocalMap.get()方法实现原理？</li>
<li>项目中ThreadLocal使用情况？遇到的坑？</li>
</ul>
</li>
</ul>
<h2 id="6-ThreadPoolExecutor线程池"><a href="#6-ThreadPoolExecutor线程池" class="headerlink" title="6.ThreadPoolExecutor线程池"></a>6.ThreadPoolExecutor线程池</h2><h3 id="工人-猪的例子很好-1-20左右"><a href="#工人-猪的例子很好-1-20左右" class="headerlink" title="工人-猪的例子很好(1:20左右)"></a>工人-猪的例子很好(1:20左右)</h3><h3 id="线程状态图"><a href="#线程状态图" class="headerlink" title="线程状态图"></a>线程状态图</h3><h3 id="线程池的目的和优势"><a href="#线程池的目的和优势" class="headerlink" title="线程池的目的和优势"></a>线程池的目的和优势</h3><ul>
<li>重用存在的线程，减少线程创建，消亡的开销，提高性能</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="ThreadPoolExecutor构造函数的重要参数"><a href="#ThreadPoolExecutor构造函数的重要参数" class="headerlink" title="ThreadPoolExecutor构造函数的重要参数"></a>ThreadPoolExecutor构造函数的重要参数</h3><p>public ThreadPoolExecutor(int corePoolSize,<br>               int maximumPoolSize,<br>               long keepAliveTime,<br>               TimeUnit unit,<br>               BlockingQueue<runnable> workQueue,<br>               ThreadFactory threadFactory,<br>               RejectedExecutionHandler handler)</runnable></p>
<ul>
<li>corePoolSize：核心线程数</li>
<li>maximumPoolSize：线程池最大线程数</li>
<li>keepAliveTime：允许线程最大闲置时间</li>
<li>unit：闲置时间单位</li>
<li>workQueue：一个阻塞队列，用于保存等待被执行的任务</li>
<li>threadFactory：线程工厂，用于创建新线程</li>
<li><p>handler：拒绝策略</p>
<ul>
<li>AbortPolicy：直接抛出异常，默认策略</li>
<li>CallerRunsPolicy：用调用者所在的线程来执行任务</li>
<li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务</li>
<li>DiscardPolicy：直接丢弃任务</li>
</ul>
</li>
</ul>
<h3 id="线程池重要属性"><a href="#线程池重要属性" class="headerlink" title="线程池重要属性"></a>线程池重要属性</h3><ul>
<li><p>ctl 是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段</p>
<p>  private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));<br>   private static final int COUNT_BITS = Integer.SIZE - 3;<br>   private static final int CAPACITY  = (1 &lt;&lt; COUNT_BITS) - 1;</p>
</li>
</ul>
<h3 id="线程池架构"><a href="#线程池架构" class="headerlink" title="线程池架构"></a>线程池架构</h3><ul>
<li>并没有标注哪些是核心线程，移除线程时，是随机移除，最后只要保证线程数等于传入的核心线程数即可</li>
</ul>
<h3 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h3><p>public void execute(Runnable command) {<br>  if (command == null)<br>    throw new NullPointerException();<br>  /*</p>
<pre><code> * clt记录着runState和workerCount
 */
</code></pre><p>  int c = ctl.get();<br>  /*</p>
<pre><code> * workerCountOf方法取出低29位的值，表示当前活动的线程数；
 * 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中；
 * 并把任务添加到该线程中。
 */
</code></pre><p>  if (workerCountOf(c) &lt; corePoolSize) {<br>      /*</p>
<pre><code>     * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；
     * 如果为true，根据corePoolSize来判断；
     * 如果为false，则根据maximumPoolSize来判断
     */
if (addWorker(command, true))
  return;
/*
     * 如果添加失败，则重新获取ctl值
     */
c = ctl.get();
</code></pre><p>  }<br>  /*</p>
<pre><code> * 如果当前线程池是运行状态并且任务添加到队列成功
 */
</code></pre><p>  if (isRunning(c) &amp;&amp; workQueue.offer(command)) {<br>      // 重新获取ctl值<br>    int recheck = ctl.get();<br>    // 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，<br>        // 这时需要移除该command<br>        // 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回<br>    if (! isRunning(recheck) &amp;&amp; remove(command))<br>      reject(command);<br>    /*</p>
<pre><code>     * 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法
     * 这里传入的参数表示：
     * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；
     * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；
     * 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。
     */
else if (workerCountOf(recheck) == 0)
  addWorker(null, false);
</code></pre><p>  }<br>  /*</p>
<pre><code> * 如果执行到这里，有两种情况：
 * 1. 线程池已经不是RUNNING状态；
 * 2. 线程池是RUNNING状态，但workerCount &gt;= corePoolSize并且workQueue已满。
 * 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；
 * 如果失败则拒绝该任务
 */
</code></pre><p>  else if (!addWorker(command, false))<br>    reject(command);<br>}</p>
<ul>
<li><p>方法解释</p>
<ul>
<li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；</li>
<li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
<li><p>整体流程图</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li><p>addWorker(Runnable firstTask, boolean core)：添加线程</p>
<p>  private boolean addWorker(Runnable firstTask, boolean core) {</p>
<pre><code>  boolean workerStarted = false;
  boolean workerAdded = false;
  Worker w = null;
  try {
      w = new Worker(firstTask);
      final Thread t = w.thread;
      if (t != null) {
          final ReentrantLock mainLock = this.mainLock;
          mainLock.lock();
          try {
              // Recheck while holding lock.
              // Back out on ThreadFactory failure or if
              // shut down before lock acquired.
              int rs = runStateOf(ctl.get());

              if (rs &lt; SHUTDOWN ||
                  (rs == SHUTDOWN &amp;&amp; firstTask == null)) {
                  if (t.isAlive()) // precheck that t is startable
                      throw new IllegalThreadStateException();
                  workers.add(w);
                  int s = workers.size();
                  if (s &gt; largestPoolSize)
                      largestPoolSize = s;
                  workerAdded = true;
              }
          } finally {
              mainLock.unlock();
          }
          if (workerAdded) {
              t.start();
              workerStarted = true;
          }
      }
  } finally {
      if (! workerStarted)
          addWorkerFailed(w);
  }
  return workerStarted;
</code></pre><p>  }</p>
<ul>
<li><p>细节</p>
<ul>
<li><p>Worker类：封装了Thread，继承了AQS类，即“工人”</p>
<p>  private final class Worker</p>
<pre><code>  extends AbstractQueuedSynchronizer
  implements Runnable
</code></pre><p>  {</p>
<pre><code>  /**
   * This class will never be serialized, but we provide a
   * serialVersionUID to suppress a javac warning.
   */
  private static final long serialVersionUID = 6138294804551838833L;

  /** Thread this worker is running in.  Null if factory fails. */
  final Thread thread;
  /** Initial task to run.  Possibly null. */
  Runnable firstTask;
  /** Per-thread task counter */
  volatile long completedTasks;
</code></pre></li>
</ul>
</li>
<li><p>t.start()会执行runWorker(Worker w)：执行当前任务</p>
<p>  Thread wt = Thread.currentThread();<br>  Runnable task = w.firstTask;<br>  w.firstTask = null;<br>  w.unlock(); // allow interrupts<br>  boolean completedAbruptly = true;<br>  try {</p>
<pre><code>  while (task != null || (task = getTask()) != null) {
      w.lock();
      // If pool is stopping, ensure thread is interrupted;
      // if not, ensure thread is not interrupted.  This
      // requires a recheck in second case to deal with
      // shutdownNow race while clearing interrupt
      if ((runStateAtLeast(ctl.get(), STOP) ||
           (Thread.interrupted() &amp;&amp;
            runStateAtLeast(ctl.get(), STOP))) &amp;&amp;
          !wt.isInterrupted())
          wt.interrupt();
      try {
          beforeExecute(wt, task);
          Throwable thrown = null;
          try {
              task.run();
          } catch (RuntimeException x) {
              thrown = x; throw x;
          } catch (Error x) {
              thrown = x; throw x;
          } catch (Throwable x) {
              thrown = x; throw new Error(x);
          } finally {
              afterExecute(task, thrown);
          }
      } finally {
          task = null;
          w.completedTasks++;
          w.unlock();
      }
  }
  completedAbruptly = false;
</code></pre><p>  } finally {</p>
<pre><code>  processWorkerExit(w, completedAbruptly);
</code></pre><p>  }</p>
<ul>
<li><p>getTask():从阻塞队列中获取任务</p>
<p>  boolean timedOut = false; // Did the last poll() time out?</p>
<p>  for (;;) {</p>
<pre><code>  // Are workers subject to culling?
  boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;

  try {
      Runnable r = timed ?
          workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
          workQueue.take();
      if (r != null)
          return r;
      timedOut = true;
  } catch (InterruptedException retry) {
      timedOut = false;
  }
</code></pre><p>  }</p>
<ul>
<li><p>细节</p>
<ul>
<li>getTask()返回null的话，在runWorker()中会跳出while循环，执行processWorkerExit()，从而执行workers.remove()移除该工作线程</li>
</ul>
</li>
<li><p>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) ，如果在keepAliveTime内未获取到任务，返回null</p>
</li>
<li>workQueue.take();如果队列为空，会阻塞直到队列不为空</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul>
<li><p>美团线程池骚操作</p>
</li>
<li><p>线程池源码详解</p>
</li>
</ul>
<h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><ul>
<li>tomcat的线程池用于处理请求，springboot自建的线程池用于处理业务</li>
</ul>
<h2 id="7-ScheduledThreadPoolExecutor"><a href="#7-ScheduledThreadPoolExecutor" class="headerlink" title="7.ScheduledThreadPoolExecutor"></a>7.ScheduledThreadPoolExecutor</h2><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ul>
<li><p>执行流程图</p>
</li>
<li><p>构造方法</p>
<ul>
<li><p>ScheduledThreadPoolExecutor(int corePoolSize)</p>
<p>  public ScheduledThreadPoolExecutor(int corePoolSize) {</p>
<pre><code>  super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
        new DelayedWorkQueue());
</code></pre><p>  }</p>
<ul>
<li>继承了父类的构造方法</li>
<li>想实现定时任务，所以要依靠DelayedWorkQueue</li>
</ul>
</li>
<li><p>ScheduledFutureTask：调用定时任务方法时，传入Runnable类后会封装成ScheduledFutureTask</p>
<p>  ScheduledFutureTask(Runnable r, V result, long ns, long period) {</p>
<pre><code>  super(r, result);
  this.time = ns;
  this.period = period;
  this.sequenceNumber = sequencer.getAndIncrement();
</code></pre><p>  }</p>
<ul>
<li>ScheduledFutureTask类继承图</li>
</ul>
</li>
</ul>
</li>
<li><p>两种延迟(定时)任务方法</p>
<ul>
<li><p>scheduleAtFixedRate</p>
<p>  public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</p>
<pre><code>                                            long initialDelay,
                                            long period,
                                            TimeUnit unit) {
  if (command == null || unit == null)
      throw new NullPointerException();
  if (period &lt;= 0)
      throw new IllegalArgumentException();
  ScheduledFutureTask&lt;Void&gt; sft =
      new ScheduledFutureTask&lt;Void&gt;(command,
                                    null,
                                    triggerTime(initialDelay, unit),
                                    unit.toNanos(period));
  RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);
  sft.outerTask = t;
  delayedExecute(t);
  return t;
</code></pre><p>  }</p>
<ul>
<li><p>decorateTask(command, sft)</p>
<p>  protected <v> RunnableScheduledFuture<v> decorateTask(</v></v></p>
<pre><code>  Runnable runnable, RunnableScheduledFuture&lt;V&gt; task) {
  return task;
</code></pre><p>  }</p>
<ul>
<li>默认返回传入的task，可以重载自定义</li>
</ul>
</li>
<li><p>sft.outerTask = t;</p>
<ul>
<li>将任务赋值给outerTask，方便后面定时执行</li>
</ul>
</li>
<li><p>delayedExecute(t);</p>
<ul>
<li><p>super.getQueue().add(task);</p>
<ul>
<li>与ThreadPoolExecutor不同的是，这里直接把任务加入延迟队列</li>
</ul>
</li>
<li><p>ensurePrestart();该方法会走ThreadPoolExecutor，从队列中取任务执行，并且构造函数传入的是DelayedWorkQueue，详细流程参考ThreadPoolExecutor</p>
<ul>
<li><p>DelayedWorkQueue.take()取任务执行</p>
<p>  public RunnableScheduledFuture&lt;?&gt; take() throws InterruptedException {</p>
<pre><code>  final ReentrantLock lock = this.lock;
  lock.lockInterruptibly();
  try {
      for (;;) {
          RunnableScheduledFuture&lt;?&gt; first = queue[0];
          if (first == null)
              available.await();
          else {
              long delay = first.getDelay(NANOSECONDS);
              if (delay &lt;= 0)
                  return finishPoll(first);
              first = null; // don&#39;t retain ref while waiting
              if (leader != null)
                  available.await();
              else {
                  Thread thisThread = Thread.currentThread();
                  leader = thisThread;
                  try {
                      available.awaitNanos(delay);
                  } finally {
                      if (leader == thisThread)
                          leader = null;
                  }
              }
          }
      }
  } finally {
      if (leader == null &amp;&amp; queue[0] != null)
          available.signal();
      lock.unlock();
  }
</code></pre><p>  }</p>
<ul>
<li>available.awaitNanos(delay);阻塞到执行时间</li>
</ul>
</li>
<li><p>ScheduledFutureTask.run()</p>
<p>  public void run() {</p>
<pre><code>  boolean periodic = isPeriodic();
  if (!canRunInCurrentRunState(periodic))
      cancel(false);
  else if (!periodic)
      ScheduledFutureTask.super.run();
  else if (ScheduledFutureTask.super.runAndReset()) {
      setNextRunTime();
      reExecutePeriodic(outerTask);
  }
</code></pre><p>  }</p>
<ul>
<li><p>setNextRunTime();</p>
<p>  private void setNextRunTime() {</p>
<pre><code>  long p = period;
  if (p &gt; 0)
      time += p;
  else
      time = triggerTime(-p);
</code></pre><p>  }</p>
<ul>
<li>计算下次任务执行时间</li>
</ul>
</li>
<li><p>reExecutePeriodic(outerTask);</p>
<p>  void reExecutePeriodic(RunnableScheduledFuture&lt;?&gt; task) {</p>
<pre><code>  if (canRunInCurrentRunState(true)) {
      super.getQueue().add(task);
      if (!canRunInCurrentRunState(true) &amp;&amp; remove(task))
          task.cancel(false);
      else
          ensurePrestart();
  }
</code></pre><p>  }</p>
<ul>
<li>与ensurePrestart类似：把任务放到队列中，重新创建线程执行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>scheduleWithFixedDelay</p>
<p>  public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</p>
<pre><code>                                               long initialDelay,
                                               long delay,
                                               TimeUnit unit) {
  if (command == null || unit == null)
      throw new NullPointerException();
  if (delay &lt;= 0)
      throw new IllegalArgumentException();
  ScheduledFutureTask&lt;Void&gt; sft =
      new ScheduledFutureTask&lt;Void&gt;(command,
                                    null,
                                    triggerTime(initialDelay, unit),
                                    unit.toNanos(-delay));
  RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);
  sft.outerTask = t;
  delayedExecute(t);
  return t;
</code></pre><p>  }</p>
<ul>
<li>与scheduleAtFixedRate不同的是delay会变成-delay，然后在setNextRunTime();设置执行时间</li>
</ul>
</li>
</ul>
</li>
<li><p>使用实例</p>
<p>  @Slf4j<br>  public class ScheduleThreadPoolRunner {</p>
<pre><code>public static void main(String[] args) {
  ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);

  //发心跳，service1-&gt;service2,每次过5s，发送一个心跳，证明s2可用
  scheduledThreadPoolExecutor.scheduleWithFixedDelay(() -&gt; {
    log.info(&quot;send heart beat&quot;);
    long starttime = System.currentTimeMillis(), nowtime = starttime;
    while ((nowtime - starttime) &lt; 5000) {
      nowtime = System.currentTimeMillis();
      try {
        Thread.sleep(100);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
    log.info(&quot;task over....&quot;);
  }, 1000, 2000, TimeUnit.MILLISECONDS);
}
</code></pre><p>  }</p>
</li>
</ul>
<h3 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h3><ul>
<li><p>按照执行时间的升序来排列</p>
</li>
<li><p>依赖的数据结构是堆</p>
</li>
<li><p>offer()</p>
<p>  public boolean offer(Runnable x) {</p>
<pre><code>  if (x == null)
      throw new NullPointerException();
  RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;
  final ReentrantLock lock = this.lock;
  lock.lock();
  try {
      int i = size;
      if (i &gt;= queue.length)
          grow();
      size = i + 1;
      if (i == 0) {
          queue[0] = e;
          setIndex(e, 0);
      } else {
          siftUp(i, e);
      }
      if (queue[0] == e) {
          leader = null;
          available.signal();
      }
  } finally {
      lock.unlock();
  }
  return true;
</code></pre><p>  }</p>
</li>
</ul>
<h2 id="8-Future-amp-ForkJoin"><a href="#8-Future-amp-ForkJoin" class="headerlink" title="8.Future&amp;ForkJoin"></a>8.Future&amp;ForkJoin</h2><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><ul>
<li><p>异步执行任务</p>
</li>
<li><p>使用get()阻塞直到任务完成</p>
</li>
<li><p>get()</p>
<p>  public V get() throws InterruptedException, ExecutionException {</p>
<pre><code>  int s = state;
  if (s &lt;= COMPLETING)
      s = awaitDone(false, 0L);
  return report(s);
</code></pre><p>  }</p>
</li>
</ul>
<h3 id="ForkJoin-不常用"><a href="#ForkJoin-不常用" class="headerlink" title="ForkJoin(不常用)"></a>ForkJoin(不常用)</h3><ul>
<li><p>分而治之，充分利用CPU</p>
<ul>
<li>每个线程都有一个工作队列Deque</li>
</ul>
</li>
<li><p>工作窃取算法</p>
<ul>
<li>scan()方法扫描到就会窃取其他线程的任务</li>
</ul>
</li>
<li><p>流程图</p>
</li>
<li><p>工作场景</p>
<ul>
<li>数据清洗</li>
<li>排序</li>
<li>查找</li>
<li>数据量特别大</li>
</ul>
</li>
</ul>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><ul>
<li>美团</li>
</ul>
<h2 id="9-disruptor-思想先进，用得不多"><a href="#9-disruptor-思想先进，用得不多" class="headerlink" title="9.disruptor(思想先进，用得不多)"></a>9.disruptor(思想先进，用得不多)</h2><h3 id="工作原理图"><a href="#工作原理图" class="headerlink" title="工作原理图"></a>工作原理图</h3><h3 id="对阻塞队列的一种改进"><a href="#对阻塞队列的一种改进" class="headerlink" title="对阻塞队列的一种改进"></a>对阻塞队列的一种改进</h3><ul>
<li>阻塞队列同时只能有一个线程在工作</li>
<li>disruptor支持多生产-消费</li>
<li>基本无锁</li>
</ul>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>商城项目记录</title>
    <url>/alex-next/2022/10/27/javaEE/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p>微服务架构图</p>
<p><img alt="谷粒商城-微服务架构图" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230108213105.jpg"></p>
<h3 id="分布式基础概念"><a href="#分布式基础概念" class="headerlink" title="分布式基础概念"></a>分布式基础概念</h3><h4 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h4><h4 id="集群-分布式-节点"><a href="#集群-分布式-节点" class="headerlink" title="集群-分布式-节点"></a>集群-分布式-节点</h4><h4 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h4><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><h4 id="服务注册-发现-amp-注册中心"><a href="#服务注册-发现-amp-注册中心" class="headerlink" title="服务注册/发现&amp;注册中心"></a>服务注册/发现&amp;注册中心</h4><h4 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h4><h4 id="服务熔断-amp-降级"><a href="#服务熔断-amp-降级" class="headerlink" title="服务熔断&amp;降级"></a>服务熔断&amp;降级</h4><h4 id="API网关l"><a href="#API网关l" class="headerlink" title="API网关l"></a>API网关l</h4><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="1-搭建linux虚拟机"><a href="#1-搭建linux虚拟机" class="headerlink" title="1.搭建linux虚拟机"></a>1.搭建linux虚拟机</h4><h5 id="vagrant安装"><a href="#vagrant安装" class="headerlink" title="vagrant安装"></a>vagrant安装</h5><blockquote>
<p>网络设置-不要端口转发</p>
<p>端口转发示意图：</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230108213058.png"></p>
</blockquote>
<h5 id="自己使用的virtualbox安装"><a href="#自己使用的virtualbox安装" class="headerlink" title="自己使用的virtualbox安装"></a>自己使用的virtualbox安装</h5><blockquote>
<p>sudo -i进入root权限</p>
</blockquote>
<p>安装过程中页面小：使用</p>
<p>sudo xrandr和xrandr -s 1920x1080进行设置</p>
<p>1.安装成功后记得找上面设备-&gt;安装增强功能</p>
<p>2.安装成功后使用xshell连接ubuntu</p>
<p>2.1 安装软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br><span class="line">#开启防火墙端口</span><br><span class="line">firewall-cmd --zone=public --add-port=22/tcp --permanent</span><br></pre></td></tr></table></figure>
<p>2.2 设置网卡</p>
<p>解释：</p>
<p>NAT模式是最简单的实现虚拟机上网的方式，你可以这样理解：Vhost访问网络的所有数据都是由主机提供的，vhost并不真实存在于网络中，主机与网络中的任何机器都不能查看和访问到Vhost的存在。<br>虚拟机与主机关系：<br>只能单向访问，虚拟机可以通过网络访问到主机，主机无法通过网络访问到虚拟机。</p>
<p><img alt="img" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230115231221.png"></p>
<p><img alt="12" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230115231222.png"></p>
<p>2.3 然后使用ifconfig查看ubuntu的ip地址，然后使用xshell连接</p>
<h5 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h5><blockquote>
<p><a href="https://blog.csdn.net/ningmengzhihe/article/details/127295333" target="_blank" rel="noopener">https://blog.csdn.net/ningmengzhihe/article/details/127295333</a></p>
</blockquote>
<h4 id="2-安装docker"><a href="#2-安装docker" class="headerlink" title="2.安装docker"></a>2.安装docker</h4><blockquote>
<p>docker镜像去dockerhub</p>
<p>docker本身去docker官网找文档</p>
</blockquote>
<h4 id="3-docker安装mysql"><a href="#3-docker安装mysql" class="headerlink" title="3.docker安装mysql"></a>3.docker安装mysql</h4><blockquote>
<p>挂载文件，方便修改文件</p>
<p>开机自启动：sudo docker update mysql —restart=always</p>
</blockquote>
<p>==mysql(5.7)闪退解决方案，但是下载mysql5.6没有问题==</p>
<p><a href="https://www.zhangshengrong.com/p/QrXebV9p1d/" target="_blank" rel="noopener">https://www.zhangshengrong.com/p/QrXebV9p1d/</a></p>
<p>镜像中apt-update太慢(使用cat &gt;&gt; 加入)</p>
<p><a href="https://blog.csdn.net/yjk13703623757/article/details/113194891" target="_blank" rel="noopener">https://blog.csdn.net/yjk13703623757/article/details/113194891</a></p>
<blockquote>
<p>创建容器并启动</p>
<p>docker run -p 3306:3306 —name mysql \</p>
<p>-v /mydata/mysql/log:/var/log/mysql \</p>
<p>-v /mydata/mysql/data:/var/lib/mysql \</p>
<p>-v /mydata/mysql/conf:/etc/mysql \</p>
<p>-e MYSQL_ROOT_PASSWORD=root \</p>
<p>-d mysql:5.7</p>
</blockquote>
<h4 id="4-docker安装redis"><a href="#4-docker安装redis" class="headerlink" title="4.docker安装redis"></a>4.docker安装redis</h4><blockquote>
<p>开启持久化 appendonly yes</p>
<p>开机自启动：sudo docker update redis —restart=always</p>
</blockquote>
<h4 id="5-安装开发环境"><a href="#5-安装开发环境" class="headerlink" title="5.安装开发环境"></a>5.安装开发环境</h4><p>git </p>
<blockquote>
<p>配置ssh免密登陆</p>
</blockquote>
<h4 id="6-逆向生成代码"><a href="#6-逆向生成代码" class="headerlink" title="6.逆向生成代码"></a>6.逆向生成代码</h4><p>使用人人开源生成器生成</p>
<h3 id="前端开发基础知识"><a href="#前端开发基础知识" class="headerlink" title="前端开发基础知识"></a>前端开发基础知识</h3><blockquote>
<p>==请参考课件==</p>
</blockquote>
<p>前后端技术类比图</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230108213052.png"></p>
<h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><blockquote>
<p>js是它的一个实现</p>
</blockquote>
<h5 id="map-reduce"><a href="#map-reduce" class="headerlink" title="==map== ==reduce=="></a>==map== ==reduce==</h5><h5 id="promise"><a href="#promise" class="headerlink" title="==promise=="></a>==promise==</h5><p>&gt;</p>
<blockquote>
<p>解决异步嵌套</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;     $.ajax(&#123;</span><br><span class="line">&gt;         url: <span class="string">"mock/user.json"</span>,</span><br><span class="line">&gt;         success(data) &#123;</span><br><span class="line">&gt;             <span class="built_in">console</span>.log(<span class="string">"查询用户："</span>, data);</span><br><span class="line">&gt;             resolve(data.id);</span><br><span class="line">&gt;         &#125;,</span><br><span class="line">&gt;         error(error) &#123;</span><br><span class="line">&gt;             <span class="built_in">console</span>.log(<span class="string">"出现异常了："</span> + error);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;);</span><br><span class="line">&gt; &#125;).then(<span class="function">(<span class="params">userId</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;         $.ajax(&#123;</span><br><span class="line">&gt;             url: <span class="string">`mock/user_corse_<span class="subst">$&#123;userId&#125;</span>.json`</span>,</span><br><span class="line">&gt;             success(data) &#123;</span><br><span class="line">&gt;                 <span class="built_in">console</span>.log(<span class="string">"查询到课程："</span>, data);</span><br><span class="line">&gt;                 resolve(data.id);</span><br><span class="line">&gt;             &#125;,</span><br><span class="line">&gt;             error(error) &#123;</span><br><span class="line">&gt;             	<span class="built_in">console</span>.log(<span class="string">"出现异常了："</span> + error);</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;);</span><br><span class="line">&gt;     &#125;);</span><br><span class="line">&gt; &#125;).then(<span class="function">(<span class="params">corseId</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;     <span class="built_in">console</span>.log(corseId);</span><br><span class="line">&gt;     $.ajax(&#123;</span><br><span class="line">&gt;         url: <span class="string">`mock/corse_score_<span class="subst">$&#123;corseId&#125;</span>.json`</span>,</span><br><span class="line">&gt;         success(data) &#123;</span><br><span class="line">&gt;             <span class="built_in">console</span>.log(<span class="string">"查询到分数："</span>, data);</span><br><span class="line">&gt;         &#125;,</span><br><span class="line">&gt;         error(error) &#123;</span><br><span class="line">&gt;             <span class="built_in">console</span>.log(<span class="string">"出现异常了："</span> + error);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;);</span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>优化：将promise封装为一个方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> <span class="keyword">get</span> = function (url, data) &#123; <span class="comment">// 实际开发中会单独放到 common.js 中</span></span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;         $.ajax(&#123;</span><br><span class="line">&gt;             url: url,</span><br><span class="line">&gt;             type: <span class="string">"GET"</span>,</span><br><span class="line">&gt;             data: data,</span><br><span class="line">&gt;             success(result) &#123;</span><br><span class="line">&gt;             	resolve(result);</span><br><span class="line">&gt;             &#125;,</span><br><span class="line">&gt;             error(error) &#123;</span><br><span class="line">&gt;             	reject(error);</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;);</span><br><span class="line">&gt;     &#125;)</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">get</span>("mock/user.json").then((result) =&gt; &#123;</span><br><span class="line">&gt;     <span class="built_in">console</span>.log(<span class="string">"查询用户："</span>, result);</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">get</span>(`mock/user_corse_$&#123;result.id&#125;.json<span class="string">`);</span></span><br><span class="line"><span class="string">&gt; &#125;).then((result) =&gt; &#123;</span></span><br><span class="line"><span class="string">&gt;     console.log("查询到课程：", result);</span></span><br><span class="line"><span class="string">&gt;     return get(`</span>mock/corse_score_$&#123;result.id&#125;.json<span class="string">`)</span></span><br><span class="line"><span class="string">&gt; &#125;).then((result) =&gt; &#123;</span></span><br><span class="line"><span class="string">&gt; 	console.log("查询到分数：", result);</span></span><br><span class="line"><span class="string">&gt; &#125;).catch(() =&gt; &#123;</span></span><br><span class="line"><span class="string">&gt; 	console.log("出现异常了：" + error);</span></span><br><span class="line"><span class="string">&gt; &#125;);</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h5><blockquote>
<p>是vue模块化的基础</p>
<p>导出</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> util = &#123;</span><br><span class="line">    sum(a,b)&#123;</span><br><span class="line">    	<span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"jack"</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">21</span></span><br><span class="line"><span class="keyword">export</span> &#123;util,name,age&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以自己起名</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    sum(a,b)&#123;</span><br><span class="line">    	<span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>导入</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> util <span class="keyword">from</span> <span class="string">'hello.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;age,name&#125; <span class="keyword">from</span> <span class="string">'user.js'</span></span><br></pre></td></tr></table></figure>
<h5 id="json-的key和value相同可以省略key"><a href="#json-的key和value相同可以省略key" class="headerlink" title="json 的key和value相同可以省略key"></a>json 的key和value相同可以省略key</h5><h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><p>主要用到其中的npm，相当于java的maven</p>
<p>每次开启vue项目使用npm install根据package.json安装依赖包</p>
<h4 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h4><h5 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h5><blockquote>
<p>1.npm init -y生成package.json</p>
<p>2.npm install vue</p>
<p>调试工具vue-devtools</p>
</blockquote>
<h5 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h5><blockquote>
<p>数据与页面元素绑定上了，只需要把关注点放到model上，不需要繁琐的操作DOM</p>
</blockquote>
<h5 id="指令总结"><a href="#指令总结" class="headerlink" title="指令总结"></a>指令总结</h5><blockquote>
<p><strong>v-text、v-html和双大括号:给标签内容绑定值          双大括号就是直接从data中取出数据</strong></p>
<p><strong>v-bind:给标签属性绑定值</strong>  可以缩写，只留冒号</p>
<p><strong>以上都是单向绑定数据(页面值变了，data中不会变)</strong></p>
<p><strong>v-model可以实现双向绑定(页面值变了，data中会变)</strong></p>
<p><strong>v-model可以绑定的元素有input、select、textarea、checkbox、radio、components(vue组件)</strong></p>
<p><strong>v-on:给标签绑定事件</strong></p>
<p>​    事件修饰符</p>
<p>​    按键修饰符</p>
<p>​    组合按钮</p>
<p>v-for  写上:key渲染效率更高</p>
<p>v-if (直接html消失)</p>
<p>v-show(display:none)</p>
<p><strong>以上绑定的值都是从data中取出</strong></p>
<p>==最最最核心的就是data，页面的动态绑定的状态值都是在这里==</p>
</blockquote>
<h5 id="计算属性"><a href="#计算属性" class="headerlink" title="==计算属性=="></a>==计算属性==</h5><blockquote>
<p>computed：动态计算</p>
<p>应用：某个变量发生变化时，其他变量根据这个变量变化</p>
</blockquote>
<h5 id="监听器"><a href="#监听器" class="headerlink" title="==监听器=="></a>==监听器==</h5><blockquote>
<p>watch：监听某个方法的变化</p>
<p>应用：某个变量变化时，做出相应的反应(函数)</p>
</blockquote>
<h5 id="过滤器"><a href="#过滤器" class="headerlink" title="==过滤器=="></a>==过滤器==</h5><blockquote>
<p>filters：定义一些函数进行转换</p>
<p>应用：(0,1)-&gt;(男，女)</p>
<p>全局过滤器：Vue.filter({})</p>
</blockquote>
<h5 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h5><blockquote>
<p>复用重复的组件</p>
<p>tips</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; data()&#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> &#123;</span><br><span class="line">&gt;         count:<span class="number">1</span></span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; 组件中返回了一个新对象，而不是</span><br><span class="line">&gt; data()&#123;</span><br><span class="line">&gt;     count:<span class="number">1</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; 这样可以防止动一个组件，其他跟着一起动</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="父子组件传值"><a href="#父子组件传值" class="headerlink" title="==父子组件传值=="></a>==父子组件传值==</h5><blockquote>
<p>参考</p>
<p><a href="https://www.jianshu.com/p/1e91be0d280d" target="_blank" rel="noopener">https://www.jianshu.com/p/1e91be0d280d</a> 父子组件的通信</p>
<p><a href="https://www.jianshu.com/p/3ab0b823d5b0" target="_blank" rel="noopener">https://www.jianshu.com/p/3ab0b823d5b0</a> 非父子组件的通信、插槽Slot</p>
<p><a href="https://www.jianshu.com/p/7a972277dd0d" target="_blank" rel="noopener">https://www.jianshu.com/p/7a972277dd0d</a> 动态组件、异步组件、生命周期、组件的v-model、Mixin</p>
</blockquote>
<h6 id="使用了-emit向父组件中返回值"><a href="#使用了-emit向父组件中返回值" class="headerlink" title="==使用了$emit向父组件中返回值=="></a>==使用了$emit向父组件中返回值==</h6><p>父组件(brand-add-or-update.vue)：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">single-upload</span> <span class="attr">v-model</span>=<span class="string">"dataForm.logo"</span>&gt;</span><span class="tag">&lt;/<span class="name">single-upload</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>子组件(singleUpload.vue)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">emitInput(val) &#123;</span><br><span class="line">    参考  https:<span class="comment">//www.h5w3.com/81714.html</span></span><br><span class="line">    在这里返回给父组件 </span><br><span class="line">    <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, val)<span class="comment">// 触发输入行为,v-model 绑定的是 input 事件</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">handleUploadSuccess(res, file) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"上传成功..."</span>)</span><br><span class="line">        <span class="keyword">this</span>.showFileList = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.fileList.pop();</span><br><span class="line">        <span class="keyword">this</span>.fileList.push(&#123;<span class="attr">name</span>: file.name, <span class="attr">url</span>: <span class="keyword">this</span>.dataObj.host + <span class="string">'/'</span> + <span class="keyword">this</span>.dataObj.key.replace(<span class="string">"$&#123;filename&#125;"</span>,file.name)&#125;);</span><br><span class="line">        <span class="comment">// 在这里返回给父组件logo的地址</span></span><br><span class="line">        <span class="keyword">this</span>.emitInput(<span class="keyword">this</span>.fileList[<span class="number">0</span>].url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="父组件可以使用-props-把数据传给子组件"><a href="#父组件可以使用-props-把数据传给子组件" class="headerlink" title="==父组件可以使用 props 把数据传给子组件=="></a>==父组件可以使用 props 把数据传给子组件==</h6><p>父组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//直接绑定 :title=v-bind:title</span><br><span class="line"><span class="tag">&lt;<span class="name">show-message</span> <span class="attr">:title</span>=<span class="string">"title"</span> <span class="attr">:content</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">show-message</span>&gt;</span></span><br><span class="line">//绑定对象的属性</span><br><span class="line"><span class="tag">&lt;<span class="name">show-message</span> <span class="attr">:title</span>=<span class="string">"message.title"</span> <span class="attr">:content</span>=<span class="string">"message.content"</span>&gt;</span><span class="tag">&lt;/<span class="name">show-message</span>&gt;</span></span><br><span class="line">//绑定对象，就会把对象的所有属性绑定到组件上，这种写法和上一行效果一样</span><br><span class="line"><span class="tag">&lt;<span class="name">show-message</span> <span class="attr">v-bind</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">show-message</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//数据</span><br><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    title: "嘻嘻嘻",</span><br><span class="line">    content: "我是嘻嘻嘻嘻",</span><br><span class="line">    message: &#123;</span><br><span class="line">      title: "嘿嘿嘿",</span><br><span class="line">      content: "我是嘿嘿嘿"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子组件  </p>
<blockquote>
<p>子组件使用props指定要什么值</p>
<p>父组件调用子组件时也要指定传什么值</p>
</blockquote>
<p><img alt="img" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230108230519"></p>
<h5 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h5><blockquote>
<p>Vue在生命周期的每个状态都设置了监听函数，我们可以根据业务需求在Vue的各个生命周期设置各种函数执行相应的功能 </p>
<p>有点像Spring的AOP？？</p>
</blockquote>
<h5 id="使用脚手架快速开发"><a href="#使用脚手架快速开发" class="headerlink" title="使用脚手架快速开发"></a>使用脚手架快速开发</h5><blockquote>
<p>1.<strong>npm install webpack -g</strong></p>
<p>2.<strong>npm install -g @vue/cli-init</strong></p>
<p>​    安装vue脚手架</p>
<p>3.vue init webpack appname</p>
<p>​    初始化</p>
<p>==初始化的Vue项目详解看P43==</p>
<p>@是src根目录</p>
<p>==vscode可以自定义代码模板     ctrl+shift+f快速整理==</p>
</blockquote>
<h4 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h4><blockquote>
<p>老浏览器不支持ES6语法，Babel可以转成它们支持的老js语法</p>
</blockquote>
<h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><blockquote>
<p>打包工具，gulp是同类产品</p>
</blockquote>
<h3 id="SpringCloud-amp-SpringCloud-Alibaba组件"><a href="#SpringCloud-amp-SpringCloud-Alibaba组件" class="headerlink" title="==SpringCloud &amp; SpringCloud Alibaba组件=="></a>==SpringCloud &amp; SpringCloud Alibaba组件==</h3><blockquote>
<p>==SpringCloud Alibaba组件请参考github项目==</p>
<p><strong>SpringCloud</strong> <strong>的几大痛点</strong></p>
<p>SpringCloud 部分组件停止维护和更新，给开发带来不便；</p>
<p>SpringCloud 部分环境搭建复杂，没有完善的可视化界面，我们需要大量的二次开发和定制</p>
<p>SpringCloud 配置复杂，难以上手，部分配置差别难以区分和合理应用</p>
<p><strong>SpringCloud Alibaba</strong> <strong>的优势：</strong></p>
<p>阿里使用过的组件经历了考验，性能强悍，设计合理，现在开源出来大家用</p>
<p>成套的产品搭配完善的可视化界面给开发运维带来极大的便利</p>
<p>搭建简单，学习曲线低。</p>
</blockquote>
<p><strong>结合</strong> <strong>SpringCloud Alibaba</strong> <strong>我们最终的技术搭配方案：</strong></p>
<h5 id="SpringCloud-Alibaba-Nacos：注册中心（服务发现注册）"><a href="#SpringCloud-Alibaba-Nacos：注册中心（服务发现注册）" class="headerlink" title="SpringCloud Alibaba - Nacos：注册中心（服务发现注册）"></a><strong>SpringCloud Alibaba - Nacos</strong>：注册中心（服务发现注册）</h5><blockquote>
<p>对比Eureka</p>
<p>1.先在github上下载nacos文件包</p>
<p>2.引入pom依赖</p>
<p>3.配置application.yml的nacos地址</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">&gt; spring:</span></span><br><span class="line"><span class="string">&gt;   application:</span></span><br><span class="line"><span class="string">&gt;     name: gulimall-coupon</span></span><br><span class="line"><span class="string">&gt;   cloud:</span></span><br><span class="line"><span class="string">&gt;     nacos:</span></span><br><span class="line"><span class="string">&gt;       discovery:</span></span><br><span class="line"><span class="string">&gt;         server-addr: localhost:8848</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>4.开启@EnableDiscoveryClient注解</p>
</blockquote>
<h5 id="SpringCloud-Alibaba-Nacos：配置中心-（动态配置管理）"><a href="#SpringCloud-Alibaba-Nacos：配置中心-（动态配置管理）" class="headerlink" title="==SpringCloud Alibaba - Nacos：配置中心==（动态配置管理）"></a><strong>==SpringCloud Alibaba - Nacos：配置中心==（动态配置管理）</strong></h5><h6 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h6><blockquote>
<p>1.先在github上下载nacos文件包</p>
<p>2.引入pom依赖</p>
<p>3.配置bootstrap.yml的nacos地址</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">&gt; spring:</span></span><br><span class="line"><span class="string">&gt;   application:</span></span><br><span class="line"><span class="string">&gt;     name: gulimall-coupon</span></span><br><span class="line"><span class="string">&gt;   cloud:</span></span><br><span class="line"><span class="string">&gt;     nacos:</span></span><br><span class="line"><span class="string">&gt;       config:</span></span><br><span class="line"><span class="string">&gt;         server-addr: localhost:8848</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>==4.在需要刷新属性值的类上加上@RefreshScope==+ 属性名上加@Value</p>
<p>5.在nacos界面添加配置，配置的id是springboot启动界面出现的properties名称(项目名.properties)</p>
<p>tips：优先使用配置中心的配置，再使用项目中的配置</p>
<p>==作用：可以实时，不下线应用的前提下修改application.properties配置文件中的值==</p>
</blockquote>
<h6 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h6><blockquote>
<p><strong>1.命名空间:</strong></p>
<p>配置隔离：</p>
<p>1.1默认的命名空间是public，通过命名空间区分测试、开发、生产环境</p>
<blockquote>
<p>在bootstrap中配置命名空间的空间id—namespace</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">&gt; &gt; spring:</span></span><br><span class="line"><span class="string">&gt; &gt;   application:</span></span><br><span class="line"><span class="string">&gt; &gt;     name: gulimall-coupon</span></span><br><span class="line"><span class="string">&gt; &gt;   cloud:</span></span><br><span class="line"><span class="string">&gt; &gt;     nacos:</span></span><br><span class="line"><span class="string">&gt; &gt;       config:</span></span><br><span class="line"><span class="string">&gt; &gt;         server-addr: localhost:8848</span></span><br><span class="line"><span class="string">&gt; &gt;         namespace: 5f96fa79-8abf-49a7-a148-7bee7f77a575</span></span><br><span class="line"><span class="string">&gt; &gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>1.2每一个微服务相互隔离配置，每一个微服务都创建自己的命名空间</p>
<p>2.配置集：所有的配置的集合</p>
<p>3.配置集Id：类似文件名</p>
<p>​    Data ID：类似文件名</p>
<p>4.配置分组：默认所有的配置集都属于DEFAULT_GROUP</p>
<p>要指定group，在bootstrap.yml中配置group</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">&gt; spring:</span></span><br><span class="line"><span class="string">&gt;   application:</span></span><br><span class="line"><span class="string">&gt;     name: gulimall-coupon</span></span><br><span class="line"><span class="string">&gt;   cloud:</span></span><br><span class="line"><span class="string">&gt;     nacos:</span></span><br><span class="line"><span class="string">&gt;       config:</span></span><br><span class="line"><span class="string">&gt;         group: 双11</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>5.<strong>加载多配置文件</strong></p>
<p>直接在nacos中操作</p>
<p>在bootstrap.properties/bootstrap.yml添加ext-config</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.server-addr=127.0.0.1:8848</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.namespace=31098de9-fa28-41c9-b0bd-c754ce319ed4</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.ext-config[0].data-id=gulimall-datasource.yml</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string"># 是否自动刷新</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.ext-config[0].refresh=false</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.ext-config[0].group=dev</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string"></span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.ext-config[0].data-id=gulimall-mybatis.yml</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string"># 是否自动刷新</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.ext-config[0].refresh=false</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.ext-config[0].group=dev</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string"></span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.ext-config[0].data-id=gulimall-other.yml</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string"># 是否自动刷新</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.ext-config[0].refresh=false</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="string">spring.cloud.nacos.config.ext-config[0].group=dev</span></span><br><span class="line"><span class="attr">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>然后就可以把application.yml注释掉，直接用nacos的配置</p>
</blockquote>
<h5 id="SpringCloud-Ribbon：负载均衡"><a href="#SpringCloud-Ribbon：负载均衡" class="headerlink" title="SpringCloud - Ribbon：负载均衡"></a><strong>SpringCloud - Ribbon</strong>：负载均衡</h5><h5 id="SpringCloud-Feign：声明式-HTTP-客户端（调用远程服务）"><a href="#SpringCloud-Feign：声明式-HTTP-客户端（调用远程服务）" class="headerlink" title="SpringCloud - Feign：声明式 HTTP 客户端（调用远程服务）"></a><strong>SpringCloud - Feign</strong>：声明式 <strong>HTTP</strong> <strong>客户端（调用远程服务）</strong></h5><h5 id="SpringCloud-Alibaba-Sentinel：服务容错（限流、降级、熔断）"><a href="#SpringCloud-Alibaba-Sentinel：服务容错（限流、降级、熔断）" class="headerlink" title="SpringCloud Alibaba - Sentinel：服务容错（限流、降级、熔断）"></a><strong>SpringCloud Alibaba - Sentinel</strong>：服务容错（限流、降级、熔断）</h5><blockquote>
<p>对比Hystrix</p>
</blockquote>
<h5 id="SpringCloud-Gateway：API-网关（webflux-编程模式）"><a href="#SpringCloud-Gateway：API-网关（webflux-编程模式）" class="headerlink" title="SpringCloud - Gateway：API 网关（webflux 编程模式）"></a><strong>SpringCloud - Gateway</strong>：<strong>API </strong>网关（<strong>webflux</strong> <strong>编程模式）</strong></h5><blockquote>
<p>比zuul功能更多，取代了zuul</p>
<p>route(路由)</p>
<p>predicate(断言)</p>
<p>filter</p>
<p>通过路由经过断言和过滤器抵达请求，类似SpringMVC流程</p>
<p>1.添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>2.网关不需要数据库，添加如下配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="meta">@SpringBootApplication</span>(exclude = &#123;DataSourceAutoConfiguration.class&#125; )</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="SpringCloud-Sleuth：调用链监控"><a href="#SpringCloud-Sleuth：调用链监控" class="headerlink" title="SpringCloud - Sleuth：调用链监控"></a><strong>SpringCloud - Sleuth</strong>：调用链监控</h5><h5 id="SpringCloud-Alibaba-Seata：原Fescar，即分布式事务解决方案"><a href="#SpringCloud-Alibaba-Seata：原Fescar，即分布式事务解决方案" class="headerlink" title="SpringCloud Alibaba - Seata：原Fescar，即分布式事务解决方案"></a><strong>SpringCloud Alibaba - Seata</strong>：原Fescar<strong>，即分布式事务解决方案</strong></h5><h5 id="SpringCloud-Alibaba-OSS"><a href="#SpringCloud-Alibaba-OSS" class="headerlink" title="SpringCloud Alibaba - OSS"></a>SpringCloud Alibaba - OSS</h5><p>1.导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alicloud-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.配置yml</p>
<p>3.注入OSSClient(实际要注入的是OSS)</p>
<h3 id="后端正式开发"><a href="#后端正式开发" class="headerlink" title="后端正式开发"></a>后端正式开发</h3><h4 id="1-构建权限树"><a href="#1-构建权限树" class="headerlink" title="1.构建权限树"></a>1.构建权限树</h4><blockquote>
<p>思路，先把所有的id和entity用map存起来，再遍历</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来存放结果</span></span><br><span class="line">List&lt;AuthPO&gt; authTree = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 使用map表示每一个菜单与id的对应关系</span></span><br><span class="line">Map&lt;Long,AuthPO&gt; authMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 将菜单id与菜单对象以K-V对模式存入map</span></span><br><span class="line"><span class="keyword">for</span>(AuthPO auth: authPOList)&#123;</span><br><span class="line">    authMap.put(auth.getId(),auth);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (AuthPO auth:authPOList)&#123;</span><br><span class="line">    Long pid = auth.getAuthParentId();</span><br><span class="line">    <span class="keyword">if</span>(Objects.equals(pid,<span class="number">0L</span>))&#123;</span><br><span class="line">        authTree.add(auth);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AuthPO father = authMap.get(pid);</span><br><span class="line">    father.getChildren().add(auth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-gateway配置路由-作用-前端项目不用再一个一个改请求地址"><a href="#2-gateway配置路由-作用-前端项目不用再一个一个改请求地址" class="headerlink" title="2.gateway配置路由(作用:前端项目不用再一个一个改请求地址)"></a>2.gateway配置路由(作用:前端项目不用再一个一个改请求地址)</h4><blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">&gt; spring:</span></span><br><span class="line"><span class="string">&gt;   cloud:</span></span><br><span class="line"><span class="string">&gt;     gateway:</span></span><br><span class="line"><span class="string">&gt;       routes:</span></span><br><span class="line"><span class="string">&gt;         - id: admin_route</span></span><br><span class="line"><span class="string">&gt;           # lb表示负载均衡(loadbalance),renren-fast是微服务名称</span></span><br><span class="line"><span class="string">&gt;           uri: lb://renren-fast</span></span><br><span class="line"><span class="string">&gt;           predicates:</span></span><br><span class="line"><span class="string">&gt;           	********项目中这个路由最好写到最后，最后才生效******</span></span><br><span class="line"><span class="string">&gt;             - Path=/api/**</span></span><br><span class="line"><span class="string">&gt;           filters:</span></span><br><span class="line"><span class="string">&gt;             - RewritePath=/api/(?&lt;segment&gt;/?.*), /renren-fast/$\&#123;segment&#125;</span></span><br><span class="line"><span class="string">&gt;             </span></span><br><span class="line"><span class="string">&gt; 前端请求：localhost:88/api/captcha.jpg</span></span><br><span class="line"><span class="string">&gt; 转到后端请求会重新拼接上来：localhost:8080/api/captcha.jpg</span></span><br><span class="line"><span class="string">&gt; 所以要用- RewritePath=/api/(?&lt;segment&gt;/?.*), /renren-fast/$\&#123;segment&#125;</span></span><br><span class="line"><span class="string">&gt; 效果就是把api替换为renren-fast即localhost:8080/api/captcha.jpg-&gt;localhost:8080/renren-fast/captcha.jpg</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="3-跨域-amp-CORS同源策略"><a href="#3-跨域-amp-CORS同源策略" class="headerlink" title="==3.跨域&amp;CORS同源策略=="></a>==3.跨域&amp;CORS同源策略==</h4><blockquote>
<p>localhost:8080和localhost:88就是非同源，协议、ip和端口号一致才叫同源(域名和域名对应ip都不行)，这就不符合CORS同源策略</p>
<p><img alt="5" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230108213019.png"></p>
<p>==跨域流程参考课件图==</p>
<p>非简单请求(json数据不是)都会先发送预检请求，成功后，才发送真实请求</p>
</blockquote>
<p><strong>解决方案</strong></p>
<p>1.使用nginx部署为统一域(有图)</p>
<p>2.给预检请求配置，此次请求能跨域</p>
<blockquote>
<p>不止这一种方式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallCorsConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsWebFilter <span class="title">corsWebFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line"></span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、配置跨域</span></span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">"*"</span>);</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">// 是否允许携带cookie</span></span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">		<span class="comment">// 任意路径都需要跨域配置</span></span><br><span class="line">        source.registerCorsConfiguration(<span class="string">"/**"</span>,corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsWebFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-对象存储"><a href="#4-对象存储" class="headerlink" title="==4.对象存储=="></a>==4.对象存储==</h4><p><img alt="6" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230108212958.png"></p>
<p>分布式项目一定要有一个专门存储图片、文件等对象的服务</p>
<p>对象存储上传方式(参考ppt图)</p>
<blockquote>
<p>服务器签名后直传，文件不经过服务器，只是从服务器拿一个签名</p>
</blockquote>
<p>步骤：</p>
<p>1.导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alicloud-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.配置yml</p>
<p>3.注入OSSClient(实际要注入的是OSS)</p>
<p>==4.请求/oss/policy获取签名==</p>
<p>==5.因为是浏览器直接向OSS传输文件，所以还存在跨域问题，要在阿里云OSS配置跨域==</p>
<p><img alt="7" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230108212933.png"></p>
<p>6.如果上传成功后，不能通过直链访问，还要配置bucket的读写权限</p>
<p><img alt="9" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230112140644.png"></p>
<h4 id="5-校验配置"><a href="#5-校验配置" class="headerlink" title="5.校验配置"></a>5.校验配置</h4><h5 id="5-1-可以紧跟-Valid后的bean声明BindingResult获得校验结果"><a href="#5-1-可以紧跟-Valid后的bean声明BindingResult获得校验结果" class="headerlink" title="5.1 可以紧跟@Valid后的bean声明BindingResult获得校验结果"></a>5.1 可以紧跟@Valid后的bean声明BindingResult获得校验结果</h5><p>这边引用的是注册功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(value = <span class="string">"/register"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">(@Valid UserRegisterVo vos, BindingResult result,</span></span></span><br><span class="line"><span class="function"><span class="params">                       RedirectAttributes attributes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果有错误回到注册页面</span></span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">        Map&lt;String, String&gt; errors = result.getFieldErrors().stream().collect(Collectors.toMap(FieldError::getField, FieldError::getDefaultMessage));</span><br><span class="line">        attributes.addFlashAttribute(<span class="string">"errors"</span>,errors);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//效验出错回到注册页面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:http://auth.gulimall.com/reg.html"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-2-分组校验"><a href="#5-2-分组校验" class="headerlink" title="5.2 分组校验"></a>5.2 分组校验</h5><p>定义空的interface，配置校验时，指定该分组</p>
<h5 id="5-3-自定义校验"><a href="#5-3-自定义校验" class="headerlink" title="5.3 自定义校验"></a>5.3 自定义校验</h5><p>编写自定义Annotation和Validator，编写ValidationMessages.properties文件</p>
<p><strong>下面的例子就是要满足取得值在vals内</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = &#123; ListValueConstraintValidator.class &#125;)<span class="comment">// 可以指定多个校验器</span></span><br><span class="line"><span class="meta">@Target</span>(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ListValue &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "</span>&#123;com.atguigu.common.valid.ListValue.message&#125;<span class="string">";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Class&lt;?&gt;[] groups() default &#123; &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Class&lt;? extends Payload&gt;[] payload() default &#123; &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    int[] vals() default &#123; &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListValueConstraintValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">ListValue</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> constraintAnnotation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ListValue constraintAnnotation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] vals = constraintAnnotation.vals();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> val : vals) &#123;</span><br><span class="line">            set.add(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否效验成功</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 需要效验的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Integer value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否有包含的值</span></span><br><span class="line">        <span class="keyword">boolean</span> contains = set.contains(value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> contains;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-日志"><a href="#6-日志" class="headerlink" title="6.日志"></a>6.日志</h4><p>直接使用@Slf4j+log</p>
<h4 id="7-推荐不要使用关联查询，把sql语句拆成多句"><a href="#7-推荐不要使用关联查询，把sql语句拆成多句" class="headerlink" title="7.推荐不要使用关联查询，把sql语句拆成多句"></a>7.推荐不要使用关联查询，把sql语句拆成多句</h4><h4 id="8-for和foreach的区别"><a href="#8-for和foreach的区别" class="headerlink" title="8.for和foreach的区别"></a>8.for和foreach的区别</h4><p><a href="https://blog.csdn.net/cpcpcp123/article/details/125410074" target="_blank" rel="noopener">参考</a></p>
<h4 id="9-feign细节"><a href="#9-feign细节" class="headerlink" title="==9.feign细节=="></a>==9.feign细节==</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feign流程:</span><br><span class="line">1、CouponFeignService.saveSpuBounds(spuBoundTo);</span><br><span class="line">*      1）、@RequestBody将这个对象转为json。</span><br><span class="line">*      2）、找到gulimall-coupon服务，给/coupon/spubounds/save发送请求。</span><br><span class="line">*          将上一步转的json放在请求体位置，发送请求；</span><br><span class="line">*      3）、对方服务收到请求。请求体里有json数据。</span><br><span class="line">*          (@RequestBody SpuBoundsEntity spuBounds)；将请求体的json转为SpuBoundsEntity；</span><br><span class="line">feign细节:只要json数据模型是兼容的。双方服务无需使用同一个to</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1)、让所有请求过网关；</span><br><span class="line">*          1、@FeignClient(&quot;gulimall-gateway&quot;)：给gulimall-gateway所在的机器发请求</span><br><span class="line">*          2、/api/product/skuinfo/info/&#123;skuId&#125;</span><br><span class="line">2）、直接让后台指定服务处理</span><br><span class="line">*          1、@FeignClient(&quot;gulimall-product&quot;)</span><br><span class="line">*          2、/product/skuinfo/info/&#123;skuId&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-SPU和SKU"><a href="#10-SPU和SKU" class="headerlink" title="10.SPU和SKU"></a>10.SPU和SKU</h4><p>SPU表示通用的一类商品，SKU表示具体的某个型号某个参数的商品</p>
<h3 id="前端项目开发"><a href="#前端项目开发" class="headerlink" title="前端项目开发"></a>前端项目开发</h3><blockquote>
<p>入门案例先参考category.vue就行</p>
</blockquote>
<h4 id="1-index-js中配置请求路径"><a href="#1-index-js中配置请求路径" class="headerlink" title="1.index.js中配置请求路径"></a>1.index.js中配置请求路径</h4><blockquote>
<p>localhost:88  统一从网关获取访问路径，</p>
<p>这样多个微服务地址，不用改来改去</p>
<p>配合后端第2条看</p>
</blockquote>
<h4 id="2-data-解构数据"><a href="#2-data-解构数据" class="headerlink" title="2.{data}解构数据"></a>2.{data}解构数据</h4><p>原始的data传到前端是这样的</p>
<p><img alt="10" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230112162643.png"></p>
<p>{data}解构之后才是后端真正传的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getMenus() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$http(&#123;</span><br><span class="line">        url: <span class="keyword">this</span>.$http.adornUrl(<span class="string">"/product/category/list"</span>),</span><br><span class="line">        method: <span class="string">"get"</span></span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功获取到菜单数据..."</span>, data.page);</span><br><span class="line">        <span class="keyword">this</span>.menus = data.page;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line">因为这边要得数据是数组类型，而我们的数据是</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"msg"</span>: <span class="string">"success"</span>,</span><br><span class="line">  <span class="string">"code"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">"page"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"图书、音像、电子书刊"</span>,</span><br><span class="line">      <span class="string">"parentId"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">"status"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">"sort"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">"icon"</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="string">"unit"</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="string">"children"</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">这样的对象类型</span><br><span class="line">否则就这样写</span><br><span class="line">getMenus() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$http(&#123;</span><br><span class="line">        url: <span class="keyword">this</span>.$http.adornUrl(<span class="string">"/product/category/list"</span>),</span><br><span class="line">        method: <span class="string">"get"</span></span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功获取到菜单数据..."</span>, data.data.page);</span><br><span class="line">        <span class="keyword">this</span>.menus = data.data.page;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h4 id="3-飘号-引用变量"><a href="#3-飘号-引用变量" class="headerlink" title="3.``(飘号)引用变量"></a>3.``(飘号)引用变量</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$confirm(<span class="string">`是否删除【<span class="subst">$&#123;data.name&#125;</span>】菜单?`</span>, <span class="string">"提示"</span>, &#123;</span><br><span class="line">    confirmButtonText: <span class="string">"确定"</span>,</span><br><span class="line">    cancelButtonText: <span class="string">"取消"</span>,</span><br><span class="line">    type: <span class="string">"warning"</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="4-拖拽功能有空可以看看"><a href="#4-拖拽功能有空可以看看" class="headerlink" title="4.拖拽功能有空可以看看"></a>4.拖拽功能有空可以看看</h4><h4 id="5-this-refs-menuTree"><a href="#5-this-refs-menuTree" class="headerlink" title="==5.this.$refs.menuTree=="></a>==5.this.$refs.menuTree==</h4><blockquote>
<p>在category.vue中</p>
<p>$refs表示从template节点中取，menuTree是vue的template其中一个节点取得名字</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">el-tree</span> <span class="attr">:data</span>=<span class="string">"menus"</span> <span class="attr">ref</span>=<span class="string">"menuTree"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-tree</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>这样就能拿到这个节点的属性</p>
<p>其实后台开发人员可能也是要写前端的，真正的前端开发人员是写面向用户的前端</p>
</blockquote>
<h4 id="6-slot"><a href="#6-slot" class="headerlink" title="==6.slot=="></a>==6.slot==</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">"showStatus"</span> <span class="attr">header-align</span>=<span class="string">"center"</span> <span class="attr">align</span>=<span class="string">"center"</span> <span class="attr">label</span>=<span class="string">"显示状态"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-switch</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">v-model</span>=<span class="string">"scope.row.showStatus"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">active-color</span>=<span class="string">"#13ce66"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">inactive-color</span>=<span class="string">"#ff4949"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">:active-value</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">:inactive-value</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">                   @<span class="attr">change</span>=<span class="string">"updateBrandStatus(scope.row)"</span></span></span><br><span class="line"><span class="tag">                   &gt;</span><span class="tag">&lt;/<span class="name">el-switch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>scope中封装了这一列的所有信息</p>
</blockquote>
<h4 id="7-上传文件"><a href="#7-上传文件" class="headerlink" title="==7.上传文件=="></a>==7.上传文件==</h4><p>记得在components中声明要是用哪些组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SingleUpload <span class="keyword">from</span> <span class="string">"@/components/upload/singleUpload"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123; SingleUpload &#125;,</span><br><span class="line">  data() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==因为是直接浏览器向OSS传输文件，所以还存在跨域问题，要在阿里云OSS配置跨域==</p>
<p><img alt="7" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230108212933.png"></p>
<p>如果上传成功后，不能通过直链访问，还要配置bucket的读写权限</p>
<p><img alt="9" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230112140644.png"></p>
<h4 id="8-父子组件传值"><a href="#8-父子组件传值" class="headerlink" title="8.父子组件传值"></a>8.父子组件传值</h4><blockquote>
<p>上传文件</p>
<p>category.vue 树形菜单</p>
</blockquote>
<h5 id="8-1-使用了-emit向父组件中返回值"><a href="#8-1-使用了-emit向父组件中返回值" class="headerlink" title="==8.1 使用了$emit向父组件中返回值=="></a>==8.1 使用了$emit向父组件中返回值==</h5><p>父组件(brand-add-or-update.vue)：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">single-upload</span> <span class="attr">v-model</span>=<span class="string">"dataForm.logo"</span>&gt;</span><span class="tag">&lt;/<span class="name">single-upload</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>子组件(singleUpload.vue)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">emitInput(val) &#123;</span><br><span class="line">    在这里返回给父组件</span><br><span class="line">    <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, val)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">handleUploadSuccess(res, file) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"上传成功..."</span>)</span><br><span class="line">        <span class="keyword">this</span>.showFileList = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.fileList.pop();</span><br><span class="line">        <span class="keyword">this</span>.fileList.push(&#123;<span class="attr">name</span>: file.name, <span class="attr">url</span>: <span class="keyword">this</span>.dataObj.host + <span class="string">'/'</span> + <span class="keyword">this</span>.dataObj.key.replace(<span class="string">"$&#123;filename&#125;"</span>,file.name)&#125;);</span><br><span class="line">        <span class="comment">// 在这里返回给父组件logo的地址</span></span><br><span class="line">        <span class="keyword">this</span>.emitInput(<span class="keyword">this</span>.fileList[<span class="number">0</span>].url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="8-2-父组件可以使用-props-把数据传给子组件"><a href="#8-2-父组件可以使用-props-把数据传给子组件" class="headerlink" title="8.2 父组件可以使用 props 把数据传给子组件"></a>8.2 父组件可以使用 props 把数据传给子组件</h5><h4 id="9-表单校验"><a href="#9-表单校验" class="headerlink" title="9.表单校验"></a>9.表单校验</h4><p>默认校验+自定义校验</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="1-什么是微服务？"><a href="#1-什么是微服务？" class="headerlink" title="1.什么是微服务？"></a>1.什么是微服务？</h4><h4 id="2-分布式和集群的区别？"><a href="#2-分布式和集群的区别？" class="headerlink" title="2.分布式和集群的区别？"></a>2.分布式和集群的区别？</h4><blockquote>
<p>分布式是将不同的业务分布在不同的地方</p>
<p>集群指的是将几台服务器集中在一起，实现同一业务</p>
<p><img alt="分布式-集群" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230108213120.png"></p>
</blockquote>
<h3 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h3><h4 id="1-nacos-报错endpoint-is-blank"><a href="#1-nacos-报错endpoint-is-blank" class="headerlink" title="1.nacos 报错endpoint is blank"></a>1.nacos 报错endpoint is blank</h4><blockquote>
<p>解决：</p>
<p>在bootstrap.yml中添加</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">&gt; spring:</span></span><br><span class="line"><span class="string">&gt;   application:</span></span><br><span class="line"><span class="string">&gt;     name: gulimall-coupon</span></span><br><span class="line"><span class="string">&gt;   cloud:</span></span><br><span class="line"><span class="string">&gt;     nacos:</span></span><br><span class="line"><span class="string">&gt;       config:</span></span><br><span class="line"><span class="string">&gt;         server-addr: localhost:8848</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>注意是nacos.config而不是nacos.discovery</p>
</blockquote>
<h2 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h2><h3 id="要点"><a href="#要点" class="headerlink" title="==要点=="></a>==要点==</h3><h4 id="1-项目中使用elasticsearch"><a href="#1-项目中使用elasticsearch" class="headerlink" title="1.项目中使用elasticsearch"></a>1.项目中使用elasticsearch</h4><p>不仅要把数据存到mysql中，还要存到es中，才能以后调用es的api进行检索</p>
<h4 id="2-使用typeReference封装接口"><a href="#2-使用typeReference封装接口" class="headerlink" title="2.使用typeReference封装接口"></a>2.使用typeReference封装接口</h4><p>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用fastjson进行反序列化</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getData</span><span class="params">(TypeReference&lt;T&gt; typeReference)</span> </span>&#123;</span><br><span class="line">    Object data = get(<span class="string">"data"</span>);	<span class="comment">//默认是map</span></span><br><span class="line">    String jsonString = JSON.toJSONString(data);</span><br><span class="line">    T t = JSON.parseObject(jsonString, typeReference);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">R skuHasStock = wareFeignService.getSkuHasStock(skuIdList);</span><br><span class="line"></span><br><span class="line">TypeReference&lt;List&lt;SkuHasStockVo&gt;&gt; typeReference = <span class="keyword">new</span> TypeReference&lt;List&lt;SkuHasStockVo&gt;&gt;() &#123;&#125;;</span><br><span class="line">stockMap = skuHasStock.getData(typeReference).stream()</span><br><span class="line">    .collect(Collectors.toMap(SkuHasStockVo::getSkuId, item -&gt; item.getHasStock()));</span><br></pre></td></tr></table></figure>
<h4 id="3-测试分布式场景"><a href="#3-测试分布式场景" class="headerlink" title="3.测试分布式场景"></a>3.测试分布式场景</h4><p>同一个应用在idea配置那边多复制几份，改下端口，然后运行即可。</p>
<h4 id="4-注意线程池配置"><a href="#4-注意线程池配置" class="headerlink" title="4.注意线程池配置"></a>4.注意线程池配置</h4><blockquote>
<p>放在这里的原因是注意这边的参数注入，学着点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties</span>(ThreadPoolConfigProperties.class)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolExecutor <span class="title">threadPoolExecutor</span><span class="params">(ThreadPoolConfigProperties poolConfigProperties)</span></span>&#123;</span><br><span class="line">        <span class="comment">// poolConfigProperties这边就可以直接从配置文件中获取到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                poolConfigProperties.getCoreSize(),</span><br><span class="line">                poolConfigProperties.getMaxSize(),</span><br><span class="line">                poolConfigProperties.getKeepAliveTime(),</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">100000</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-feign远程请求丢失请求头"><a href="#5-feign远程请求丢失请求头" class="headerlink" title="5.feign远程请求丢失请求头"></a>5.feign远程请求丢失请求头</h4><p>原因：feign远程调用会创建一个全新的请求，从而丢失了请求头(后面可能导致丢失各种登录状态)</p>
<p><img alt="36" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230210212732.png"></p>
<p>解决</p>
<blockquote>
<p>在feign的RequestInterceptor中加上同步请求头就行了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuliFeignConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"requestInterceptor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestInterceptor <span class="title">requestInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RequestInterceptor requestInterceptor = <span class="keyword">new</span> RequestInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//1、使用RequestContextHolder拿到刚进来的请求数据</span></span><br><span class="line">                ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 主要同步cookie,</span></span><br><span class="line">                <span class="keyword">if</span> (requestAttributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//老请求</span></span><br><span class="line">                    HttpServletRequest request = requestAttributes.getRequest();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//2、同步请求头的数据（主要是cookie）</span></span><br><span class="line">                        String cookie = request.getHeader(<span class="string">"Cookie"</span>);</span><br><span class="line">                        <span class="comment">//把老请求的cookie值放到新请求上来，进行一个同步(注意这里是设置请求头，而不是localstorage)</span></span><br><span class="line">                        template.header(<span class="string">"Cookie"</span>, cookie);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> requestInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-feign异步调用丢失上下文信息"><a href="#6-feign异步调用丢失上下文信息" class="headerlink" title="6.feign异步调用丢失上下文信息"></a>6.feign异步调用丢失上下文信息</h4><blockquote>
<p>原因：这里主要是异步调用，异步调用会开启新线程，而新线程中没有请求数据</p>
<p>==说一下这里使用问题5中的RequestInterceptor拦截器为什么没有用？==</p>
<p>因为在cart和address异步线程中RequestContextHolder本来就没有相应的请求信息，所以后面同步cookie自然也没有用。</p>
<p>这个只有主线程请求进来的时候RequestContextHolder中才有请求信息。</p>
<p>所以要做的就是把主线程中RequestContextHolder的请求数据放到cart和address异步线程。</p>
</blockquote>
<p><img alt="37" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230210214712.png"></p>
<h4 id="7-幂等性"><a href="#7-幂等性" class="headerlink" title="==7.幂等性=="></a>==7.幂等性==</h4><blockquote>
<p>有文档</p>
</blockquote>
<h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p><strong>接口幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的</strong></p>
<h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><p>用户多次点击按钮</p>
<p>用户页面回退再次提交</p>
<p>微服务互相调用，由于网络问题，导致请求失败。feign 触发重试机制</p>
<p>其他业务情况</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><h6 id="1-token机制"><a href="#1-token机制" class="headerlink" title="1.token机制"></a>1.token机制</h6><blockquote>
<p>前端传的token和redis的Token一样，就执行业务</p>
</blockquote>
<h6 id="2-锁机制"><a href="#2-锁机制" class="headerlink" title="2.锁机制"></a>2.锁机制</h6><p>乐观锁</p>
<p>悲观锁</p>
<p>业务层分布式锁</p>
<h6 id="3-各种唯一约束"><a href="#3-各种唯一约束" class="headerlink" title="3.各种唯一约束"></a>3.各种唯一约束</h6><p>数据库唯一约束</p>
<p>redis  set防重</p>
<h6 id="4-防重表"><a href="#4-防重表" class="headerlink" title="4.防重表"></a>4.防重表</h6><h6 id="5-全局请求唯一id"><a href="#5-全局请求唯一id" class="headerlink" title="5.全局请求唯一id"></a>5.全局请求唯一id</h6><h3 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h3><blockquote>
<p>有参考文档</p>
<p>可以快速地<strong>储存、搜索和分析</strong>海量数据</p>
</blockquote>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><blockquote>
<p>可参考</p>
<p><a href="https://blog.csdn.net/Vincent9847/article/details/118244167" target="_blank" rel="noopener">https://blog.csdn.net/Vincent9847/article/details/118244167</a></p>
</blockquote>
<p><img alt="11" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230115212116.png"></p>
<h5 id="1-index-索引-，"><a href="#1-index-索引-，" class="headerlink" title="1.index(索引)，"></a>1.index(索引)，</h5><p>动词，相当于 MySQL 中的 insert；</p>
<p>名词，相当于 MySQL 中的 Database</p>
<h5 id="2-type-类型-，类似于mysql的table"><a href="#2-type-类型-，类似于mysql的table" class="headerlink" title="2.type(类型)，类似于mysql的table"></a>2.type(类型)，类似于mysql的table</h5><h5 id="3-Document-文档-，相当于mysql表中的数据-行"><a href="#3-Document-文档-，相当于mysql表中的数据-行" class="headerlink" title="3.Document(文档)，相当于mysql表中的数据(行)"></a>3.Document(文档)，相当于mysql表中的数据(行)</h5><h5 id="4-倒排索引"><a href="#4-倒排索引" class="headerlink" title="==4.倒排索引=="></a>==4.倒排索引==</h5><p>ElasticSearch搜索为什么很快的原因</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><blockquote>
<p>参考文档</p>
</blockquote>
<p>改变权限</p>
<blockquote>
<p>chmod -R 777 /mydata/elasticsearch/ 保证权限</p>
<p>-R递归所有目录改变权限</p>
</blockquote>
<p>第一次启动ElasticSearch</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e &quot;discovery.type=single-node&quot; \</span><br><span class="line">-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; \</span><br><span class="line">-v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-d elasticsearch:7.4.2</span><br><span class="line"></span><br><span class="line">9200是http请求接口，9300是分布式集群下的端口</span><br></pre></td></tr></table></figure>
<blockquote>
<p>docker update elasticsearch —restart=always</p>
</blockquote>
<p>第一次启动Kibana</p>
<blockquote>
<p>docker run —name kibana -e ELASTICSEARCH_HOSTS=<a href="http://192.168.56.108:9200" target="_blank" rel="noopener">http://192.168.56.108:9200</a> -p 5601:5601 -d kibana:7.4.2</p>
</blockquote>
<p>如果已启动过</p>
<blockquote>
<p>docker start 进程编号(部分即可)</p>
<p>参考文档</p>
</blockquote>
<p>增删改查+批量操作</p>
<p>批量测试数据地址</p>
<blockquote>
<p><a href="https://gitee.com/xlh_blog/common_content/blob/master/es%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE.json#" target="_blank" rel="noopener">https://gitee.com/xlh_blog/common_content/blob/master/es%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE.json#</a></p>
</blockquote>
<h4 id="高级检索"><a href="#高级检索" class="headerlink" title="高级检索"></a>高级检索</h4><blockquote>
<p>参考文档</p>
</blockquote>
<h5 id="1-SearchAPI"><a href="#1-SearchAPI" class="headerlink" title="1.SearchAPI"></a>1.SearchAPI</h5><blockquote>
<p>GET bank/_search?q=*&amp;sort=account_number:asc</p>
</blockquote>
<p>match,sort..</p>
<h5 id="2-Query-DSL"><a href="#2-Query-DSL" class="headerlink" title="2.Query DSL"></a>2.Query DSL</h5><blockquote>
<p>返回部分字段</p>
<p>匹配查询(match 只要匹配到任意一个单词，默认会分词)(address.keyword就可以匹配精确值(是全等))</p>
<p>短语匹配(全部匹配)</p>
<p>多字段匹配(<strong>multi_match</strong>，多个字段包含指定字符)</p>
<p>复合匹配(bool，这里面的条件必须都要满足(must,should,must_not)</p>
<p>==结果过滤(用在复合匹配中，filter查出结果后过滤，和Must区别就是不贡献相关性得分)==</p>
<p>term(多个就是terms)   和 match一样，匹配某个属性值，但推荐全文检索使用match，其他非text字段匹配使用term</p>
<p>nested用于存储复杂类型(对象)</p>
<p><strong>aggregations</strong>聚合分析结果(平均值，年龄段个数)，类似SQL的group by(求多个年龄段的平均薪资)</p>
</blockquote>
<h5 id="3-Mapping"><a href="#3-Mapping" class="headerlink" title="3.Mapping"></a>3.Mapping</h5><blockquote>
<p>可以类比mybatis</p>
<p>ElasticSearch默认会推断出所以的映射类型，但可以自己指定</p>
</blockquote>
<h5 id="4-分词"><a href="#4-分词" class="headerlink" title="4.分词"></a>4.分词</h5><blockquote>
<p>下载</p>
<p>wget <a href="https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.4.2/elasticsearch-analysis-ik-7.4.2.zip" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.4.2/elasticsearch-analysis-ik-7.4.2.zip</a></p>
<p>自定义分词</p>
<p>需要借助nginx，nginx安装参考附录</p>
</blockquote>
<h4 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h4><h5 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallElasticSearchConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RequestOptions COMMON_OPTIONS;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        RequestOptions.Builder builder = RequestOptions.DEFAULT.toBuilder();</span><br><span class="line">        <span class="comment">// builder.addHeader("Authorization", "Bearer " + TOKEN);</span></span><br><span class="line">        <span class="comment">// builder.setHttpAsyncResponseConsumerFactory(</span></span><br><span class="line">        <span class="comment">//         new HttpAsyncResponseConsumerFactory</span></span><br><span class="line">        <span class="comment">//                 .HeapBufferedResponseConsumerFactory(30 * 1024 * 1024 * 1024));</span></span><br><span class="line">        COMMON_OPTIONS = builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">esRestClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(</span><br><span class="line">                RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">"192.168.77.130"</span>, <span class="number">9200</span>, <span class="string">"http"</span>)));</span><br><span class="line">        <span class="keyword">return</span>  client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="DSL在java中的示例"><a href="#DSL在java中的示例" class="headerlink" title="==DSL在java中的示例=="></a>==DSL在java中的示例==</h5><p>见search服务中的MallSearchServiceImpl#buildSearchRequest</p>
<p>请看P173-192</p>
<h4 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h4><p>181P，分享一个自己遇到的问题：<br>问题：org.elasticsearch.ElasticsearchException: Elasticsearch exception [type=illegal_argument_exception, reason=Can’t load fielddata on 【brandName】 because fielddata is unsupported on fields of type 【keyword】. Use doc values instead.]</p>
<p>思路：出现该错误是因为ES5.x之后，对聚合所依据的字段用单独的数据结构(fielddata)缓存到内存里了，但是在text字段上默认是禁用的，如果有需要单独开启，这样做的目的是为了节省内存空间。<br>具体实现方法可以参考文档或者自行百度。</p>
<p>解决：在字段里加上keyword，例如：<br>.field(“brandName.keyword”)<br>.field(“brandImg.keyword”)<br>.field(“catalogName.keyword”)<br>.field(“attrs.attrName.keyword”)</p>
<h3 id="nginx"><a href="#nginx" class="headerlink" title="==nginx=="></a>==nginx==</h3><blockquote>
<p>1.保护了真实的web服务器</p>
<p>2.方便动静分离和负载均衡</p>
</blockquote>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><blockquote>
<p>详情见文档</p>
<p>1.随便启动一个 nginx 实例，只是为了复制出配置</p>
<p>docker run -p 80:80 —name nginx -d nginx:1.10</p>
<p>2.将容器内的配置文件拷贝到当前目录：docker container cp nginx:/etc/nginx . </p>
<p><strong>别忘了后面的点</strong></p>
<p>3.修改文件名称：mv nginx conf 把这个 conf 移动到/mydata/nginx 下</p>
<p>4.终止原容器：docker stop nginx</p>
<p>5.执行命令删除原容器：docker rm $ContainerId</p>
<p>6.创建新的 nginx；执行以下命令</p>
<p>启动</p>
<p>docker run -p 80:80 —name nginx -v /mydata/nginx/html:/usr/share/nginx/html -v /mydata/nginx/logs:/var/log/nginx -v /mydata/nginx/conf:/etc/nginx -d nginx:1.10</p>
</blockquote>
<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>详情</p>
<p><img alt="img" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230201212605.png"></p>
<h4 id="使用nginx反向代理"><a href="#使用nginx反向代理" class="headerlink" title="==使用nginx反向代理=="></a>==使用nginx反向代理==</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><img alt="img" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230201213548.png"></p>
<p>步骤：</p>
<p>1.用户访问gulimall.com(由于是本地测试，这边只是改了本地的hosts模仿DNS域名解析器)，发到nginx</p>
<p>==tips：记住不能挂VPN，否则DNS解析默认走代理服务器，不会走Hosts文件中配置的地址==</p>
<p>2.nginx监听gulimall.com这个域名，监听到请求就发给proxy_pass配置的后台服务器(这里配置的是网关，网关再转发给相应的服务器)</p>
<p>3.网关根据路由规则，匹配后台服务器</p>
<p>4.转到后台服务器调用接口。</p>
<h5 id="不改进"><a href="#不改进" class="headerlink" title="不改进"></a>不改进</h5><p>配置文件</p>
<p>conf.d/default.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  gulimall.com; # nginx监听客户端访问的域名(ip地址),然后根据下面配置的转发给相应的后台服务器</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    #access_log  /var/log/nginx/log/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://192.168.56.1:10000; # 转发给相应的服务器,这里是本机(不是虚拟机)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page /50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h5><p>==将转发的地址改为网关的地址==</p>
<p>nginx.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line">    upstream gulimall&#123; # 这里的gulimall和default.conf中对应</span><br><span class="line">        server 192.168.56.1:88; # 配置上游服务器的地址,即网关地址</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>conf.d/default.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  gulimall.com; # nginx监听客户端访问的域名(ip地址),然后根据下面配置的转发给相应的后台服务器</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    #access_log  /var/log/nginx/log/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">    	proxy_set_header Host $host; # nginx给网关转发的时候会丢掉host,不补上识别不到,所以要加上</span><br><span class="line">        proxy_pass http://gulimall; # 默认转发给上游服务器(网关),之后再负载均衡的转给各个服务器</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page /50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>网关的yml配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">- id:</span> <span class="string">gulimall_host_route</span></span><br><span class="line">	<span class="attr">uri:</span> <span class="attr">lb://gulimall-product</span></span><br><span class="line">	<span class="attr">predicates:</span></span><br><span class="line">		<span class="bullet">-</span> <span class="string">Host=gulimall.com,item.gulimall.com</span></span><br></pre></td></tr></table></figure>
<h4 id="使用nginx实现动静分离"><a href="#使用nginx实现动静分离" class="headerlink" title="==使用nginx实现动静分离=="></a>==使用nginx实现动静分离==</h4><p>简单来说就是，静态资源不要放到后台服务器，这样会直接请求到tomcat，</p>
<p>而是应该把静态资源放到nginx，让用户去直接请求nginx得到这些静态资源，缓解后台tomcat的压力。</p>
<p><img alt="14" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230202162959.png"></p>
<p>在conf.d/gulimall.conf中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  gulimall.com; # nginx监听客户端访问的域名(ip地址),然后根据下面配置的转发给相应的后台服务器</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    #access_log  /var/log/nginx/log/host.access.log  main;</span><br><span class="line">    ##############################看这里##########################</span><br><span class="line">    location /static/&#123;</span><br><span class="line">    	root /usr/share/nginx/html;  # 注意这边是nginx的/bin/bash里面的路径，而不是外头的路径</span><br><span class="line">    &#125;</span><br><span class="line">    ##############################看这里##########################</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">    	proxy_set_header Host $host; # nginx给网关转发的时候会丢掉host,不补上识别不到,所以要加上</span><br><span class="line">        proxy_pass http://gulimall; # 默认转发给上游服务器(网关),之后再负载均衡的转给各个服务器</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page /50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p>TPS:系统每秒处理交易数，单位是笔/秒。</p>
<p>QPS:系统每秒处理查询次数，单位是次/秒</p>
<p>一般情况下：</p>
<p>金融行业：1000TPS~50000TPS，不包括互联网化的活动</p>
<p>保险行业：100TPS~100000TPS，不包括互联网化的活动</p>
<p>制造行业：10TPS~5000TPS</p>
<p>互联网电子商务：10000TPS~1000000TPS</p>
<p>互联网中型网站：1000TPS~50000TPS</p>
<p>互联网小型网站：500TPS~10000TPS</p>
<h4 id="Jemter工具"><a href="#Jemter工具" class="headerlink" title="Jemter工具"></a>Jemter工具</h4><p><a href="https://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">下载</a></p>
<p>具体使用见资料</p>
<h5 id="bug-1"><a href="#bug-1" class="headerlink" title="bug"></a>bug</h5><p>报错：<strong>JMeter Address Already in use</strong></p>
<blockquote>
<p>windows 本身提供的端口访问机制的问题。</p>
<p>Windows 提供给 TCP/IP 链接的端口为 1024-5000，并且要四分钟来循环回收他们。就导致</p>
<p>我们在短时间内跑大量的请求时将端口占满了。</p>
<p>1.cmd 中，用 regedit 命令打开注册表</p>
<p>2.在 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters 下，</p>
<p>1 .右击 parameters，添加一个新的 DWORD，名字为 MaxUserPort</p>
<p>2 .然后双击 MaxUserPort，输入数值数据为 65534，基数选择十进制（如果是分布式运</p>
<p>行的话，控制机器和负载机器都需要这样操作哦）</p>
<ol>
<li>修改配置完毕之后记得重启机器才会生效</li>
</ol>
<p><a href="https://support.microsoft.com/zh-cn/help/196271/when-you-try-to-connect-from-tcp-ports-grea" target="_blank" rel="noopener">https://support.microsoft.com/zh-cn/help/196271/when-you-try-to-connect-from-tcp-ports-grea</a></p>
<p>ter-than-5000-you-receive-t</p>
<p>TCPTimedWaitDelay：30</p>
</blockquote>
<h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><h4 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h4><p>jvisualvm是升级版的jconsole，所以一般都使用jvisualvm，Jmeter压测配合jvisualvm观察</p>
<p>==下图是课上压测的结果==</p>
<p><img alt="13" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230202155547.png"></p>
<p>==结论(优化方向)==：</p>
<p>中间件越多，性能损失越大，大多都损失在网络交互了；</p>
<p>业务：</p>
<p>​    Db（MySQL 优化）</p>
<p>​    模板的渲染速度（缓存）</p>
<p>​    静态资源</p>
<h3 id="缓存与分布式锁-Redis"><a href="#缓存与分布式锁-Redis" class="headerlink" title="==缓存与分布式锁(Redis)=="></a>==缓存与分布式锁(Redis)==</h3><p>使用redis做分布式缓存架构图</p>
<p><img alt="img" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230202181916.png"></p>
<h4 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h4><blockquote>
<p>安装</p>
<p>docker pull redis</p>
<p>配置</p>
<p>mkdir -p /mydata/redis/conf</p>
<p>touch /mydata/redis/conf/redis.conf</p>
<p>启动</p>
<p>docker run -p 6379:6379 —name redis -v /mydata/redis/data:/data -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf</p>
<p>设置开机自动启动</p>
<p>docker update redis —restart=always</p>
<p>以redis-cli进入内部</p>
<p>docker exec -it redis redis-cli</p>
</blockquote>
<h4 id="SpringBoot整合-1"><a href="#SpringBoot整合-1" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h4><p>导入依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入redis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">lettuce会产生堆外内存溢出OutOfDirectMemoryError:</span><br><span class="line">//1)、springboot2.0以后默认使用lettuce操作redis的客户端，它使用通信</span><br><span class="line">//2)、lettuce的bug导致netty堆外内存溢出   可设置：-Dio.netty.maxDirectMemory</span><br><span class="line">//解决方案：不能直接使用-Dio.netty.maxDirectMemory去调大堆外内存</span><br><span class="line">//1)、升级lettuce客户端。      2）、切换使用jedis</span><br></pre></td></tr></table></figure>
<p>配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">redis:</span></span><br><span class="line"><span class="attr">        host:</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.108</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>
<p>注入StringRedisTemplate进行使用</p>
<h4 id="本地锁"><a href="#本地锁" class="headerlink" title="本地锁"></a>本地锁</h4><p>synchronized，juc(lock)只能锁住当前进程，在分布式场景下想要锁住所有的必须使用分布式锁</p>
<p><img alt="15" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230202201550.png"></p>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>原理图</p>
<p><img alt="16" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230202203300.png"></p>
<p>==实现过程中有好多坑，详细可以看资料图以及视频P158==</p>
<p>代码</p>
<p>==获取锁和设置过期时间必须是原子操作，否则很可能会有并发问题==</p>
<p>==删除锁+判断锁也是要原子操作(使用lua脚本)==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据库查询并封装数据::分布式锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatalogJsonFromDbWithRedisLock() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、占分布式锁。去redis占坑      设置过期时间必须和加锁是同步的，保证原子性（避免死锁）</span></span><br><span class="line">    String uuid = UUID.randomUUID().toString();</span><br><span class="line">    Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(<span class="string">"lock"</span>, uuid,<span class="number">300</span>,TimeUnit.SECONDS);<span class="comment">// 相当于setnxex</span></span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        System.out.println(<span class="string">"获取分布式锁成功..."</span>);</span><br><span class="line">        Map&lt;String, List&lt;Catelog2Vo&gt;&gt; dataFromDb = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//加锁成功...执行业务</span></span><br><span class="line">            dataFromDb = getDataFromDb();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 使用Lua脚本</span></span><br><span class="line">            String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//删除锁</span></span><br><span class="line">            stringRedisTemplate.execute(<span class="keyword">new</span> DefaultRedisScript&lt;Long&gt;(script, Long.class), Arrays.asList(<span class="string">"lock"</span>), uuid);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先去redis查询下保证当前的锁是自己的</span></span><br><span class="line">        <span class="comment">//获取值对比，对比成功删除=原子性 lua脚本解锁</span></span><br><span class="line">        <span class="comment">// String lockValue = stringRedisTemplate.opsForValue().get("lock");</span></span><br><span class="line">        <span class="comment">// if (uuid.equals(lockValue)) &#123;</span></span><br><span class="line">        <span class="comment">//     //删除我自己的锁</span></span><br><span class="line">        <span class="comment">//     stringRedisTemplate.delete("lock");</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dataFromDb;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"获取分布式锁失败...等待重试..."</span>);</span><br><span class="line">        <span class="comment">//加锁失败...重试机制</span></span><br><span class="line">        <span class="comment">//休眠一百毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        <span class="keyword">return</span> getCatalogJsonFromDbWithRedisLock();     <span class="comment">//自旋的方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用Redisson实现分布式锁"><a href="#使用Redisson实现分布式锁" class="headerlink" title="使用Redisson实现分布式锁"></a>使用Redisson实现分布式锁</h4><blockquote>
<p>一个实现了分布式锁的框架，包括所有JUC锁的分布式版</p>
</blockquote>
<p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedissonConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有对Redisson的使用都是通过RedissonClient</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(destroyMethod=<span class="string">"shutdown"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redisson</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1、创建配置</span></span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">"redis://192.168.56.108:6379"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、根据Config创建出RedissonClient实例</span></span><br><span class="line">        <span class="comment">//Redis url should start with redis:// or rediss://</span></span><br><span class="line">        RedissonClient redissonClient = Redisson.create(config);</span><br><span class="line">        <span class="keyword">return</span> redissonClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="阻塞锁Rlock测试"><a href="#阻塞锁Rlock测试" class="headerlink" title="阻塞锁Rlock测试"></a>阻塞锁Rlock测试</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、获取一把锁，只要锁的名字一样，就是同一把锁</span></span><br><span class="line">    RLock myLock = redisson.getLock(<span class="string">"my-lock"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、加锁</span></span><br><span class="line">    myLock.lock();      <span class="comment">//阻塞式等待。默认加的锁都是30s</span></span><br><span class="line">    <span class="comment">//1）、锁的自动续期，如果业务超长，运行期间自动锁上新的30s。不用担心业务时间长，锁自动过期被删掉</span></span><br><span class="line">    <span class="comment">//2）、加锁的业务只要运行完成，就不会给当前锁续期，即使不手动解锁，锁默认会在30s内自动过期，不会产生死锁问题</span></span><br><span class="line">    <span class="comment">// myLock.lock(10,TimeUnit.SECONDS);   //10秒钟自动解锁,自动解锁时间一定要大于业务执行时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//问题：在锁时间到了以后，不会自动续期</span></span><br><span class="line">    <span class="comment">//1、如果我们传递了锁的超时时间，就发送给redis执行脚本，进行占锁，默认超时就是 我们制定的时间  myLock.lock(10,TimeUnit.SECONDS);   </span></span><br><span class="line">    <span class="comment">//2、如果我们未指定锁的超时时间，就使用 lockWatchdogTimeout = 30 * 1000 【看门狗默认时间】   myLock.lock(); </span></span><br><span class="line">    <span class="comment">//只要占锁成功，就会启动一个定时任务【重新给锁设置过期时间，新的过期时间就是看门狗的默认时间】,每隔10秒都会自动的再次续期，续成30秒</span></span><br><span class="line">    <span class="comment">// internalLockLeaseTime 【看门狗时间】 / 3， 10s</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最佳实践:省去了看门狗机制,手动指定大一点的超时时间</span></span><br><span class="line">    <span class="comment">// myLock.lock(30,TimeUnit.SECONDS); </span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"加锁成功，执行业务..."</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">20</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3、解锁  假设解锁代码没有运行，Redisson会不会出现死锁</span></span><br><span class="line">        System.out.println(<span class="string">"释放锁..."</span> + Thread.currentThread().getId());</span><br><span class="line">        myLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==重要==</p>
<p>redisson</p>
<p>1）、==锁的自动续期==，如果业务超长，运行期间自动锁上新的30s。不用担心业务时间长，锁自动过期被删掉<br>2）、加锁的业务只要运行完成，就不会给当前锁续期，即使不手动解锁，锁默认会在30s内自动过期，不会产生死锁问题</p>
<h5 id="读写锁RReadWriteLock测试"><a href="#读写锁RReadWriteLock测试" class="headerlink" title="读写锁RReadWriteLock测试"></a>读写锁RReadWriteLock测试</h5><blockquote>
<p>改数据加写锁，读数据加读锁(操作系统中读写者问题)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保证一定能读到最新数据，修改期间，写锁是一个排它锁（互斥锁、独享锁），读锁是一个共享锁</span></span><br><span class="line"><span class="comment">     * 写锁没释放读锁必须等待</span></span><br><span class="line"><span class="comment">     * 读 + 读 ：相当于无锁，并发读，只会在Redis中记录好，所有当前的读锁。他们都会同时加锁成功</span></span><br><span class="line"><span class="comment">     * 写 + 读 ：必须等待写锁释放</span></span><br><span class="line"><span class="comment">     * 写 + 写 ：阻塞方式</span></span><br><span class="line"><span class="comment">     * 读 + 写 ：有读锁。写也需要等待</span></span><br><span class="line"><span class="comment">     * 只要有读或者写的存都必须等待</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/write"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">writeValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">""</span>;</span><br><span class="line">    RReadWriteLock readWriteLock = redisson.getReadWriteLock(<span class="string">"rw-lock"</span>);</span><br><span class="line">    RLock rLock = readWriteLock.writeLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1、改数据加写锁，读数据加读锁</span></span><br><span class="line">        rLock.lock();</span><br><span class="line">        s = UUID.randomUUID().toString();</span><br><span class="line">        ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();</span><br><span class="line">        ops.set(<span class="string">"writeValue"</span>,s);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/read"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">""</span>;</span><br><span class="line">    RReadWriteLock readWriteLock = redisson.getReadWriteLock(<span class="string">"rw-lock"</span>);</span><br><span class="line">    <span class="comment">//加读锁</span></span><br><span class="line">    RLock rLock = readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        rLock.lock();</span><br><span class="line">        ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();</span><br><span class="line">        s = ops.get(<span class="string">"writeValue"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">10</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="信号量Semaphore测试"><a href="#信号量Semaphore测试" class="headerlink" title="信号量Semaphore测试"></a>信号量Semaphore测试</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 车库停车</span></span><br><span class="line"><span class="comment"> * 3车位</span></span><br><span class="line"><span class="comment"> * 信号量也可以做分布式限流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/park"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">park</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    RSemaphore park = redisson.getSemaphore(<span class="string">"park"</span>);</span><br><span class="line">    park.acquire();     <span class="comment">//获取一个信号、获取一个值,占一个车位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = park.tryAcquire();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;<span class="comment">// 成功获取到锁</span></span><br><span class="line">        <span class="comment">//执行业务</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ok=&gt;"</span> + flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/go"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RSemaphore park = redisson.getSemaphore(<span class="string">"park"</span>);</span><br><span class="line">    park.release();     <span class="comment">//释放一个车位</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="闭锁CountDownLatch测试"><a href="#闭锁CountDownLatch测试" class="headerlink" title="闭锁CountDownLatch测试"></a>闭锁CountDownLatch测试</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 放假、锁门</span></span><br><span class="line"><span class="comment"> * 1班没人了</span></span><br><span class="line"><span class="comment"> * 5个班，全部走完，我们才可以锁大门</span></span><br><span class="line"><span class="comment"> * 分布式闭锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/lockDoor"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">lockDoor</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    RCountDownLatch door = redisson.getCountDownLatch(<span class="string">"door"</span>);</span><br><span class="line">    door.trySetCount(<span class="number">5</span>);</span><br><span class="line">    door.await();       <span class="comment">//等待闭锁完成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"放假了..."</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/gogogo/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">gogogo</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">    RCountDownLatch door = redisson.getCountDownLatch(<span class="string">"door"</span>);</span><br><span class="line">    door.countDown();       <span class="comment">//计数-1</span></span><br><span class="line">    <span class="keyword">return</span> id + <span class="string">"班的人都走了..."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="缓存数据库一致性问题"><a href="#缓存数据库一致性问题" class="headerlink" title="缓存数据库一致性问题"></a>缓存数据库一致性问题</h4><h5 id="双写模式"><a href="#双写模式" class="headerlink" title="双写模式"></a>双写模式</h5><p><img alt="17" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230204202833.png"></p>
<h5 id="失效模式"><a href="#失效模式" class="headerlink" title="失效模式"></a>失效模式</h5><p><img alt="18" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230204203036.png"></p>
<h5 id="都会有脏数据问题-解决方案"><a href="#都会有脏数据问题-解决方案" class="headerlink" title="都会有脏数据问题(解决方案)"></a>都会有脏数据问题(解决方案)</h5><p>1、对于并发几率很小的数据(如个人维度的订单数据、用户数据等)，这种几乎不用考虑这个问题，很少会发生缓存不一致，可以给缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。</p>
<p>2、就算并发很高，如果业务上能容忍短时间的缓存数据不一致(如商品名称，商品分类菜单等)，缓存加上过期时间依然可以解决大部分业务对于缓存的要求。</p>
<p>3、如果不能容忍缓存数据不一致，可以通过加<strong>读写锁</strong>保证并发读写或写写的时候按顺序排好队，<strong>读读的时候相当于无锁</strong>。</p>
<p>4、也可以用阿里开源的canal通过监听数据库的binlog日志及时的去修改缓存，但是引入了新的中间件，增加了系统的复杂度。</p>
<p><img alt="19" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230204203615.png"></p>
<p><strong>总结：</strong></p>
<p>以上我们针对的都是<strong>读多写少</strong>的情况加入缓存提高性能，如果<strong>写多读多</strong>的情况又不能容忍缓存数据不一致，那就没必要加缓存了，可以直接操作数据库。放入缓存的数据应该是对实时性、一致性要求不是很高的数据。切记不要为了用缓存，同时又要保证绝对的一致性做大量的过度设计和控制，增加系统复杂性！</p>
<h3 id="SpringCache"><a href="#SpringCache" class="headerlink" title="SpringCache"></a>SpringCache</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>SpringCache是用来整合缓存的框架，==简化缓存判断操作==</p>
<p><img alt="20" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230204210113.png"></p>
<p>Cache 接口为缓存的组件规范定义，包含缓存的各种操作集合；Cache 接 口 下 Spring 提 供 了 各 种 xxxCache 的 实 现 ； 如 RedisCache ， EhCacheCache , </p>
<p>ConcurrentMapCache 等；</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置类上配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallProductApplication</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>yml中设置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    cache:</span></span><br><span class="line">      	<span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">      	<span class="comment"># 下面的配置可选</span></span><br><span class="line">      	<span class="attr">redis:</span></span><br><span class="line"><span class="attr">          time-to-live:</span> <span class="number">3600000</span></span><br><span class="line">          <span class="comment"># 如果指定了前缀就用我们指定的前缀，如果没有就默认使用缓存的名字(Value)作为前缀</span></span><br><span class="line"><span class="attr">          key-prefix:</span> <span class="string">CHCHE_</span></span><br><span class="line"><span class="attr">          use-key-prefix:</span> <span class="literal">true</span></span><br><span class="line">          <span class="comment"># 是否缓存空值,防止缓存穿透</span></span><br><span class="line"><span class="attr">          cache-null-values:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><p><img alt="21" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230204210737.png"></p>
<h5 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h5><p>细节</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.每一个需要缓存的数据我们都来指定要放到那个名字的缓存。【缓存的分区(按照业务类型分)】</span><br><span class="line">2.代表当前方法的结果需要缓存，如果缓存中有，方法都不用调用，如果缓存中没有，会调用方法。最后将方法的结果放入缓存</span><br><span class="line">3.默认行为</span><br><span class="line">     如果缓存中有，方法不再调用</span><br><span class="line">      key是默认生成的:     缓存的名字(即设置的value值)::SimpleKey::[](自动生成key值)</span><br><span class="line">      缓存的value值，默认使用jdk序列化机制，将序列化的数据存到redis中</span><br><span class="line">      默认时间是 -1：</span><br><span class="line"></span><br><span class="line">   自定义操作：key的生成</span><br><span class="line">      指定生成缓存的key：key属性指定，接收一个Spel</span><br><span class="line">      指定缓存的数据的存活时间:配置文档中修改存活时间</span><br><span class="line">      将数据保存为json格式 :</span><br><span class="line">          容器中没有RedisCacheConfiguration就用默认的配置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 4、Spring-Cache的不足之处：</span><br><span class="line">  1）、读模式</span><br><span class="line">      缓存穿透：查询一个null数据。解决方案：缓存空数据</span><br><span class="line">      缓存击穿：大量并发进来同时查询一个正好过期的数据。解决方案：加锁 ? 默认是无加锁的;使用sync = true来解决击穿问题</span><br><span class="line">      缓存雪崩：大量的key同时过期。解决：加随机时间。加上过期时间</span><br><span class="line">  2)、写模式：（缓存与数据库一致）</span><br><span class="line">      1）、读写加锁。</span><br><span class="line">      2）、引入Canal,感知到MySQL的更新去更新Redis</span><br><span class="line">      3）、读多写多，直接去数据库查询就行</span><br><span class="line"> </span><br><span class="line">  总结：</span><br><span class="line">      常规数据（读多写少，即时性，一致性要求不高的数据，完全可以使用Spring-Cache）：写模式(只要缓存的数据有过期时间就足够了)</span><br><span class="line">      特殊数据：特殊设计</span><br><span class="line"></span><br><span class="line">  原理：</span><br><span class="line">      CacheManager(RedisCacheManager)-&gt;Cache(RedisCache)-&gt;Cache负责缓存的读写</span><br></pre></td></tr></table></figure>
<p>实际使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(value = &#123;<span class="string">"category"</span>&#125;,key = <span class="string">"#root.method.name"</span>,sync = <span class="keyword">true</span>)</span><br><span class="line"><span class="comment">// 第一次执行下面方法，并把返回值放入缓存,第二次缓存中有值，就不用走下面方法</span></span><br><span class="line"><span class="comment">// redis中存的key就是上面value和key的结合,sync=true用于解决缓存击穿加锁</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;CategoryEntity&gt; <span class="title">getLevel1Categorys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"getLevel1Categorys........"</span>);</span><br><span class="line">    <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">    List&lt;CategoryEntity&gt; categoryEntities = <span class="keyword">this</span>.baseMapper.selectList(</span><br><span class="line">            <span class="keyword">new</span> QueryWrapper&lt;CategoryEntity&gt;().eq(<span class="string">"parent_cid"</span>, <span class="number">0</span>));</span><br><span class="line">    System.out.println(<span class="string">"消耗时间："</span>+ (System.currentTimeMillis() - l));</span><br><span class="line">    <span class="keyword">return</span> categoryEntities;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义数据(key和value)在redis中的保存形式(这边自定义为json)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties</span>(CacheProperties.class)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCacheConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCacheConfiguration <span class="title">redisCacheConfiguration</span><span class="params">(CacheProperties cacheProperties)</span> </span>&#123;</span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line">        config = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> StringRedisSerializer()))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer()));</span><br><span class="line">        CacheProperties.Redis redisProperties = cacheProperties.getRedis();</span><br><span class="line">        <span class="comment">//将配置文件中所有的配置都生效</span></span><br><span class="line">        <span class="keyword">if</span> (redisProperties.getTimeToLive() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            config = config.entryTtl(redisProperties.getTimeToLive());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (redisProperties.getKeyPrefix() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            config = config.prefixKeysWith(redisProperties.getKeyPrefix());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!redisProperties.isCacheNullValues()) &#123;</span><br><span class="line">            config = config.disableCachingNullValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!redisProperties.isUseKeyPrefix()) &#123;</span><br><span class="line">            config = config.disableKeyPrefix();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h5><p>缓存数据库一致性中的删除模式使用这个注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheEvict</span>(value = <span class="string">"category"</span>,allEntries = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>
<h5 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h5><p>适用于双写模式，更新缓存</p>
<h5 id="Caching"><a href="#Caching" class="headerlink" title="@Caching"></a>@Caching</h5><p>用于组合缓存注解，比如下面方法结束后，从redis中删除多个缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Caching</span>(evict = &#123;</span><br><span class="line">        <span class="meta">@CacheEvict</span>(value = <span class="string">"category"</span>,key = <span class="string">"'getLevel1Categorys'"</span>),</span><br><span class="line">        <span class="meta">@CacheEvict</span>(value = <span class="string">"category"</span>,key = <span class="string">"'getCatalogJson'"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>删除指定某个分区也能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheEvict</span>(value = <span class="string">"category"</span>,allEntries = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>
<h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><h5 id="读模式"><a href="#读模式" class="headerlink" title="读模式"></a>读模式</h5><p>缓存穿透：解决-缓存空数据(cache-null-values=true)</p>
<p>缓存击穿：解决-加锁(只准有一个线程进入mysql)？@Cacheable(sync=true)</p>
<p>缓存雪崩：解决-随机过期时间</p>
<h5 id="写模式-缓存数据库不一致"><a href="#写模式-缓存数据库不一致" class="headerlink" title="写模式(缓存数据库不一致)"></a>写模式(缓存数据库不一致)</h5><p>读写加锁(读写锁)</p>
<p>引入canal，感知mysql的Binlog更新去更新数据库</p>
<p>读多写多，直接去查数据库</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="==异步=="></a>==异步==</h3><p>3种方式创建线程</p>
<p>Thread,Runnable,Callable</p>
<p>此外还有线程池，使用线程池可以降低资源消耗，有效管理线程。</p>
<h4 id="CompletableFuture异步编排"><a href="#CompletableFuture异步编排" class="headerlink" title="CompletableFuture异步编排"></a>CompletableFuture异步编排</h4><blockquote>
<p>详细见文档</p>
</blockquote>
<p>不同的异步任务可能存在关联 ，就需要用到异步编排，类似前端的promise</p>
<blockquote>
<p><strong>方法不以</strong> <strong>Async</strong> <strong>结尾，意味着</strong> <strong>Action</strong> <strong>使用相同的线程执行，而</strong> <strong>Async</strong> <strong>可能会使用其他线程</strong></p>
<p><strong>执行（如果是使用相同的线程池，也可能会被同一个线程选中执行）</strong></p>
</blockquote>
<h5 id="初步使用-1"><a href="#初步使用-1" class="headerlink" title="初步使用"></a>初步使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">    <span class="number">20</span>,</span><br><span class="line">    <span class="number">100</span>,</span><br><span class="line">    <span class="number">10L</span>,</span><br><span class="line">    TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="number">10000</span>),</span><br><span class="line">    Executors.defaultThreadFactory(),</span><br><span class="line">    <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 没返回值</span></span><br><span class="line">CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"运行结果："</span> + i);</span><br><span class="line">&#125;,executor);</span><br><span class="line"><span class="comment">// 有返回值</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"运行结果："</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor);</span><br><span class="line"></span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure>
<h5 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h5><blockquote>
<p>whenComplete:方法执行完，不管成没成功都会调用</p>
<p>exceptionally:发生异常调用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"运行结果："</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor).whenComplete((res,exception)-&gt;&#123;<span class="comment">// 不管完没完成都会调用,相当于finally</span></span><br><span class="line">    <span class="comment">// 不能处理返回结果</span></span><br><span class="line">    System.out.println(<span class="string">"异步任务成功完成了...结果是："</span> + res + <span class="string">"异常是："</span> + exception);</span><br><span class="line">&#125;).exceptionally((throwable -&gt; &#123;<span class="comment">// 异常调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<h5 id="handle"><a href="#handle" class="headerlink" title="handle()"></a>handle()</h5><blockquote>
<p>用于方法执行成功后处理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"运行结果："</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor).handle((result,thr) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (thr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"异步任务成功完成了...结果是："</span> + result + <span class="string">"异常是："</span> + thr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h5><blockquote>
<p>业务场景：A执行完再执行B</p>
<p>thenApply 方法：当一个线程依赖另一个线程时，获取上一个任务返回的结果，并返回当前任务的返回值。(能接受上一步结果，有返回值)</p>
<p>thenAccept 方法：消费处理结果。接收任务的处理结果，并消费处理，无返回结果。(能接受上一步结果，但是无返回值)</p>
<p>thenRun 方法：只要上面的任务执行完成，就开始执行 thenRun，只是处理完任务后，执行thenRun 的后续操作（不能获取上一步的执行结果）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"运行结果："</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor).thenAccept((res)-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="number">11</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//                .thenApplyAsync(res -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("任务2启动了..." + res);</span></span><br><span class="line"><span class="comment">//            return "Hello" + res;</span></span><br><span class="line"><span class="comment">//        &#125;, executor);</span></span><br></pre></td></tr></table></figure>
<h5 id="两个任务都要完成"><a href="#两个任务都要完成" class="headerlink" title="两个任务都要完成"></a>两个任务都要完成</h5><blockquote>
<p>两个任务都完成，再执行后面的</p>
<p>thenCombine：组合两个 future，获取两个 future 的返回结果，并返回当前任务的返回值</p>
<p>thenAcceptBoth：组合两个 future，获取两个 future 任务的返回结果，然后处理任务，没有返回值。</p>
<p>runAfterBoth：组合两个 future，不需要获取 future 的结果，只需两个 future 处理完任务后，处理该任务。</p>
<p><strong>方法不以</strong> <strong>Async</strong> <strong>结尾，意味着</strong> <strong>Action</strong> <strong>使用相同的线程执行，而</strong> <strong>Async</strong> <strong>可能会使用其他线程</strong></p>
<p><strong>执行（如果是使用相同的线程池，也可能会被同一个线程选中执行）</strong></p>
<p>使用方法同上面的回调方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"运行结果："</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"当前线程2："</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"运行结果2："</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor);</span><br><span class="line">future1.runAfterBothAsync(future2,()-&gt;&#123;<span class="comment">// 这个任务是两个任务都执行完再执行的任务</span></span><br><span class="line">    System.out.println(<span class="string">"任务三"</span>);</span><br><span class="line">&#125;,executor);</span><br><span class="line">future1.thenAcceptBothAsync(future2,(res1,res2)-&gt;&#123;<span class="comment">// 这个任务是两个任务都执行完再执行的任务</span></span><br><span class="line">    System.out.println(res1+<span class="string">"："</span>+res2);</span><br><span class="line">&#125;,executor);</span><br></pre></td></tr></table></figure>
<h5 id="两个任务只要一个完成"><a href="#两个任务只要一个完成" class="headerlink" title="两个任务只要一个完成"></a>两个任务只要一个完成</h5><blockquote>
<p>applyToEither：两个任务有一个执行完成，获取它的返回值，处理任务并有新的返回值。</p>
<p>acceptEither：两个任务有一个执行完成，获取它的返回值，处理任务，没有新的返回值。</p>
<p>runAfterEither：两个任务有一个执行完成，不需要获取 future 的结果，处理任务，也没有返回值。</p>
<p><strong>方法不以</strong> <strong>Async</strong> <strong>结尾，意味着</strong> <strong>Action</strong> <strong>使用相同的线程执行，而</strong> <strong>Async</strong> <strong>可能会使用其他线程</strong></p>
<p><strong>执行（如果是使用相同的线程池，也可能会被同一个线程选中执行）</strong></p>
</blockquote>
<h5 id="多任务组合"><a href="#多任务组合" class="headerlink" title="多任务组合"></a>多任务组合</h5><blockquote>
<p>allOf：等待所有任务完成</p>
<p>anyOf：只要有一个任务完成</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"运行结果："</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"当前线程2："</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"运行结果2："</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; future3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"当前线程3："</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"运行结果3："</span> + i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor);</span><br><span class="line">CompletableFuture&lt;Void&gt; allOf = CompletableFuture.allOf(future1, future2, future3);</span><br><span class="line">allOf.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">//CompletableFuture&lt;Object&gt; anyOf = CompletableFuture.anyOf(future1, future2, future3);</span></span><br><span class="line"><span class="comment">//System.out.println("end"+anyOf.get());</span></span><br></pre></td></tr></table></figure>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>代码在product服务的SkuInfoServiceImpl类中</p>
<h3 id="认证服务"><a href="#认证服务" class="headerlink" title="认证服务"></a>认证服务</h3><h4 id="简单登录逻辑"><a href="#简单登录逻辑" class="headerlink" title="简单登录逻辑"></a>简单登录逻辑</h4><h5 id="验证码-令牌机制"><a href="#验证码-令牌机制" class="headerlink" title="验证码(令牌机制)"></a>验证码(令牌机制)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/sms/sendCode"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">sendCode</span><span class="params">(@RequestParam(<span class="string">"phone"</span>)</span> String phone) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、接口防刷</span></span><br><span class="line">    String redisCode = stringRedisTemplate.opsForValue().get(AuthServerConstant.SMS_CODE_CACHE_PREFIX + phone);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(redisCode)) &#123;</span><br><span class="line">        <span class="comment">//活动存入redis的时间，用当前时间减去存入redis的时间，判断用户手机号是否在60s内发送验证码</span></span><br><span class="line">        <span class="keyword">long</span> currentTime = Long.parseLong(redisCode.split(<span class="string">"_"</span>)[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() - currentTime &lt; <span class="number">60000</span>) &#123;</span><br><span class="line">            <span class="comment">//60s内不能再发</span></span><br><span class="line">            <span class="keyword">return</span> R.error(BizCodeEnum.SMS_CODE_EXCEPTION.getCode(),BizCodeEnum.SMS_CODE_EXCEPTION.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、验证码的再次效验 redis.存key-phone,value-code</span></span><br><span class="line">    <span class="keyword">int</span> code = (<span class="keyword">int</span>) ((Math.random() * <span class="number">9</span> + <span class="number">1</span>) * <span class="number">100000</span>);</span><br><span class="line">    String codeNum = String.valueOf(code);</span><br><span class="line">    String redisStorage = codeNum + <span class="string">"_"</span> + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存入redis，防止同一个手机号在60秒内再次发送验证码</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(AuthServerConstant.SMS_CODE_CACHE_PREFIX+phone,</span><br><span class="line">                                          redisStorage,<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这边是测试所以就不真正发了</span></span><br><span class="line">    <span class="comment">// 调用第三方接口发送</span></span><br><span class="line">    <span class="comment">//        thirdPartFeignService.sendCode(phone, codeNum);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span> 重定向携带数据：利用session原理，将数据放在session中。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span> 只要跳转到下一个页面取出这个数据以后，session里面的数据就会删掉</span></span><br><span class="line"><span class="comment">     * TODO：分布下session问题</span></span><br><span class="line"><span class="comment">     * RedirectAttributes：重定向也可以保留数据，不会丢失</span></span><br><span class="line"><span class="comment">     * 用户注册</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@PostMapping</span>(value = <span class="string">"/register"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">(@Valid UserRegisterVo vos, BindingResult result,</span></span></span><br><span class="line"><span class="function"><span class="params">                       RedirectAttributes attributes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果有错误回到注册页面</span></span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">        Map&lt;String, String&gt; errors = result.getFieldErrors().stream().collect(Collectors.toMap(FieldError::getField, FieldError::getDefaultMessage));</span><br><span class="line">        attributes.addFlashAttribute(<span class="string">"errors"</span>,errors);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//效验出错回到注册页面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:http://auth.gulimall.com/reg.html"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、效验验证码</span></span><br><span class="line">    String code = vos.getCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取存入Redis里的验证码</span></span><br><span class="line">    String redisCode = stringRedisTemplate.opsForValue().get(AuthServerConstant.SMS_CODE_CACHE_PREFIX + vos.getPhone());</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(redisCode)) &#123;</span><br><span class="line">        <span class="comment">//截取字符串</span></span><br><span class="line">        <span class="keyword">if</span> (code.equals(redisCode.split(<span class="string">"_"</span>)[<span class="number">0</span>])) &#123;<span class="comment">// 传入的验证码正确</span></span><br><span class="line">            <span class="comment">//删除验证码;令牌机制</span></span><br><span class="line">            stringRedisTemplate.delete(AuthServerConstant.SMS_CODE_CACHE_PREFIX+vos.getPhone());</span><br><span class="line">            <span class="comment">//验证码通过，真正注册，调用远程服务进行注册</span></span><br><span class="line">            R register = memberFeignService.register(vos);</span><br><span class="line">            <span class="keyword">if</span> (register.getCode() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"redirect:http://auth.gulimall.com/login.html"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//失败</span></span><br><span class="line">                Map&lt;String, String&gt; errors = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                errors.put(<span class="string">"msg"</span>, register.getData(<span class="string">"msg"</span>,<span class="keyword">new</span> TypeReference&lt;String&gt;()&#123;&#125;));</span><br><span class="line">                attributes.addFlashAttribute(<span class="string">"errors"</span>,errors);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"redirect:http://auth.gulimall.com/reg.html"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//效验出错回到注册页面</span></span><br><span class="line">            Map&lt;String, String&gt; errors = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            errors.put(<span class="string">"code"</span>,<span class="string">"验证码错误"</span>);</span><br><span class="line">            attributes.addFlashAttribute(<span class="string">"errors"</span>,errors);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"redirect:http://auth.gulimall.com/reg.html"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//效验出错回到注册页面</span></span><br><span class="line">        Map&lt;String, String&gt; errors = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        errors.put(<span class="string">"code"</span>,<span class="string">"验证码错误"</span>);</span><br><span class="line">        attributes.addFlashAttribute(<span class="string">"errors"</span>,errors);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:http://auth.gulimall.com/reg.html"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="社交登录"><a href="#社交登录" class="headerlink" title="社交登录"></a>社交登录</h4><blockquote>
<p>使用第三方账号登录</p>
<p>通过访问令牌，只能访问获得公共的信息</p>
</blockquote>
<p>使用OAuth2.0原理图</p>
<p><img alt="22" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230207210459.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.用户点击社交登录</span></span><br><span class="line"><span class="comment">// 2.跳转到微博授权页面</span></span><br><span class="line"><span class="comment">// 3.微博返回授权页面(code在这边返回)</span></span><br><span class="line"><span class="comment">// 4.用户输入账号密码授权</span></span><br><span class="line"><span class="comment">// 5.跳转到微博进行登录</span></span><br><span class="line"><span class="comment">// 6.微博远程登录成功,返回会获得code,然后用code可以换取token(这里对应图中的第四步)</span></span><br><span class="line"><span class="comment">// 7.本地服务登录：查看是否是第一次登录(是否有账号),若没账号,还要走注册流程(在memberFeignService.oauthLogin(socialUser)中)</span></span><br><span class="line"><span class="comment">// 8.返回登录成功页面(到首页去？)</span></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/oauth2.0/weibo/success"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">weibo</span><span class="params">(@RequestParam(<span class="string">"code"</span>)</span> String code, HttpSession session) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"client_id"</span>,<span class="string">"2077705774"</span>);</span><br><span class="line">    map.put(<span class="string">"client_secret"</span>,<span class="string">"40af02bd1c7e435ba6a6e9cd3bf799fd"</span>);</span><br><span class="line">    map.put(<span class="string">"grant_type"</span>,<span class="string">"authorization_code"</span>);</span><br><span class="line">    map.put(<span class="string">"redirect_uri"</span>,<span class="string">"http://auth.gulimall.com/oauth2.0/weibo/success"</span>);</span><br><span class="line">    map.put(<span class="string">"code"</span>,code);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、根据用户授权返回的code换取access_token</span></span><br><span class="line">    HttpResponse response = HttpUtils.doPost(<span class="string">"https://api.weibo.com"</span>, <span class="string">"/oauth2/access_token"</span>, <span class="string">"post"</span>, <span class="keyword">new</span> HashMap&lt;&gt;(), map, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、处理</span></span><br><span class="line">    <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">//获取到了access_token,转为通用社交登录对象</span></span><br><span class="line">        String json = EntityUtils.toString(response.getEntity());</span><br><span class="line">        <span class="comment">//String json = JSON.toJSONString(response.getEntity());</span></span><br><span class="line">        SocialUser socialUser = JSON.parseObject(json, SocialUser.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//知道了哪个社交用户</span></span><br><span class="line">        <span class="comment">//1）、当前用户如果是第一次进网站，自动注册进来（为当前社交用户生成一个会员信息，以后这个社交账号就对应指定的会员）</span></span><br><span class="line">        <span class="comment">//登录或者注册这个社交用户</span></span><br><span class="line">        System.out.println(socialUser.getAccess_token());</span><br><span class="line">        <span class="comment">//调用远程服务</span></span><br><span class="line">        R oauthLogin = memberFeignService.oauthLogin(socialUser);</span><br><span class="line">        <span class="keyword">if</span> (oauthLogin.getCode() == <span class="number">0</span>) &#123;</span><br><span class="line">            MemberResponseVo data = oauthLogin.getData(<span class="string">"data"</span>, <span class="keyword">new</span> TypeReference&lt;MemberResponseVo&gt;() &#123;&#125;);</span><br><span class="line">            log.info(<span class="string">"登录成功：用户信息：&#123;&#125;"</span>,data.toString());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1、第一次使用session，命令浏览器保存卡号，JSESSIONID这个cookie</span></span><br><span class="line">            <span class="comment">//以后浏览器访问哪个网站就会带上这个网站的cookie</span></span><br><span class="line">            <span class="comment">//TODO 1、默认发的令牌。当前域（解决子域session共享问题）</span></span><br><span class="line">            <span class="comment">//TODO 2、使用JSON的序列化方式来序列化对象到Redis中</span></span><br><span class="line">            session.setAttribute(LOGIN_USER,data);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//2、登录成功跳回首页</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"redirect:http://gulimall.com"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"redirect:http://auth.gulimall.com/login.html"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:http://auth.gulimall.com/login.html"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分布式Session"><a href="#分布式Session" class="headerlink" title="==分布式Session=="></a>==分布式Session==</h4><p><img alt="23" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230207223539.png"></p>
<p>==问题：session只能用于一台机器，对于不同机器，不同服务，不同域名都不能共享==</p>
<h5 id="方案1-session复制"><a href="#方案1-session复制" class="headerlink" title="方案1-session复制"></a>方案1-session复制</h5><p>小型系统可以考虑，大型系统同步代价太高</p>
<p><img alt="24" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208140252.png"></p>
<h5 id="方案2-客户端存储"><a href="#方案2-客户端存储" class="headerlink" title="方案2-客户端存储"></a>方案2-客户端存储</h5><p>不安全，不推荐</p>
<p><img alt="25" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208140505.png"></p>
<h5 id="方案3-使用hash一致性"><a href="#方案3-使用hash一致性" class="headerlink" title="方案3-使用hash一致性"></a>方案3-使用hash一致性</h5><p>问题不是很大，该方案也常用</p>
<p><img alt="26" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208140648.png"></p>
<h5 id="方案4-统一存储"><a href="#方案4-统一存储" class="headerlink" title="方案4-统一存储"></a>方案4-统一存储</h5><p><img alt="27" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208140845.png"></p>
<h5 id="使用SpringSession的最终方案"><a href="#使用SpringSession的最终方案" class="headerlink" title="==使用SpringSession的最终方案=="></a>==使用SpringSession的最终方案==</h5><h6 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h6><p><img alt="28" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208141949.png"></p>
<p>每次将session存入redis，取得时候不要取出(auth.gulimall.com)这样的域名，而是取出(.gulimall.com)这样的域名，这样所有其他子域名下的服务拿到session也能认证成功。</p>
<h6 id="导入依赖-1"><a href="#导入依赖-1" class="headerlink" title="导入依赖"></a>导入依赖</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 整合springsession --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h6><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    session:</span></span><br><span class="line"><span class="attr">        store-type:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure>
<h6 id="配置类的注解"><a href="#配置类的注解" class="headerlink" title="配置类的注解"></a>配置类的注解</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableRedisHttpSession     //整合Redis作为session存储</span><br><span class="line">public class GulimallAuthServerApplication &#123;&#125;</span><br></pre></td></tr></table></figure>
<h6 id="存入redis"><a href="#存入redis" class="headerlink" title="==存入redis=="></a>==存入redis==</h6><p>==注意别忘了pojo要想存入redis，必须实现序列化接口(因为对象在内存中，要想存到远程的redis中，就必须转化为二进制流通过网络传输到redis服务器)或使用json序列化传输==</p>
<p>使用序列化接口方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MemberResponseVo data = oauthLogin.getData(<span class="string">"data"</span>, <span class="keyword">new</span> TypeReference&lt;MemberResponseVo&gt;() &#123;&#125;);</span><br><span class="line">log.info(<span class="string">"登录成功：用户信息：&#123;&#125;"</span>,data.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、第一次使用session，命令浏览器保存卡号，JSESSIONID这个cookie</span></span><br><span class="line"><span class="comment">//以后浏览器访问哪个网站就会带上这个网站的cookie</span></span><br><span class="line"><span class="comment">//TODO 1、默认发的令牌。当前域（解决子域session共享问题）</span></span><br><span class="line"><span class="comment">//TODO 2、使用JSON的序列化方式来序列化对象到Redis中</span></span><br><span class="line">session.setAttribute(LOGIN_USER,data);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberResponseVo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>使用json序列化：</p>
<p>需要配置序列化器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallSessionConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现子域session共享的问题</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CookieSerializer <span class="title">cookieSerializer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DefaultCookieSerializer cookieSerializer = <span class="keyword">new</span> DefaultCookieSerializer();</span><br><span class="line">        <span class="comment">//放大作用域</span></span><br><span class="line">        cookieSerializer.setDomainName(<span class="string">"gulimall.com"</span>);</span><br><span class="line">        cookieSerializer.setCookieName(<span class="string">"GULISESSION"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cookieSerializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// json-&gt;redis的序列化器,这样就不需要每个类都要继承序列化接口类了</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisSerializer&lt;Object&gt; <span class="title">springSessionDefaultRedisSerializer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericJackson2JsonRedisSerializer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="实现子域session共享的问题"><a href="#实现子域session共享的问题" class="headerlink" title="==实现子域session共享的问题=="></a>==实现子域session共享的问题==</h6><p>配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallSessionConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现子域session共享的问题</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CookieSerializer <span class="title">cookieSerializer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DefaultCookieSerializer cookieSerializer = <span class="keyword">new</span> DefaultCookieSerializer();</span><br><span class="line">        <span class="comment">//放大作用域</span></span><br><span class="line">        cookieSerializer.setDomainName(<span class="string">"gulimall.com"</span>);</span><br><span class="line">        cookieSerializer.setCookieName(<span class="string">"GULISESSION"</span>);<span class="comment">// 名字应该无所谓</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cookieSerializer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="SpringSession核心原理"><a href="#SpringSession核心原理" class="headerlink" title="==SpringSession核心原理=="></a>==SpringSession核心原理==</h6><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.@EnableRedisHttpSession导入RedisHttpSessionConfiguration配置</span></span><br><span class="line"><span class="code">      1、给容器中添加了一个组件</span></span><br><span class="line"><span class="code">          SessionRepository-》RedisOperationsSessionRepository：Redis操作session，session的增删改查封装类</span></span><br><span class="line"><span class="code">      2.SessionRepositoryFilter-&gt;Filter:每个请求过来都必须经过filter</span></span><br><span class="line"><span class="code">          2.1创建的时候，就自动从容器中获取到了SessionRepository</span></span><br><span class="line"><span class="code">          2.2原生的request和response对象在里面经过包装变成SessionRepositoryRequestWrapper和SessionRepositoryResponseWrapper(装饰者模式)</span></span><br><span class="line"><span class="code">          2.3我们获取session,通常使用request.getSession(),这里就实际上调用了SessionRepositoryRequestWrapper.getSession()方法</span></span><br></pre></td></tr></table></figure>
<p><img alt="29" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208150723.png"></p>
<h4 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h4><blockquote>
<p>SSO(Single Sign On) 一处登陆、处处可用</p>
<p>适用于多系统(不同的父域名)</p>
</blockquote>
<h3 id="购物车功能"><a href="#购物车功能" class="headerlink" title="购物车功能"></a>购物车功能</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>电商购物车<br>    存储<br>        1）以用户id为key<br>        2）商品id为field<br>        3）商品数量为value<br>    操作<br>        添加商品：hset cart:1001 10088 1<br>        增加数量：hincrby cart:1001 10088 1<br>        商品总数：hlen cart:1001<br>        删除商品：hdel cart:1001 10088<br>        获取购物车所有商品：hgetall cart:1001</p>
<p><img alt="3" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208174708.png"></p>
<h4 id="业务需求"><a href="#业务需求" class="headerlink" title="==业务需求=="></a>==业务需求==</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">去购物车页面的请求</span><br><span class="line">浏览器有一个cookie:user-key 标识用户的身份，一个月过期</span><br><span class="line">如果第一次使用jd的购物车功能，都会给一个临时的用户身份:</span><br><span class="line">浏览器以后保存，每次访问都会带上这个cookie；</span><br><span class="line"></span><br><span class="line">登录：session有</span><br><span class="line">没登录：按照cookie里面带来user-key来做</span><br><span class="line">第一次，如果没有临时用户，自动创建一个临时用户</span><br></pre></td></tr></table></figure>
<p>==使用HandlerInterceptor+ThreadLocal实现拦截添加临时用户的功能==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;UserInfoTo&gt; toThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 目标方法执行之前</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        UserInfoTo userInfoTo = <span class="keyword">new</span> UserInfoTo();</span><br><span class="line"></span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        <span class="comment">//获得当前登录用户的信息</span></span><br><span class="line">        MemberResponseVo memberResponseVo = (MemberResponseVo) session.getAttribute(LOGIN_USER);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (memberResponseVo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//用户登录了</span></span><br><span class="line">            userInfoTo.setUserId(memberResponseVo.getId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="keyword">null</span> &amp;&amp; cookies.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                <span class="comment">//user-key</span></span><br><span class="line">                String name = cookie.getName();</span><br><span class="line">                <span class="keyword">if</span> (name.equals(TEMP_USER_COOKIE_NAME)) &#123;</span><br><span class="line">                    userInfoTo.setUserKey(cookie.getValue());</span><br><span class="line">                    <span class="comment">//标记为已是临时用户</span></span><br><span class="line">                    userInfoTo.setTempUser(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有临时用户一定分配一个临时用户</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(userInfoTo.getUserKey())) &#123;</span><br><span class="line">            String uuid = UUID.randomUUID().toString();</span><br><span class="line">            userInfoTo.setUserKey(uuid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//目标方法执行之前</span></span><br><span class="line">        toThreadLocal.set(userInfoTo);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务执行之后，分配临时用户来浏览器保存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelAndView</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前用户的值</span></span><br><span class="line">        UserInfoTo userInfoTo = toThreadLocal.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有临时用户一定保存一个临时用户</span></span><br><span class="line">        <span class="keyword">if</span> (!userInfoTo.getTempUser()) &#123;</span><br><span class="line">            <span class="comment">//创建一个cookie</span></span><br><span class="line">            Cookie cookie = <span class="keyword">new</span> Cookie(TEMP_USER_COOKIE_NAME, userInfoTo.getUserKey());</span><br><span class="line">            <span class="comment">//扩大作用域</span></span><br><span class="line">            cookie.setDomain(<span class="string">"gulimall.com"</span>);</span><br><span class="line">            <span class="comment">//设置过期时间</span></span><br><span class="line">            cookie.setMaxAge(TEMP_USER_COOKIE_TIMEOUT);</span><br><span class="line">            response.addCookie(cookie);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="购物车redis代码"><a href="#购物车redis代码" class="headerlink" title="购物车redis代码"></a>购物车redis代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//绑定指定的key操作Redis</span></span><br><span class="line">BoundHashOperations&lt;String, Object, Object&gt; operations = stringRedisTemplate.boundHashOps(cartKey);</span><br><span class="line">operations.get(skuId.toString());</span><br><span class="line">operations.put(skuId.toString(), cartItemJson);</span><br><span class="line">operations.delete(skuId.toString());</span><br></pre></td></tr></table></figure>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><blockquote>
<p>docker pull rabbitmq:managment</p>
<p>启动</p>
<p>docker run -d —name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management</p>
<p>tip:没有的话，docker run 会先安装在启动</p>
<p>解释</p>
<blockquote>
<p>4369, 25672 (Erlang发现&amp;集群端口)</p>
<p>5672, 5671 (AMQP端口)</p>
<p>15672 (web管理后台端口)</p>
<p>61613, 61614 (STOMP协议端口)</p>
<p>1883, 8883 (MQTT协议端口)</p>
<p><a href="https://www.rabbitmq.com/networking.html" target="_blank" rel="noopener">https://www.rabbitmq.com/networking.html</a></p>
</blockquote>
<p>默认账号  guest/guest</p>
</blockquote>
<h4 id="MQ优势"><a href="#MQ优势" class="headerlink" title="MQ优势"></a>MQ优势</h4><p>​    应用解耦</p>
<blockquote>
<p>如若订单系统调用库存系统的接口改了，那么订单系统也要跟着改，不方便维护</p>
</blockquote>
<p><img alt="1" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208203444.png"></p>
<p>​    异步提速</p>
<p><img alt="2" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208203447.png"></p>
<p>​    削峰填谷</p>
<p><img alt="3" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208203450.png"></p>
<h4 id="消息队列两大规范"><a href="#消息队列两大规范" class="headerlink" title="消息队列两大规范"></a>消息队列两大规范</h4><p>JMS，ActiveMQ实现</p>
<p>AMQP，RabbitMQ实现</p>
<p><img alt="30" data-src="E:\desktop\自学\MyNote\项目\谷粒商城\images\30.png"></p>
<h4 id="基本组件图-概念图"><a href="#基本组件图-概念图" class="headerlink" title="基本组件图(概念图)"></a>基本组件图(概念图)</h4><blockquote>
<p>这是比较整体的图，具体的来说有好几种模式(工作模式，路由模式(Direct：定向)，发布/订阅模式(Fanout：广播)，Topics主题模式(Topic：通配符))</p>
</blockquote>
<p><img alt="img" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230208210335.png"></p>
<p>其中MQ就充当了Broker消息代理的角色</p>
<p>route-key路由键结合交换机的类型(direct,fanout,topic)决定消息发给哪些队列，==注意和队列名称和交换机名称没有关系==</p>
<p>VHost</p>
<blockquote>
<p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</p>
<p>比如java和PHP可以隔离出两个VHost，一个崩溃了不会影响另一个；或者生产和测试可以隔离出两个VHost </p>
</blockquote>
<h4 id="SpringBoot整合-2"><a href="#SpringBoot整合-2" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h4><h5 id="导入依赖-2"><a href="#导入依赖-2" class="headerlink" title="导入依赖"></a>导入依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="AmqpAdmin用于增删改查队列、交换机及其绑定关系等"><a href="#AmqpAdmin用于增删改查队列、交换机及其绑定关系等" class="headerlink" title="AmqpAdmin用于增删改查队列、交换机及其绑定关系等"></a>AmqpAdmin用于增删改查队列、交换机及其绑定关系等</h5><blockquote>
<p>结合web图形界面更直观</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DirectExchange(String name, boolean durable, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">    <span class="comment">// 名称,持久化,是否自动删除,额外参数</span></span><br><span class="line">    admin.declareExchange(<span class="keyword">new</span> DirectExchange(<span class="string">"hello-java-exchange"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>));</span><br><span class="line">    log.info(<span class="string">"Exchange:&#123;&#125;创建成功"</span>,<span class="string">"hello-java-exchange"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Queue(String name, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">    <span class="comment">// 名称,是否持久化,是否排他(只能被一个人连接),是否自动删除,额外参数</span></span><br><span class="line">    admin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">"hello-java-queue"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>));</span><br><span class="line">    log.info(<span class="string">"Queue:&#123;&#125;创建成功"</span>,<span class="string">"hello-java-queue"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Binding(String destination, Binding.DestinationType destinationType, String exchange, String routingKey,</span></span><br><span class="line"><span class="comment">//                Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">    <span class="comment">// 目的地，目的地类型(交换机或队列)，交换机，路由键</span></span><br><span class="line">    admin.declareBinding(<span class="keyword">new</span> Binding(<span class="string">"hello-java-queue"</span>,Binding.DestinationType.QUEUE,</span><br><span class="line">            <span class="string">"hello-java-exchange"</span>,</span><br><span class="line">            <span class="string">"hello.java"</span>,<span class="keyword">null</span>));</span><br><span class="line">    log.info(<span class="string">"Binding:&#123;&#125;创建成功"</span>,<span class="string">"hello-java-binding"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RabbitTemplate用于发送消息"><a href="#RabbitTemplate用于发送消息" class="headerlink" title="RabbitTemplate用于发送消息"></a>RabbitTemplate用于发送消息</h5><p>如果要发送对象，就必须实现序列化接口</p>
<p>或者转为json发送(需要往容器中注入rabbitmq的json转换器 Jackson2JsonMessageConverter)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    OrderReturnReasonEntity reasonEntity = <span class="keyword">new</span> OrderReturnReasonEntity();</span><br><span class="line">    reasonEntity.setId(<span class="number">1L</span>);</span><br><span class="line">    reasonEntity.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">    reasonEntity.setName(<span class="string">"reason"</span>);</span><br><span class="line">    reasonEntity.setStatus(<span class="number">1</span>);</span><br><span class="line">    reasonEntity.setSort(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 如果要发送对象，就必须实现序列化接口或者转为json发送</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"hello-java-exchange"</span>,<span class="string">"hello.java"</span>,reasonEntity);</span><br><span class="line">    log.info(<span class="string">"消息:&#123;&#125;发送完成"</span>,<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RabbitListner用于监听信息"><a href="#RabbitListner用于监听信息" class="headerlink" title="@RabbitListner用于监听信息"></a>@RabbitListner用于监听信息</h5><blockquote>
<p>例如接收如上RabbitTemplate发送的信息</p>
<p>@RabbitHandler也常用，不过只能用于方法；@RabbitListner可以用于方法和类。但是@RabbitHandler标注能够方便标注重载方法(区分不同的消息)，@RabbitListner此时就用来标注到类上，表示接收哪个队列的消息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"orderItemService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderItemServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">OrderItemDao</span>, <span class="title">OrderItemEntity</span>&gt; <span class="keyword">implements</span> <span class="title">OrderItemService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = &#123;<span class="string">"hello-java-queue"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revieveMessage</span><span class="params">(Message message,</span></span></span><br><span class="line"><span class="function"><span class="params">                               OrderReturnReasonEntity content,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//拿到主体内容</span></span><br><span class="line">        <span class="keyword">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="comment">//拿到的消息头属性信息</span></span><br><span class="line">        MessageProperties messageProperties = message.getMessageProperties();</span><br><span class="line">        System.out.println(<span class="string">"接受到的消息...内容"</span> + message + <span class="string">"===内容："</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消息确认机制"><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h4><blockquote>
<p>==保证消息不丢失，可靠抵达，虽然可以使用事务消息，但是性能下降250倍，为此引入确认机制==</p>
</blockquote>
<p>==分别从服务端和消费端实现确认机制==</p>
<p><img alt="32" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230210170128.png"></p>
<h5 id="ConfirmCallback"><a href="#ConfirmCallback" class="headerlink" title="ConfirmCallback"></a>ConfirmCallback</h5><p>只要消息抵达Broker就ack=true</p>
<p><img alt="33" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230210170520.png"></p>
<h5 id="ReturnCallback"><a href="#ReturnCallback" class="headerlink" title="ReturnCallback"></a>ReturnCallback</h5><p>==只要消息没有投递给指定的队列，就触发这个失败回调==</p>
<p><img alt="34" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230210170517.png"></p>
<h5 id="Ack消息确认机制"><a href="#Ack消息确认机制" class="headerlink" title="==Ack消息确认机制=="></a>==Ack消息确认机制==</h5><p><img alt="35" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/20230210170513.png"></p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    rabbitmq:</span></span><br><span class="line"><span class="attr">        host:</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.108</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">        virtual-host:</span> <span class="string">/</span></span><br><span class="line">        <span class="comment"># 开启发送端消息抵达Broker确认</span></span><br><span class="line"><span class="attr">        publisher-confirms:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 开启发送端消息抵达Queue确认</span></span><br><span class="line"><span class="attr">        publisher-returns:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 只要消息抵达Queue，就会异步发送优先回调returnfirm</span></span><br><span class="line"><span class="attr">        template:</span></span><br><span class="line"><span class="attr">          mandatory:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 手动ack消息，不使用默认的消费端确认</span></span><br><span class="line"><span class="attr">        listener:</span></span><br><span class="line"><span class="attr">          simple:</span></span><br><span class="line"><span class="attr">            acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure>
<p>服务端确认需要的配置config.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageConverter <span class="title">messageConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制RabbitTemplate</span></span><br><span class="line"><span class="comment">     * 1、服务收到消息就会回调</span></span><br><span class="line"><span class="comment">     *      1、spring.rabbitmq.publisher-confirms: true</span></span><br><span class="line"><span class="comment">     *      2、设置确认回调</span></span><br><span class="line"><span class="comment">     * 2、消息正确抵达队列就会进行回调</span></span><br><span class="line"><span class="comment">     *      1、spring.rabbitmq.publisher-returns: true</span></span><br><span class="line"><span class="comment">     *         spring.rabbitmq.template.mandatory: true</span></span><br><span class="line"><span class="comment">     *      2、设置确认回调ReturnCallback</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3、消费端确认(保证每个消息都被正确消费，此时才可以broker删除这个消息)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// @PostConstruct  //MyRabbitConfig对象创建完成以后，执行这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initRabbitTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1、只要消息抵达Broker就ack=true</span></span><br><span class="line"><span class="comment">         * correlationData：当前消息的唯一关联数据(这个是消息的唯一id)</span></span><br><span class="line"><span class="comment">         * ack：消息是否成功收到</span></span><br><span class="line"><span class="comment">         * cause：失败的原因</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//设置确认回调</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback((correlationData,ack,cause) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"confirm...correlationData["</span>+correlationData+<span class="string">"]==&gt;ack:["</span>+ack+<span class="string">"]==&gt;cause:["</span>+cause+<span class="string">"]"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 只要消息没有投递给指定的队列，就触发这个失败回调</span></span><br><span class="line"><span class="comment">         * message：投递失败的消息详细信息</span></span><br><span class="line"><span class="comment">         * replyCode：回复的状态码</span></span><br><span class="line"><span class="comment">         * replyText：回复的文本内容</span></span><br><span class="line"><span class="comment">         * exchange：当时这个消息发给哪个交换机</span></span><br><span class="line"><span class="comment">         * routingKey：当时这个消息用哪个路邮键</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setReturnCallback((message,replyCode,replyText,exchange,routingKey) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"Fail Message["</span>+message+<span class="string">"]==&gt;replyCode["</span>+replyCode+<span class="string">"]"</span> +</span><br><span class="line">                    <span class="string">"==&gt;replyText["</span>+replyText+<span class="string">"]==&gt;exchange["</span>+exchange+<span class="string">"]==&gt;routingKey["</span>+routingKey+<span class="string">"]"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ack消费者确认机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revieveMessage</span><span class="params">(Message message,</span></span></span><br><span class="line"><span class="function"><span class="params">                           OrderReturnReasonEntity content,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Channel channel)</span></span>&#123;</span><br><span class="line">    <span class="comment">//拿到主体内容</span></span><br><span class="line">    <span class="keyword">byte</span>[] body = message.getBody();</span><br><span class="line">    <span class="comment">//拿到的消息头属性信息</span></span><br><span class="line">    MessageProperties messageProperties = message.getMessageProperties();</span><br><span class="line">    System.out.println(<span class="string">"接受到的消息...内容"</span> + <span class="keyword">new</span> String(body) + <span class="string">"===内容："</span> + content);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deliveryTag在该通道内从1开始计数   表示消息唯一标识</span></span><br><span class="line">    <span class="keyword">long</span> deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">    <span class="comment">// 签收消息</span></span><br><span class="line">    <span class="comment">// multiple=false(挨个签收)</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.basicAck(deliveryTag,<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 表示消息唯一标识,是否批量,拒绝后是否发挥服务器重新入队</span></span><br><span class="line">        <span class="comment">// channel.basicNack(deliveryTag,false,true);</span></span><br><span class="line">        <span class="comment">//            // 表示消息唯一标识,拒绝后是否发挥服务器重新入队</span></span><br><span class="line">        <span class="comment">// channel.basicReject(deliveryTag,true);</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 网络中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h4><h5 id="死信路由-DLX"><a href="#死信路由-DLX" class="headerlink" title="死信路由(DLX)"></a>死信路由(DLX)</h5><p>一个消息在满足如下条件下，会进死信路由，记住这里是路由而不是队列， 一个路由可以对应很多队列。（什么是死信）</p>
<p>成为死信的情况：</p>
<p>​        1.一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不会被再次放在队列里，被其他消费者使用。（basic.reject/ basic.nack）requeue=false<br>​        2.上面的消息的TTL到了，消息过期了。<br>​        3.队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上</p>
<p>Dead Letter Exchange其实就是一种普通的exchange，和创建其他exchange没有两样。只是在某一个设置Dead Letter Exchange的队列中有 消息过期了，会自动触发消息的转发，发送到Dead Letter Exchange中去。</p>
<p>我们既可以控制消息在一段时间后变成死信，又可以控制变成死信的消息 被路由到某一个指定的交换机，结合二者，其实就可以实现一个延时队列</p>
<p>手动ack&amp;异常消息统一放在一个队列处理建议的两种方式<br>        catch异常后，手动发送到指定队列，然后使用channel给rabbitmq确认消息已消费<br>        给Queue绑定死信队列，使用nack（requque为false）确认消息消费失败</p>
<h5 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h5><p><img alt="39" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/39.png"></p>
<h5 id="定时任务时效性"><a href="#定时任务时效性" class="headerlink" title="定时任务时效性"></a>定时任务时效性</h5><p><img alt="40" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/40.png"></p>
<h4 id="订单业务—使用MQ实现最终一致性的分布式事务"><a href="#订单业务—使用MQ实现最终一致性的分布式事务" class="headerlink" title="==订单业务—使用MQ实现最终一致性的分布式事务=="></a>==订单业务—使用MQ实现最终一致性的分布式事务==</h4><p>==遵循一个服务一个交换机的原则==，延时队列设计如下图。</p>
<p><img alt="41" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/41.png"></p>
<h5 id="整体消息队列架构"><a href="#整体消息队列架构" class="headerlink" title="整体消息队列架构"></a>整体消息队列架构</h5><p><img alt="消息队列流程" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/消息队列流程.jpg"></p>
<h5 id="创建延时队列"><a href="#创建延时队列" class="headerlink" title="创建延时队列"></a>创建延时队列</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">orderDelayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Queue(String name,  队列名字</span></span><br><span class="line"><span class="comment">        boolean durable,  是否持久化</span></span><br><span class="line"><span class="comment">        boolean exclusive,  是否排他</span></span><br><span class="line"><span class="comment">        boolean autoDelete, 是否自动删除</span></span><br><span class="line"><span class="comment">        Map&lt;String, Object&gt; arguments) 属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HashMap&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    arguments.put(<span class="string">"x-dead-letter-exchange"</span>, <span class="string">"order-event-exchange"</span>);<span class="comment">// 死信之后发给那个交换机</span></span><br><span class="line">    arguments.put(<span class="string">"x-dead-letter-routing-key"</span>, <span class="string">"order.release.order"</span>);<span class="comment">// 死信之后的routing-key</span></span><br><span class="line">    arguments.put(<span class="string">"x-message-ttl"</span>, <span class="number">60000</span>); <span class="comment">// 消息过期时间 1分钟</span></span><br><span class="line">    Queue queue = <span class="keyword">new</span> Queue(<span class="string">"order.delay.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建死信交换机"><a href="#创建死信交换机" class="headerlink" title="创建死信交换机"></a>创建死信交换机</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TopicExchange</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Exchange <span class="title">orderEventExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *   String name,</span></span><br><span class="line"><span class="comment">     *   boolean durable,</span></span><br><span class="line"><span class="comment">     *   boolean autoDelete,</span></span><br><span class="line"><span class="comment">     *   Map&lt;String, Object&gt; arguments</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"order-event-exchange"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建目的地交换机"><a href="#创建目的地交换机" class="headerlink" title="创建目的地交换机"></a>创建目的地交换机</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">orderReleaseQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue queue = <span class="keyword">new</span> Queue(<span class="string">"order.release.order.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="绑定关系"><a href="#绑定关系" class="headerlink" title="绑定关系"></a>绑定关系</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">orderCreateBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * String destination, 目的地（队列名或者交换机名字）</span></span><br><span class="line"><span class="comment">     * DestinationType destinationType, 目的地类型（Queue、Exhcange）</span></span><br><span class="line"><span class="comment">     * String exchange,</span></span><br><span class="line"><span class="comment">     * String routingKey,</span></span><br><span class="line"><span class="comment">     * Map&lt;String, Object&gt; arguments</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Binding(<span class="string">"order.delay.queue"</span>,</span><br><span class="line">            Binding.DestinationType.QUEUE,</span><br><span class="line">            <span class="string">"order-event-exchange"</span>,</span><br><span class="line">            <span class="string">"order.create.order"</span>,</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">orderReleaseBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Binding(<span class="string">"order.release.order.queue"</span>,</span><br><span class="line">            Binding.DestinationType.QUEUE,</span><br><span class="line">            <span class="string">"order-event-exchange"</span>,</span><br><span class="line">            <span class="string">"order.release.order"</span>,</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="发消息"><a href="#发消息" class="headerlink" title="发消息"></a>发消息</h5><p>订单创建成功往延时队列中发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TODO 订单创建成功，发送消息给MQ</span></span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">"order-event-exchange"</span>,<span class="string">"order.create.order"</span>,order.getOrder());</span><br><span class="line"><span class="comment">// 这里不需要有消费者,过期之后让消费者取消订单就行</span></span><br></pre></td></tr></table></figure>
<h5 id="监听过期消息"><a href="#监听过期消息" class="headerlink" title="监听过期消息"></a>监听过期消息</h5><p>在延迟队列中的消息，相当于有个定时器，到期之后，能够监听到，就可以调用方法来取消订单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"order.release.order.queue"</span>)</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderCloseListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listener</span><span class="params">(OrderEntity orderEntity, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到过期的订单信息，准备关闭订单"</span> + orderEntity.getOrderSn());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            orderService.closeOrder(orderEntity);</span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            channel.basicReject(message.getMessageProperties().getDeliveryTag(),<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MQ的几个可靠性问题"><a href="#MQ的几个可靠性问题" class="headerlink" title="MQ的几个可靠性问题"></a>MQ的几个可靠性问题</h4><h5 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h5><p>没抵达broker(MQ服务器)：保证每个消息一定会发出去，做好日志(存到mysql中)。定期扫描数据库，重新发送失败的消息</p>
<p>抵达了broker(MQ服务器)：使用publisher的消息确认机制</p>
<p><img alt="42" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/42.png"></p>
<h5 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h5><p><img alt="43" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/43.png"></p>
<h5 id="消息积压"><a href="#消息积压" class="headerlink" title="消息积压"></a>消息积压</h5><p><img alt="44" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/44.png"></p>
<h3 id="订单业务"><a href="#订单业务" class="headerlink" title="==订单业务=="></a>==订单业务==</h3><h4 id="幂等性"><a href="#幂等性" class="headerlink" title="==幂等性=="></a>==幂等性==</h4><blockquote>
<p><strong>接口幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的</strong></p>
</blockquote>
<p>进入订单确认页的时候存一份令牌</p>
<blockquote>
<p>order服务下的OrderServiceImpl</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为用户设置一个token，三十分钟过期时间（存在redis）</span></span><br><span class="line">String token = UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">redisTemplate.opsForValue().set(USER_ORDER_TOKEN_PREFIX+memberResponseVo.getId(),token,<span class="number">30</span>, TimeUnit.MINUTES);</span><br><span class="line">confirmVo.setOrderToken(token);</span><br></pre></td></tr></table></figure>
<p>提交订单的时候就要使用lua脚本原子性查，并且删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、验证令牌是否合法【令牌的对比和删除必须保证原子性】</span></span><br><span class="line">String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">String orderToken = vo.getOrderToken();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过lua脚本原子验证令牌和删除令牌</span></span><br><span class="line">Long result = redisTemplate.execute(<span class="keyword">new</span> DefaultRedisScript&lt;Long&gt;(script, Long.class),</span><br><span class="line">        Arrays.asList(USER_ORDER_TOKEN_PREFIX + memberResponseVo.getId()),</span><br><span class="line">        orderToken);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0L</span>) &#123;</span><br><span class="line">    <span class="comment">//令牌验证失败</span></span><br><span class="line">    responseVo.setCode(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> responseVo;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//令牌验证成功</span></span><br></pre></td></tr></table></figure>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="==分布式事务=="></a>==分布式事务==</h4><p>本地事务异常</p>
<p><img alt="38" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/项目笔记/谷粒商城/38.png"></p>
<h5 id="seata（2PC）"><a href="#seata（2PC）" class="headerlink" title="seata（2PC）"></a>seata（2PC）</h5><h6 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h6><p>1.给每个服务的数据库中加入undo_log表(具体内容从官网上查)</p>
<p>2.安装事务协调器seata(从Github下载)，并启动</p>
<p>3.导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>4.配置</p>
<p>注册中心配置—&gt;registry.conf</p>
<p>seata配置—&gt;file.conf</p>
<p>5.注入Seata代理数据源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySeataConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSourceProperties dataSourceProperties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties dataSourceProperties)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HikariDataSource dataSource = dataSourceProperties.initializeDataSourceBuilder().type(HikariDataSource.class).build();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(dataSourceProperties.getName())) &#123;</span><br><span class="line">            dataSource.setPoolName(dataSourceProperties.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProxy(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.(==这个0.xx才有，1.2之后都没有了==)每个微服务都需要导入file.conf和registry.conf，还要在file.conf修改</p>
<blockquote>
<p>   service下的vgroup_mapping修改成vgroup_mapping.微服务名称-fescar-service-group = “default”</p>
</blockquote>
<p>7.给大事务方法加上@GlobalTransactional，小事务加上@Transactional就行</p>
<h6 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h6><p>AT模式(默认)，不适合高并发，不考虑2PC，也不考虑TCC模式，这样的是强一致性，很消耗性能</p>
<h5 id="高性能的实现方式"><a href="#高性能的实现方式" class="headerlink" title="==高性能的实现方式=="></a>==高性能的实现方式==</h5><p>这就是文档中的<strong>柔性事务+可靠消息+最终一致性方案</strong></p>
<p>使用MQ回滚，保证弱一致性-最终一致性</p>
<h4 id="业务分析"><a href="#业务分析" class="headerlink" title="业务分析"></a>业务分析</h4><p>库存解锁：就是防止后续付款的时候，库存没货了。所以在创建订单时就把库存锁定，后面付款时就肯定有库存。</p>
<h3 id="分布式原理"><a href="#分布式原理" class="headerlink" title="==分布式原理=="></a>==分布式原理==</h3><blockquote>
<p>  参考文档</p>
<p>  <a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></p>
<p>  <a href="https://raft.github.io/" target="_blank" rel="noopener">https://raft.github.io/</a></p>
</blockquote>
<p>==C和A无法同时满足(一致性和可用性无法同时满足)，所以不存在CA系统，只有AP和CP系统==</p>
<p>ABC系统，A给C同步数据时，网线断了，那么此时A和B都是8，C还是7。如要满足可用性，那么读出来的数据是7，不满足一致性；如要满足一致性，读出来的数据是8，那么C就不能用。综上，一致性和可用性无法同时满足</p>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot中后台接受前台传递的对象数组</title>
    <url>/alex-next/2020/04/23/javaEE/springboot/springboot%E4%B8%AD%E5%90%8E%E5%8F%B0%E6%8E%A5%E5%8F%97%E5%89%8D%E5%8F%B0%E4%BC%A0%E9%80%92%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="springboot中后台接受前台传递的对象数组"><a href="#springboot中后台接受前台传递的对象数组" class="headerlink" title="springboot中后台接受前台传递的对象数组"></a>springboot中后台接受前台传递的对象数组</h1><h2 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h2><p><strong>前台部分</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">let student = [&#123;name:<span class="string">"zs"</span>,age:<span class="number">12</span>&#125;,&#123;name:<span class="string">"ls"</span>,age:<span class="number">45</span>&#125;]</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">	type:<span class="string">"post"</span>,</span><br><span class="line">	url:<span class="string">"/filePage/JsonTest"</span>,</span><br><span class="line">	dataType: <span class="string">'json'</span>,</span><br><span class="line">	contentType:<span class="string">"application/json"</span>,</span><br><span class="line">	data:JSON.stringify(student),</span><br><span class="line">	success:function()&#123;</span><br><span class="line">		console.log(<span class="number">12345676</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：在ajax中，如果没加contentType:”application/json”，那么data就应该对应的是key-value形式，如：data:”students=”+JSON.stringify(student)；如果加了，那么ajax发送的data就必须是JSON字符串形式。</p>
<p><strong>后台部分</strong></p>
<p>controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/JsonTest"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">JsonTest</span><span class="params">(@RequestBody Student[] students)</span> </span>&#123;</span><br><span class="line">	System.out.println(students[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> Results.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@RequestBody会根据前台json字符串中的key来匹配对应实体类(Student)的属性，再调用实体类的setter方法将值赋给该属性。</p>
<p><strong>实体类</strong> </p>
<p>Student.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Student [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h2><p><strong>前台部分</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	let student = [&#123;name:<span class="string">"zs"</span>,age:<span class="number">12</span>&#125;,&#123;name:<span class="string">"ls"</span>,age:<span class="number">45</span>&#125;]</span><br><span class="line">	$.ajax(&#123;</span><br><span class="line">		type:<span class="string">"post"</span>,</span><br><span class="line">		url:<span class="string">"/filePage/JsonTest"</span>,</span><br><span class="line">		dataType: <span class="string">'json'</span>,</span><br><span class="line"><span class="comment">//		contentType:"application/json",</span></span><br><span class="line">		data:<span class="string">"student="</span>+JSON.stringify(student),</span><br><span class="line">		success:function()&#123;</span><br><span class="line">			console.log(<span class="number">12345676</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>:这里没有加上contentType:”application/json”,所以data要写成key-value形式。</p>
<p><strong>后台部分</strong></p>
<p>controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/JsonTest"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">JsonTest</span><span class="params">(String student)</span> </span>&#123;</span><br><span class="line">	System.out.println(student);</span><br><span class="line">	List&lt;Student&gt; students = JSONArray.parseArray(student,Student.class);</span><br><span class="line">	System.out.println(students);</span><br><span class="line">	<span class="keyword">return</span> Results.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：JSONArray是import com.alibaba.fastjson.JSONArray;<br>引入的。pom.xml依赖如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- Json --&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;1.2.58&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>实体类不变。</p>
<p><strong>还有一点注意的是</strong>，两种方式的ajax请求方式一定要是post。</p>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>项目总结</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础篇</title>
    <url>/alex-next/2021/08/29/javaEE/Docker%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="第一章-Docker简介"><a href="#第一章-Docker简介" class="headerlink" title="第一章 Docker简介"></a>第一章 Docker简介</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><h3 id="问题：为什么会有-docker-的出现"><a href="#问题：为什么会有-docker-的出现" class="headerlink" title="问题：为什么会有 docker 的出现"></a>问题：为什么会有 docker 的出现</h3><p>一款产 品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验<br><strong>Docker</strong>之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案。<br>环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装?也就是说，安装的时候，把原始环境-模-样地复制过来。开发人员利用Docker可以消除协作编码时“在我的机器上可正常工作”的问题。</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811094546.png"></p>
<p>之前在服务器配置一个应用的运行环境，要安装各种软件，就拿尚硅谷电商项目的环境来说吧，<strong>Java/TomcatMySQL/JDBC</strong>驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在<strong>Windows</strong>上安装的这些环境，到了Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。</p>
<p>传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等java为例)。而为了让这程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，<strong>开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。</strong>Docker镜 像的设计<strong>，使得Docker得以打过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运.作。</strong></p>
<h3 id="docker理念"><a href="#docker理念" class="headerlink" title="docker理念"></a>docker理念</h3><p>Docker是基于Go语言实现的云开源项目。<br>Docker的主要目标是“<strong>Build, Ship[ and Run Any App,Anywhere</strong>“，也就是通过对应用组件的封装、分发、部署、运行等生命期的管理，使用户的APP (可以是一个WEB应用或数据库应用等等)及其运行环境能够做到“<strong>一次封装，到处运行</strong>”。</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811094648.png"></p>
<p> Linux容器技术的出现就解决了这样一 一个问题，而Docker就是在它的基础上发展过来的。将应用运行在Docker容器上面，而Docker容器在任何操作系统上都是一-致的，这就实现了跨平台、跨服务器。<strong>只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作</strong></p>
<h3 id="一句话"><a href="#一句话" class="headerlink" title="一句话"></a>一句话</h3><p>解决了运行环境和配置问题的软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术</p>
<h2 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h2><h3 id="之前的虚拟机技术"><a href="#之前的虚拟机技术" class="headerlink" title="之前的虚拟机技术"></a>之前的虚拟机技术</h3><p>虚拟机<strong>(virtual machine)</strong>就是带环境安装的一种解决方案。</p>
<p>它可以在一种操作系统里面运行另一种作系统，比如在<strong>Windows系统里面运行Linux系统</strong>。应用程序对此毫无感知，因为虚拟机看上去跟真实系统- -模-样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095046.png"></p>
<p>虚拟机的缺点:</p>
<p>1、资源占用多</p>
<p>2、冗余步骤多</p>
<p>3、启动慢</p>
<h3 id="容器虚拟化技术"><a href="#容器虚拟化技术" class="headerlink" title="容器虚拟化技术"></a>容器虚拟化技术</h3><p>由于前面虛拟机存在这些缺点，<strong>Linux</strong> 发展出了另一种虚拟化技术: <strong>Linux 容器</strong>(Linux Containers,缩为LXC)。</p>
<p><strong>Linux容器不是模拟一个完整的操作系统</strong>，而是对进程进行隔离。有了容器，就可以将软件运行所的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。.</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095112.png"></p>
<p>比较了<strong>Docker</strong>和传统虚拟化方式的不同之处:</p>
<p>1、传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程;</p>
<p>2、而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，<strong>而且也没有进行硬件虚拟</strong>。因此容器要比传统虚拟机为轻便。</p>
<p>3、每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。</p>
<h3 id="开发-运维-DevOps"><a href="#开发-运维-DevOps" class="headerlink" title="开发/运维(DevOps)"></a>开发/运维(DevOps)</h3><p>一次构建、随处运行，</p>
<h4 id="更快速的应用交付和部署"><a href="#更快速的应用交付和部署" class="headerlink" title="更快速的应用交付和部署"></a>更快速的应用交付和部署</h4><p>​        传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker化<br>之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测<br>试验证时间。</p>
<h4 id="更便捷的升级和扩缩容"><a href="#更便捷的升级和扩缩容" class="headerlink" title="更便捷的升级和扩缩容"></a>更便捷的升级和扩缩容</h4><p>​        随着微服务架构和Docker的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个Docker容器将变成-块“积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。</p>
<h4 id="更简单的系统运维"><a href="#更简单的系统运维" class="headerlink" title="更简单的系统运维"></a>更简单的系统运维</h4><p>​        应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度—致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。</p>
<h4 id="更高效的计算资源利用"><a href="#更高效的计算资源利用" class="headerlink" title="更高效的计算资源利用"></a>更高效的计算资源利用</h4><p>​    <strong>Docker是内核级虚拟化</strong>，其不像传统的虚拟化技术一样 需要额外的Hypervisor支持，所以在-台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率。</p>
<h3 id="企业级"><a href="#企业级" class="headerlink" title="企业级"></a>企业级</h3><p>新浪</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095119.png"></p>
<p>美团</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095124.png"></p>
<p>蘑菇街</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095129.png"></p>
<h3 id="去哪下"><a href="#去哪下" class="headerlink" title="去哪下"></a>去哪下</h3><h4 id="1、官网"><a href="#1、官网" class="headerlink" title="1、官网"></a>1、官网</h4><p>docker官网： <a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a></p>
<p>docker中文网站: <a href="https://www.docker-cn.com/" target="_blank" rel="noopener">https://www.docker-cn.com/</a></p>
<h4 id="2、仓库"><a href="#2、仓库" class="headerlink" title="2、仓库"></a>2、仓库</h4><p>Docker Hub官网：<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p>
<h1 id="第二章-Docker安装"><a href="#第二章-Docker安装" class="headerlink" title="第二章 Docker安装"></a>第二章 Docker安装</h1><h2 id="前提说明"><a href="#前提说明" class="headerlink" title="前提说明"></a>前提说明</h2><p><strong>CentOS Docker安装</strong><br>Docker支持以下的CentOS版本:<br>CentOS 7 (64-bit)<br>CentOS 6.5 (64-bit)或更高的版本</p>
<p><strong>前提条件</strong><br>目前，CentOS 仅发行版本中的内核支持Docker。<br>Docker运行在CentOS 7.上，要求系统为64位、系统内核版本为3.10以上。<br>Docker运行在CentOS-6.5或更高的版本的CentOS上，要求系统为64位、系<strong>统内核版本为2.6.32-431或者更高版本。</strong></p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095135.png"></p>
<h2 id="Docker-的基本组成"><a href="#Docker-的基本组成" class="headerlink" title="Docker 的基本组成"></a>Docker 的基本组成</h2><h3 id="docker架构图"><a href="#docker架构图" class="headerlink" title="docker架构图"></a>docker架构图</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20220813182938.png"></p>
<h3 id="镜像-image"><a href="#镜像-image" class="headerlink" title="镜像( image )"></a>镜像( image )</h3><p>Docker镜像(lmage)就是-一个只读的模板。镜像可以用来创建Docker容器，个镜像可以创建很多容器</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095144.png"></p>
<h3 id="容器-container"><a href="#容器-container" class="headerlink" title="容器( container)"></a>容器( container)</h3><p>Docker利用容器(Container) 独立运行的一个或一组应用。<strong>容器是用镜像创建的运行实例。</strong><br>它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。<br><strong>可以把容器看做是一个简 易版的Linux环境</strong>(包括root用户权限、进程空间、用户空间和网络空间等)和运行在其中的应用程序。<br>容器的定义和镜像几乎一模一样，也是一堆层的统一视角， 唯- -区别在于容器的最上面那-层是可读可写的。</p>
<h3 id="仓库-repository"><a href="#仓库-repository" class="headerlink" title="仓库( repository)"></a>仓库( repository)</h3><p>仓库(<strong>Repository</strong>) 是<strong>集中存放镜像</strong>文件的场所。<br>仓库(<strong>Repository</strong>)和仓库注册服务器(<strong>Registry</strong>) 是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多镜像，<br>每个镜像有不同的标签(tag) 。</p>
<p>仓库分为公开仓库(<strong>Public</strong>) 和私有仓库(<strong>Private</strong>) 两种形式。<br><strong>最大的公开仓库是Docker Hub(ttps://hub. docker.com/)</strong><br>存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云、网易云等</p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结 ()"></a>小总结 ()</h3><p>需要正确的理解仓储/镜像/容器这几个概念:</p>
<p>Docker本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一-个可交付的运行环境，这个打好的运行环境就似乎image镜像文件。只有通过这个镜像文件才能生成Docker容器。image文件可以看作是容器的模板。Docker根据image文件生成容器的实例。同一个image文件，可以生成多个同时运行的容器实例。</p>
<p>image文件生成的容器实例，本身也是一一个文件，称为镜像文件。</p>
<p>一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一-个对应的运行实例，也就是我们的容器至于仓储，就是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以了。|</p>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="Centos6-8安装Docker"><a href="#Centos6-8安装Docker" class="headerlink" title="Centos6.8安装Docker"></a>Centos6.8安装Docker</h3><p>1、yum install -y epel-release</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095150.png"></p>
<p>2、yum install -y docker-io</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095156.png"></p>
<p>3、安装后的配置文件： etc/sysconfig/docker</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095201.png"></p>
<p>4、启动 Docker后台服务: service docker start</p>
<p>5、docker version 验证</p>
<h3 id="Centos7-0安装Docker"><a href="#Centos7-0安装Docker" class="headerlink" title="Centos7.0安装Docker"></a>Centos7.0安装Docker</h3><p><a href="https://docs.docker.com/engine/install/centos/" target="_blank" rel="noopener">https://docs.docker.com/engine/install/centos/</a></p>
<h2 id="永远的helloworld"><a href="#永远的helloworld" class="headerlink" title="永远的helloworld"></a>永远的helloworld</h2><h3 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h3><p>是什么</p>
<p>​    <a href="https://promotion.aliyun.com/ntms/act/kubernetes.html" target="_blank" rel="noopener">https://promotion.aliyun.com/ntms/act/kubernetes.html</a></p>
<p>注册一个属于自己的阿里云账户( 可复用淘宝账号)</p>
<p>获得加速器地址连接</p>
<p>​    登录阿里云开发者平台</p>
<p>​    获取加速器地址</p>
<p>配置本机Docker运行镜像加速器</p>
<p>​    鉴于国内网络问题，后续拉取Docker镜像十分缓慢，我们可以需要配置加速器来解决，<br>我使用的是阿里云的本人自己账号的镜像地址(需要自己注册有一个属于你自己的): ht:po/. mirror aliyuncns .com</p>
<ul>
<li>vim /etc/sysconfig/docker<br>将获得的自己账户下的阿里云加速地址配置进<br>other_ args-=”—registry-mirror=<a href="https://你自" target="_blank" rel="noopener">https://你自</a> 己的账号加速信息.mirror .aliyuncs.com</li>
</ul>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095235.png"></p>
<p>重新启动 Docker 后台服务：service docker restart</p>
<p>Linux系统下配置完加速器需要检查是否生效</p>
<h3 id="网易云加速"><a href="#网易云加速" class="headerlink" title="网易云加速"></a>网易云加速</h3><p>基本上同上述阿里云</p>
<p>启动Docker后台容器(测试运行 hello-world )</p>
<p>​    docker run hello world</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095239.png"></p>
<p>run干了什么</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095244.png"></p>
<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><h3 id="Docker是怎样工作的"><a href="#Docker是怎样工作的" class="headerlink" title="Docker是怎样工作的"></a>Docker是怎样工作的</h3><p>Docker是一个Client-Server结构的系统，Docker守 护进程运行在主机上，然后通过Socket连 接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。<strong>容器，是一个运行时环境，就是我们前面说到的集装箱。</strong></p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095248.png"></p>
<h3 id="为什么Docker比较比vm快"><a href="#为什么Docker比较比vm快" class="headerlink" title="为什么Docker比较比vm快"></a>为什么Docker比较比vm快</h3><p>1、<strong>docker</strong>有着比虚拟机更少的抽象层。由亍docker不需要<strong>Hypervisor</strong>实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。<br>2、<strong>docker</strong>利用的是宿主机的内核,而不需要<strong>Guest OS</strong>。因此,当新建一个 容器时,docker不需要和虚拟机一样 重新加载- - 个操作系统内核仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建—个虚拟机时,虚拟机软件需要加载GuestOS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一-个docker容器只需要几秒钟。</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095252.png"></p>
<h1 id="第三章-Docker常用命令"><a href="#第三章-Docker常用命令" class="headerlink" title="第三章 Docker常用命令"></a>第三章 Docker常用命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker Version</span><br><span class="line"></span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line">docker --help</span><br><span class="line">	自己查看官网解释，高手都是自己练出来的，百度上只不过是翻译了下，加了点例子</span><br></pre></td></tr></table></figure>
<h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><h3 id="docker-images-列出本机上的镜像"><a href="#docker-images-列出本机上的镜像" class="headerlink" title="docker images 列出本机上的镜像"></a>docker images 列出本机上的镜像</h3><h3 id="OPTIONS-说明："><a href="#OPTIONS-说明：" class="headerlink" title="OPTIONS 说明："></a><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095259.png">OPTIONS 说明：</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">-a 列出本地所有的镜像(含中间映射层)</span><br><span class="line">-q 只显示镜像ID</span><br><span class="line">--digests 显示镜像的摘要信息</span><br><span class="line">--no-trunc 显示完整的镜像信息</span><br></pre></td></tr></table></figure>
<h3 id="docker-search-某个XXX镜像的名字"><a href="#docker-search-某个XXX镜像的名字" class="headerlink" title="docker search 某个XXX镜像的名字"></a>docker search 某个XXX镜像的名字</h3><p>​    网站 www.dockerhub.com</p>
<p>​    docker search [OPTIONS] 镜像名字</p>
<p>​    OPTIONS 说明</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">--no-trun 显示完整的镜像描述</span><br><span class="line">-s 列出收藏数不小于指定值的镜像</span><br><span class="line">--automated 只列出 automated build类型的镜像</span><br></pre></td></tr></table></figure>
<h3 id="docker-pull-某个镜像的名字"><a href="#docker-pull-某个镜像的名字" class="headerlink" title="docker pull 某个镜像的名字"></a>docker pull 某个镜像的名字</h3><p>​    下载镜像</p>
<p>​     docker pull 镜像名字[:TAG]</p>
<h3 id="docker-rmi-某个XXX镜像的名字ID"><a href="#docker-rmi-某个XXX镜像的名字ID" class="headerlink" title="docker rmi 某个XXX镜像的名字ID"></a>docker rmi 某个XXX镜像的名字ID</h3><p>​    删除镜像</p>
<p>​    删除单个 docker rm -f 镜像ID</p>
<p>​    删除多个 docker rm -f 镜像名1:TAG 镜像名2:TAG</p>
<p>​    删除多个 docker rmi -f ${docker images -qa}</p>
<h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p>有镜像才能创建容器，这是根本前提(下载一个Centos镜像演示)</p>
<p>​    docker pull centos</p>
<h3 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h3><p>​    docker run [OPTIONS] IMAGE [COMMAND][ARG]</p>
<p>​    OPTIONS 说明 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OPTIONS说明(常用) :有些是一个减号，有些是两个减号</span><br><span class="line">--name=<span class="string">"容器新名字"</span>:为容器指定一个名称;</span><br><span class="line">-d:后台运行容器，并返回容器ID， 也即启动守护式容器;</span><br><span class="line">-i:以交互模式运行容器，通常与-t同时使用;</span><br><span class="line">-t:为容器重新分配一个伪输入终端，通常与-i同时使用;</span><br><span class="line">-P:随机端口映射;</span><br><span class="line">-p:指定端口映射，有以下四种格式</span><br><span class="line">ip:hostPort:containerPort</span><br><span class="line">ip::containerPort</span><br><span class="line">hostPort:containerPort</span><br><span class="line">containerPort</span><br></pre></td></tr></table></figure>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095306.png"></p>
<h3 id="列出当前所有正在运行的容器"><a href="#列出当前所有正在运行的容器" class="headerlink" title="列出当前所有正在运行的容器"></a>列出当前所有<strong>正在运行</strong>的容器</h3><p>​    dockers ps [OPTIONS]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OPTIONS说明(常用) :</span><br><span class="line">-a :列出当前所有正在运行的容器+历史上运行过的</span><br><span class="line">-|:显示最近创建的容器。</span><br><span class="line">-n:显示最近n个创建的容器。</span><br><span class="line">-q :静默模式，只显示容器编号。</span><br><span class="line">--no-trunc :不截断输出。</span><br></pre></td></tr></table></figure>
<h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><p>两种退出方式</p>
<p>​    exit 容器不停止退出，bash窗口停止</p>
<p>​    ctrl+P+Q 容器不停止，bash窗口不停止</p>
<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>docker start 容器ID或容器签名</p>
<h3 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h3><p>docker restart 容器ID或容器签名</p>
<h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><p>docker stop 容器ID或容器签名</p>
<h3 id="强制停止容器"><a href="#强制停止容器" class="headerlink" title="强制停止容器"></a>强制停止容器</h3><p>docker kill 容器ID或容器签名</p>
<h3 id="删除已停止的容器"><a href="#删除已停止的容器" class="headerlink" title="删除已停止的容器"></a>删除已停止的容器</h3><p>docker rm 容器ID  -f</p>
<p>​    一次性删除多个容器</p>
<p>​    docker rm -f $(docker ps -a -q)</p>
<p>​    docker ps -a -q | xargs docker rm</p>
<h2 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h2><h3 id="启动守护式容器"><a href="#启动守护式容器" class="headerlink" title="启动守护式容器"></a>启动守护式容器</h3><p>使用镜像centos:latest以后台模式启动一个容器<br>docker run -d centos</p>
<p>问题:然后docker ps -a进行查看,<strong>会发现容器已经退出</strong><br>很重要的要说明的一点: <strong>Docker容器后台运行,就必须有一个前台进程.</strong><br>容器运行的命令如果不是那些<strong>一直挂起的命令</strong> (比如运行top，tail) ，就是会自动退出的。<br>这个是<strong>docker</strong>的机制问题,比如你的web容器，我们以<strong>nginx</strong>为例，正常情况下,我们配置启动服务只需要启动响应的<strong>service</strong>即可。例如<br>service nginx start<br>但是,这样做,<strong>nginx</strong>为后台进程模式运行,就导致<strong>docker</strong>前台没有运行的应用,这样的容器后台启动后，会立即自杀因为他觉得他没事可做了.所以，最佳的解决方案是将你要运行的程序以前台进程的形式运行</p>
<h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><p>docker logs -f -t —tail 容器ID </p>
<p>​    -t 是加入时间戳</p>
<p>​    -f 跟随最新的日志打印</p>
<p>​    —tail 数字显示最后多少条</p>
<h3 id="查看容器内的进程"><a href="#查看容器内的进程" class="headerlink" title="查看容器内的进程"></a>查看容器内的进程</h3><p>docker top 容器ID</p>
<h3 id="查看容器内部细节"><a href="#查看容器内部细节" class="headerlink" title="查看容器内部细节"></a>查看容器内部细节</h3><p>docker inspect 容器ID</p>
<h3 id="进入正在运行的容器并以命令行交互"><a href="#进入正在运行的容器并以命令行交互" class="headerlink" title="进入正在运行的容器并以命令行交互"></a>进入正在运行的容器并以命令行交互</h3><p>docker exec -it 容器ID bashShell</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095314.png"></p>
<p>重新进入docker attach 容器ID</p>
<p>上述两个区别</p>
<p>attach 直接进入容器启动命令的终端，不会启动新的进程</p>
<p>exec 实在容器中打开新的终端，并且可以穷的那个新的进程</p>
<h3 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h3><p>docker cp 容器ID:容器内路径 目的主机路径</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095318.png"></p>
<h2 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h2><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095323.png"></p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095333.png"></p>
<h1 id="第四章-Docker-镜像"><a href="#第四章-Docker-镜像" class="headerlink" title="第四章 Docker 镜像"></a>第四章 Docker 镜像</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的有内容，包括代码、运行时、库、环境变量和配置文件。</p>
<h3 id="UnionFS-联合文件系统"><a href="#UnionFS-联合文件系统" class="headerlink" title="UnionFS(联合文件系统)"></a>UnionFS(联合文件系统)</h3><p>UnionFS (状节又件示统)<br>UnionFS (联合文件系统) : Union文件系统(UnionFS)是一一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修作为一 次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a singlevirtualfilesystem)。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)可以制作各种具.体的应用镜像。</p>
<p>特性:一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文<br>件系统会包含所有底层的文件和目录</p>
<h3 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h3><p><strong>Docker镜像加载原理:</strong><br>    <strong>docker</strong>的镜像实际上由一层一层的文件系统组成，这种层级的文件系统<strong>UnionFS。</strong></p>
<p><strong>botfs(boot file system)</strong>主要包含<strong>bootloader</strong>和<strong>kernel</strong>, <strong>bootloader</strong>主 要是引导加载<strong>kernel</strong>, <strong>Linux</strong>刚启动时会加载bootfs文件系统，在<strong>Docker</strong>镜像的最底层是<strong>bootfs</strong>。这一-层与我们典型的<strong>Linux/Unix</strong>系统是- - -样的，包含boot加载器和内核。当boot加载完成之 后整个内核就都在内存中了，此时内存的使用权己由bootfs转交给内核，此时系统也会卸载bootfs。</p>
<p><strong>rootfs (root file system)，</strong>在<strong>bootfs</strong>之 上。 包含的就是典型Linux系统中的<strong>/dev, /proc, /bin, /etc</strong>等标准目录和文件。<strong>rootfs</strong>就 是各种不同的操作系统发行版，比如<strong>Ubuntu</strong>，<strong>Centos</strong>等等。</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095340.png"></p>
<p>平时我们安装的虚拟机的Centos都是好几个G ，为什么docker这里才要200m</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095345.png"></p>
<p>对于一个精简的<strong>OS, rootfs</strong>可 以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用<strong>Host</strong>的<strong>kernel</strong>,自只需要提供rootfs就行了。由此可见对于不同的<strong>linux</strong>发行版, <strong>bootfs</strong>基本是一致的, <strong>rootfs</strong>会有差别，因此不同的发行版可以公用<strong>bootfs</strong>。</p>
<h3 id="分层的镜像"><a href="#分层的镜像" class="headerlink" title="分层的镜像"></a>分层的镜像</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095349.png"></p>
<h3 id="分层的镜像-1"><a href="#分层的镜像-1" class="headerlink" title="分层的镜像"></a>分层的镜像</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095353.png"></p>
<h3 id="为什么-Docker纪念馆想要采用这种分层结构"><a href="#为什么-Docker纪念馆想要采用这种分层结构" class="headerlink" title="为什么 Docker纪念馆想要采用这种分层结构"></a>为什么 Docker纪念馆想要采用这种分层结构</h3><p>最大的一个好处就是-<strong>共享资源</strong><br>比如:<strong>有多个镜像都从相同的base镜像构建而来</strong>，那么宿主机只需在磁盘上保存一份<strong>base</strong>镜像,<br>同时内存中也只需加载一份<strong>base</strong>镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到<strong>镜像的顶部</strong>，这一层通常被称为<strong>容器层</strong>，容器层之下都叫<strong>镜像层</strong></p>
<h2 id="Docker镜像Commit操作"><a href="#Docker镜像Commit操作" class="headerlink" title="Docker镜像Commit操作"></a>Docker镜像Commit操作</h2><p>docker commit 提交容器副本使之称为一个新的镜像</p>
<p>docker commit -m=”提交的描述信息” -a=”作者” 容器ID 要创建的目标镜像名:[标签名]</p>
<h3 id="案例演示："><a href="#案例演示：" class="headerlink" title="案例演示："></a>案例演示：</h3><p>1、从Hub上下载tomcat镜像到本地并成功运行</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095358.png"></p>
<p>docker run -d -p 8080:8080 tomcat</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-p主机端口：docker容器端口</span><br><span class="line">-P:随机分配端口</span><br><span class="line">i:交互</span><br><span class="line">t:终端</span><br></pre></td></tr></table></figure>
<p>2、故意删除上一步镜像生产tomcat容器的文档</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095404.png"></p>
<p>3、也即当前的tomcat运行实例是一个没有文档内容的容器，以他为模板commit一个没有doc的tomcat新镜像 atguigu/tomcat02</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095408.png"></p>
<p>4、启动我们的新镜像并和原来的对比</p>
<p>​    启动atuigu/tomcat02 没有doc</p>
<p>​    启动原来tomcat他有doc</p>
<h1 id="第五章-Docker容器数据卷"><a href="#第五章-Docker容器数据卷" class="headerlink" title="第五章 Docker容器数据卷"></a>第五章 Docker容器数据卷</h1><h2 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h2><p>先来看看<strong>Docker</strong>的理念:<br><em>将运用与运行的环境打包形成容器运行，运行可以伴随着容器，但是我们对数据的要求希望是持久化的
</em>容器之间希望有可能共享数据<br><strong>Docker</strong>容器产生的数据，如果不通过<strong>docker</strong> <strong>commit</strong>生成新的镜像，使得数据做为镜像的一部分保存下来，<br>那么当容器删除后，数据自然也就没有了。<br>为了能保存数据在docker中我们使用卷。|</p>
<p>一句话：有点类似我们Redis里面的rdb和aof文件</p>
<h2 id="能干嘛-1"><a href="#能干嘛-1" class="headerlink" title="能干嘛"></a>能干嘛</h2><p>卷就是目录或文件，存在于一个或多个容器中，由<strong>docker</strong>挂载到容器，但不属于联合文件系统，因此能够绕过Union FileSystem提供一些用 于持续存储或共享数据的特性:<br>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不 会在容器删除时删除其挂载的数据卷</p>
<p>特点:<br>1:数据卷可在容器之间共享或重用数据<br>2:卷中的更改可以直接生效<br>3:数据卷中的更改不会包含在镜像的更新中<br>4:数据卷的生命周期一直持续到没有容器使用它为止</p>
<p><strong>容器的持久化</strong></p>
<p><strong>容器间继承+共享数据</strong></p>
<h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><h3 id="容器内添加"><a href="#容器内添加" class="headerlink" title="容器内添加"></a>容器内添加</h3><h4 id="直接命令添加"><a href="#直接命令添加" class="headerlink" title="直接命令添加"></a>直接命令添加</h4><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095414.png"></p>
<p>docker run -it -v /宿主机绝对路径目录:/容器内目录 镜像名</p>
<p>查看数据卷是否挂载成功</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095419.png"></p>
<p>容器和宿主机之间数据共享</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095423.png"></p>
<p>容器停止退出后，主机修改后的数据是否同步</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095427.png"></p>
<p>命令(带权限)</p>
<p>​    docker run -it -v /宿主机绝对路径目录:/容器内目录<strong>:ro</strong> 镜像名</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095430.png"></p>
<h4 id="DockerFile添加"><a href="#DockerFile添加" class="headerlink" title="DockerFile添加"></a>DockerFile添加</h4><p>根目录下新建mydocker文件夹并进入</p>
<p>可在Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095434.png"></p>
<p>File构建</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095438.png"></p>
<p>build后生成镜像</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095446.png"></p>
<p>获得一个新镜像zzyy/centos</p>
<p>run容器</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095450.png"></p>
<p>通过上述步骤，容器内的卷目录地址已经知道，对应的主机目录在哪</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095454.png"></p>
<p><strong>主机对应默认地址</strong></p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095458.png"></p>
<p>备注</p>
<p>Docker挂载主机目录Docker访问出现cannot open directory . Permission denied<br>解决办法:在挂载目录后多加一个—privileged=true参数即可</p>
<h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器.</p>
<h3 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h3><p>以上一步新建的zzyy/centos为模板并运行容器 doc1/doc2/doc3</p>
<p>他们已经具有容器卷</p>
<p>​    /dataVolumeContainer1</p>
<p>​    /dataVolumeContainer2</p>
<h3 id="容器间传递共享-—volumes-from"><a href="#容器间传递共享-—volumes-from" class="headerlink" title="容器间传递共享(—volumes -from)"></a>容器间传递共享(—volumes -from)</h3><h4 id="先启动一个父容器doc1"><a href="#先启动一个父容器doc1" class="headerlink" title="先启动一个父容器doc1"></a>先启动一个父容器doc1</h4><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095502.png"></p>
<p>启动后在 dataVolumeContainer1中新增内容</p>
<h4 id="doc2-doc3-继承doc1"><a href="#doc2-doc3-继承doc1" class="headerlink" title="doc2/doc3 继承doc1"></a>doc2/doc3 继承doc1</h4><p>​    <strong>—volumes -from</strong></p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095506.png"></p>
<p>doc2/doc3 分别在dataVolumeContainer2各自新增内容</p>
<h4 id="回到doc1可以看到02-03各自添加的都能共享了"><a href="#回到doc1可以看到02-03各自添加的都能共享了" class="headerlink" title="回到doc1可以看到02/03各自添加的都能共享了"></a>回到doc1可以看到02/03各自添加的都能共享了</h4><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095510.png"></p>
<h4 id="删除doc1-doc2修改后doc3是否可以访问"><a href="#删除doc1-doc2修改后doc3是否可以访问" class="headerlink" title="删除doc1 doc2修改后doc3是否可以访问"></a>删除doc1 doc2修改后doc3是否可以访问</h4><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095515.png"></p>
<h4 id="删除doc02后doc3是否访问"><a href="#删除doc02后doc3是否访问" class="headerlink" title="删除doc02后doc3是否访问"></a>删除doc02后doc3是否访问</h4><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095519.png"></p>
<p>在进一步</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095523.png"></p>
<h4 id="新建doc04继承doc03-然后删除doc03"><a href="#新建doc04继承doc03-然后删除doc03" class="headerlink" title="新建doc04继承doc03 然后删除doc03"></a>新建doc04继承doc03 然后删除doc03</h4><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095527.png"></p>
<p><strong>结论：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止</strong></p>
<h1 id="第六章-DockerFile解析"><a href="#第六章-DockerFile解析" class="headerlink" title="第六章 DockerFile解析"></a>第六章 DockerFile解析</h1><h2 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h2><h3 id="Dockerfile是用来构建Docker镜像的构建文件，由一系列命令和参数构成的脚本"><a href="#Dockerfile是用来构建Docker镜像的构建文件，由一系列命令和参数构成的脚本" class="headerlink" title="Dockerfile是用来构建Docker镜像的构建文件，由一系列命令和参数构成的脚本"></a>Dockerfile是用来构建Docker镜像的构建文件，由一系列命令和参数构成的脚本</h3><h3 id="构建三步骤"><a href="#构建三步骤" class="headerlink" title="构建三步骤"></a>构建三步骤</h3><p>​    编写Dockerfile文件</p>
<p>​    docker build</p>
<p>​    docker run</p>
<h3 id="文件什么样？？？"><a href="#文件什么样？？？" class="headerlink" title="文件什么样？？？"></a>文件什么样？？？</h3><p>​    熟悉的Centos为例</p>
<p><a href="http://hub.docker.com/_/centos" target="_blank" rel="noopener">http://hub.docker.com/_/centos</a></p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095531.png"></p>
<h2 id="DockerFile构建过程解析"><a href="#DockerFile构建过程解析" class="headerlink" title="DockerFile构建过程解析"></a>DockerFile构建过程解析</h2><p>Dockerfile内容基础知识</p>
<p>1、每条保留字指令都必须为大写字母且后面要跟随至少一个参数<br>2、 指令按照从.上到下，顺序执行<br>3、#表示注释<br>4、每条指令都会创建一个新的镜像层，并对镜像进行提交</p>
<h3 id="Docker执行Dockerfile的大致流程"><a href="#Docker执行Dockerfile的大致流程" class="headerlink" title="Docker执行Dockerfile的大致流程"></a>Docker执行Dockerfile的大致流程</h3><p>1、 docker 从基础镜像运行一个容器<br>2、执行一-条指令并对容器作出修改<br>3、执行类似docker commit的操作提交- -个新的镜像层<br>4、docker再基 于刚提交的镜像运行一一个新容器<br>5、执行dockerfile中的 下一条指令直到所有指令都执行完成</p>
<h3 id="小总结-2"><a href="#小总结-2" class="headerlink" title="小总结"></a>小总结</h3><p>从应用软件的角度来看，Dockerfile、 Docker镜像与Docker容器分别代表软件的三个不同阶段，<br>Dockerfile是软件的原材料<br>Docker镜像是软件的交付品<br>Docker容器则可以认为是软件的运行态。<br>Dockerfile面向开发，Docker镜 像成为交付标准，Docker容 器则涉及部署与运维，三者缺- -不可，合力充当Docker体系的基石。</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095538.png"></p>
<p>1、Dockerfile，需要定义一个Dockerfile，Dockerfile定 义了进程需要的一切东西。Dockerfile涉 及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;<br>2、Docker镜像，在用Dockerfile定义一文件之后，docker build时会产生- -个Docker镜像，当运行Docker镜像时，会真正开始提供服务;<br>3、Docker容器，容器是直接提供服务的。</p>
<h2 id="DockerFile体系结构-保留字指令"><a href="#DockerFile体系结构-保留字指令" class="headerlink" title="DockerFile体系结构(保留字指令)"></a>DockerFile体系结构(保留字指令)</h2><p><img style="zoom:200%;" data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095546.png"></p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095551.png"></p>
<p>小总结</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095555.png"></p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="Base-镜像-scratch"><a href="#Base-镜像-scratch" class="headerlink" title="Base 镜像(scratch)"></a>Base 镜像(scratch)</h3><p>Docker Hub中 99%的镜像都是通过在base镜像中安装和配置需要的软件构建出来的</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095559.png"></p>
<h3 id="自定义镜像mycentos"><a href="#自定义镜像mycentos" class="headerlink" title="自定义镜像mycentos"></a>自定义镜像mycentos</h3><h4 id="1、编写"><a href="#1、编写" class="headerlink" title="1、编写"></a>1、编写</h4><p>​    Hub默认Centos镜像是什么情况</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095603.png"></p>
<p>准备Dockerfile文件</p>
<p>myCentOS内容Dockerfile</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095607.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER ZZYY&lt;zzyy167@126.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo "success--------------ok"</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>
<h4 id="2、构建"><a href="#2、构建" class="headerlink" title="2、构建"></a>2、构建</h4><p>docker build -t 新镜像名字:TAG .</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095613.png"></p>
<h4 id="3、运行"><a href="#3、运行" class="headerlink" title="3、运行"></a>3、运行</h4><p>docker run -it 新镜像名字:TAG </p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095617.png"></p>
<h4 id="4、列出镜像的变更历史"><a href="#4、列出镜像的变更历史" class="headerlink" title="4、列出镜像的变更历史"></a>4、列出镜像的变更历史</h4><p>docker history 镜像名</p>
<p>CMD/ENTRYPOINT 镜像案例</p>
<p>都是指定一个容器启动时要运行的命令</p>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>​    Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被dockerrun之后的参数替换</p>
<p>​    Case</p>
<p>​    tomcat的讲解演示 docker run -it -p 8080:8080 tomcat ls -l</p>
<h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>​    docker run 之后的参数会被当做参数传递给 ENTRYPOINT 之后形成新的命令组合</p>
<p>​    Case </p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095622.png"></p>
<p>制作CMD版可以查询IP信息的容器</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095625.png"></p>
<h4 id="curl的命令解释"><a href="#curl的命令解释" class="headerlink" title="curl的命令解释"></a>curl的命令解释</h4><p><strong>curl</strong>命令可以用来执行下载、发送各种<strong>HTTP</strong>请求，指定<strong>HTTP</strong>头部等操作。</p>
<p>如果系统没有<strong>curl</strong>可以使用<strong>yum install curl</strong>安装，也可以下载安装。<br><strong>curl是将下载文件输出到stdout</strong><br>使用命令: curl <a href="http://www" target="_blank" rel="noopener">http://www</a> .baidu.com<br>执行后，www.baidu.com的html就会显示在屏幕上了</p>
<p>这是最简单的使用方法。用这个命令获得了htp://curl.haxx.se指向的页面，同样，如果这里的URL指向的是—个文件或者一幅图都可以直接下载到本地。如果下载的是HTML文档，那么缺省的将只显示文件头部，即HTML文档的header。要全部显示，请加参数-i</p>
<p>WHY</p>
<p>我们可以看到可执行文件找不到的报错，<strong>executable file not found。</strong><br>之前我们说过，<strong>跟在镜像名后面的是command,运行时会替换CMD的默认值。</strong><br>因此这里的-i替换了原来的CMD，而不是添加在原来的curl -s htp://ip.cn后面。而-i 根本不是命令，所以自然找不到。<br>那么如果我们希望加入-i这参数，我们就必须重新完整的输入这个命令:<br><strong>$ docker run myip curl -s <a href="http://ip.cn" target="_blank" rel="noopener">http://ip.cn</a> -i</strong></p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095631.png"></p>
<h3 id="自定义镜像Tomcat"><a href="#自定义镜像Tomcat" class="headerlink" title="自定义镜像Tomcat"></a>自定义镜像Tomcat</h3><h4 id="1、mkdir-p-zzyy-mydockerfile-tomcat9"><a href="#1、mkdir-p-zzyy-mydockerfile-tomcat9" class="headerlink" title="1、mkdir -p /zzyy/mydockerfile/tomcat9"></a>1、mkdir -p /zzyy/mydockerfile/tomcat9</h4><h4 id="2、在上述目录下-touch-c-txt"><a href="#2、在上述目录下-touch-c-txt" class="headerlink" title="2、在上述目录下 touch c.txt"></a>2、在上述目录下 touch c.txt</h4><h4 id="3、将jdk和tomcat安装的压缩包拷贝进上一步目录"><a href="#3、将jdk和tomcat安装的压缩包拷贝进上一步目录" class="headerlink" title="3、将jdk和tomcat安装的压缩包拷贝进上一步目录"></a>3、将jdk和tomcat安装的压缩包拷贝进上一步目录</h4><h4 id="4、在zzyyuse-mydockerfile-tomcat9目录下新建Dockerfile文件"><a href="#4、在zzyyuse-mydockerfile-tomcat9目录下新建Dockerfile文件" class="headerlink" title="4、在zzyyuse/mydockerfile/tomcat9目录下新建Dockerfile文件"></a>4、在zzyyuse/mydockerfile/tomcat9目录下新建Dockerfile文件</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span> zzyy&lt;zzyybs@ <span class="number">126</span>.com&gt;</span><br><span class="line"><span class="comment">#把宿主机当前上下文的c .txt拷贝到容器/usr/local/路径下</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> c.txt /usr/<span class="built_in">local</span>/cincontainer.txt</span></span><br><span class="line"><span class="comment">#把java与tomcat添加到容器中</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> jdk-8u171-linux x64.tar .gz /usr/<span class="built_in">local</span>/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> apache-tomcat-9.0.8.tar.gz /usr/ocal/</span></span><br><span class="line"><span class="comment">#安装vim编辑器</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install vim</span></span><br><span class="line"><span class="comment">#设置工 作访问时候的WORKDIR路径， 登录落脚点</span></span><br><span class="line"><span class="keyword">ENV</span> MYPATH /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="comment">#配:置java与tomcat环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_ HOME /usr/localjdk1 .<span class="number">8.0</span>_ <span class="number">171</span></span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH $JAVA_ HOME/lib/dt.jar:$JAVA_ HOME/lib/tools.jar</span><br><span class="line"><span class="keyword">ENV</span> CATALINA_ HOME /usr/local/apache-tomcat-<span class="number">9.0</span>.<span class="number">8</span></span><br><span class="line"><span class="keyword">ENV</span> CATALINA_ BASE /usr/ocal/apache-tomcat-<span class="number">9.0</span>.<span class="number">8</span></span><br><span class="line"><span class="keyword">ENV</span> PATH $PATH:$JAVA_ HOME/bin:$CATALINA_ HOME/ib:$CATALINA_ HOME/bin</span><br><span class="line"><span class="comment">#容器运行时监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment">#启动时运行tomcat</span></span><br><span class="line"><span class="comment"># ENTRYPOINT ["/usrl/local/apache-tomcat-9.0.8/bin/startup.sh" ]</span></span><br><span class="line"><span class="comment"># CMD ["/usr/local/apache-tomcat-9.0.8/bin/catalina.sh","run"]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /usr/<span class="built_in">local</span>/apache-tomcat-9.0.8/bin/startup.sh &amp;&amp; tail -F /usr/<span class="built_in">local</span>/apache-tomcat-9.0.8/<span class="keyword">in</span>/logs/catalina.out</span></span><br></pre></td></tr></table></figure>
<p>目录内容</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095636.png"></p>
<h4 id="5、构建"><a href="#5、构建" class="headerlink" title="5、构建"></a>5、构建</h4><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095640.png"></p>
<p>构建完成</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095643.png"></p>
<h4 id="6、run"><a href="#6、run" class="headerlink" title="6、run"></a>6、run</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d -p 9080:8080 -name myt9</span></span><br><span class="line"> -v /zyuse/mydockerfiletomcat9/test:/usrlocal/apache-tomcat9.<span class="number">0.8</span>/webapps/test</span><br><span class="line"> -v /zzyyuse/mydockerfile/tomcat9/tomcat9logs/:/usrlocal/apache-tomcat-<span class="number">9.0</span>.<span class="number">8</span>/logs -privileged=true zzyytomcat9</span><br></pre></td></tr></table></figure>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095647.png"></p>
<p>备注</p>
<p>Docker挂载主机目录Docker访问出现cannot open directory : Permission denied解决办法:在挂载目录后多加一个—privileged=true参数即可</p>
<h4 id="7、验证"><a href="#7、验证" class="headerlink" title="7、验证"></a>7、验证</h4><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095652.png"></p>
<h4 id="8、综合前-述容器卷测试的web服务test发布"><a href="#8、综合前-述容器卷测试的web服务test发布" class="headerlink" title="8、综合前 述容器卷测试的web服务test发布"></a>8、综合前 述容器卷测试的web服务test发布</h4><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095656.png"></p>
<p>web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1 .0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmIns:xsi</span>=<span class="string">"http://www.w3.org/2001/XML Schema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmIns</span>=<span class="string">"http://java sun.com/xm/ns/javaee"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaL</span> <span class="attr">ocation</span>=<span class="string">"http://java. sun.com/xml/ns/javaee htp:/:/java. sun.com/xml/ns/javaee/web-app_ 2_ _5.xsd"</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">"WebApp_ ID"</span> <span class="attr">version</span>=<span class="string">"2.5"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">display-name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>a.jsp</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC“<span class="comment">//W3C//DTD HTML 4.01 Transitional//EN" http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here &lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">welcome-</span><br><span class="line">&lt;%=<span class="string">"i am in docker tomcat self "</span>%&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;% System.out,.printIn(<span class="string">"==========docker tomcat self"</span>);%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/htmI&gt;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span> <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC“//W3C//DTD HTML 4.01 Transitional//EN" http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">welcome-</span><br><span class="line"><span class="tag">&lt;<span class="name">%="i</span> <span class="attr">am</span> <span class="attr">in</span> <span class="attr">docker</span> <span class="attr">tomcat</span> <span class="attr">self</span> "%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">System.out</span>,<span class="attr">.printIn</span>("==========<span class="string">docker</span> <span class="attr">tomcat</span> <span class="attr">self</span>");%&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">htmI</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="小总结-3"><a href="#小总结-3" class="headerlink" title="小总结"></a>小总结</h2><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095705.png"></p>
<h1 id="第七章-Docker常用安装"><a href="#第七章-Docker常用安装" class="headerlink" title="第七章 Docker常用安装"></a>第七章 Docker常用安装</h1><h2 id="总体步骤"><a href="#总体步骤" class="headerlink" title="总体步骤"></a>总体步骤</h2><blockquote>
<p>搜索镜像</p>
<p>拉取镜像</p>
<p>查看镜像</p>
<p>启动镜像</p>
<p>停止容器</p>
<p>移除容器</p>
</blockquote>
<h2 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h2><h3 id="docker-hub-上查找mysql镜像"><a href="#docker-hub-上查找mysql镜像" class="headerlink" title="docker hub 上查找mysql镜像"></a>docker hub 上查找mysql镜像</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095710.png"></p>
<h3 id="从-docker-hub-阿里云加速器-拉取mysql镜像到本地标签为5-6"><a href="#从-docker-hub-阿里云加速器-拉取mysql镜像到本地标签为5-6" class="headerlink" title="从 docker hub(阿里云加速器)拉取mysql镜像到本地标签为5.6"></a>从 docker hub(阿里云加速器)拉取mysql镜像到本地标签为5.6</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095713.png"></p>
<h3 id="使用mysql5-6镜像创建容器-也叫运行镜像"><a href="#使用mysql5-6镜像创建容器-也叫运行镜像" class="headerlink" title="使用mysql5.6镜像创建容器(也叫运行镜像)"></a>使用mysql5.6镜像创建容器(也叫运行镜像)</h3><p>使用mysql镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 12345:3306 --name mysql </span><br><span class="line">-v /ggcc/mysql/conf:/etc/mysql/conf.d </span><br><span class="line">-v /ggcc/mysql/logs:/logs </span><br><span class="line">-v /ggcc/mysql/data:/var/lib/mysql </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6</span><br><span class="line">----------------------------------------------</span><br><span class="line">命令说明:</span><br><span class="line">-p 12345:3306:将主机的12345端口映射到docker容器的3306端口。</span><br><span class="line">-name mysq:运行服务名字</span><br><span class="line">-V /ggcc/mysql/conf:/etc/mysql/conf.d :将主机/zzyyuse/mysq|录下的conf/my.cnf挂载到容器的/etc/mysql/conf.d</span><br><span class="line">-v /ggcc/mysqlogs/logs: 将主机/zzyyuse/mysq|目 录下的logs 目录挂载到容器的/logs。</span><br><span class="line">-V /ggcc/mysqldata:/var/lib/mysql :将主机lzzyyuse/mysql目录下的data目录挂载到容器的/var/lib/mysql .</span><br><span class="line">-e MYSQL_ ROOT_ PASSWORD=123456: 初始化root用户的密码。.</span><br><span class="line">-d mysql:5.6:后台程序运行mysql5.6 </span><br><span class="line">----------------------------------------------</span><br><span class="line">docker exec -it Mysql运行成功后的容器ID /bin/bash</span><br><span class="line">----------------------------------------------</span><br><span class="line">数据备份小测试</span><br><span class="line">docker exec mysql服务容器ID sh -c 'exec mysqldump --all-databases -uroot -p"123456"' &gt;/ggcc/all-database.sql</span><br></pre></td></tr></table></figure>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095717.png"></p>
<h3 id="数据备份测试"><a href="#数据备份测试" class="headerlink" title="数据备份测试"></a>数据备份测试</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095721.png"></p>
<h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><h3 id="从docker-hu上-阿里云加速器-拉取redis镜像到本地标签为：3-2"><a href="#从docker-hu上-阿里云加速器-拉取redis镜像到本地标签为：3-2" class="headerlink" title="从docker hu上(阿里云加速器)拉取redis镜像到本地标签为：3.2"></a>从docker hu上(阿里云加速器)拉取redis镜像到本地标签为：3.2</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095728.png"></p>
<h3 id="使用redis3-2镜像创建容器-也叫运行镜像"><a href="#使用redis3-2镜像创建容器-也叫运行镜像" class="headerlink" title="使用redis3.2镜像创建容器(也叫运行镜像)"></a>使用redis3.2镜像创建容器(也叫运行镜像)</h3><p>​    使用镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 6379:6379 -v /ggcc/myredis/data:/data -v /ggcc/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis redis-server /usr/local/etc/redis/redis.conf --appendonly yes</span><br></pre></td></tr></table></figure>
<h3 id="在主机-ggcc-myredis-conf-redis-conf目录上新建redis-conf文件"><a href="#在主机-ggcc-myredis-conf-redis-conf目录上新建redis-conf文件" class="headerlink" title="在主机/ggcc/myredis/conf/redis.conf目录上新建redis.conf文件"></a>在主机/ggcc/myredis/conf/redis.conf目录上新建redis.conf文件</h3><p>vim /ggcc/myredis/conf/redis.conf/redis.conf</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Redis configuration file example.</span><br><span class="line">#</span><br><span class="line"># Note that in order to read the configuration file, Redis must be</span><br><span class="line"># started with the file path as first argument:</span><br><span class="line">#</span><br><span class="line"># ./redis-server /path/to/redis.conf</span><br><span class="line"></span><br><span class="line"># Note on units: when memory size is needed, it is possible to specify</span><br><span class="line"># it in the usual form of 1k 5GB 4M and so forth:</span><br><span class="line">#</span><br><span class="line"># 1k =&gt; 1000 bytes</span><br><span class="line"># 1kb =&gt; 1024 bytes</span><br><span class="line"># 1m =&gt; 1000000 bytes</span><br><span class="line"># 1mb =&gt; 1024*1024 bytes</span><br><span class="line"># 1g =&gt; 1000000000 bytes</span><br><span class="line"># 1gb =&gt; 1024*1024*1024 bytes</span><br><span class="line">#</span><br><span class="line"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span><br><span class="line"></span><br><span class="line">################################## INCLUDES ###################################</span><br><span class="line"></span><br><span class="line"># Include one or more other config files here.  This is useful if you</span><br><span class="line"># have a standard template that goes to all Redis servers but also need</span><br><span class="line"># to customize a few per-server settings.  Include files can include</span><br><span class="line"># other files, so use this wisely.</span><br><span class="line">#</span><br><span class="line"># Notice option "include" won't be rewritten by command "CONFIG REWRITE"</span><br><span class="line"># from admin or Redis Sentinel. Since Redis always uses the last processed</span><br><span class="line"># line as value of a configuration directive, you'd better put includes</span><br><span class="line"># at the beginning of this file to avoid overwriting config change at runtime.</span><br><span class="line">#</span><br><span class="line"># If instead you are interested in using includes to override configuration</span><br><span class="line"># options, it is better to use include as the last line.</span><br><span class="line">#</span><br><span class="line"># include /path/to/local.conf</span><br><span class="line"># include /path/to/other.conf</span><br><span class="line"></span><br><span class="line">################################## MODULES #####################################</span><br><span class="line"></span><br><span class="line"># Load modules at startup. If the server is not able to load modules</span><br><span class="line"># it will abort. It is possible to use multiple loadmodule directives.</span><br><span class="line">#</span><br><span class="line"># loadmodule /path/to/my_module.so</span><br><span class="line"># loadmodule /path/to/other_module.so</span><br><span class="line"></span><br><span class="line">################################## NETWORK #####################################</span><br><span class="line"></span><br><span class="line"># By default, if no "bind" configuration directive is specified, Redis listens</span><br><span class="line"># for connections from all the network interfaces available on the server.</span><br><span class="line"># It is possible to listen to just one or multiple selected interfaces using</span><br><span class="line"># the "bind" configuration directive, followed by one or more IP addresses.</span><br><span class="line">#</span><br><span class="line"># Examples:</span><br><span class="line">#</span><br><span class="line"># bind 192.168.1.100 10.0.0.1</span><br><span class="line"># bind 127.0.0.1 ::1</span><br><span class="line">#</span><br><span class="line"># ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the</span><br><span class="line"># internet, binding to all the interfaces is dangerous and will expose the</span><br><span class="line"># instance to everybody on the internet. So by default we uncomment the</span><br><span class="line"># following bind directive, that will force Redis to listen only into</span><br><span class="line"># the IPv4 loopback interface address (this means Redis will be able to</span><br><span class="line"># accept connections only from clients running into the same computer it</span><br><span class="line"># is running).</span><br><span class="line">#</span><br><span class="line"># IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES</span><br><span class="line"># JUST COMMENT THE FOLLOWING LINE.</span><br><span class="line"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">#bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># Protected mode is a layer of security protection, in order to avoid that</span><br><span class="line"># Redis instances left open on the internet are accessed and exploited.</span><br><span class="line">#</span><br><span class="line"># When protected mode is on and if:</span><br><span class="line">#</span><br><span class="line"># 1) The server is not binding explicitly to a set of addresses using the</span><br><span class="line">#    "bind" directive.</span><br><span class="line"># 2) No password is configured.</span><br><span class="line">#</span><br><span class="line"># The server only accepts connections from clients connecting from the</span><br><span class="line"># IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain</span><br><span class="line"># sockets.</span><br><span class="line">#</span><br><span class="line"># By default protected mode is enabled. You should disable it only if</span><br><span class="line"># you are sure you want clients from other hosts to connect to Redis</span><br><span class="line"># even if no authentication is configured, nor a specific set of interfaces</span><br><span class="line"># are explicitly listed using the "bind" directive.</span><br><span class="line"><span class="keyword">protected</span>-mode yes</span><br><span class="line"></span><br><span class="line"># Accept connections on the specified port, default is 6379 (IANA #815344).</span><br><span class="line"># If port 0 is specified Redis will not listen on a TCP socket.</span><br><span class="line">port <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"># TCP listen() backlog.</span><br><span class="line">#</span><br><span class="line"># In high requests-per-second environments you need an high backlog in order</span><br><span class="line"># to avoid slow clients connections issues. Note that the Linux kernel</span><br><span class="line"># will silently truncate it to the value of /proc/sys/net/core/somaxconn so</span><br><span class="line"># make sure to raise both the value of somaxconn and tcp_max_syn_backlog</span><br><span class="line"># in order to get the desired effect.</span><br><span class="line">tcp-backlog <span class="number">511</span></span><br><span class="line"></span><br><span class="line"># Unix socket.</span><br><span class="line">#</span><br><span class="line"># Specify the path for the Unix socket that will be used to listen for</span><br><span class="line"># incoming connections. There is no default, so Redis will not listen</span><br><span class="line"># on a unix socket when not specified.</span><br><span class="line">#</span><br><span class="line"># unixsocket /tmp/redis.sock</span><br><span class="line"># unixsocketperm 700</span><br><span class="line"></span><br><span class="line"># Close the connection after a client is idle for N seconds (0 to disable)</span><br><span class="line">timeout <span class="number">0</span></span><br><span class="line"></span><br><span class="line"># TCP keepalive.</span><br><span class="line">#</span><br><span class="line"># If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence</span><br><span class="line"># of communication. This is useful for two reasons:</span><br><span class="line">#</span><br><span class="line"># 1) Detect dead peers.</span><br><span class="line"># 2) Take the connection alive from the point of view of network</span><br><span class="line">#    equipment in the middle.</span><br><span class="line">#</span><br><span class="line"># On Linux, the specified value (in seconds) is the period used to send ACKs.</span><br><span class="line"># Note that to close the connection the double of the time is needed.</span><br><span class="line"># On other kernels the period depends on the kernel configuration.</span><br><span class="line">#</span><br><span class="line"># A reasonable value for this option is 300 seconds, which is the new</span><br><span class="line"># Redis default starting with Redis 3.2.1.</span><br><span class="line">tcp-keepalive <span class="number">300</span></span><br><span class="line"></span><br><span class="line">################################# TLS/SSL #####################################</span><br><span class="line"></span><br><span class="line"># By default, TLS/SSL is disabled. To enable it, the "tls-port" configuration</span><br><span class="line"># directive can be used to define TLS-listening ports. To enable TLS on the</span><br><span class="line"># default port, use:</span><br><span class="line">#</span><br><span class="line"># port 0</span><br><span class="line"># tls-port 6379</span><br><span class="line"></span><br><span class="line"># Configure a X.509 certificate and private key to use for authenticating the</span><br><span class="line"># server to connected clients, masters or cluster peers.  These files should be</span><br><span class="line"># PEM formatted.</span><br><span class="line">#</span><br><span class="line"># tls-cert-file redis.crt </span><br><span class="line"># tls-key-file redis.key</span><br><span class="line"></span><br><span class="line"># Configure a DH parameters file to enable Diffie-Hellman (DH) key exchange:</span><br><span class="line">#</span><br><span class="line"># tls-dh-params-file redis.dh</span><br><span class="line"></span><br><span class="line"># Configure a CA certificate(s) bundle or directory to authenticate TLS/SSL</span><br><span class="line"># clients and peers.  Redis requires an explicit configuration of at least one</span><br><span class="line"># of these, and will not implicitly use the system wide configuration.</span><br><span class="line">#</span><br><span class="line"># tls-ca-cert-file ca.crt</span><br><span class="line"># tls-ca-cert-dir /etc/ssl/certs</span><br><span class="line"></span><br><span class="line"># By default, clients (including replica servers) on a TLS port are required</span><br><span class="line"># to authenticate using valid client side certificates.</span><br><span class="line">#</span><br><span class="line"># If "no" is specified, client certificates are not required and not accepted.</span><br><span class="line"># If "optional" is specified, client certificates are accepted and must be</span><br><span class="line"># valid if provided, but are not required.</span><br><span class="line">#</span><br><span class="line"># tls-auth-clients no</span><br><span class="line"># tls-auth-clients optional</span><br><span class="line"></span><br><span class="line"># By default, a Redis replica does not attempt to establish a TLS connection</span><br><span class="line"># with its master.</span><br><span class="line">#</span><br><span class="line"># Use the following directive to enable TLS on replication links.</span><br><span class="line">#</span><br><span class="line"># tls-replication yes</span><br><span class="line"></span><br><span class="line"># By default, the Redis Cluster bus uses a plain TCP connection. To enable</span><br><span class="line"># TLS for the bus protocol, use the following directive:</span><br><span class="line">#</span><br><span class="line"># tls-cluster yes</span><br><span class="line"></span><br><span class="line"># Explicitly specify TLS versions to support. Allowed values are case insensitive</span><br><span class="line"># and include "TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3" (OpenSSL &gt;= 1.1.1) or</span><br><span class="line"># any combination. To enable only TLSv1.2 and TLSv1.3, use:</span><br><span class="line">#</span><br><span class="line"># tls-protocols "TLSv1.2 TLSv1.3"</span><br><span class="line"></span><br><span class="line"># Configure allowed ciphers.  See the ciphers(1ssl) manpage for more information</span><br><span class="line"># about the syntax of this string.</span><br><span class="line">#</span><br><span class="line"># Note: this configuration applies only to &lt;= TLSv1.2.</span><br><span class="line">#</span><br><span class="line"># tls-ciphers DEFAULT:!MEDIUM</span><br><span class="line"></span><br><span class="line"># Configure allowed TLSv1.3 ciphersuites.  See the ciphers(1ssl) manpage for more</span><br><span class="line"># information about the syntax of this string, and specifically for TLSv1.3</span><br><span class="line"># ciphersuites.</span><br><span class="line">#</span><br><span class="line"># tls-ciphersuites TLS_CHACHA20_POLY1305_SHA256</span><br><span class="line"></span><br><span class="line"># When choosing a cipher, use the server's preference instead of the client</span><br><span class="line"># preference. By default, the server follows the client's preference.</span><br><span class="line">#</span><br><span class="line"># tls-prefer-server-ciphers yes</span><br><span class="line"></span><br><span class="line"># By default, TLS session caching is enabled to allow faster and less expensive</span><br><span class="line"># reconnections by clients that support it. Use the following directive to disable</span><br><span class="line"># caching.</span><br><span class="line">#</span><br><span class="line"># tls-session-caching no</span><br><span class="line"></span><br><span class="line"># Change the default number of TLS sessions cached. A zero value sets the cache</span><br><span class="line"># to unlimited size. The default size is 20480.</span><br><span class="line">#</span><br><span class="line"># tls-session-cache-size 5000</span><br><span class="line"></span><br><span class="line"># Change the default timeout of cached TLS sessions. The default timeout is 300</span><br><span class="line"># seconds.</span><br><span class="line">#</span><br><span class="line"># tls-session-cache-timeout 60</span><br><span class="line"></span><br><span class="line">################################# GENERAL #####################################</span><br><span class="line"></span><br><span class="line"># By default Redis does not run as a daemon. Use 'yes' if you need it.</span><br><span class="line"># Note that Redis will write a pid file in /var/run/redis.pid when daemonized.</span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"># If you run Redis from upstart or systemd, Redis can interact with your</span><br><span class="line"># supervision tree. Options:</span><br><span class="line">#   supervised no      - no supervision interaction</span><br><span class="line">#   supervised upstart - signal upstart by putting Redis into SIGSTOP mode</span><br><span class="line">#   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET</span><br><span class="line">#   supervised auto    - detect upstart or systemd method based on</span><br><span class="line">#                        UPSTART_JOB or NOTIFY_SOCKET environment variables</span><br><span class="line"># Note: these supervision methods only signal "process is ready."</span><br><span class="line">#       They do not enable continuous liveness pings back to your supervisor.</span><br><span class="line">supervised no</span><br><span class="line"></span><br><span class="line"># If a pid file is specified, Redis writes it where specified at startup</span><br><span class="line"># and removes it at exit.</span><br><span class="line">#</span><br><span class="line"># When the server runs non daemonized, no pid file is created if none is</span><br><span class="line"># specified in the configuration. When the server is daemonized, the pid file</span><br><span class="line"># is used even if not specified, defaulting to "/var/run/redis.pid".</span><br><span class="line">#</span><br><span class="line"># Creating a pid file is best effort: if Redis is not able to create it</span><br><span class="line"># nothing bad happens, the server will start and run normally.</span><br><span class="line">pidfile /<span class="keyword">var</span>/run/redis_6379.pid</span><br><span class="line"></span><br><span class="line"># Specify the server verbosity level.</span><br><span class="line"># This can be one of:</span><br><span class="line"># debug (a lot of information, useful for development/testing)</span><br><span class="line"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="line"># notice (moderately verbose, what you want in production probably)</span><br><span class="line"># warning (only very important / critical messages are logged)</span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line"># Specify the log file name. Also the empty string can be used to force</span><br><span class="line"># Redis to log on the standard output. Note that if you use standard</span><br><span class="line"># output for logging but daemonize, logs will be sent to /dev/null</span><br><span class="line">logfile <span class="string">""</span></span><br><span class="line"></span><br><span class="line"># To enable logging to the system logger, just set 'syslog-enabled' to yes,</span><br><span class="line"># and optionally update the other syslog parameters to suit your needs.</span><br><span class="line"># syslog-enabled no</span><br><span class="line"></span><br><span class="line"># Specify the syslog identity.</span><br><span class="line"># syslog-ident redis</span><br><span class="line"></span><br><span class="line"># Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.</span><br><span class="line"># syslog-facility local0</span><br><span class="line"></span><br><span class="line"># Set the number of databases. The default database is DB 0, you can select</span><br><span class="line"># a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span><br><span class="line"># dbid is a number between 0 and 'databases'-1</span><br><span class="line">databases <span class="number">16</span></span><br><span class="line"></span><br><span class="line"># By default Redis shows an ASCII art logo only when started to log to the</span><br><span class="line"># standard output and if the standard output is a TTY. Basically this means</span><br><span class="line"># that normally a logo is displayed only in interactive sessions.</span><br><span class="line">#</span><br><span class="line"># However it is possible to force the pre-4.0 behavior and always show a</span><br><span class="line"># ASCII art logo in startup logs by setting the following option to yes.</span><br><span class="line">always-show-logo yes</span><br><span class="line"></span><br><span class="line">################################ SNAPSHOTTING  ################################</span><br><span class="line">#</span><br><span class="line"># Save the DB on disk:</span><br><span class="line">#</span><br><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#</span><br><span class="line">#   Will save the DB if both the given number of seconds and the given</span><br><span class="line">#   number of write operations against the DB occurred.</span><br><span class="line">#</span><br><span class="line">#   In the example below the behaviour will be to save:</span><br><span class="line">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">#   after 60 sec if at least 10000 keys changed</span><br><span class="line">#</span><br><span class="line">#   Note: you can disable saving completely by commenting out all "save" lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save ""</span><br><span class="line"></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"># By default Redis will stop accepting writes if RDB snapshots are enabled</span><br><span class="line"># (at least one save point) and the latest background save failed.</span><br><span class="line"># This will make the user aware (in a hard way) that data is not persisting</span><br><span class="line"># on disk properly, otherwise chances are that no one will notice and some</span><br><span class="line"># disaster will happen.</span><br><span class="line">#</span><br><span class="line"># If the background saving process will start working again Redis will</span><br><span class="line"># automatically allow writes again.</span><br><span class="line">#</span><br><span class="line"># However if you have setup your proper monitoring of the Redis server</span><br><span class="line"># and persistence, you may want to disable this feature so that Redis will</span><br><span class="line"># continue to work as usual even if there are problems with disk,</span><br><span class="line"># permissions, and so forth.</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># Compress string objects using LZF when dump .rdb databases?</span><br><span class="line"># For default that's set to 'yes' as it's almost always a win.</span><br><span class="line"># If you want to save some CPU in the saving child set it to 'no' but</span><br><span class="line"># the dataset will likely be bigger if you have compressible values or keys.</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span><br><span class="line"># This makes the format more resistant to corruption but there is a performance</span><br><span class="line"># hit to pay (around 10%) when saving and loading RDB files, so you can disable it</span><br><span class="line"># for maximum performances.</span><br><span class="line">#</span><br><span class="line"># RDB files created with checksum disabled have a checksum of zero that will</span><br><span class="line"># tell the loading code to skip the check.</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"># The filename where to dump the DB</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># Remove RDB files used by replication in instances without persistence</span><br><span class="line"># enabled. By default this option is disabled, however there are environments</span><br><span class="line"># where for regulations or other security concerns, RDB files persisted on</span><br><span class="line"># disk by masters in order to feed replicas, or stored on disk by replicas</span><br><span class="line"># in order to load them for the initial synchronization, should be deleted</span><br><span class="line"># ASAP. Note that this option ONLY WORKS in instances that have both AOF</span><br><span class="line"># and RDB persistence disabled, otherwise is completely ignored.</span><br><span class="line">#</span><br><span class="line"># An alternative (and sometimes better) way to obtain the same effect is</span><br><span class="line"># to use diskless replication on both master and replicas instances. However</span><br><span class="line"># in the case of replicas, diskless is not always an option.</span><br><span class="line">rdb-del-sync-files no</span><br><span class="line"></span><br><span class="line"># The working directory.</span><br><span class="line">#</span><br><span class="line"># The DB will be written inside this directory, with the filename specified</span><br><span class="line"># above using the 'dbfilename' configuration directive.</span><br><span class="line">#</span><br><span class="line"># The Append Only File will also be created inside this directory.</span><br><span class="line">#</span><br><span class="line"># Note that you must specify a directory here, not a file name.</span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line">################################# REPLICATION #################################</span><br><span class="line"></span><br><span class="line"># Master-Replica replication. Use replicaof to make a Redis instance a copy of</span><br><span class="line"># another Redis server. A few things to understand ASAP about Redis replication.</span><br><span class="line">#</span><br><span class="line">#   +------------------+      +---------------+</span><br><span class="line">#   |      Master      | ---&gt; |    Replica    |</span><br><span class="line">#   | (receive writes) |      |  (exact copy) |</span><br><span class="line">#   +------------------+      +---------------+</span><br><span class="line">#</span><br><span class="line"># 1) Redis replication is asynchronous, but you can configure a master to</span><br><span class="line">#    stop accepting writes if it appears to be not connected with at least</span><br><span class="line">#    a given number of replicas.</span><br><span class="line"># 2) Redis replicas are able to perform a partial resynchronization with the</span><br><span class="line">#    master if the replication link is lost for a relatively small amount of</span><br><span class="line">#    time. You may want to configure the replication backlog size (see the next</span><br><span class="line">#    sections of this file) with a sensible value depending on your needs.</span><br><span class="line"># 3) Replication is automatic and does not need user intervention. After a</span><br><span class="line">#    network partition replicas automatically try to reconnect to masters</span><br><span class="line">#    and resynchronize with them.</span><br><span class="line">#</span><br><span class="line"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line"># If the master is password protected (using the "requirepass" configuration</span><br><span class="line"># directive below) it is possible to tell the replica to authenticate before</span><br><span class="line"># starting the replication synchronization process, otherwise the master will</span><br><span class="line"># refuse the replica request.</span><br><span class="line">#</span><br><span class="line"># masterauth &lt;master-password&gt;</span><br><span class="line">#</span><br><span class="line"># However this is not enough if you are using Redis ACLs (for Redis version</span><br><span class="line"># 6 or greater), and the default user is not capable of running the PSYNC</span><br><span class="line"># command and/or other commands needed for replication. In this case it's</span><br><span class="line"># better to configure a special user to use with replication, and specify the</span><br><span class="line"># masteruser configuration as such:</span><br><span class="line">#</span><br><span class="line"># masteruser &lt;username&gt;</span><br><span class="line">#</span><br><span class="line"># When masteruser is specified, the replica will authenticate against its</span><br><span class="line"># master using the new AUTH form: AUTH &lt;username&gt; &lt;password&gt;.</span><br><span class="line"></span><br><span class="line"># When a replica loses its connection with the master, or when the replication</span><br><span class="line"># is still in progress, the replica can act in two different ways:</span><br><span class="line">#</span><br><span class="line"># 1) if replica-serve-stale-data is set to 'yes' (the default) the replica will</span><br><span class="line">#    still reply to client requests, possibly with out of date data, or the</span><br><span class="line">#    data set may just be empty if this is the first synchronization.</span><br><span class="line">#</span><br><span class="line"># 2) if replica-serve-stale-data is set to 'no' the replica will reply with</span><br><span class="line">#    an error "SYNC with master in progress" to all the kind of commands</span><br><span class="line">#    but to INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,</span><br><span class="line">#    SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,</span><br><span class="line">#    COMMAND, POST, HOST: and LATENCY.</span><br><span class="line">#</span><br><span class="line">replica-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"># You can configure a replica instance to accept writes or not. Writing against</span><br><span class="line"># a replica instance may be useful to store some ephemeral data (because data</span><br><span class="line"># written on a replica will be easily deleted after resync with the master) but</span><br><span class="line"># may also cause problems if clients are writing to it because of a</span><br><span class="line"># misconfiguration.</span><br><span class="line">#</span><br><span class="line"># Since Redis 2.6 by default replicas are read-only.</span><br><span class="line">#</span><br><span class="line"># Note: read only replicas are not designed to be exposed to untrusted clients</span><br><span class="line"># on the internet. It's just a protection layer against misuse of the instance.</span><br><span class="line"># Still a read only replica exports by default all the administrative commands</span><br><span class="line"># such as CONFIG, DEBUG, and so forth. To a limited extent you can improve</span><br><span class="line"># security of read only replicas using 'rename-command' to shadow all the</span><br><span class="line"># administrative / dangerous commands.</span><br><span class="line">replica-read-only yes</span><br><span class="line"></span><br><span class="line"># Replication SYNC strategy: disk or socket.</span><br><span class="line">#</span><br><span class="line"># New replicas and reconnecting replicas that are not able to continue the</span><br><span class="line"># replication process just receiving differences, need to do what is called a</span><br><span class="line"># "full synchronization". An RDB file is transmitted from the master to the</span><br><span class="line"># replicas.</span><br><span class="line">#</span><br><span class="line"># The transmission can happen in two different ways:</span><br><span class="line">#</span><br><span class="line"># 1) Disk-backed: The Redis master creates a new process that writes the RDB</span><br><span class="line">#                 file on disk. Later the file is transferred by the parent</span><br><span class="line">#                 process to the replicas incrementally.</span><br><span class="line"># 2) Diskless: The Redis master creates a new process that directly writes the</span><br><span class="line">#              RDB file to replica sockets, without touching the disk at all.</span><br><span class="line">#</span><br><span class="line"># With disk-backed replication, while the RDB file is generated, more replicas</span><br><span class="line"># can be queued and served with the RDB file as soon as the current child</span><br><span class="line"># producing the RDB file finishes its work. With diskless replication instead</span><br><span class="line"># once the transfer starts, new replicas arriving will be queued and a new</span><br><span class="line"># transfer will start when the current one terminates.</span><br><span class="line">#</span><br><span class="line"># When diskless replication is used, the master waits a configurable amount of</span><br><span class="line"># time (in seconds) before starting the transfer in the hope that multiple</span><br><span class="line"># replicas will arrive and the transfer can be parallelized.</span><br><span class="line">#</span><br><span class="line"># With slow disks and fast (large bandwidth) networks, diskless replication</span><br><span class="line"># works better.</span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"># When diskless replication is enabled, it is possible to configure the delay</span><br><span class="line"># the server waits in order to spawn the child that transfers the RDB via socket</span><br><span class="line"># to the replicas.</span><br><span class="line">#</span><br><span class="line"># This is important since once the transfer starts, it is not possible to serve</span><br><span class="line"># new replicas arriving, that will be queued for the next RDB transfer, so the</span><br><span class="line"># server waits a delay in order to let more replicas arrive.</span><br><span class="line">#</span><br><span class="line"># The delay is specified in seconds, and by default is 5 seconds. To disable</span><br><span class="line"># it entirely just set it to 0 seconds and the transfer will start ASAP.</span><br><span class="line">repl-diskless-sync-delay <span class="number">5</span></span><br><span class="line"></span><br><span class="line"># -----------------------------------------------------------------------------</span><br><span class="line"># WARNING: RDB diskless load is experimental. Since in this setup the replica</span><br><span class="line"># does not immediately store an RDB on disk, it may cause data loss during</span><br><span class="line"># failovers. RDB diskless load + Redis modules not handling I/O reads may also</span><br><span class="line"># cause Redis to abort in case of I/O errors during the initial synchronization</span><br><span class="line"># stage with the master. Use only if your do what you are doing.</span><br><span class="line"># -----------------------------------------------------------------------------</span><br><span class="line">#</span><br><span class="line"># Replica can load the RDB it reads from the replication link directly from the</span><br><span class="line"># socket, or store the RDB to a file and read that file after it was completely</span><br><span class="line"># recived from the master.</span><br><span class="line">#</span><br><span class="line"># In many cases the disk is slower than the network, and storing and loading</span><br><span class="line"># the RDB file may increase replication time (and even increase the master's</span><br><span class="line"># Copy on Write memory and salve buffers).</span><br><span class="line"># However, parsing the RDB file directly from the socket may mean that we have</span><br><span class="line"># to flush the contents of the current database before the full rdb was</span><br><span class="line"># received. For this reason we have the following options:</span><br><span class="line">#</span><br><span class="line"># "disabled"    - Don't use diskless load (store the rdb file to the disk first)</span><br><span class="line"># "on-empty-db" - Use diskless load only when it is completely safe.</span><br><span class="line"># "swapdb"      - Keep a copy of the current db contents in RAM while parsing</span><br><span class="line">#                 the data directly from the socket. note that this requires</span><br><span class="line">#                 sufficient memory, if you don't have it, you risk an OOM kill.</span><br><span class="line">repl-diskless-load disabled</span><br><span class="line"></span><br><span class="line"># Replicas send PINGs to server in a predefined interval. It's possible to</span><br><span class="line"># change this interval with the repl_ping_replica_period option. The default</span><br><span class="line"># value is 10 seconds.</span><br><span class="line">#</span><br><span class="line"># repl-ping-replica-period 10</span><br><span class="line"></span><br><span class="line"># The following option sets the replication timeout for:</span><br><span class="line">#</span><br><span class="line"># 1) Bulk transfer I/O during SYNC, from the point of view of replica.</span><br><span class="line"># 2) Master timeout from the point of view of replicas (data, pings).</span><br><span class="line"># 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).</span><br><span class="line">#</span><br><span class="line"># It is important to make sure that this value is greater than the value</span><br><span class="line"># specified for repl-ping-replica-period otherwise a timeout will be detected</span><br><span class="line"># every time there is low traffic between the master and the replica.</span><br><span class="line">#</span><br><span class="line"># repl-timeout 60</span><br><span class="line"></span><br><span class="line"># Disable TCP_NODELAY on the replica socket after SYNC?</span><br><span class="line">#</span><br><span class="line"># If you select "yes" Redis will use a smaller number of TCP packets and</span><br><span class="line"># less bandwidth to send data to replicas. But this can add a delay for</span><br><span class="line"># the data to appear on the replica side, up to 40 milliseconds with</span><br><span class="line"># Linux kernels using a default configuration.</span><br><span class="line">#</span><br><span class="line"># If you select "no" the delay for data to appear on the replica side will</span><br><span class="line"># be reduced but more bandwidth will be used for replication.</span><br><span class="line">#</span><br><span class="line"># By default we optimize for low latency, but in very high traffic conditions</span><br><span class="line"># or when the master and replicas are many hops away, turning this to "yes" may</span><br><span class="line"># be a good idea.</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"># Set the replication backlog size. The backlog is a buffer that accumulates</span><br><span class="line"># replica data when replicas are disconnected for some time, so that when a</span><br><span class="line"># replica wants to reconnect again, often a full resync is not needed, but a</span><br><span class="line"># partial resync is enough, just passing the portion of data the replica</span><br><span class="line"># missed while disconnected.</span><br><span class="line">#</span><br><span class="line"># The bigger the replication backlog, the longer the time the replica can be</span><br><span class="line"># disconnected and later be able to perform a partial resynchronization.</span><br><span class="line">#</span><br><span class="line"># The backlog is only allocated once there is at least a replica connected.</span><br><span class="line">#</span><br><span class="line"># repl-backlog-size 1mb</span><br><span class="line"></span><br><span class="line"># After a master has no longer connected replicas for some time, the backlog</span><br><span class="line"># will be freed. The following option configures the amount of seconds that</span><br><span class="line"># need to elapse, starting from the time the last replica disconnected, for</span><br><span class="line"># the backlog buffer to be freed.</span><br><span class="line">#</span><br><span class="line"># Note that replicas never free the backlog for timeout, since they may be</span><br><span class="line"># promoted to masters later, and should be able to correctly "partially</span><br><span class="line"># resynchronize" with the replicas: hence they should always accumulate backlog.</span><br><span class="line">#</span><br><span class="line"># A value of 0 means to never release the backlog.</span><br><span class="line">#</span><br><span class="line"># repl-backlog-ttl 3600</span><br><span class="line"></span><br><span class="line"># The replica priority is an integer number published by Redis in the INFO</span><br><span class="line"># output. It is used by Redis Sentinel in order to select a replica to promote</span><br><span class="line"># into a master if the master is no longer working correctly.</span><br><span class="line">#</span><br><span class="line"># A replica with a low priority number is considered better for promotion, so</span><br><span class="line"># for instance if there are three replicas with priority 10, 100, 25 Sentinel</span><br><span class="line"># will pick the one with priority 10, that is the lowest.</span><br><span class="line">#</span><br><span class="line"># However a special priority of 0 marks the replica as not able to perform the</span><br><span class="line"># role of master, so a replica with priority of 0 will never be selected by</span><br><span class="line"># Redis Sentinel for promotion.</span><br><span class="line">#</span><br><span class="line"># By default the priority is 100.</span><br><span class="line">replica-priority <span class="number">100</span></span><br><span class="line"></span><br><span class="line"># It is possible for a master to stop accepting writes if there are less than</span><br><span class="line"># N replicas connected, having a lag less or equal than M seconds.</span><br><span class="line">#</span><br><span class="line"># The N replicas need to be in "online" state.</span><br><span class="line">#</span><br><span class="line"># The lag in seconds, that must be &lt;= the specified value, is calculated from</span><br><span class="line"># the last ping received from the replica, that is usually sent every second.</span><br><span class="line">#</span><br><span class="line"># This option does not GUARANTEE that N replicas will accept the write, but</span><br><span class="line"># will limit the window of exposure for lost writes in case not enough replicas</span><br><span class="line"># are available, to the specified number of seconds.</span><br><span class="line">#</span><br><span class="line"># For example to require at least 3 replicas with a lag &lt;= 10 seconds use:</span><br><span class="line">#</span><br><span class="line"># min-replicas-to-write 3</span><br><span class="line"># min-replicas-max-lag 10</span><br><span class="line">#</span><br><span class="line"># Setting one or the other to 0 disables the feature.</span><br><span class="line">#</span><br><span class="line"># By default min-replicas-to-write is set to 0 (feature disabled) and</span><br><span class="line"># min-replicas-max-lag is set to 10.</span><br><span class="line"></span><br><span class="line"># A Redis master is able to list the address and port of the attached</span><br><span class="line"># replicas in different ways. For example the "INFO replication" section</span><br><span class="line"># offers this information, which is used, among other tools, by</span><br><span class="line"># Redis Sentinel in order to discover replica instances.</span><br><span class="line"># Another place where this info is available is in the output of the</span><br><span class="line"># "ROLE" command of a master.</span><br><span class="line">#</span><br><span class="line"># The listed IP and address normally reported by a replica is obtained</span><br><span class="line"># in the following way:</span><br><span class="line">#</span><br><span class="line">#   IP: The address is auto detected by checking the peer address</span><br><span class="line">#   of the socket used by the replica to connect with the master.</span><br><span class="line">#</span><br><span class="line">#   Port: The port is communicated by the replica during the replication</span><br><span class="line">#   handshake, and is normally the port that the replica is using to</span><br><span class="line">#   listen for connections.</span><br><span class="line">#</span><br><span class="line"># However when port forwarding or Network Address Translation (NAT) is</span><br><span class="line"># used, the replica may be actually reachable via different IP and port</span><br><span class="line"># pairs. The following two options can be used by a replica in order to</span><br><span class="line"># report to its master a specific set of IP and port, so that both INFO</span><br><span class="line"># and ROLE will report those values.</span><br><span class="line">#</span><br><span class="line"># There is no need to use both the options if you need to override just</span><br><span class="line"># the port or the IP address.</span><br><span class="line">#</span><br><span class="line"># replica-announce-ip 5.5.5.5</span><br><span class="line"># replica-announce-port 1234</span><br><span class="line"></span><br><span class="line">############################### KEYS TRACKING #################################</span><br><span class="line"></span><br><span class="line"># Redis implements server assisted support for client side caching of values.</span><br><span class="line"># This is implemented using an invalidation table that remembers, using</span><br><span class="line"># 16 millions of slots, what clients may have certain subsets of keys. In turn</span><br><span class="line"># this is used in order to send invalidation messages to clients. Please</span><br><span class="line"># to understand more about the feature check this page:</span><br><span class="line">#</span><br><span class="line">#   https://redis.io/topics/client-side-caching</span><br><span class="line">#</span><br><span class="line"># When tracking is enabled for a client, all the read only queries are assumed</span><br><span class="line"># to be cached: this will force Redis to store information in the invalidation</span><br><span class="line"># table. When keys are modified, such information is flushed away, and</span><br><span class="line"># invalidation messages are sent to the clients. However if the workload is</span><br><span class="line"># heavily dominated by reads, Redis could use more and more memory in order</span><br><span class="line"># to track the keys fetched by many clients.</span><br><span class="line">#</span><br><span class="line"># For this reason it is possible to configure a maximum fill value for the</span><br><span class="line"># invalidation table. By default it is set to 1M of keys, and once this limit</span><br><span class="line"># is reached, Redis will start to evict keys in the invalidation table</span><br><span class="line"># even if they were not modified, just to reclaim memory: this will in turn</span><br><span class="line"># force the clients to invalidate the cached values. Basically the table</span><br><span class="line"># maximum size is a trade off between the memory you want to spend server</span><br><span class="line"># side to track information about who cached what, and the ability of clients</span><br><span class="line"># to retain cached objects in memory.</span><br><span class="line">#</span><br><span class="line"># If you set the value to 0, it means there are no limits, and Redis will</span><br><span class="line"># retain as many keys as needed in the invalidation table.</span><br><span class="line"># In the "stats" INFO section, you can find information about the number of</span><br><span class="line"># keys in the invalidation table at every given moment.</span><br><span class="line">#</span><br><span class="line"># Note: when key tracking is used in broadcasting mode, no memory is used</span><br><span class="line"># in the server side so this setting is useless.</span><br><span class="line">#</span><br><span class="line"># tracking-table-max-keys 1000000</span><br><span class="line"></span><br><span class="line">################################## SECURITY ###################################</span><br><span class="line"></span><br><span class="line"># Warning: since Redis is pretty fast an outside user can try up to</span><br><span class="line"># 1 million passwords per second against a modern box. This means that you</span><br><span class="line"># should use very strong passwords, otherwise they will be very easy to break.</span><br><span class="line"># Note that because the password is really a shared secret between the client</span><br><span class="line"># and the server, and should not be memorized by any human, the password</span><br><span class="line"># can be easily a long string from /dev/urandom or whatever, so by using a</span><br><span class="line"># long and unguessable password no brute force attack will be possible.</span><br><span class="line"></span><br><span class="line"># Redis ACL users are defined in the following format:</span><br><span class="line">#</span><br><span class="line">#   user &lt;username&gt; ... acl rules ...</span><br><span class="line">#</span><br><span class="line"># For example:</span><br><span class="line">#</span><br><span class="line">#   user worker +@list +@connection ~jobs:* on &gt;ffa9203c493aa99</span><br><span class="line">#</span><br><span class="line"># The special username "default" is used for new connections. If this user</span><br><span class="line"># has the "nopass" rule, then new connections will be immediately authenticated</span><br><span class="line"># as the "default" user without the need of any password provided via the</span><br><span class="line"># AUTH command. Otherwise if the "default" user is not flagged with "nopass"</span><br><span class="line"># the connections will start in not authenticated state, and will require</span><br><span class="line"># AUTH (or the HELLO command AUTH option) in order to be authenticated and</span><br><span class="line"># start to work.</span><br><span class="line">#</span><br><span class="line"># The ACL rules that describe what an user can do are the following:</span><br><span class="line">#</span><br><span class="line">#  on           Enable the user: it is possible to authenticate as this user.</span><br><span class="line">#  off          Disable the user: it's no longer possible to authenticate</span><br><span class="line">#               with this user, however the already authenticated connections</span><br><span class="line">#               will still work.</span><br><span class="line">#  +&lt;command&gt;   Allow the execution of that command</span><br><span class="line">#  -&lt;command&gt;   Disallow the execution of that command</span><br><span class="line">#  +@&lt;category&gt; Allow the execution of all the commands in such category</span><br><span class="line">#               with valid categories are like @admin, @set, @sortedset, ...</span><br><span class="line">#               and so forth, see the full list in the server.c file where</span><br><span class="line">#               the Redis command table is described and defined.</span><br><span class="line">#               The special category @all means all the commands, but currently</span><br><span class="line">#               present in the server, and that will be loaded in the future</span><br><span class="line">#               via modules.</span><br><span class="line">#  +&lt;command&gt;|subcommand    Allow a specific subcommand of an otherwise</span><br><span class="line">#                           disabled command. Note that this form is not</span><br><span class="line">#                           allowed as negative like -DEBUG|SEGFAULT, but</span><br><span class="line">#                           only additive starting with "+".</span><br><span class="line">#  allcommands  Alias for +@all. Note that it implies the ability to execute</span><br><span class="line">#               all the future commands loaded via the modules system.</span><br><span class="line">#  nocommands   Alias for -@all.</span><br><span class="line">#  ~&lt;pattern&gt;   Add a pattern of keys that can be mentioned as part of</span><br><span class="line">#               commands. For instance ~* allows all the keys. The pattern</span><br><span class="line">#               is a glob-style pattern like the one of KEYS.</span><br><span class="line">#               It is possible to specify multiple patterns.</span><br><span class="line">#  allkeys      Alias for ~*</span><br><span class="line">#  resetkeys    Flush the list of allowed keys patterns.</span><br><span class="line">#  &gt;&lt;password&gt;  Add this passowrd to the list of valid password for the user.</span><br><span class="line">#               For example &gt;mypass will add "mypass" to the list.</span><br><span class="line">#               This directive clears the "nopass" flag (see later).</span><br><span class="line">#  &lt;&lt;password&gt;  Remove this password from the list of valid passwords.</span><br><span class="line">#  nopass       All the set passwords of the user are removed, and the user</span><br><span class="line">#               is flagged as requiring no password: it means that every</span><br><span class="line">#               password will work against this user. If this directive is</span><br><span class="line">#               used for the default user, every new connection will be</span><br><span class="line">#               immediately authenticated with the default user without</span><br><span class="line">#               any explicit AUTH command required. Note that the "resetpass"</span><br><span class="line">#               directive will clear this condition.</span><br><span class="line">#  resetpass    Flush the list of allowed passwords. Moreover removes the</span><br><span class="line">#               "nopass" status. After "resetpass" the user has no associated</span><br><span class="line">#               passwords and there is no way to authenticate without adding</span><br><span class="line">#               some password (or setting it as "nopass" later).</span><br><span class="line">#  reset        Performs the following actions: resetpass, resetkeys, off,</span><br><span class="line">#               -@all. The user returns to the same state it has immediately</span><br><span class="line">#               after its creation.</span><br><span class="line">#</span><br><span class="line"># ACL rules can be specified in any order: for instance you can start with</span><br><span class="line"># passwords, then flags, or key patterns. However note that the additive</span><br><span class="line"># and subtractive rules will CHANGE MEANING depending on the ordering.</span><br><span class="line"># For instance see the following example:</span><br><span class="line">#</span><br><span class="line">#   user alice on +@all -DEBUG ~* &gt;somepassword</span><br><span class="line">#</span><br><span class="line"># This will allow "alice" to use all the commands with the exception of the</span><br><span class="line"># DEBUG command, since +@all added all the commands to the set of the commands</span><br><span class="line"># alice can use, and later DEBUG was removed. However if we invert the order</span><br><span class="line"># of two ACL rules the result will be different:</span><br><span class="line">#</span><br><span class="line">#   user alice on -DEBUG +@all ~* &gt;somepassword</span><br><span class="line">#</span><br><span class="line"># Now DEBUG was removed when alice had yet no commands in the set of allowed</span><br><span class="line"># commands, later all the commands are added, so the user will be able to</span><br><span class="line"># execute everything.</span><br><span class="line">#</span><br><span class="line"># Basically ACL rules are processed left-to-right.</span><br><span class="line">#</span><br><span class="line"># For more information about ACL configuration please refer to</span><br><span class="line"># the Redis web site at https://redis.io/topics/acl</span><br><span class="line"></span><br><span class="line"># ACL LOG</span><br><span class="line">#</span><br><span class="line"># The ACL Log tracks failed commands and authentication events associated</span><br><span class="line"># with ACLs. The ACL Log is useful to troubleshoot failed commands blocked </span><br><span class="line"># by ACLs. The ACL Log is stored in memory. You can reclaim memory with </span><br><span class="line"># ACL LOG RESET. Define the maximum entry length of the ACL Log below.</span><br><span class="line">acllog-max-len <span class="number">128</span></span><br><span class="line"></span><br><span class="line"># Using an external ACL file</span><br><span class="line">#</span><br><span class="line"># Instead of configuring users here in this file, it is possible to use</span><br><span class="line"># a stand-alone file just listing users. The two methods cannot be mixed:</span><br><span class="line"># if you configure users here and at the same time you activate the exteranl</span><br><span class="line"># ACL file, the server will refuse to start.</span><br><span class="line">#</span><br><span class="line"># The format of the external ACL user file is exactly the same as the</span><br><span class="line"># format that is used inside redis.conf to describe users.</span><br><span class="line">#</span><br><span class="line"># aclfile /etc/redis/users.acl</span><br><span class="line"></span><br><span class="line"># IMPORTANT NOTE: starting with Redis 6 "requirepass" is just a compatiblity</span><br><span class="line"># layer on top of the new ACL system. The option effect will be just setting</span><br><span class="line"># the password for the default user. Clients will still authenticate using</span><br><span class="line"># AUTH &lt;password&gt; as usually, or more explicitly with AUTH default &lt;password&gt;</span><br><span class="line"># if they follow the new protocol: both will work.</span><br><span class="line">#</span><br><span class="line"># requirepass foobared</span><br><span class="line"></span><br><span class="line"># Command renaming (DEPRECATED).</span><br><span class="line">#</span><br><span class="line"># ------------------------------------------------------------------------</span><br><span class="line"># WARNING: avoid using this option if possible. Instead use ACLs to remove</span><br><span class="line"># commands from the default user, and put them only in some admin user you</span><br><span class="line"># create for administrative purposes.</span><br><span class="line"># ------------------------------------------------------------------------</span><br><span class="line">#</span><br><span class="line"># It is possible to change the name of dangerous commands in a shared</span><br><span class="line"># environment. For instance the CONFIG command may be renamed into something</span><br><span class="line"># hard to guess so that it will still be available for internal-use tools</span><br><span class="line"># but not available for general clients.</span><br><span class="line">#</span><br><span class="line"># Example:</span><br><span class="line">#</span><br><span class="line"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="line">#</span><br><span class="line"># It is also possible to completely kill a command by renaming it into</span><br><span class="line"># an empty string:</span><br><span class="line">#</span><br><span class="line"># rename-command CONFIG ""</span><br><span class="line">#</span><br><span class="line"># Please note that changing the name of commands that are logged into the</span><br><span class="line"># AOF file or transmitted to replicas may cause problems.</span><br><span class="line"></span><br><span class="line">################################### CLIENTS ####################################</span><br><span class="line"></span><br><span class="line"># Set the max number of connected clients at the same time. By default</span><br><span class="line"># this limit is set to 10000 clients, however if the Redis server is not</span><br><span class="line"># able to configure the process file limit to allow for the specified limit</span><br><span class="line"># the max number of allowed clients is set to the current file limit</span><br><span class="line"># minus 32 (as Redis reserves a few file descriptors for internal uses).</span><br><span class="line">#</span><br><span class="line"># Once the limit is reached Redis will close all the new connections sending</span><br><span class="line"># an error 'max number of clients reached'.</span><br><span class="line">#</span><br><span class="line"># IMPORTANT: When Redis Cluster is used, the max number of connections is also</span><br><span class="line"># shared with the cluster bus: every node in the cluster will use two</span><br><span class="line"># connections, one incoming and another outgoing. It is important to size the</span><br><span class="line"># limit accordingly in case of very large clusters.</span><br><span class="line">#</span><br><span class="line"># maxclients 10000</span><br><span class="line"></span><br><span class="line">############################## MEMORY MANAGEMENT ################################</span><br><span class="line"></span><br><span class="line"># Set a memory usage limit to the specified amount of bytes.</span><br><span class="line"># When the memory limit is reached Redis will try to remove keys</span><br><span class="line"># according to the eviction policy selected (see maxmemory-policy).</span><br><span class="line">#</span><br><span class="line"># If Redis can't remove keys according to the policy, or if the policy is</span><br><span class="line"># set to 'noeviction', Redis will start to reply with errors to commands</span><br><span class="line"># that would use more memory, like SET, LPUSH, and so on, and will continue</span><br><span class="line"># to reply to read-only commands like GET.</span><br><span class="line">#</span><br><span class="line"># This option is usually useful when using Redis as an LRU or LFU cache, or to</span><br><span class="line"># set a hard memory limit for an instance (using the 'noeviction' policy).</span><br><span class="line">#</span><br><span class="line"># WARNING: If you have replicas attached to an instance with maxmemory on,</span><br><span class="line"># the size of the output buffers needed to feed the replicas are subtracted</span><br><span class="line"># from the used memory count, so that network problems / resyncs will</span><br><span class="line"># not trigger a loop where keys are evicted, and in turn the output</span><br><span class="line"># buffer of replicas is full with DELs of keys evicted triggering the deletion</span><br><span class="line"># of more keys, and so forth until the database is completely emptied.</span><br><span class="line">#</span><br><span class="line"># In short... if you have replicas attached it is suggested that you set a lower</span><br><span class="line"># limit for maxmemory so that there is some free RAM on the system for replica</span><br><span class="line"># output buffers (but this is not needed if the policy is 'noeviction').</span><br><span class="line">#</span><br><span class="line"># maxmemory &lt;bytes&gt;</span><br><span class="line"></span><br><span class="line"># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span><br><span class="line"># is reached. You can select one from the following behaviors:</span><br><span class="line">#</span><br><span class="line"># volatile-lru -&gt; Evict using approximated LRU, only keys with an expire set.</span><br><span class="line"># allkeys-lru -&gt; Evict any key using approximated LRU.</span><br><span class="line"># volatile-lfu -&gt; Evict using approximated LFU, only keys with an expire set.</span><br><span class="line"># allkeys-lfu -&gt; Evict any key using approximated LFU.</span><br><span class="line"># volatile-random -&gt; Remove a random key having an expire set.</span><br><span class="line"># allkeys-random -&gt; Remove a random key, any key.</span><br><span class="line"># volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</span><br><span class="line"># noeviction -&gt; Don't evict anything, just return an error on write operations.</span><br><span class="line">#</span><br><span class="line"># LRU means Least Recently Used</span><br><span class="line"># LFU means Least Frequently Used</span><br><span class="line">#</span><br><span class="line"># Both LRU, LFU and volatile-ttl are implemented using approximated</span><br><span class="line"># randomized algorithms.</span><br><span class="line">#</span><br><span class="line"># Note: with any of the above policies, Redis will return an error on write</span><br><span class="line">#       operations, when there are no suitable keys for eviction.</span><br><span class="line">#</span><br><span class="line">#       At the date of writing these commands are: set setnx setex append</span><br><span class="line">#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span><br><span class="line">#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span><br><span class="line">#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span><br><span class="line">#       getset mset msetnx exec sort</span><br><span class="line">#</span><br><span class="line"># The default is:</span><br><span class="line">#</span><br><span class="line"># maxmemory-policy noeviction</span><br><span class="line"></span><br><span class="line"># LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated</span><br><span class="line"># algorithms (in order to save memory), so you can tune it for speed or</span><br><span class="line"># accuracy. For default Redis will check five keys and pick the one that was</span><br><span class="line"># used less recently, you can change the sample size using the following</span><br><span class="line"># configuration directive.</span><br><span class="line">#</span><br><span class="line"># The default of 5 produces good enough results. 10 Approximates very closely</span><br><span class="line"># true LRU but costs more CPU. 3 is faster but not very accurate.</span><br><span class="line">#</span><br><span class="line"># maxmemory-samples 5</span><br><span class="line"></span><br><span class="line"># Starting from Redis 5, by default a replica will ignore its maxmemory setting</span><br><span class="line"># (unless it is promoted to master after a failover or manually). It means</span><br><span class="line"># that the eviction of keys will be just handled by the master, sending the</span><br><span class="line"># DEL commands to the replica as keys evict in the master side.</span><br><span class="line">#</span><br><span class="line"># This behavior ensures that masters and replicas stay consistent, and is usually</span><br><span class="line"># what you want, however if your replica is writable, or you want the replica</span><br><span class="line"># to have a different memory setting, and you are sure all the writes performed</span><br><span class="line"># to the replica are idempotent, then you may change this default (but be sure</span><br><span class="line"># to understand what you are doing).</span><br><span class="line">#</span><br><span class="line"># Note that since the replica by default does not evict, it may end using more</span><br><span class="line"># memory than the one set via maxmemory (there are certain buffers that may</span><br><span class="line"># be larger on the replica, or data structures may sometimes take more memory</span><br><span class="line"># and so forth). So make sure you monitor your replicas and make sure they</span><br><span class="line"># have enough memory to never hit a real out-of-memory condition before the</span><br><span class="line"># master hits the configured maxmemory setting.</span><br><span class="line">#</span><br><span class="line"># replica-ignore-maxmemory yes</span><br><span class="line"></span><br><span class="line"># Redis reclaims expired keys in two ways: upon access when those keys are</span><br><span class="line"># found to be expired, and also in background, in what is called the</span><br><span class="line"># "active expire key". The key space is slowly and interactively scanned</span><br><span class="line"># looking for expired keys to reclaim, so that it is possible to free memory</span><br><span class="line"># of keys that are expired and will never be accessed again in a short time.</span><br><span class="line">#</span><br><span class="line"># The default effort of the expire cycle will try to avoid having more than</span><br><span class="line"># ten percent of expired keys still in memory, and will try to avoid consuming</span><br><span class="line"># more than 25% of total memory and to add latency to the system. However</span><br><span class="line"># it is possible to increase the expire "effort" that is normally set to</span><br><span class="line"># "1", to a greater value, up to the value "10". At its maximum value the</span><br><span class="line"># system will use more CPU, longer cycles (and technically may introduce</span><br><span class="line"># more latency), and will tollerate less already expired keys still present</span><br><span class="line"># in the system. It's a tradeoff betweeen memory, CPU and latecy.</span><br><span class="line">#</span><br><span class="line"># active-expire-effort 1</span><br><span class="line"></span><br><span class="line">############################# LAZY FREEING ####################################</span><br><span class="line"></span><br><span class="line"># Redis has two primitives to delete keys. One is called DEL and is a blocking</span><br><span class="line"># deletion of the object. It means that the server stops processing new commands</span><br><span class="line"># in order to reclaim all the memory associated with an object in a synchronous</span><br><span class="line"># way. If the key deleted is associated with a small object, the time needed</span><br><span class="line"># in order to execute the DEL command is very small and comparable to most other</span><br><span class="line"># O(1) or O(log_N) commands in Redis. However if the key is associated with an</span><br><span class="line"># aggregated value containing millions of elements, the server can block for</span><br><span class="line"># a long time (even seconds) in order to complete the operation.</span><br><span class="line">#</span><br><span class="line"># For the above reasons Redis also offers non blocking deletion primitives</span><br><span class="line"># such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and</span><br><span class="line"># FLUSHDB commands, in order to reclaim memory in background. Those commands</span><br><span class="line"># are executed in constant time. Another thread will incrementally free the</span><br><span class="line"># object in the background as fast as possible.</span><br><span class="line">#</span><br><span class="line"># DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.</span><br><span class="line"># It's up to the design of the application to understand when it is a good</span><br><span class="line"># idea to use one or the other. However the Redis server sometimes has to</span><br><span class="line"># delete keys or flush the whole database as a side effect of other operations.</span><br><span class="line"># Specifically Redis deletes objects independently of a user call in the</span><br><span class="line"># following scenarios:</span><br><span class="line">#</span><br><span class="line"># 1) On eviction, because of the maxmemory and maxmemory policy configurations,</span><br><span class="line">#    in order to make room for new data, without going over the specified</span><br><span class="line">#    memory limit.</span><br><span class="line"># 2) Because of expire: when a key with an associated time to live (see the</span><br><span class="line">#    EXPIRE command) must be deleted from memory.</span><br><span class="line"># 3) Because of a side effect of a command that stores data on a key that may</span><br><span class="line">#    already exist. For example the RENAME command may delete the old key</span><br><span class="line">#    content when it is replaced with another one. Similarly SUNIONSTORE</span><br><span class="line">#    or SORT with STORE option may delete existing keys. The SET command</span><br><span class="line">#    itself removes any old content of the specified key in order to replace</span><br><span class="line">#    it with the specified string.</span><br><span class="line"># 4) During replication, when a replica performs a full resynchronization with</span><br><span class="line">#    its master, the content of the whole database is removed in order to</span><br><span class="line">#    load the RDB file just transferred.</span><br><span class="line">#</span><br><span class="line"># In all the above cases the default is to delete objects in a blocking way,</span><br><span class="line"># like if DEL was called. However you can configure each case specifically</span><br><span class="line"># in order to instead release memory in a non-blocking way like if UNLINK</span><br><span class="line"># was called, using the following configuration directives.</span><br><span class="line"></span><br><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">replica-lazy-flush no</span><br><span class="line"></span><br><span class="line"># It is also possible, for the case when to replace the user code DEL calls</span><br><span class="line"># with UNLINK calls is not easy, to modify the default behavior of the DEL</span><br><span class="line"># command to act exactly like UNLINK, using the following configuration</span><br><span class="line"># directive:</span><br><span class="line"></span><br><span class="line">lazyfree-lazy-user-del no</span><br><span class="line"></span><br><span class="line">################################ THREADED I/O #################################</span><br><span class="line"></span><br><span class="line"># Redis is mostly single threaded, however there are certain threaded</span><br><span class="line"># operations such as UNLINK, slow I/O accesses and other things that are</span><br><span class="line"># performed on side threads.</span><br><span class="line">#</span><br><span class="line"># Now it is also possible to handle Redis clients socket reads and writes</span><br><span class="line"># in different I/O threads. Since especially writing is so slow, normally</span><br><span class="line"># Redis users use pipelining in order to speedup the Redis performances per</span><br><span class="line"># core, and spawn multiple instances in order to scale more. Using I/O</span><br><span class="line"># threads it is possible to easily speedup two times Redis without resorting</span><br><span class="line"># to pipelining nor sharding of the instance.</span><br><span class="line">#</span><br><span class="line"># By default threading is disabled, we suggest enabling it only in machines</span><br><span class="line"># that have at least 4 or more cores, leaving at least one spare core.</span><br><span class="line"># Using more than 8 threads is unlikely to help much. We also recommend using</span><br><span class="line"># threaded I/O only if you actually have performance problems, with Redis</span><br><span class="line"># instances being able to use a quite big percentage of CPU time, otherwise</span><br><span class="line"># there is no point in using this feature.</span><br><span class="line">#</span><br><span class="line"># So for instance if you have a four cores boxes, try to use 2 or 3 I/O</span><br><span class="line"># threads, if you have a 8 cores, try to use 6 threads. In order to</span><br><span class="line"># enable I/O threads use the following configuration directive:</span><br><span class="line">#</span><br><span class="line"># io-threads 4</span><br><span class="line">#</span><br><span class="line"># Setting io-threads to 1 will just use the main thread as usually.</span><br><span class="line"># When I/O threads are enabled, we only use threads for writes, that is</span><br><span class="line"># to thread the write(2) syscall and transfer the client buffers to the</span><br><span class="line"># socket. However it is also possible to enable threading of reads and</span><br><span class="line"># protocol parsing using the following configuration directive, by setting</span><br><span class="line"># it to yes:</span><br><span class="line">#</span><br><span class="line"># io-threads-do-reads no</span><br><span class="line">#</span><br><span class="line"># Usually threading reads doesn't help much.</span><br><span class="line">#</span><br><span class="line"># NOTE 1: This configuration directive cannot be changed at runtime via</span><br><span class="line"># CONFIG SET. Aso this feature currently does not work when SSL is</span><br><span class="line"># enabled.</span><br><span class="line">#</span><br><span class="line"># NOTE 2: If you want to test the Redis speedup using redis-benchmark, make</span><br><span class="line"># sure you also run the benchmark itself in threaded mode, using the</span><br><span class="line"># --threads option to match the number of Redis theads, otherwise you'll not</span><br><span class="line"># be able to notice the improvements.</span><br><span class="line"></span><br><span class="line">############################ KERNEL OOM CONTROL ##############################</span><br><span class="line"></span><br><span class="line"># On Linux, it is possible to hint the kernel OOM killer on what processes</span><br><span class="line"># should be killed first when out of memory.</span><br><span class="line">#</span><br><span class="line"># Enabling this feature makes Redis actively control the oom_score_adj value</span><br><span class="line"># for all its processes, depending on their role. The default scores will</span><br><span class="line"># attempt to have background child processes killed before all others, and</span><br><span class="line"># replicas killed before masters.</span><br><span class="line"></span><br><span class="line">oom-score-adj no</span><br><span class="line"></span><br><span class="line"># When oom-score-adj is used, this directive controls the specific values used</span><br><span class="line"># for master, replica and background child processes. Values range -1000 to</span><br><span class="line"># 1000 (higher means more likely to be killed).</span><br><span class="line">#</span><br><span class="line"># Unprivileged processes (not root, and without CAP_SYS_RESOURCE capabilities)</span><br><span class="line"># can freely increase their value, but not decrease it below its initial</span><br><span class="line"># settings.</span><br><span class="line">#</span><br><span class="line"># Values are used relative to the initial value of oom_score_adj when the server</span><br><span class="line"># starts. Because typically the initial value is 0, they will often match the</span><br><span class="line"># absolute values.</span><br><span class="line"></span><br><span class="line">oom-score-adj-values <span class="number">0</span> <span class="number">200</span> <span class="number">800</span></span><br><span class="line"></span><br><span class="line">############################## APPEND ONLY MODE ###############################</span><br><span class="line"></span><br><span class="line"># By default Redis asynchronously dumps the dataset on disk. This mode is</span><br><span class="line"># good enough in many applications, but an issue with the Redis process or</span><br><span class="line"># a power outage may result into a few minutes of writes lost (depending on</span><br><span class="line"># the configured save points).</span><br><span class="line">#</span><br><span class="line"># The Append Only File is an alternative persistence mode that provides</span><br><span class="line"># much better durability. For instance using the default data fsync policy</span><br><span class="line"># (see later in the config file) Redis can lose just one second of writes in a</span><br><span class="line"># dramatic event like a server power outage, or a single write if something</span><br><span class="line"># wrong with the Redis process itself happens, but the operating system is</span><br><span class="line"># still running correctly.</span><br><span class="line">#</span><br><span class="line"># AOF and RDB persistence can be enabled at the same time without problems.</span><br><span class="line"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span><br><span class="line"># with the better durability guarantees.</span><br><span class="line">#</span><br><span class="line"># Please check http://redis.io/topics/persistence for more information.</span><br><span class="line"></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># The name of the append only file (default: "appendonly.aof")</span><br><span class="line"></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br><span class="line"></span><br><span class="line"># The fsync() call tells the Operating System to actually write data on disk</span><br><span class="line"># instead of waiting for more data in the output buffer. Some OS will really flush</span><br><span class="line"># data on disk, some other OS will just try to do it ASAP.</span><br><span class="line">#</span><br><span class="line"># Redis supports three different modes:</span><br><span class="line">#</span><br><span class="line"># no: don't fsync, just let the OS flush the data when it wants. Faster.</span><br><span class="line"># always: fsync after every write to the append only log. Slow, Safest.</span><br><span class="line"># everysec: fsync only one time every second. Compromise.</span><br><span class="line">#</span><br><span class="line"># The default is "everysec", as that's usually the right compromise between</span><br><span class="line"># speed and data safety. It's up to you to understand if you can relax this to</span><br><span class="line"># "no" that will let the operating system flush the output buffer when</span><br><span class="line"># it wants, for better performances (but if you can live with the idea of</span><br><span class="line"># some data loss consider the default persistence mode that's snapshotting),</span><br><span class="line"># or on the contrary, use "always" that's very slow but a bit safer than</span><br><span class="line"># everysec.</span><br><span class="line">#</span><br><span class="line"># More details please check the following article:</span><br><span class="line"># http://antirez.com/post/redis-persistence-demystified.html</span><br><span class="line">#</span><br><span class="line"># If unsure, use "everysec".</span><br><span class="line"></span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"></span><br><span class="line"># When the AOF fsync policy is set to always or everysec, and a background</span><br><span class="line"># saving process (a background save or AOF log background rewriting) is</span><br><span class="line"># performing a lot of I/O against the disk, in some Linux configurations</span><br><span class="line"># Redis may block too long on the fsync() call. Note that there is no fix for</span><br><span class="line"># this currently, as even performing fsync in a different thread will block</span><br><span class="line"># our synchronous write(2) call.</span><br><span class="line">#</span><br><span class="line"># In order to mitigate this problem it's possible to use the following option</span><br><span class="line"># that will prevent fsync() from being called in the main process while a</span><br><span class="line"># BGSAVE or BGREWRITEAOF is in progress.</span><br><span class="line">#</span><br><span class="line"># This means that while another child is saving, the durability of Redis is</span><br><span class="line"># the same as "appendfsync none". In practical terms, this means that it is</span><br><span class="line"># possible to lose up to 30 seconds of log in the worst scenario (with the</span><br><span class="line"># default Linux settings).</span><br><span class="line">#</span><br><span class="line"># If you have latency problems turn this to "yes". Otherwise leave it as</span><br><span class="line"># "no" that is the safest pick from the point of view of durability.</span><br><span class="line"></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># Automatic rewrite of the append only file.</span><br><span class="line"># Redis is able to automatically rewrite the log file implicitly calling</span><br><span class="line"># BGREWRITEAOF when the AOF log size grows by the specified percentage.</span><br><span class="line">#</span><br><span class="line"># This is how it works: Redis remembers the size of the AOF file after the</span><br><span class="line"># latest rewrite (if no rewrite has happened since the restart, the size of</span><br><span class="line"># the AOF at startup is used).</span><br><span class="line">#</span><br><span class="line"># This base size is compared to the current size. If the current size is</span><br><span class="line"># bigger than the specified percentage, the rewrite is triggered. Also</span><br><span class="line"># you need to specify a minimal size for the AOF file to be rewritten, this</span><br><span class="line"># is useful to avoid rewriting the AOF file even if the percentage increase</span><br><span class="line"># is reached but it is still pretty small.</span><br><span class="line">#</span><br><span class="line"># Specify a percentage of zero in order to disable the automatic AOF</span><br><span class="line"># rewrite feature.</span><br><span class="line"></span><br><span class="line">auto-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line">auto-aof-rewrite-min-size <span class="number">64</span>mb</span><br><span class="line"></span><br><span class="line"># An AOF file may be found to be truncated at the end during the Redis</span><br><span class="line"># startup process, when the AOF data gets loaded back into memory.</span><br><span class="line"># This may happen when the system where Redis is running</span><br><span class="line"># crashes, especially when an ext4 filesystem is mounted without the</span><br><span class="line"># data=ordered option (however this can't happen when Redis itself</span><br><span class="line"># crashes or aborts but the operating system still works correctly).</span><br><span class="line">#</span><br><span class="line"># Redis can either exit with an error when this happens, or load as much</span><br><span class="line"># data as possible (the default now) and start if the AOF file is found</span><br><span class="line"># to be truncated at the end. The following option controls this behavior.</span><br><span class="line">#</span><br><span class="line"># If aof-load-truncated is set to yes, a truncated AOF file is loaded and</span><br><span class="line"># the Redis server starts emitting a log to inform the user of the event.</span><br><span class="line"># Otherwise if the option is set to no, the server aborts with an error</span><br><span class="line"># and refuses to start. When the option is set to no, the user requires</span><br><span class="line"># to fix the AOF file using the "redis-check-aof" utility before to restart</span><br><span class="line"># the server.</span><br><span class="line">#</span><br><span class="line"># Note that if the AOF file will be found to be corrupted in the middle</span><br><span class="line"># the server will still exit with an error. This option only applies when</span><br><span class="line"># Redis will try to read more data from the AOF file but not enough bytes</span><br><span class="line"># will be found.</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"># When rewriting the AOF file, Redis is able to use an RDB preamble in the</span><br><span class="line"># AOF file for faster rewrites and recoveries. When this option is turned</span><br><span class="line"># on the rewritten AOF file is composed of two different stanzas:</span><br><span class="line">#</span><br><span class="line">#   [RDB file][AOF tail]</span><br><span class="line">#</span><br><span class="line"># When loading Redis recognizes that the AOF file starts with the "REDIS"</span><br><span class="line"># string and loads the prefixed RDB file, and continues loading the AOF</span><br><span class="line"># tail.</span><br><span class="line">aof-use-rdb-preamble yes</span><br><span class="line"></span><br><span class="line">################################ LUA SCRIPTING  ###############################</span><br><span class="line"></span><br><span class="line"># Max execution time of a Lua script in milliseconds.</span><br><span class="line">#</span><br><span class="line"># If the maximum execution time is reached Redis will log that a script is</span><br><span class="line"># still in execution after the maximum allowed time and will start to</span><br><span class="line"># reply to queries with an error.</span><br><span class="line">#</span><br><span class="line"># When a long running script exceeds the maximum execution time only the</span><br><span class="line"># SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be</span><br><span class="line"># used to stop a script that did not yet called write commands. The second</span><br><span class="line"># is the only way to shut down the server in the case a write command was</span><br><span class="line"># already issued by the script but the user doesn't want to wait for the natural</span><br><span class="line"># termination of the script.</span><br><span class="line">#</span><br><span class="line"># Set it to 0 or a negative value for unlimited execution without warnings.</span><br><span class="line">lua-time-limit <span class="number">5000</span></span><br><span class="line"></span><br><span class="line">################################ REDIS CLUSTER  ###############################</span><br><span class="line"></span><br><span class="line"># Normal Redis instances can't be part of a Redis Cluster; only nodes that are</span><br><span class="line"># started as cluster nodes can. In order to start a Redis instance as a</span><br><span class="line"># cluster node enable the cluster support uncommenting the following:</span><br><span class="line">#</span><br><span class="line"># cluster-enabled yes</span><br><span class="line"></span><br><span class="line"># Every cluster node has a cluster configuration file. This file is not</span><br><span class="line"># intended to be edited by hand. It is created and updated by Redis nodes.</span><br><span class="line"># Every Redis Cluster node requires a different cluster configuration file.</span><br><span class="line"># Make sure that instances running in the same system do not have</span><br><span class="line"># overlapping cluster configuration file names.</span><br><span class="line">#</span><br><span class="line"># cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"># Cluster node timeout is the amount of milliseconds a node must be unreachable</span><br><span class="line"># for it to be considered in failure state.</span><br><span class="line"># Most other internal time limits are multiple of the node timeout.</span><br><span class="line">#</span><br><span class="line"># cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line"># A replica of a failing master will avoid to start a failover if its data</span><br><span class="line"># looks too old.</span><br><span class="line">#</span><br><span class="line"># There is no simple way for a replica to actually have an exact measure of</span><br><span class="line"># its "data age", so the following two checks are performed:</span><br><span class="line">#</span><br><span class="line"># 1) If there are multiple replicas able to failover, they exchange messages</span><br><span class="line">#    in order to try to give an advantage to the replica with the best</span><br><span class="line">#    replication offset (more data from the master processed).</span><br><span class="line">#    Replicas will try to get their rank by offset, and apply to the start</span><br><span class="line">#    of the failover a delay proportional to their rank.</span><br><span class="line">#</span><br><span class="line"># 2) Every single replica computes the time of the last interaction with</span><br><span class="line">#    its master. This can be the last ping or command received (if the master</span><br><span class="line">#    is still in the "connected" state), or the time that elapsed since the</span><br><span class="line">#    disconnection with the master (if the replication link is currently down).</span><br><span class="line">#    If the last interaction is too old, the replica will not try to failover</span><br><span class="line">#    at all.</span><br><span class="line">#</span><br><span class="line"># The point "2" can be tuned by user. Specifically a replica will not perform</span><br><span class="line"># the failover if, since the last interaction with the master, the time</span><br><span class="line"># elapsed is greater than:</span><br><span class="line">#</span><br><span class="line">#   (node-timeout * replica-validity-factor) + repl-ping-replica-period</span><br><span class="line">#</span><br><span class="line"># So for example if node-timeout is 30 seconds, and the replica-validity-factor</span><br><span class="line"># is 10, and assuming a default repl-ping-replica-period of 10 seconds, the</span><br><span class="line"># replica will not try to failover if it was not able to talk with the master</span><br><span class="line"># for longer than 310 seconds.</span><br><span class="line">#</span><br><span class="line"># A large replica-validity-factor may allow replicas with too old data to failover</span><br><span class="line"># a master, while a too small value may prevent the cluster from being able to</span><br><span class="line"># elect a replica at all.</span><br><span class="line">#</span><br><span class="line"># For maximum availability, it is possible to set the replica-validity-factor</span><br><span class="line"># to a value of 0, which means, that replicas will always try to failover the</span><br><span class="line"># master regardless of the last time they interacted with the master.</span><br><span class="line"># (However they'll always try to apply a delay proportional to their</span><br><span class="line"># offset rank).</span><br><span class="line">#</span><br><span class="line"># Zero is the only value able to guarantee that when all the partitions heal</span><br><span class="line"># the cluster will always be able to continue.</span><br><span class="line">#</span><br><span class="line"># cluster-replica-validity-factor 10</span><br><span class="line"></span><br><span class="line"># Cluster replicas are able to migrate to orphaned masters, that are masters</span><br><span class="line"># that are left without working replicas. This improves the cluster ability</span><br><span class="line"># to resist to failures as otherwise an orphaned master can't be failed over</span><br><span class="line"># in case of failure if it has no working replicas.</span><br><span class="line">#</span><br><span class="line"># Replicas migrate to orphaned masters only if there are still at least a</span><br><span class="line"># given number of other working replicas for their old master. This number</span><br><span class="line"># is the "migration barrier". A migration barrier of 1 means that a replica</span><br><span class="line"># will migrate only if there is at least 1 other working replica for its master</span><br><span class="line"># and so forth. It usually reflects the number of replicas you want for every</span><br><span class="line"># master in your cluster.</span><br><span class="line">#</span><br><span class="line"># Default is 1 (replicas migrate only if their masters remain with at least</span><br><span class="line"># one replica). To disable migration just set it to a very large value.</span><br><span class="line"># A value of 0 can be set but is useful only for debugging and dangerous</span><br><span class="line"># in production.</span><br><span class="line">#</span><br><span class="line"># cluster-migration-barrier 1</span><br><span class="line"></span><br><span class="line"># By default Redis Cluster nodes stop accepting queries if they detect there</span><br><span class="line"># is at least an hash slot uncovered (no available node is serving it).</span><br><span class="line"># This way if the cluster is partially down (for example a range of hash slots</span><br><span class="line"># are no longer covered) all the cluster becomes, eventually, unavailable.</span><br><span class="line"># It automatically returns available as soon as all the slots are covered again.</span><br><span class="line">#</span><br><span class="line"># However sometimes you want the subset of the cluster which is working,</span><br><span class="line"># to continue to accept queries for the part of the key space that is still</span><br><span class="line"># covered. In order to do so, just set the cluster-require-full-coverage</span><br><span class="line"># option to no.</span><br><span class="line">#</span><br><span class="line"># cluster-require-full-coverage yes</span><br><span class="line"></span><br><span class="line"># This option, when set to yes, prevents replicas from trying to failover its</span><br><span class="line"># master during master failures. However the master can still perform a</span><br><span class="line"># manual failover, if forced to do so.</span><br><span class="line">#</span><br><span class="line"># This is useful in different scenarios, especially in the case of multiple</span><br><span class="line"># data center operations, where we want one side to never be promoted if not</span><br><span class="line"># in the case of a total DC failure.</span><br><span class="line">#</span><br><span class="line"># cluster-replica-no-failover no</span><br><span class="line"></span><br><span class="line"># This option, when set to yes, allows nodes to serve read traffic while the</span><br><span class="line"># the cluster is in a down state, as long as it believes it owns the slots. </span><br><span class="line">#</span><br><span class="line"># This is useful for two cases.  The first case is for when an application </span><br><span class="line"># doesn't require consistency of data during node failures or network partitions.</span><br><span class="line"># One example of this is a cache, where as long as the node has the data it</span><br><span class="line"># should be able to serve it. </span><br><span class="line">#</span><br><span class="line"># The second use case is for configurations that don't meet the recommended  </span><br><span class="line"># three shards but want to enable cluster mode and scale later. A </span><br><span class="line"># master outage in a 1 or 2 shard configuration causes a read/write outage to the</span><br><span class="line"># entire cluster without this option set, with it set there is only a write outage.</span><br><span class="line"># Without a quorum of masters, slot ownership will not change automatically. </span><br><span class="line">#</span><br><span class="line"># cluster-allow-reads-when-down no</span><br><span class="line"></span><br><span class="line"># In order to setup your cluster make sure to read the documentation</span><br><span class="line"># available at http://redis.io web site.</span><br><span class="line"></span><br><span class="line">########################## CLUSTER DOCKER/NAT support  ########################</span><br><span class="line"></span><br><span class="line"># In certain deployments, Redis Cluster nodes address discovery fails, because</span><br><span class="line"># addresses are NAT-ted or because ports are forwarded (the typical case is</span><br><span class="line"># Docker and other containers).</span><br><span class="line">#</span><br><span class="line"># In order to make Redis Cluster working in such environments, a static</span><br><span class="line"># configuration where each node knows its public address is needed. The</span><br><span class="line"># following two options are used for this scope, and are:</span><br><span class="line">#</span><br><span class="line"># * cluster-announce-ip</span><br><span class="line"># * cluster-announce-port</span><br><span class="line"># * cluster-announce-bus-port</span><br><span class="line">#</span><br><span class="line"># Each instruct the node about its address, client port, and cluster message</span><br><span class="line"># bus port. The information is then published in the header of the bus packets</span><br><span class="line"># so that other nodes will be able to correctly map the address of the node</span><br><span class="line"># publishing the information.</span><br><span class="line">#</span><br><span class="line"># If the above options are not used, the normal Redis Cluster auto-detection</span><br><span class="line"># will be used instead.</span><br><span class="line">#</span><br><span class="line"># Note that when remapped, the bus port may not be at the fixed offset of</span><br><span class="line"># clients port + 10000, so you can specify any port and bus-port depending</span><br><span class="line"># on how they get remapped. If the bus-port is not set, a fixed offset of</span><br><span class="line"># 10000 will be used as usually.</span><br><span class="line">#</span><br><span class="line"># Example:</span><br><span class="line">#</span><br><span class="line"># cluster-announce-ip 10.1.1.5</span><br><span class="line"># cluster-announce-port 6379</span><br><span class="line"># cluster-announce-bus-port 6380</span><br><span class="line"></span><br><span class="line">################################## SLOW LOG ###################################</span><br><span class="line"></span><br><span class="line"># The Redis Slow Log is a system to log queries that exceeded a specified</span><br><span class="line"># execution time. The execution time does not include the I/O operations</span><br><span class="line"># like talking with the client, sending the reply and so forth,</span><br><span class="line"># but just the time needed to actually execute the command (this is the only</span><br><span class="line"># stage of command execution where the thread is blocked and can not serve</span><br><span class="line"># other requests in the meantime).</span><br><span class="line">#</span><br><span class="line"># You can configure the slow log with two parameters: one tells Redis</span><br><span class="line"># what is the execution time, in microseconds, to exceed in order for the</span><br><span class="line"># command to get logged, and the other parameter is the length of the</span><br><span class="line"># slow log. When a new command is logged the oldest one is removed from the</span><br><span class="line"># queue of logged commands.</span><br><span class="line"></span><br><span class="line"># The following time is expressed in microseconds, so 1000000 is equivalent</span><br><span class="line"># to one second. Note that a negative number disables the slow log, while</span><br><span class="line"># a value of zero forces the logging of every command.</span><br><span class="line">slowlog-log-slower-than <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"># There is no limit to this length. Just be aware that it will consume memory.</span><br><span class="line"># You can reclaim memory used by the slow log with SLOWLOG RESET.</span><br><span class="line">slowlog-max-len <span class="number">128</span></span><br><span class="line"></span><br><span class="line">################################ LATENCY MONITOR ##############################</span><br><span class="line"></span><br><span class="line"># The Redis latency monitoring subsystem samples different operations</span><br><span class="line"># at runtime in order to collect data related to possible sources of</span><br><span class="line"># latency of a Redis instance.</span><br><span class="line">#</span><br><span class="line"># Via the LATENCY command this information is available to the user that can</span><br><span class="line"># print graphs and obtain reports.</span><br><span class="line">#</span><br><span class="line"># The system only logs operations that were performed in a time equal or</span><br><span class="line"># greater than the amount of milliseconds specified via the</span><br><span class="line"># latency-monitor-threshold configuration directive. When its value is set</span><br><span class="line"># to zero, the latency monitor is turned off.</span><br><span class="line">#</span><br><span class="line"># By default latency monitoring is disabled since it is mostly not needed</span><br><span class="line"># if you don't have latency issues, and collecting data has a performance</span><br><span class="line"># impact, that while very small, can be measured under big load. Latency</span><br><span class="line"># monitoring can easily be enabled at runtime using the command</span><br><span class="line"># "CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;" if needed.</span><br><span class="line">latency-monitor-threshold <span class="number">0</span></span><br><span class="line"></span><br><span class="line">############################# EVENT NOTIFICATION ##############################</span><br><span class="line"></span><br><span class="line"># Redis can notify Pub/Sub clients about events happening in the key space.</span><br><span class="line"># This feature is documented at http://redis.io/topics/notifications</span><br><span class="line">#</span><br><span class="line"># For instance if keyspace events notification is enabled, and a client</span><br><span class="line"># performs a DEL operation on key "foo" stored in the Database 0, two</span><br><span class="line"># messages will be published via Pub/Sub:</span><br><span class="line">#</span><br><span class="line"># PUBLISH __keyspace@0__:foo del</span><br><span class="line"># PUBLISH __keyevent@0__:del foo</span><br><span class="line">#</span><br><span class="line"># It is possible to select the events that Redis will notify among a set</span><br><span class="line"># of classes. Every class is identified by a single character:</span><br><span class="line">#</span><br><span class="line">#  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.</span><br><span class="line">#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.</span><br><span class="line">#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</span><br><span class="line">#  $     String commands</span><br><span class="line">#  l     List commands</span><br><span class="line">#  s     Set commands</span><br><span class="line">#  h     Hash commands</span><br><span class="line">#  z     Sorted set commands</span><br><span class="line">#  x     Expired events (events generated every time a key expires)</span><br><span class="line">#  e     Evicted events (events generated when a key is evicted for maxmemory)</span><br><span class="line">#  t     Stream commands</span><br><span class="line">#  m     Key-miss events (Note: It is not included in the 'A' class)</span><br><span class="line">#  A     Alias for g$lshzxet, so that the "AKE" string means all the events</span><br><span class="line">#        (Except key-miss events which are excluded from 'A' due to their</span><br><span class="line">#         unique nature).</span><br><span class="line">#</span><br><span class="line">#  The "notify-keyspace-events" takes as argument a string that is composed</span><br><span class="line">#  of zero or multiple characters. The empty string means that notifications</span><br><span class="line">#  are disabled.</span><br><span class="line">#</span><br><span class="line">#  Example: to enable list and generic events, from the point of view of the</span><br><span class="line">#           event name, use:</span><br><span class="line">#</span><br><span class="line">#  notify-keyspace-events Elg</span><br><span class="line">#</span><br><span class="line">#  Example 2: to get the stream of the expired keys subscribing to channel</span><br><span class="line">#             name __keyevent@0__:expired use:</span><br><span class="line">#</span><br><span class="line">#  notify-keyspace-events Ex</span><br><span class="line">#</span><br><span class="line">#  By default all notifications are disabled because most users don't need</span><br><span class="line">#  this feature and the feature has some overhead. Note that if you don't</span><br><span class="line">#  specify at least one of K or E, no events will be delivered.</span><br><span class="line">notify-keyspace-events <span class="string">""</span></span><br><span class="line"></span><br><span class="line">############################### GOPHER SERVER #################################</span><br><span class="line"></span><br><span class="line"># Redis contains an implementation of the Gopher protocol, as specified in</span><br><span class="line"># the RFC 1436 (https://www.ietf.org/rfc/rfc1436.txt).</span><br><span class="line">#</span><br><span class="line"># The Gopher protocol was very popular in the late '90s. It is an alternative</span><br><span class="line"># to the web, and the implementation both server and client side is so simple</span><br><span class="line"># that the Redis server has just 100 lines of code in order to implement this</span><br><span class="line"># support.</span><br><span class="line">#</span><br><span class="line"># What do you do with Gopher nowadays? Well Gopher never *really* died, and</span><br><span class="line"># lately there is a movement in order for the Gopher more hierarchical content</span><br><span class="line"># composed of just plain text documents to be resurrected. Some want a simpler</span><br><span class="line"># internet, others believe that the mainstream internet became too much</span><br><span class="line"># controlled, and it's cool to create an alternative space for people that</span><br><span class="line"># want a bit of fresh air.</span><br><span class="line">#</span><br><span class="line"># Anyway for the 10nth birthday of the Redis, we gave it the Gopher protocol</span><br><span class="line"># as a gift.</span><br><span class="line">#</span><br><span class="line"># --- HOW IT WORKS? ---</span><br><span class="line">#</span><br><span class="line"># The Redis Gopher support uses the inline protocol of Redis, and specifically</span><br><span class="line"># two kind of inline requests that were anyway illegal: an empty request</span><br><span class="line"># or any request that starts with "/" (there are no Redis commands starting</span><br><span class="line"># with such a slash). Normal RESP2/RESP3 requests are completely out of the</span><br><span class="line"># path of the Gopher protocol implementation and are served as usually as well.</span><br><span class="line">#</span><br><span class="line"># If you open a connection to Redis when Gopher is enabled and send it</span><br><span class="line"># a string like "/foo", if there is a key named "/foo" it is served via the</span><br><span class="line"># Gopher protocol.</span><br><span class="line">#</span><br><span class="line"># In order to create a real Gopher "hole" (the name of a Gopher site in Gopher</span><br><span class="line"># talking), you likely need a script like the following:</span><br><span class="line">#</span><br><span class="line">#   https://github.com/antirez/gopher2redis</span><br><span class="line">#</span><br><span class="line"># --- SECURITY WARNING ---</span><br><span class="line">#</span><br><span class="line"># If you plan to put Redis on the internet in a publicly accessible address</span><br><span class="line"># to server Gopher pages MAKE SURE TO SET A PASSWORD to the instance.</span><br><span class="line"># Once a password is set:</span><br><span class="line">#</span><br><span class="line">#   1. The Gopher server (when enabled, not by default) will still serve</span><br><span class="line">#      content via Gopher.</span><br><span class="line">#   2. However other commands cannot be called before the client will</span><br><span class="line">#      authenticate.</span><br><span class="line">#</span><br><span class="line"># So use the 'requirepass' option to protect your instance.</span><br><span class="line">#</span><br><span class="line"># To enable Gopher support uncomment the following line and set</span><br><span class="line"># the option from no (the default) to yes.</span><br><span class="line">#</span><br><span class="line"># gopher-enabled no</span><br><span class="line"></span><br><span class="line">############################### ADVANCED CONFIG ###############################</span><br><span class="line"></span><br><span class="line"># Hashes are encoded using a memory efficient data structure when they have a</span><br><span class="line"># small number of entries, and the biggest entry does not exceed a given</span><br><span class="line"># threshold. These thresholds can be configured using the following directives.</span><br><span class="line">hash-max-ziplist-entries <span class="number">512</span></span><br><span class="line">hash-max-ziplist-value <span class="number">64</span></span><br><span class="line"></span><br><span class="line"># Lists are also encoded in a special way to save a lot of space.</span><br><span class="line"># The number of entries allowed per internal list node can be specified</span><br><span class="line"># as a fixed maximum size or a maximum number of elements.</span><br><span class="line"># For a fixed maximum size, use -5 through -1, meaning:</span><br><span class="line"># -5: max size: 64 Kb  &lt;-- not recommended for normal workloads</span><br><span class="line"># -4: max size: 32 Kb  &lt;-- not recommended</span><br><span class="line"># -3: max size: 16 Kb  &lt;-- probably not recommended</span><br><span class="line"># -2: max size: 8 Kb   &lt;-- good</span><br><span class="line"># -1: max size: 4 Kb   &lt;-- good</span><br><span class="line"># Positive numbers mean store up to _exactly_ that number of elements</span><br><span class="line"># per list node.</span><br><span class="line"># The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),</span><br><span class="line"># but if your use case is unique, adjust the settings as necessary.</span><br><span class="line">list-max-ziplist-size -<span class="number">2</span></span><br><span class="line"></span><br><span class="line"># Lists may also be compressed.</span><br><span class="line"># Compress depth is the number of quicklist ziplist nodes from *each* side of</span><br><span class="line"># the list to *exclude* from compression.  The head and tail of the list</span><br><span class="line"># are always uncompressed for fast push/pop operations.  Settings are:</span><br><span class="line"># 0: disable all list compression</span><br><span class="line"># 1: depth 1 means "don't start compressing until after 1 node into the list,</span><br><span class="line">#    going from either the head or tail"</span><br><span class="line">#    So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]</span><br><span class="line">#    [head], [tail] will always be uncompressed; inner nodes will compress.</span><br><span class="line"># 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]</span><br><span class="line">#    2 here means: don't compress head or head-&gt;next or tail-&gt;prev or tail,</span><br><span class="line">#    but compress all nodes between them.</span><br><span class="line"># 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]</span><br><span class="line"># etc.</span><br><span class="line">list-compress-depth <span class="number">0</span></span><br><span class="line"></span><br><span class="line"># Sets have a special encoding in just one case: when a set is composed</span><br><span class="line"># of just strings that happen to be integers in radix 10 in the range</span><br><span class="line"># of 64 bit signed integers.</span><br><span class="line"># The following configuration setting sets the limit in the size of the</span><br><span class="line"># set in order to use this special memory saving encoding.</span><br><span class="line">set-max-intset-entries <span class="number">512</span></span><br><span class="line"></span><br><span class="line"># Similarly to hashes and lists, sorted sets are also specially encoded in</span><br><span class="line"># order to save a lot of space. This encoding is only used when the length and</span><br><span class="line"># elements of a sorted set are below the following limits:</span><br><span class="line">zset-max-ziplist-entries <span class="number">128</span></span><br><span class="line">zset-max-ziplist-value <span class="number">64</span></span><br><span class="line"></span><br><span class="line"># HyperLogLog sparse representation bytes limit. The limit includes the</span><br><span class="line"># 16 bytes header. When an HyperLogLog using the sparse representation crosses</span><br><span class="line"># this limit, it is converted into the dense representation.</span><br><span class="line">#</span><br><span class="line"># A value greater than 16000 is totally useless, since at that point the</span><br><span class="line"># dense representation is more memory efficient.</span><br><span class="line">#</span><br><span class="line"># The suggested value is ~ 3000 in order to have the benefits of</span><br><span class="line"># the space efficient encoding without slowing down too much PFADD,</span><br><span class="line"># which is O(N) with the sparse encoding. The value can be raised to</span><br><span class="line"># ~ 10000 when CPU is not a concern, but space is, and the data set is</span><br><span class="line"># composed of many HyperLogLogs with cardinality in the 0 - 15000 range.</span><br><span class="line">hll-sparse-max-bytes <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"># Streams macro node max size / items. The stream data structure is a radix</span><br><span class="line"># tree of big nodes that encode multiple items inside. Using this configuration</span><br><span class="line"># it is possible to configure how big a single node can be in bytes, and the</span><br><span class="line"># maximum number of items it may contain before switching to a new node when</span><br><span class="line"># appending new stream entries. If any of the following settings are set to</span><br><span class="line"># zero, the limit is ignored, so for instance it is possible to set just a</span><br><span class="line"># max entires limit by setting max-bytes to 0 and max-entries to the desired</span><br><span class="line"># value.</span><br><span class="line">stream-node-max-bytes <span class="number">4096</span></span><br><span class="line">stream-node-max-entries <span class="number">100</span></span><br><span class="line"></span><br><span class="line"># Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in</span><br><span class="line"># order to help rehashing the main Redis hash table (the one mapping top-level</span><br><span class="line"># keys to values). The hash table implementation Redis uses (see dict.c)</span><br><span class="line"># performs a lazy rehashing: the more operation you run into a hash table</span><br><span class="line"># that is rehashing, the more rehashing "steps" are performed, so if the</span><br><span class="line"># server is idle the rehashing is never complete and some more memory is used</span><br><span class="line"># by the hash table.</span><br><span class="line">#</span><br><span class="line"># The default is to use this millisecond 10 times every second in order to</span><br><span class="line"># actively rehash the main dictionaries, freeing memory when possible.</span><br><span class="line">#</span><br><span class="line"># If unsure:</span><br><span class="line"># use "activerehashing no" if you have hard latency requirements and it is</span><br><span class="line"># not a good thing in your environment that Redis can reply from time to time</span><br><span class="line"># to queries with 2 milliseconds delay.</span><br><span class="line">#</span><br><span class="line"># use "activerehashing yes" if you don't have such hard requirements but</span><br><span class="line"># want to free memory asap when possible.</span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line"># The client output buffer limits can be used to force disconnection of clients</span><br><span class="line"># that are not reading data from the server fast enough for some reason (a</span><br><span class="line"># common reason is that a Pub/Sub client can't consume messages as fast as the</span><br><span class="line"># publisher can produce them).</span><br><span class="line">#</span><br><span class="line"># The limit can be set differently for the three different classes of clients:</span><br><span class="line">#</span><br><span class="line"># normal -&gt; normal clients including MONITOR clients</span><br><span class="line"># replica  -&gt; replica clients</span><br><span class="line"># pubsub -&gt; clients subscribed to at least one pubsub channel or pattern</span><br><span class="line">#</span><br><span class="line"># The syntax of every client-output-buffer-limit directive is the following:</span><br><span class="line">#</span><br><span class="line"># client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br><span class="line">#</span><br><span class="line"># A client is immediately disconnected once the hard limit is reached, or if</span><br><span class="line"># the soft limit is reached and remains reached for the specified number of</span><br><span class="line"># seconds (continuously).</span><br><span class="line"># So for instance if the hard limit is 32 megabytes and the soft limit is</span><br><span class="line"># 16 megabytes / 10 seconds, the client will get disconnected immediately</span><br><span class="line"># if the size of the output buffers reach 32 megabytes, but will also get</span><br><span class="line"># disconnected if the client reaches 16 megabytes and continuously overcomes</span><br><span class="line"># the limit for 10 seconds.</span><br><span class="line">#</span><br><span class="line"># By default normal clients are not limited because they don't receive data</span><br><span class="line"># without asking (in a push way), but just after a request, so only</span><br><span class="line"># asynchronous clients may create a scenario where data is requested faster</span><br><span class="line"># than it can read.</span><br><span class="line">#</span><br><span class="line"># Instead there is a default limit for pubsub and replica clients, since</span><br><span class="line"># subscribers and replicas receive data in a push fashion.</span><br><span class="line">#</span><br><span class="line"># Both the hard or the soft limit can be disabled by setting them to zero.</span><br><span class="line">client-output-buffer-limit normal <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">client-output-buffer-limit replica <span class="number">256</span>mb <span class="number">64</span>mb <span class="number">60</span></span><br><span class="line">client-output-buffer-limit pubsub <span class="number">32</span>mb <span class="number">8</span>mb <span class="number">60</span></span><br><span class="line"></span><br><span class="line"># Client query buffers accumulate new commands. They are limited to a fixed</span><br><span class="line"># amount by default in order to avoid that a protocol desynchronization (for</span><br><span class="line"># instance due to a bug in the client) will lead to unbound memory usage in</span><br><span class="line"># the query buffer. However you can configure it here if you have very special</span><br><span class="line"># needs, such us huge multi/exec requests or alike.</span><br><span class="line">#</span><br><span class="line"># client-query-buffer-limit 1gb</span><br><span class="line"></span><br><span class="line"># In the Redis protocol, bulk requests, that are, elements representing single</span><br><span class="line"># strings, are normally limited ot 512 mb. However you can change this limit</span><br><span class="line"># here, but must be 1mb or greater</span><br><span class="line">#</span><br><span class="line"># proto-max-bulk-len 512mb</span><br><span class="line"></span><br><span class="line"># Redis calls an internal function to perform many background tasks, like</span><br><span class="line"># closing connections of clients in timeout, purging expired keys that are</span><br><span class="line"># never requested, and so forth.</span><br><span class="line">#</span><br><span class="line"># Not all tasks are performed with the same frequency, but Redis checks for</span><br><span class="line"># tasks to perform according to the specified "hz" value.</span><br><span class="line">#</span><br><span class="line"># By default "hz" is set to 10. Raising the value will use more CPU when</span><br><span class="line"># Redis is idle, but at the same time will make Redis more responsive when</span><br><span class="line"># there are many keys expiring at the same time, and timeouts may be</span><br><span class="line"># handled with more precision.</span><br><span class="line">#</span><br><span class="line"># The range is between 1 and 500, however a value over 100 is usually not</span><br><span class="line"># a good idea. Most users should use the default of 10 and raise this up to</span><br><span class="line"># 100 only in environments where very low latency is required.</span><br><span class="line">hz <span class="number">10</span></span><br><span class="line"></span><br><span class="line"># Normally it is useful to have an HZ value which is proportional to the</span><br><span class="line"># number of clients connected. This is useful in order, for instance, to</span><br><span class="line"># avoid too many clients are processed for each background task invocation</span><br><span class="line"># in order to avoid latency spikes.</span><br><span class="line">#</span><br><span class="line"># Since the default HZ value by default is conservatively set to 10, Redis</span><br><span class="line"># offers, and enables by default, the ability to use an adaptive HZ value</span><br><span class="line"># which will temporary raise when there are many connected clients.</span><br><span class="line">#</span><br><span class="line"># When dynamic HZ is enabled, the actual configured HZ will be used</span><br><span class="line"># as a baseline, but multiples of the configured HZ value will be actually</span><br><span class="line"># used as needed once more clients are connected. In this way an idle</span><br><span class="line"># instance will use very little CPU time while a busy instance will be</span><br><span class="line"># more responsive.</span><br><span class="line">dynamic-hz yes</span><br><span class="line"></span><br><span class="line"># When a child rewrites the AOF file, if the following option is enabled</span><br><span class="line"># the file will be fsync-ed every 32 MB of data generated. This is useful</span><br><span class="line"># in order to commit the file to the disk more incrementally and avoid</span><br><span class="line"># big latency spikes.</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line"></span><br><span class="line"># When redis saves RDB file, if the following option is enabled</span><br><span class="line"># the file will be fsync-ed every 32 MB of data generated. This is useful</span><br><span class="line"># in order to commit the file to the disk more incrementally and avoid</span><br><span class="line"># big latency spikes.</span><br><span class="line">rdb-save-incremental-fsync yes</span><br><span class="line"></span><br><span class="line"># Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good</span><br><span class="line"># idea to start with the default settings and only change them after investigating</span><br><span class="line"># how to improve the performances and how the keys LFU change over time, which</span><br><span class="line"># is possible to inspect via the OBJECT FREQ command.</span><br><span class="line">#</span><br><span class="line"># There are two tunable parameters in the Redis LFU implementation: the</span><br><span class="line"># counter logarithm factor and the counter decay time. It is important to</span><br><span class="line"># understand what the two parameters mean before changing them.</span><br><span class="line">#</span><br><span class="line"># The LFU counter is just 8 bits per key, it's maximum value is 255, so Redis</span><br><span class="line"># uses a probabilistic increment with logarithmic behavior. Given the value</span><br><span class="line"># of the old counter, when a key is accessed, the counter is incremented in</span><br><span class="line"># this way:</span><br><span class="line">#</span><br><span class="line"># 1. A random number R between 0 and 1 is extracted.</span><br><span class="line"># 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).</span><br><span class="line"># 3. The counter is incremented only if R &lt; P.</span><br><span class="line">#</span><br><span class="line"># The default lfu-log-factor is 10. This is a table of how the frequency</span><br><span class="line"># counter changes with a different number of accesses with different</span><br><span class="line"># logarithmic factors:</span><br><span class="line">#</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line"># | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line"># | 0      | 104        | 255        | 255        | 255        | 255        |</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line"># | 1      | 18         | 49         | 255        | 255        | 255        |</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line"># | 10     | 10         | 18         | 142        | 255        | 255        |</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line"># | 100    | 8          | 11         | 49         | 143        | 255        |</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line">#</span><br><span class="line"># NOTE: The above table was obtained by running the following commands:</span><br><span class="line">#</span><br><span class="line">#   redis-benchmark -n 1000000 incr foo</span><br><span class="line">#   redis-cli object freq foo</span><br><span class="line">#</span><br><span class="line"># NOTE 2: The counter initial value is 5 in order to give new objects a chance</span><br><span class="line"># to accumulate hits.</span><br><span class="line">#</span><br><span class="line"># The counter decay time is the time, in minutes, that must elapse in order</span><br><span class="line"># for the key counter to be divided by two (or decremented if it has a value</span><br><span class="line"># less &lt;= 10).</span><br><span class="line">#</span><br><span class="line"># The default value for the lfu-decay-time is 1. A Special value of 0 means to</span><br><span class="line"># decay the counter every time it happens to be scanned.</span><br><span class="line">#</span><br><span class="line"># lfu-log-factor 10</span><br><span class="line"># lfu-decay-time 1</span><br><span class="line"></span><br><span class="line">########################### ACTIVE DEFRAGMENTATION #######################</span><br><span class="line">#</span><br><span class="line"># What is active defragmentation?</span><br><span class="line"># -------------------------------</span><br><span class="line">#</span><br><span class="line"># Active (online) defragmentation allows a Redis server to compact the</span><br><span class="line"># spaces left between small allocations and deallocations of data in memory,</span><br><span class="line"># thus allowing to reclaim back memory.</span><br><span class="line">#</span><br><span class="line"># Fragmentation is a natural process that happens with every allocator (but</span><br><span class="line"># less so with Jemalloc, fortunately) and certain workloads. Normally a server</span><br><span class="line"># restart is needed in order to lower the fragmentation, or at least to flush</span><br><span class="line"># away all the data and create it again. However thanks to this feature</span><br><span class="line"># implemented by Oran Agra for Redis 4.0 this process can happen at runtime</span><br><span class="line"># in an "hot" way, while the server is running.</span><br><span class="line">#</span><br><span class="line"># Basically when the fragmentation is over a certain level (see the</span><br><span class="line"># configuration options below) Redis will start to create new copies of the</span><br><span class="line"># values in contiguous memory regions by exploiting certain specific Jemalloc</span><br><span class="line"># features (in order to understand if an allocation is causing fragmentation</span><br><span class="line"># and to allocate it in a better place), and at the same time, will release the</span><br><span class="line"># old copies of the data. This process, repeated incrementally for all the keys</span><br><span class="line"># will cause the fragmentation to drop back to normal values.</span><br><span class="line">#</span><br><span class="line"># Important things to understand:</span><br><span class="line">#</span><br><span class="line"># 1. This feature is disabled by default, and only works if you compiled Redis</span><br><span class="line">#    to use the copy of Jemalloc we ship with the source code of Redis.</span><br><span class="line">#    This is the default with Linux builds.</span><br><span class="line">#</span><br><span class="line"># 2. You never need to enable this feature if you don't have fragmentation</span><br><span class="line">#    issues.</span><br><span class="line">#</span><br><span class="line"># 3. Once you experience fragmentation, you can enable this feature when</span><br><span class="line">#    needed with the command "CONFIG SET activedefrag yes".</span><br><span class="line">#</span><br><span class="line"># The configuration parameters are able to fine tune the behavior of the</span><br><span class="line"># defragmentation process. If you are not sure about what they mean it is</span><br><span class="line"># a good idea to leave the defaults untouched.</span><br><span class="line"></span><br><span class="line"># Enabled active defragmentation</span><br><span class="line"># activedefrag no</span><br><span class="line"></span><br><span class="line"># Minimum amount of fragmentation waste to start active defrag</span><br><span class="line"># active-defrag-ignore-bytes 100mb</span><br><span class="line"></span><br><span class="line"># Minimum percentage of fragmentation to start active defrag</span><br><span class="line"># active-defrag-threshold-lower 10</span><br><span class="line"></span><br><span class="line"># Maximum percentage of fragmentation at which we use maximum effort</span><br><span class="line"># active-defrag-threshold-upper 100</span><br><span class="line"></span><br><span class="line"># Minimal effort for defrag in CPU percentage, to be used when the lower</span><br><span class="line"># threshold is reached</span><br><span class="line"># active-defrag-cycle-min 1</span><br><span class="line"></span><br><span class="line"># Maximal effort for defrag in CPU percentage, to be used when the upper</span><br><span class="line"># threshold is reached</span><br><span class="line"># active-defrag-cycle-max 25</span><br><span class="line"></span><br><span class="line"># Maximum number of set/hash/zset/list fields that will be processed from</span><br><span class="line"># the main dictionary scan</span><br><span class="line"># active-defrag-max-scan-fields 1000</span><br><span class="line"></span><br><span class="line"># Jemalloc background thread for purging will be enabled by default</span><br><span class="line">jemalloc-bg-thread yes</span><br><span class="line"></span><br><span class="line"># It is possible to pin different threads and processes of Redis to specific</span><br><span class="line"># CPUs in your system, in order to maximize the performances of the server.</span><br><span class="line"># This is useful both in order to pin different Redis threads in different</span><br><span class="line"># CPUs, but also in order to make sure that multiple Redis instances running</span><br><span class="line"># in the same host will be pinned to different CPUs.</span><br><span class="line">#</span><br><span class="line"># Normally you can do this using the "taskset" command, however it is also</span><br><span class="line"># possible to this via Redis configuration directly, both in Linux and FreeBSD.</span><br><span class="line">#</span><br><span class="line"># You can pin the server/IO threads, bio threads, aof rewrite child process, and</span><br><span class="line"># the bgsave child process. The syntax to specify the cpu list is the same as</span><br><span class="line"># the taskset command:</span><br><span class="line">#</span><br><span class="line"># Set redis server/io threads to cpu affinity 0,2,4,6:</span><br><span class="line"># server_cpulist 0-7:2</span><br><span class="line">#</span><br><span class="line"># Set bio threads to cpu affinity 1,3:</span><br><span class="line"># bio_cpulist 1,3</span><br><span class="line">#</span><br><span class="line"># Set aof rewrite child process to cpu affinity 8,9,10,11:</span><br><span class="line"># aof_rewrite_cpulist 8-11</span><br><span class="line">#</span><br><span class="line"># Set bgsave child process to cpu affinity 1,10,11</span><br><span class="line"># bgsave_cpulist 1,10-11</span><br></pre></td></tr></table></figure>
<h3 id="测试-redis-cli连接上来"><a href="#测试-redis-cli连接上来" class="headerlink" title="测试 redis-cli连接上来"></a>测试 redis-cli连接上来</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker exec -it 运行着redis服务容器的ID redis-cli</span><br></pre></td></tr></table></figure>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095817.png"></p>
<h3 id="测试持久化文件生成"><a href="#测试持久化文件生成" class="headerlink" title="测试持久化文件生成"></a>测试持久化文件生成</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095821.png"></p>
<h1 id="第-八-章-将镜像推送到阿里云"><a href="#第-八-章-将镜像推送到阿里云" class="headerlink" title="第 八 章 将镜像推送到阿里云"></a>第 八 章 将镜像推送到阿里云</h1><h2 id="本地镜像发布到阿里云流程"><a href="#本地镜像发布到阿里云流程" class="headerlink" title="本地镜像发布到阿里云流程"></a>本地镜像发布到阿里云流程</h2><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095826.png"></p>
<h2 id="镜像生成方法"><a href="#镜像生成方法" class="headerlink" title="镜像生成方法"></a>镜像生成方法</h2><p>1、前面的Dockerfile</p>
<p>2、从容器中创建一个新的镜像 </p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker commit [OPTIONS] 容器ID [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095830.png"></p>
<h2 id="将本地镜像推送到阿里云"><a href="#将本地镜像推送到阿里云" class="headerlink" title="将本地镜像推送到阿里云"></a>将本地镜像推送到阿里云</h2><h3 id="1、本地镜像素材原型"><a href="#1、本地镜像素材原型" class="headerlink" title="1、本地镜像素材原型"></a>1、本地镜像素材原型</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095834.png"></p>
<p>2、阿里云开发者平台</p>
<p><a href="https://promotion.aliyun.com/ntms/act/kubernetes.html" target="_blank" rel="noopener">https://promotion.aliyun.com/ntms/act/kubernetes.html</a></p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095838.png"></p>
<h3 id="3、创建镜像仓库"><a href="#3、创建镜像仓库" class="headerlink" title="3、创建镜像仓库"></a>3、创建镜像仓库</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095842.png"></p>
<p>命名空间</p>
<p>仓库名称</p>
<h3 id="4、将镜像推送到registry"><a href="#4、将镜像推送到registry" class="headerlink" title="4、将镜像推送到registry"></a>4、将镜像推送到registry</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ sudo docker login --username=white3e registry.cn-shenzhen.aliyuncs.com</span><br><span class="line">$ sudo docker tag [ImageId] registry.cn-shenzhen.aliyuncs.com/ggccqq/mycentos:[镜像版本号]</span><br><span class="line">$ sudo docker push registry.cn-shenzhen.aliyuncs.com/ggccqq/mycentos:[镜像版本号]</span><br><span class="line">其中[ImageId][镜像版本]自己填写</span><br></pre></td></tr></table></figure>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095848.png"></p>
<h3 id="5、公有云可以查询得到"><a href="#5、公有云可以查询得到" class="headerlink" title="5、公有云可以查询得到"></a>5、公有云可以查询得到</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095852.png"></p>
<h3 id="6、查看详情"><a href="#6、查看详情" class="headerlink" title="6、查看详情"></a>6、查看详情</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095856.png"></p>
<h2 id="将阿里云上的镜像下载到本地"><a href="#将阿里云上的镜像下载到本地" class="headerlink" title="将阿里云上的镜像下载到本地"></a>将阿里云上的镜像下载到本地</h2><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210811095900.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/docker/20210830082358.png"></p>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>spring源码(三)--循环依赖(bean的创建)</title>
    <url>/alex-next/2022/06/26/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E4%B8%89)--bean%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="循环依赖-bean的创建"><a href="#循环依赖-bean的创建" class="headerlink" title="循环依赖(bean的创建)"></a>循环依赖(bean的创建)</h2><h3 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h3><ul>
<li><p>doGetBean</p>
<ul>
<li><p>getSingleton(beanName)：出口</p>
<p>protected Object getSingleton(String beanName, boolean allowEarlyReference) {<br>   /**</p>
<pre><code>* 第一步:我们尝试去一级缓存(单例缓存池中去获取对象,一般情况从该map中获取的对象是直接可以使用的)
* IOC容器初始化加载单实例bean的时候第一次进来的时候 该map中一般返回空
*/
</code></pre><p>   Object singletonObject = this.singletonObjects.get(beanName);<br>   /**</p>
<pre><code>* 若在第一级缓存中没有获取到对象,并且singletonsCurrentlyInCreation这个list包含该beanName
* IOC容器初始化加载单实例bean的时候第一次进来的时候 该list中一般返回空,但是循环依赖的时候可以满足该条件
*/
</code></pre><p>   if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {</p>
<pre><code>  synchronized (this.singletonObjects) {
     /**
      * 尝试去二级缓存中获取对象(二级缓存中的对象是一个早期对象)
      * 何为早期对象:就是bean刚刚调用了构造方法，还来不及给bean的属性进行赋值的对象(纯净态)
      * 就是早期对象
      */
     singletonObject = this.earlySingletonObjects.get(beanName);
     /**
      * 二级缓存中也没有获取到对象,allowEarlyReference为true(参数是有上一个方法传递进来的true)
      */
     if (singletonObject == null &amp;&amp; allowEarlyReference) {
        /**
         * 直接从三级缓存中获取 ObjectFactory对象 这个对接就是用来解决循环依赖的关键所在
         * 在ioc后期的过程中,当bean调用了构造方法的时候,把早期对象包裹成一个ObjectFactory
         * 暴露到三级缓存中
         */
        ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);
        //从三级缓存中获取到对象不为空
        if (singletonFactory != null) {
           /**
            * 在这里通过暴露的ObjectFactory 包装对象中,通过调用他的getObject()来获取我们的早期对象
            * 在这个环节中会调用到 getEarlyBeanReference()来进行后置处理
            */
           singletonObject = singletonFactory.getObject();
           //把早期对象放置在二级缓存,
           this.earlySingletonObjects.put(beanName, singletonObject);
           //ObjectFactory 包装对象从三级缓存中删除掉
           this.singletonFactories.remove(beanName);
        }
     }
  }
</code></pre><p>   }<br>   return singletonObject;</p>
<ul>
<li>尝试从一级缓存中获取bean</li>
<li><p>this.earlySingletonObjects.put(beanName, singletonObject);</p>
<ul>
<li>如果bean正在创建过程中且三级缓存中存在该bean，才会进入此方法，将纯静态的bean放入二级缓存中</li>
</ul>
</li>
</ul>
</li>
<li><p>getSingleton(beanName, () -&gt; {}</p>
<ul>
<li><p>this.singletonObjects.get(beanName);</p>
<ul>
<li>尝试从一级缓存中获取bean，解决多线程下重复创建的问题，意义参考如何解决并发bean不完整的问题</li>
</ul>
</li>
<li><p>beforeSingletonCreation(beanName);</p>
<ul>
<li>标记当前的bean马上就要被创建了</li>
</ul>
</li>
<li><p>createBean(beanName, mbd, args);</p>
<ul>
<li><p>①resolveBeforeInstantiation</p>
<ul>
<li><p>postProcessBeforeInstantiation</p>
<ul>
<li>InstantiationAwareBeanPostProcessors后置处理器的postProcessBeforeInstantiation</li>
<li>aop的才会被调用</li>
</ul>
</li>
</ul>
</li>
<li><p>doCreateBean</p>
<ul>
<li><p>解释</p>
<ul>
<li>真的创建bean的逻辑,该方法是最复杂的包含了调用构造函数,给bean的属性赋值</li>
<li>调用bean的初始化操作以及 生成代理对象 都是在这里</li>
<li><p>方法在AbstractAutowireCapableBeanFactory类中</p>
<ul>
<li>类继承图</li>
<li>DefaultSingletonBeanRegistry类中声明了一二三级缓存</li>
</ul>
</li>
</ul>
</li>
<li><p>createBeanInstance</p>
<ul>
<li><p>解释</p>
<ul>
<li>创建bean实例化</li>
<li>使用合适的实例化策略来创建新的实例：工厂方法、构造函数自动注入、简单初始化 该方法很复杂也很重要</li>
</ul>
</li>
<li><p>②determineConstructorsFromBeanPostProcessors</p>
<ul>
<li>determineCandidateConstructors</li>
</ul>
</li>
<li><p>instantiateBean</p>
<ul>
<li>默认会调用无参构造函数</li>
</ul>
</li>
</ul>
</li>
<li><p>③applyMergedBeanDefinitionPostProcessors</p>
<ul>
<li>进行后置处理 @AutoWired @Value的注解的预解析</li>
</ul>
</li>
<li><p>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</p>
<ul>
<li><p>缓存单例到三级缓存中</p>
<ul>
<li>普通对象(无循环依赖)直接忽略三级缓存？</li>
</ul>
</li>
<li><p>④getEarlyBeanReference</p>
<ul>
<li>产生循环依赖会提前在属性赋值(populateBean里getBean回调getEarlyBeanReference)时，创建动态代理</li>
<li>正常情况会在初始化时创建动态代理</li>
</ul>
</li>
</ul>
</li>
<li><p>populateBean</p>
<ul>
<li><p>解释</p>
<ul>
<li>属性赋值 给我们的属性进行赋值(调用set方法进行赋值)</li>
</ul>
</li>
<li><p>⑤postProcessAfterInstantiation</p>
</li>
<li><p>autowire注入属性</p>
<ul>
<li><p>autowireByName</p>
<ul>
<li>getBean(propertyName)：依赖循环</li>
</ul>
</li>
<li><p>autowireByType</p>
</li>
</ul>
</li>
<li><p>⑥postProcessPropertyValues</p>
</li>
</ul>
</li>
<li><p>initializeBean</p>
<ul>
<li><p>解释</p>
<ul>
<li>进行对象初始化操作(在这里可能生成代理对象)</li>
</ul>
</li>
<li><p>invokeAwareMethods</p>
<ul>
<li>实现XXXAware接口进行方法的回调</li>
</ul>
</li>
<li><p>⑦applyBeanPostProcessorsBeforeInitialization</p>
<ul>
<li>调用我们的bean的后置处理器的postProcessorsBeforeInitialization方法  @PostConstruct注解的方法</li>
</ul>
</li>
<li><p>invokeInitMethods</p>
<ul>
<li>调用初始化方法</li>
</ul>
</li>
<li><p>⑧applyBeanPostProcessorsAfterInitialization</p>
<ul>
<li>调用我们bean的后置处理器的PostProcessorsAfterInitialization方法</li>
</ul>
</li>
</ul>
</li>
<li><p>earlySingletonExposure？</p>
<ul>
<li><p>getSingleton(beanName, false);</p>
<ul>
<li>返回二级缓存中的早期对象</li>
<li>为了返回回去清除二三级缓存？</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>afterSingletonCreation(beanName);</p>
<ul>
<li>后置处理</li>
<li>主要做的事情就是把singletonsCurrentlyInCreation标记正在创建的bean从集合中移除</li>
</ul>
</li>
<li><p>addSingleton(beanName, singletonObject);</p>
<ul>
<li>加入一级缓存中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p>为什么要三级缓存</p>
<ul>
<li><p>一级缓存</p>
<ul>
<li>单线程中能保证循环依赖</li>
<li>存的是成熟态的bean</li>
</ul>
</li>
<li><p>二级缓存</p>
<ul>
<li>多线程下，避免获取的Bean不完整，防止多线程中在Bean还未创建完成时读取到的Bean时不完整的</li>
<li>存的是纯静态的bean</li>
<li><p>tips</p>
<ul>
<li>正常普通的bean(不存在循环依赖的bean) 创建的过程中，压根不会把三级缓存提升到二级缓存中</li>
</ul>
</li>
</ul>
</li>
<li><p>三级缓存</p>
<ul>
<li>单一职责原则，避免耦合，</li>
<li>存的是函数接口（即不会立即缓存单例对象，而是等待调用时再返回）</li>
<li><p>好处</p>
<ul>
<li>1：延迟获取，提高性能： 因为并不是所有的Bean都存在循环引用（不需要所有单例都缓存起来等待循环依赖调用），所以当真正调用时再缓存该单例到二级缓存。</li>
<li>2：提高扩展性：这是spring一贯作风，采用bean的后置处理器方式可以提高扩展性（如代理操作等..）</li>
<li>3：aop的考虑：如果依赖的bean是代理类，那么将代理创建的方法作为回调方法。</li>
</ul>
</li>
</ul>
</li>
<li><p>循环依赖重点：缓存早期对象(实例化之后的对象)</p>
</li>
</ul>
</li>
<li><p>不能解决构造器的循环依赖</p>
<ul>
<li>在构造器实例化之前(构造器是实例化时调用)，一二三级缓存中没有bean的相关信息</li>
<li><p>例</p>
<ul>
<li><p>比如A先调用B，造成循环依赖。A先使用构造器注入，构造器注入过程中发现此时B还没有创建，于是就去创建B了，但是此时A的构造器还没有走完，三级缓存中也没有A；</p>
<ul>
<li>下次创建B时，去调用getBean(A)，就会发现一二三级缓存中都没有A，于是去DefaultSingletonBeanRegistry#getSingleton(beanName, () -&gt; {}中加入singletonsCurrentlyInCreation(保存正在创建的bean)集合时会报错</li>
</ul>
</li>
<li><p>如果使用的是setter注入，默认是使用的无参构造，之后就会将A放入三级缓存中，此时再调用getBean(A)，就能直接从三级缓存中获取到A了</p>
</li>
</ul>
</li>
<li><p>最主要的原因是构造器注入是在createBeanInstance中，而setter注入是在populateBean中，所以setter注入不会报错</p>
</li>
</ul>
</li>
<li><p>不能解决多例的循环依赖</p>
<ul>
<li>单例意味着只需要创建一次对象，后面就可以从缓存中取出来，字段注入，意味着我们无需调用构造方法进行注入。</li>
<li>如果是原型bean，那么就意味着每次都要去创建对象，无法利用缓存；</li>
<li>如果是构造方法注入，那么就意味着需要调用构造方法注入，也无法利用缓存</li>
<li><p>doGetBean代码中有一句是多例直接报错</p>
<p>if (isPrototypeCurrentlyInCreation(beanName)) {<br>   throw new BeanCurrentlyInCreationException(beanName);<br>}</p>
</li>
</ul>
</li>
<li><p>为什么循环依赖的AOP要在实例化之后就创建</p>
<ul>
<li><p>比如A先调用B，造成循环依赖。这时候会一路执行，直到调用B的属性赋值时，发现一级缓存中没有A，就调用getBean(A)，并执行三级缓存中的函数接口。</p>
<ul>
<li>正常流程的话调用这个接口就会创建AOP，正常执行下面的流程</li>
<li>若在这个函数接口这不创建A的动态代理，那么最终创建出来给B赋值的A只是普通的Bean，而不是动态代理。而这是A的动态代理则会在最后A初始化完之后创建</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>循环依赖</li>
<li>图解</li>
</ul>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring源码(八)--MyBatis源码及Spring整合源码</title>
    <url>/alex-next/2022/08/18/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E4%B9%9D)--Spring%E6%95%B4%E5%90%88mybatis/</url>
    <content><![CDATA[<h2 id="Mybatis源码"><a href="#Mybatis源码" class="headerlink" title="Mybatis源码"></a>Mybatis源码</h2><h3 id="mybatis基础笔记"><a href="#mybatis基础笔记" class="headerlink" title="mybatis基础笔记"></a>mybatis基础笔记</h3><h3 id="mybatis的设计模式"><a href="#mybatis的设计模式" class="headerlink" title="mybatis的设计模式"></a>mybatis的设计模式</h3><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li><p>解析配置文件</p>
<ul>
<li><p>类型处理器</p>
<ul>
<li>TypeHandlerRegistry</li>
</ul>
</li>
<li><p>重要的对象</p>
<ul>
<li><p>SqlSessionFactoryBuilder</p>
<ul>
<li>SqlSessionFactory构造器</li>
</ul>
</li>
<li><p>Configuration</p>
<ul>
<li>mybatis所有的属性都放到了configuration里面</li>
<li>存储了自己的内置的一些类型处理器和sql语句</li>
</ul>
</li>
</ul>
</li>
<li><p>XMLConfigBuilder.parse()</p>
<ul>
<li><p>parseConfiguration</p>
<ul>
<li><p>解析mybatis-config.xml</p>
</li>
<li><p>。。。解析各种属性</p>
</li>
<li><p>pluginElement</p>
</li>
<li><p>typeHandlerElement</p>
</li>
<li><p>mapperElement</p>
<p>  <mappers></mappers></p>
<pre><code> &lt;mapper resource=&quot;mybatis/mapper/EmployeeMapper.xml&quot;/&gt;
 &lt;mapper class=&quot;com.tuling.mapper.DeptMapper&quot;&gt;&lt;/mapper&gt;
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>                 &lt;package name=&quot;com.tuling.mapper&quot;&gt;&lt;/package&gt;

               --&gt;
            &lt;/mappers&gt;

            - XMLMapperBuilder.parse

                - 解释

                    - 解析mapper.xml文件

                - setCurrentNamespace

                    - 设置&lt;namespace&gt;

                - cacheElement

                    - 设置&lt;cache&gt;二级缓存
                    - useNewCache

                        - CacheBuilder.build

                            - setStandardDecorators

                                - 运用了装饰器模式

                - resultMapElements

                    - 设置&lt;resultMap&gt;

                - sqlElement
                - buildStatementFromContext

                    - 解析sql语句，然后得到MappedStatement对象
                    - XMLStatementBuilder.parseStatementNode

                        - getStringAttribute

                            - 解析id

                        - 。。。解析各种属性
                        - createSqlSource

                            - 解析出sqlSource，这里不会替换参数，替换参数会在调用sql时
                            - XMLScriptBuilder.parseScriptNode

                                - 解释

                                    - 把所有sql语句结点解析为SqlNode
                                    - SqlNode实现类

                                - parseDynamicTags

                                    - handleNode

                                - tip:SqlNode的apply方法要调用sql时才执行

                        - getStringAttribute

                            - 结果集的映射

                        - addMappedStatement

                            - 构建MappedStatement对象，mybatis解析的所有sql信息都存在此对象中

                - 公共方法

                    - context.evalNodes

                        - 把节点解析为XNode
</code></pre><ul>
<li><p>调用</p>
<ul>
<li><p>SqlSessionFactory.openSession</p>
<ul>
<li><p>解释</p>
<ul>
<li>开启一个新会话</li>
</ul>
</li>
<li><p>newTransaction</p>
<ul>
<li>开启一个新事务</li>
</ul>
</li>
<li><p>newExecutor</p>
<ul>
<li>创建一个sql语句执行器对象</li>
<li><p>new SimpleExecutor</p>
<ul>
<li>实例化一个执行器</li>
<li>默认SimpleExecutor，其他的还有BaseExecutor(BatchExecutor、ReuseExecutor、SimpleExecutor)—默认一级缓存、CachingExecutor(开启了二级缓存)</li>
</ul>
</li>
<li><p>interceptorChain.pluginAll</p>
<ul>
<li>创建Executor的插件</li>
<li><p>Plugin.wrap</p>
<ul>
<li><p>getAllInterfaces</p>
<ul>
<li>当前代理类型 和 @signature指定的type进行配对， 配对成功则可以代理</li>
</ul>
</li>
<li><p>Proxy.newProxyInstance</p>
<ul>
<li>对当前executor进行增强</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>selectOne</p>
<ul>
<li><p>selectList</p>
<ul>
<li><p>getMappedStatement</p>
<ul>
<li><p>解释</p>
<ul>
<li>从MappedStatement中获取sql信息</li>
</ul>
</li>
</ul>
</li>
<li><p>executor.query</p>
<ul>
<li><p>CachingExecutor#query</p>
<ul>
<li><p>ms.getBoundSql</p>
<ul>
<li>解析sql，将参数、<if>、<where>动态替换掉</where></if></li>
<li><p>sqlSource.getBoundSql</p>
<ul>
<li><p>DynamicSqlSource#getBoundSql</p>
<ul>
<li>rootSqlNode.apply</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>createCacheKey</p>
<ul>
<li>创建缓存key</li>
</ul>
</li>
<li><p>query</p>
<ul>
<li><p>ms.getCache()</p>
<ul>
<li>从二级缓存中取，取不到查</li>
</ul>
</li>
<li><p>delegate#query</p>
<ul>
<li><p>BaseExecutor#query</p>
<ul>
<li><p>localCache.getObject(key)</p>
<ul>
<li>先从一级缓存中取，取不到查数据库</li>
</ul>
</li>
<li><p>queryFromDatabase</p>
<ul>
<li>查数据库</li>
<li><p>SimpleExecutor#doQuery</p>
<ul>
<li>调用JDBC查询数据库</li>
<li><p>configuration.newStatementHandler</p>
<ul>
<li><p>RoutingStatementHandler</p>
<ul>
<li><p>new PreparedStatementHandler</p>
<ul>
<li>configuration.newParameterHandler</li>
<li>configuration.newResultSetHandler</li>
</ul>
</li>
</ul>
</li>
<li><p>为StatementHandler添加插件(interceptorChain.pluginAll)</p>
</li>
</ul>
</li>
<li><p>handler.query</p>
<ul>
<li>查出结果</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>调用sql详细流程图</p>
</li>
</ul>
</li>
</ul>
<h3 id="mybatis中几个重要的XML…Builder"><a href="#mybatis中几个重要的XML…Builder" class="headerlink" title="mybatis中几个重要的XML…Builder"></a>mybatis中几个重要的XML…Builder</h3><ul>
<li><p>1 XMLConfigBuilder</p>
<p>  解析mybatis中configLocation属性中的全局xml文件，内部会使用XMLMapperBuilder解析各个xml文件。</p>
</li>
<li><p>2 XMLMapperBuilder</p>
<p>  遍历mybatis中mapperLocations属性中的xml文件中每个节点的Builder，比如user.xml，内部会使用XMLStatementBuilder处理xml中的每个节点。</p>
</li>
<li><p>3 XMLStatementBuilder</p>
<p>  解析xml文件中各个节点，比如select,insert,update,delete节点，内部会使用XMLScriptBuilder处理节点的sql部分，遍历产生的数据会丢到Configuration的mappedStatements中。</p>
</li>
<li><p>4 XMLScriptBuilder</p>
<p>  解析xml中各个节点sql部分的Builder。</p>
</li>
</ul>
<h3 id="Mybatis四大重要执行对象"><a href="#Mybatis四大重要执行对象" class="headerlink" title="Mybatis四大重要执行对象"></a>Mybatis四大重要执行对象</h3><ul>
<li>Executor</li>
<li>ParameterHandler</li>
<li>ResultSetHandler</li>
<li><p>StatementHandler</p>
<ul>
<li>sql执行者</li>
</ul>
</li>
</ul>
<h3 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h3><ul>
<li>插件</li>
<li>cache</li>
<li>解析sql</li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li>构造器模式</li>
<li>装饰模式—缓存</li>
<li>代理模式(增强四大组件)—插件</li>
</ul>
<h3 id="插件-动态代理-责任链-、缓存-装饰器、责任链-、sql注解"><a href="#插件-动态代理-责任链-、缓存-装饰器、责任链-、sql注解" class="headerlink" title="插件(动态代理+责任链)、缓存(装饰器、责任链)、sql注解"></a>插件(动态代理+责任链)、缓存(装饰器、责任链)、sql注解</h3><h2 id="Spring整合Mybatis"><a href="#Spring整合Mybatis" class="headerlink" title="Spring整合Mybatis"></a>Spring整合Mybatis</h2><h3 id="spring怎么管理mapper接口，怎么注入到IOC容器中的"><a href="#spring怎么管理mapper接口，怎么注入到IOC容器中的" class="headerlink" title="spring怎么管理mapper接口，怎么注入到IOC容器中的"></a>spring怎么管理mapper接口，怎么注入到IOC容器中的</h3><ul>
<li><p>思路：mybatis在spring生产bean的时候修改BeanDefinition从而注入到IOC中</p>
<ul>
<li>由于mybatis的代理类是动态生成的，所以spring拿不到代理类型，并且在BeanDefinition中设置为接口类型，后续Spring也无法生成实例，所以Mybatis需要自己去实例Bean</li>
<li>所以就可以用到FactoryBean，自己控制Bean的生产过程</li>
</ul>
</li>
<li><p>MapperScannerConfigurer</p>
<ul>
<li><p>目的</p>
<ul>
<li>为了解决MapperFactoryBean需要重复配置</li>
<li>会扫描org.crowd.mapper下的所有接口，然后创建各自接口的动态代理类。</li>
</ul>
</li>
<li><p>类继承图</p>
<ul>
<li>会在invokeBeanFactoryPostProcessors执行</li>
</ul>
</li>
<li><p>SSM阶段需要自己注入MapperScannerConfigurer</p>
</li>
<li>使用xml方式</li>
</ul>
</li>
<li><p>@MapperScan#MapperScannerRegistrar</p>
<ul>
<li><p>目的</p>
<ul>
<li>为了解决MapperFactoryBean需要重复配置</li>
<li>会扫描org.crowd.mapper下的所有接口，然后创建各自接口的动态代理类。</li>
</ul>
</li>
<li><p>registerBeanDefinitions</p>
<ul>
<li><p>doScan</p>
<ul>
<li>拿到所有的Mapper接口</li>
<li><p>processBeanDefinitions</p>
<ul>
<li><p>definition.setBeanClass(this.mapperFactoryBean.getClass());</p>
<ul>
<li>设置Class类型为FactoryBean</li>
</ul>
</li>
<li><p>definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName);</p>
<ul>
<li>表示会调用FactoryBean的构造方法生成实例，并传入Mapper接口中</li>
</ul>
</li>
<li><p>definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE)</p>
<ul>
<li>为了通过set方法按类型注入sqlSessionFactory</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>不在xml配置的话，必须通过MapperScan来扫描，扫描注册的类就是MapperScannerRegistrar</p>
</li>
<li>会在invokeBeanFactoryPostProcessors执行</li>
</ul>
</li>
<li><p>MapperFactoryBean</p>
<ul>
<li><p>getBean</p>
<ul>
<li>调用getObject执行Mybatis的动态代理</li>
</ul>
</li>
</ul>
</li>
<li><p>说明</p>
<ul>
<li>mybatis-spring1.2.2中xml方式全程使用MapperScannerConfigurer；注解方式MapperScannerRegistrar会注册MapperScannerConfigurer的beanDefinition</li>
<li>mybatis-spring2.0.0中xml方式全程使用MapperScannerConfigurer；注解方式全程使用MapperScannerRegistrar</li>
</ul>
</li>
</ul>
<h3 id="构建SqlSessionFactory，用于操作数据库SqlSessionFactoryBean继承了FactoryBean和InitializingBean"><a href="#构建SqlSessionFactory，用于操作数据库SqlSessionFactoryBean继承了FactoryBean和InitializingBean" class="headerlink" title="构建SqlSessionFactory，用于操作数据库SqlSessionFactoryBean继承了FactoryBean和InitializingBean"></a>构建SqlSessionFactory，用于操作数据库SqlSessionFactoryBean继承了FactoryBean和InitializingBean</h3><ul>
<li>会在bean初始化时，执行</li>
<li><p>getObject</p>
<ul>
<li><p>afterPropertiesSet</p>
<ul>
<li><p>buildSqlSessionFactory</p>
<ul>
<li>XMLConfigBuilder</li>
<li>XMLMapperBuilder</li>
<li><p>SpringManagedTransactionFactory</p>
<ul>
<li>会使用spring的数据源</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="整合Spring和Mybatis三步"><a href="#整合Spring和Mybatis三步" class="headerlink" title="整合Spring和Mybatis三步"></a>整合Spring和Mybatis三步</h3><ul>
<li><ol>
<li>定义一个MyFactoryBean </li>
</ol>
</li>
<li><ol>
<li>定义一个MyImportBeanDefinitionRegistrar </li>
</ol>
</li>
<li><ol>
<li>在AppConfig上添加一个注解@Import(MyImportBeanDefinitionRegistrar.class)</li>
</ol>
</li>
<li>流程图</li>
</ul>
<h3 id="Component、-Import和-Bean区别"><a href="#Component、-Import和-Bean区别" class="headerlink" title="@Component、@Import和@Bean区别"></a>@Component、@Import和@Bean区别</h3><ul>
<li>@Component无法注入接口，只能注入类，@Bean可以自定义实现，可以控制bean的实例化过程，可以注入接口的实现类</li>
<li><p>@Import可以批量注入，可以导入不在扫描范围里的Bean，所以集成第三方框架一般都用@Import</p>
<ul>
<li><p>ImportSelector无法改变Bean的使用顺序，如Springboot中想要自定义某个默认的Bean(SqlSessionFactory)，就不能实现</p>
<ul>
<li>@ConditionalOnBean(SqlSessionFactory.class)配置了该bean，才注册</li>
<li>可以使用DeffredImportSelector，最后导入</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3>]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring源码(七)--日志</title>
    <url>/alex-next/2022/08/03/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E4%B8%83)--%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="spring4默认使用的是jcl-log4j，没有log4j，使用jul"><a href="#spring4默认使用的是jcl-log4j，没有log4j，使用jul" class="headerlink" title="spring4默认使用的是jcl+log4j，没有log4j，使用jul"></a>spring4默认使用的是jcl+log4j，没有log4j，使用jul</h3><h3 id="spring5默认使用spring-jcl-jul，可以指定log4j2"><a href="#spring5默认使用spring-jcl-jul，可以指定log4j2" class="headerlink" title="spring5默认使用spring-jcl+jul，可以指定log4j2"></a>spring5默认使用spring-jcl+jul，可以指定log4j2</h3><h3 id="springboot使用的是slf4j-logback"><a href="#springboot使用的是slf4j-logback" class="headerlink" title="springboot使用的是slf4j+logback"></a>springboot使用的是slf4j+logback</h3><h3 id="日志-1"><a href="#日志-1" class="headerlink" title="日志"></a>日志</h3><ul>
<li>log4j(最早的日志框架)</li>
<li>jul(输出日志为红色)(java.util.logging)(sun公司)</li>
<li>jcl(门面)(commons-logging)</li>
<li>slf4j(门面)(log4j作者觉得jcl太low)</li>
<li>logback(log4j作者觉得log4j性能太低而开发出来的)</li>
<li>log4j2(apache仿照logback)</li>
<li>spring-jcl(门面)(spring自己补充的，因为jcl不更新了)</li>
<li><p>最新的</p>
<ul>
<li>slf4j+logback</li>
<li>slf4j+log4j2</li>
</ul>
</li>
</ul>
<h3 id="不同日志适配"><a href="#不同日志适配" class="headerlink" title="不同日志适配"></a>不同日志适配</h3><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p>86.SpringBoot默认日志实现框架是什么，怎么切换成别的</p>
<ul>
<li><p>默认实现框架</p>
<ul>
<li>logback</li>
<li><p>参考</p>
<ul>
<li><p>log4j到logback原理</p>
<ul>
<li>1.log4j-api通过log4j-to-slf4j适配器转换为slf4j</li>
<li>2.slf4j通过logback-classic桥接器最终使用logback输出</li>
</ul>
</li>
</ul>
</li>
<li><p>springboot默认提供了jul和log4j到slf4j的适配器</p>
</li>
</ul>
</li>
<li><p>切换</p>
<ul>
<li><p>切换为log4j2</p>
<ul>
<li><p>添加slf4j对应的桥接器</p>
<ul>
<li>排除logback桥接器</li>
<li>加入log4j2桥接器</li>
<li>参考</li>
</ul>
</li>
</ul>
</li>
<li><p>切换为log4j</p>
<ul>
<li>排除logback桥接器</li>
<li>加入log4j的桥接器</li>
<li>参考</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring源码(一)--IOC容器整体</title>
    <url>/alex-next/2022/06/01/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E4%B8%80)--IOC%E5%AE%B9%E5%99%A8%E6%95%B4%E4%BD%93/</url>
    <content><![CDATA[<h2 id="IOC容器源码-大体"><a href="#IOC容器源码-大体" class="headerlink" title="IOC容器源码(大体)"></a>IOC容器源码(大体)</h2><h3 id="1-整体介绍"><a href="#1-整体介绍" class="headerlink" title="1.整体介绍"></a>1.整体介绍</h3><ul>
<li><p>IOC控制反转的意义</p>
<ul>
<li>当一个依赖的类改变了，不用处处都改，只需要改变IOC容器中的bean</li>
</ul>
</li>
<li><p>BeanFactory和ApplicationContext区别</p>
</li>
<li><p>循环依赖</p>
<ul>
<li>设置三级缓存解决</li>
</ul>
</li>
<li><p>扩展点</p>
<ul>
<li>集成其他框架时，用的非常多</li>
<li><p>BeanFactoryPostProcessor</p>
<ul>
<li>集成其他框架时，用的非常多</li>
</ul>
</li>
<li><p>BeanDefinitionRegistryPostProcessor</p>
<ul>
<li>用于注册扩展的bean定义，相当于“增加图纸”</li>
</ul>
</li>
</ul>
</li>
<li><p>问题</p>
<ul>
<li>描述下BeanFactory</li>
<li><p>BeanFactory和ApplicationContext的区别</p>
<ul>
<li>BeanFactory是spring的顶层核心接口，工厂只负责按照要求(beanDefinition)生产bean，要生产成什么样由ApplicationContext决定</li>
<li>ApplicationContext面向的是用户，需要提供各种人性化的服务，继承了BeanFactory，离开了BeanFactory生产不了bean(就行各种店铺离不开工厂)</li>
</ul>
</li>
<li><p>简述SpringIOC的加载过程</p>
</li>
<li><p>简述Bean的生命周期</p>
<ul>
<li><p>实例化</p>
<ul>
<li><ol>
<li>实例化Bean对象，这个时候Bean的对象是非常低级的，基本不能够被我们使用，因为连最基本的属性都没有设置，可以理解为 连Autowired注解都是没有解析的； </li>
</ol>
</li>
</ul>
</li>
<li><p>属性注入</p>
<ul>
<li><ol>
<li>填充属性，当做完这一步，Bean对象基本是完整的了，可以理解为Autowired注解已经解析完毕，依赖注入完成了； </li>
</ol>
</li>
</ul>
</li>
<li><p>初始化Initialization</p>
<ul>
<li><p>invokeAwareMethods</p>
<ul>
<li><ol>
<li>如果Bean实现了BeanNameAware接口，则调用setBeanName方法； </li>
</ol>
</li>
<li><ol>
<li>如果Bean实现了BeanClassLoaderAware接口，则调用setBeanClassLoader方法；</li>
</ol>
</li>
<li><ol>
<li>如果Bean实现了BeanFactoryAware接口，则调用setBeanFactory方法； </li>
</ol>
</li>
</ul>
</li>
<li><ol>
<li>调用BeanPostProcessor的postProcessBeforeInitialization方法；</li>
</ol>
</li>
<li><p>init</p>
<ul>
<li><ol>
<li>如果Bean实现了InitializingBean接口，调用afterPropertiesSet方法； </li>
</ol>
</li>
<li><ol>
<li>如果Bean定义了init-method方法，则调用Bean的init-method方法；</li>
</ol>
</li>
<li><ol>
<li>调用BeanPostProcessor的postProcessAfterInitialization方法；当进行到这一步，Bean已经被准备就绪了，一直停留在应用的 上下文中，直到被销毁；</li>
</ol>
</li>
</ul>
</li>
<li><p>close()</p>
<ul>
<li><ol>
<li>如果应用的上下文被销毁了，如果Bean实现了DisposableBean接口，则调用destroy方法，如果Bean定义了destory-method 声明了销毁方法也会被调用。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Spring中有哪些扩展接口及调用时机</p>
<ul>
<li>BeanFactoryPostProcessor</li>
<li>FactoryBean</li>
<li>BeanPostProcessor</li>
<li>初始化生命周期回调方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-源码介绍-IOC容器初始化过程"><a href="#2-源码介绍-IOC容器初始化过程" class="headerlink" title="2.源码介绍(IOC容器初始化过程)"></a>2.源码介绍(IOC容器初始化过程)</h3><ul>
<li><p>源码编译</p>
<ul>
<li><p>问题</p>
<ul>
<li><p>Error resolving plugin</p>
</li>
<li><p>Kotlin: warnings found and -Werror specified</p>
</li>
<li><p>CoroutinesRegistrar不存在</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用配置类的设计理念更先进</p>
</li>
<li><p>问题</p>
<ul>
<li><p>FactoryBean和BeanFactory区别</p>
<ul>
<li>FactoryBean就是一个扩展点，BeanFactory是使用了简单工厂模式，用于生产bean</li>
</ul>
</li>
<li><p>BeanFactoryPostProcessor和BeanPostProcessor区别</p>
<ul>
<li>BeanFactoryPostProcessor用于扩展bean定义，BeanPostProcessor用于扩展bean</li>
</ul>
</li>
<li><p>介绍下BeanFactoryPostProcessor在Spring中的用途</p>
<ul>
<li>扩展点，mybatis基于此与spring集成</li>
</ul>
</li>
<li><p>@Component、@Import和@Bean区别</p>
<ul>
<li>@Component无法注入接口，只能注入类，@Bean可以自定义实现，可以控制bean的实例化过程，可以注入接口的实现类</li>
<li><p>@Import可以批量注入，可以导入不在扫描范围里的Bean，所以集成第三方框架一般都用@Import</p>
<ul>
<li><p>ImportSelector无法改变Bean的使用顺序，如Springboot中想要自定义某个默认的Bean(SqlSessionFactory)，就不能实现</p>
<ul>
<li>@ConditionalOnBean(SqlSessionFactory.class)配置了该bean，才注册</li>
<li>可以使用DeffredImportSelector，最后导入</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="AnnotationConfigApplicationContext-MainConfig-class"><a href="#AnnotationConfigApplicationContext-MainConfig-class" class="headerlink" title="AnnotationConfigApplicationContext(MainConfig.class)"></a>AnnotationConfigApplicationContext(MainConfig.class)</h3><ul>
<li><p>this();</p>
<ul>
<li><p>this.beanFactory = new DefaultListableBeanFactory();</p>
<p>调用父类的构造函数，初始化BeanFactory</p>
<ul>
<li><p>解释</p>
<ul>
<li>调用父类的构造函数，初始化BeanFactory</li>
<li>DefaultListableBeanFactory还继承了BeanDefinitionRegistry的功能</li>
<li>DefaultListableBeanFactory属性</li>
</ul>
</li>
</ul>
</li>
<li><p>this.reader = new AnnotatedBeanDefinitionReader(this);</p>
<ul>
<li><p>解释</p>
<ul>
<li><p>注册spring内置的PostProcessor到BeanDefinitionMap中，这几个类是spring的创始类</p>
<ul>
<li><p>AutowiredAnnotationBeanPostProcessor</p>
<p>用于解析@Autowired</p>
</li>
<li><p>internalConfigurationAnnotationProcessorConfigurationClassPostProcessor</p>
<p>在这个类中，会解析加了@Configuration的配置类，还会解析@ComponentScan、@ComponentScans注解扫描的包，以及解析@Import等注解。</p>
</li>
<li><p>RequiredAnnotationBeanPostProcessor</p>
<p>用于解析@Required</p>
</li>
<li><p>CommonAnnotationBeanPostProcessor</p>
<p>它负责解析<br>@Resource、@WebServiceRef、@EJB三个注解。<br>这三个注解都是定义在javax.*包下的注解，属于java中的注解。</p>
</li>
<li><p>EventListenerMethodProcessor</p>
</li>
<li><p>DefaultEventListenerFactory</p>
<p>负责创建监听器：ApplicationListenerMethodAdapter<br>为标注了@EventListener的方法<br>创建调用监听适配器：ApplicationListenerMethodAdapter</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);</p>
<p>public static Set<beandefinitionholder> registerAnnotationConfigProcessors(</beandefinitionholder></p>
<pre><code>  BeanDefinitionRegistry registry, @Nullable Object source) {
</code></pre><p>   DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);<br>   if (beanFactory != null) {</p>
<pre><code>  if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {
     //注册了实现Order接口的排序器
     beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);
  }
  //设置@AutoWired的候选的解析器：ContextAnnotationAutowireCandidateResolver
  // getLazyResolutionProxyIfNecessary方法，它也是唯一实现。
  //如果字段上带有@Lazy注解，表示进行懒加载 Spring不会立即创建注入属性的实例，而是生成代理对象，来代替实例
  if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {
     beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());
  }
</code></pre><p>   }</p>
<p>   Set<beandefinitionholder> beanDefs = new LinkedHashSet&lt;&gt;(8);</beandefinitionholder></p>
<p>   /**</p>
<pre><code>* 为我们容器中注册了解析我们配置类的后置处理器ConfigurationClassPostProcessor
* 名字叫:org.springframework.context.annotation.internalConfigurationAnnotationProcessor
*/
</code></pre><p>   if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {</p>
<pre><code>  RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
  def.setSource(source);
  beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
</code></pre><p>   }</p>
<p>   /**</p>
<pre><code>* 为我们容器中注册了处理@Autowired 注解的处理器AutowiredAnnotationBeanPostProcessor
* 名字叫:org.springframework.context.annotation.internalAutowiredAnnotationProcessor
*/
</code></pre><p>   if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {</p>
<pre><code>  RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);
  def.setSource(source);
  beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
</code></pre><p>   }</p>
<p>   /**</p>
<pre><code>* 为我们容器中注册处理@Required属性的注解处理器RequiredAnnotationBeanPostProcessor
* 名字叫:org.springframework.context.annotation.internalRequiredAnnotationProcessor
*/
</code></pre><p>   if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {</p>
<pre><code>  RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);
  def.setSource(source);
  beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
</code></pre><p>   }</p>
<p>   /**</p>
<pre><code>* 为我们容器注册处理JSR规范的注解处理器CommonAnnotationBeanPostProcessor
* org.springframework.context.annotation.internalCommonAnnotationProcessor
*/
</code></pre><p>   if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {</p>
<pre><code>  RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);
  def.setSource(source);
  beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));
</code></pre><p>   }</p>
<p>   /**</p>
<pre><code>* 处理jpa注解的处理器org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor
*/
</code></pre><p>   if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {</p>
<pre><code>  RootBeanDefinition def = new RootBeanDefinition();
  try {
     def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,
           AnnotationConfigUtils.class.getClassLoader()));
  }
  catch (ClassNotFoundException ex) {
     throw new IllegalStateException(
           &quot;Cannot load optional framework class: &quot; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);
  }
  def.setSource(source);
  beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));
</code></pre><p>   }</p>
<p>   /**</p>
<pre><code>* 处理监听方法的注解@EventListener解析器EventListenerMethodProcessor
*/
</code></pre><p>   if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {</p>
<pre><code>  RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);
  def.setSource(source);
  beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));
</code></pre><p>   }</p>
<p>   /**</p>
<pre><code>* 注册事件监听器工厂
*/
</code></pre><p>   if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {</p>
<pre><code>  RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);
  def.setSource(source);
  beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));
</code></pre><p>   }</p>
<p>   return beanDefs;<br>}</p>
<ul>
<li><p>registerPostProcessor()</p>
<p>注册某个具体的内置PostProcessor，会存放到BeanDefinitionMap中</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>this.scanner = new ClassPathBeanDefinitionScanner(this);</p>
<ul>
<li><p>解释</p>
<ul>
<li>会加载系统环境变量和资源读取器，并且里面定义了扫描包的核心方法doScan()</li>
<li>但是这里的scanner只用于applicationContext调用调度扫描包注册beanDefinition</li>
<li>还有个非常重要的地方，new ClassPathBeanDefinitionScanner的时候会调用registerDefaultFilters();在里面注册扫描时过滤候选component的includeFilters</li>
</ul>
</li>
<li><p>registerDefaultFilters();</p>
</li>
<li><p>setEnvironment(environment);</p>
<ul>
<li>设置环境对象</li>
</ul>
</li>
<li><p>setResourceLoader(resourceLoader);</p>
<ul>
<li>设置资源加载器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>register(componentClasses);</p>
<p>for (Class&lt;?&gt; annotatedClass : annotatedClasses) {<br>   registerBean(annotatedClass);<br>}</p>
<ul>
<li><p>解释</p>
<ul>
<li>将配置类(@Configuration标注的)注册到BeanDefinitionMap中。(这个类是启动容器的配置类)</li>
</ul>
</li>
</ul>
</li>
<li><p>refresh();</p>
<ul>
<li><p>invokeBeanFactoryPostProcessors(beanFactory);</p>
<ul>
<li><p>解释</p>
<ul>
<li>调用我们的bean工厂的后置处理器</li>
<li>会在此将class扫描成beanDefinition到beanDefinitionMap中</li>
<li>bean工厂的后置处理器调用</li>
</ul>
</li>
<li><p>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</p>
<ul>
<li><p>解释</p>
<ul>
<li>if (beanFactory instanceof BeanDefinitionRegistry)可以发现这句代码，如果是applicationContext就进入，有众多流程</li>
<li><p>若仅仅是beanFactory，则执行如下代码</p>
<p>invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</p>
</li>
</ul>
</li>
<li><p>invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</p>
<ul>
<li><p>解释</p>
<ul>
<li>获取容器中的ConfigurationClassPostProcessor的后置处理器进行bean定义的扫描，解析@Bean,@Component,@Service等等注解，添加到beanDefinitionMap中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>getBeanFactoryPostProcessors()</p>
<ul>
<li>我们自己调用addBeanFactoryPostProcessor的自定义BeanFactoryPostProcessor</li>
</ul>
</li>
</ul>
</li>
<li><p>registerBeanPostProcessors(beanFactory);</p>
<ul>
<li><p>解释</p>
<ul>
<li>注册BeanPostProcessor</li>
</ul>
</li>
<li><p>后置处理器9处调用</p>
</li>
<li><p>registerBeanPostProcessors</p>
<ul>
<li><p>注册主要的几个BeanPostProcessor</p>
<ul>
<li><p>AutowiredAnnotationBeanPostProcessor</p>
<p>解析@Autowired</p>
</li>
<li><p>RequiredAnnotationBeanPostProcessor</p>
<p>解析@Required</p>
</li>
<li><p>CommonAnnotationBeanPostProcessor</p>
<p>解析@Resource、@WebServiceRef、@EJB</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>finishBeanFactoryInitialization(beanFactory);</p>
<ul>
<li><p>解释</p>
<ul>
<li>整个bean的创建过程</li>
</ul>
</li>
<li><p>beanFactory.preInstantiateSingletons();</p>
<p>实例化单例bean</p>
<ul>
<li><p>getBean</p>
<ul>
<li><p>doGetBean</p>
<ul>
<li>实例化createBean</li>
<li>属性注入@Autowired   @Value</li>
<li><p>初始化initMethod   destroy</p>
<ul>
<li>Aware</li>
<li>@PostConstruct</li>
<li>InitializingBean</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><ul>
<li><p>spring底层核心常用注解</p>
<ul>
<li><p>1.配置</p>
<ul>
<li>@Configuration</li>
<li>@Bean</li>
</ul>
</li>
<li><p>2.包扫描</p>
<ul>
<li><p>@ComponentScan</p>
<ul>
<li>excludeFilters</li>
<li>includeFilters</li>
<li>Filter</li>
</ul>
</li>
</ul>
</li>
<li><p>3.配置bean的作用域</p>
<ul>
<li><p>@Scope</p>
<ul>
<li>a) singleton 单实例的(默认) </li>
<li>b) prototype 多实例的 </li>
<li>c) request 同一次请求 </li>
<li>d) session 同一个会话级别</li>
</ul>
</li>
</ul>
</li>
<li><p>4.Bean的懒加载</p>
<ul>
<li>@Lazy</li>
</ul>
</li>
<li><p>5.条件判断</p>
<ul>
<li>@Conditional</li>
</ul>
</li>
<li><p>6.往IOC中添加组件</p>
<ul>
<li><p>@CompentScan +@Controller @Service @Respository @compent</p>
<ul>
<li>针对我们自己写的组件可以通过该方式来进行加载到容器中。</li>
</ul>
</li>
<li><p>@Bean</p>
<ul>
<li>适用于导入第三方组件的类</li>
</ul>
</li>
<li><p>@Import</p>
<ul>
<li>导入组件的id为全类名路径</li>
<li>ImportSelector</li>
<li>ImportBeanDefinitionRegister</li>
</ul>
</li>
<li><p>实现FactoryBean</p>
</li>
</ul>
</li>
<li><p>7.Bean的初始化和销毁方法</p>
<ul>
<li>@Bean(initMethod = “init”,destroyMethod = “destroy”)</li>
<li>实现InitializingBean和DisposableBean</li>
<li>使用@PostConstruct 和@ProDestory标注方法</li>
<li>实现BeanPostProcessor重写postProcessBeforeInitialization和postProcessAfterInitialization</li>
</ul>
</li>
<li><p>8.给组件赋值</p>
<ul>
<li>@Value +@PropertySource</li>
</ul>
</li>
<li><p>9.自动装配</p>
<ul>
<li>@Autowired</li>
<li><p>@Qualifier</p>
<ul>
<li>指定特定的bean装配，===在@bean后加@Primary</li>
</ul>
</li>
<li><p>@Resource</p>
</li>
<li>@Inject</li>
</ul>
</li>
<li><p>10.使用IOC的组件，如ApplicationContext</p>
<ul>
<li>实现XXXAware接口</li>
</ul>
</li>
<li><p>11.@Profile</p>
<ul>
<li>根据不同环境激活bean</li>
<li>运行时jvm参数来切换 -Dspring.profiles.active=test|dev|prod</li>
</ul>
</li>
</ul>
</li>
<li><p>IOC容器整体加载流程图</p>
</li>
<li>IOC容器整体加载流程图(详细)</li>
<li>spring设计模式</li>
<li><p>spring源码脑图</p>
</li>
<li><p>spring中文文档</p>
</li>
<li><p>IOC概念</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring源码(二)--注册bean定义详解</title>
    <url>/alex-next/2022/06/17/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E4%BA%8C)--%E6%B3%A8%E5%86%8CBean%E5%AE%9A%E4%B9%89%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="invokeBeanFactoryPostProcessors注册bean定义详解"><a href="#invokeBeanFactoryPostProcessors注册bean定义详解" class="headerlink" title="invokeBeanFactoryPostProcessors注册bean定义详解"></a>invokeBeanFactoryPostProcessors注册bean定义详解</h2><h3 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors"></a>invokeBeanFactoryPostProcessors</h3><ul>
<li><p>ConfigurationClassPostProcessor类继承图</p>
</li>
<li><p>实现了PriorityOrdered接口(ConfigurationClassPostProcessor)的invokeBeanDefinitionRegistryPostProcessors</p>
<ul>
<li><p>currentRegistryProcessors.add(beanFactory.getBean()</p>
<p>  if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {</p>
<pre><code> //显示的调用getBean()的方式获取出该对象然后加入到currentRegistryProcessors集合中去
 currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
 //同时也加入到processedBeans集合中去
 processedBeans.add(ppName);
</code></pre><p>  }</p>
<ul>
<li>从IOC中实例化并取出ConfigurationClassPostProcessor</li>
</ul>
</li>
<li><p>postProcessBeanDefinitionRegistry</p>
<ul>
<li><p>解释</p>
<ul>
<li>解析@Configuration的配置类</li>
<li>解析@ComponentScan注解扫描的包</li>
<li>解析@Import，@Component，@Bean等注解</li>
</ul>
</li>
<li><p>for循环configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));</p>
<ul>
<li><p>解释</p>
<ul>
<li><p>ConfigurationClassUtils.checkConfigurationClassCandidate</p>
<ul>
<li>检查是不是full的配置类@Configuration</li>
<li>lite的配置类Component，ComponentScan，Import，ImportResource</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ConfigurationClassParser.parse(candidates);递归</p>
<ul>
<li><p>解释</p>
<ul>
<li>解析配置类</li>
</ul>
</li>
<li><p>processConfigurationClass(new ConfigurationClass(metadata, beanName));</p>
<ul>
<li><p>解释</p>
<ul>
<li>真的解析我们的配置类</li>
<li>把我们的配置类源信息和beanName包装成一个ConfigurationClass 对象</li>
</ul>
</li>
<li><p>this.conditionEvaluator.shouldSkip</p>
<ul>
<li>解析判断@Conditional是否满足条件</li>
</ul>
</li>
<li><p>doProcessConfigurationClass(configClass, sourceClass);</p>
<ul>
<li>processPropertySource(propertySource);</li>
<li><p>this.componentScanParser.parse</p>
<ul>
<li><p>this.componentScanParser.parse</p>
<ul>
<li><p>解释</p>
<ul>
<li>解析@Scope的ProxyMode属性</li>
<li>设置CompentScan对象的includeFilters 包含的属性</li>
<li>设置CompentScan对象的excludeFilters 包含的属性</li>
<li>是否懒加载</li>
<li><p>扫描时会判断</p>
<ul>
<li>1.类上是否有@Component</li>
<li>2.类是否为接口、抽象类</li>
</ul>
</li>
</ul>
</li>
<li><p>scanner(ClassPathBeanDefinitionScanner).doScan</p>
<ul>
<li>将bean定义注册到BeanDefinitionMap中</li>
<li><p>findCandidateComponents(basePackage);</p>
<ul>
<li><p>scanCandidateComponents(basePackage);</p>
<ul>
<li>获得包下所有的.class文件</li>
<li><p>isCandidateComponent</p>
<ul>
<li>1.类上是否有@Component</li>
<li>2.类是否为接口、抽象类</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>registerBeanDefinition(definitionHolder, this.registry);</p>
<ul>
<li>将bean定义注册到BeanDefinitionMap中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>processImports</p>
</li>
<li>configClass.addImportedResource</li>
<li><p>retrieveBeanMethodMetadata(sourceClass);</p>
<ul>
<li>获取到我们配置类中所有标注了@Bean的方法</li>
<li>放到Set中，并未解析成Bean定义放到BeanDefinitionMap中</li>
</ul>
</li>
<li><p>processInterfaces(configClass, sourceClass);</p>
<ul>
<li>处理配置类接口 默认方法的@Bean</li>
</ul>
</li>
</ul>
</li>
<li><p>this.configurationClasses.put(configClass, configClass);</p>
<ul>
<li>放入缓存</li>
</ul>
</li>
</ul>
</li>
<li><p>processDeferredImportSelectors();</p>
<ul>
<li>处理我们延时的DeferredImportSelectors</li>
<li>springboot就是通过这步进行记载spring.factories文件中的自定装配的对象</li>
</ul>
</li>
</ul>
</li>
<li><p>this.reader.loadBeanDefinitions(configClasses);</p>
<ul>
<li>此处才把@Bean的方法和@Import 注册到BeanDefinitionMap中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>实现了Ordered接口(包含自定义的)的invokeBeanDefinitionRegistryPostProcessors</p>
<ul>
<li>实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessor也在这里，推测是因为在上一步ConfigurationClassPostProcessor把注解标注的Definition注册进来，而ConfigurationClassPostProcessor在上下文的构造函数就注册进来了，而自定义的PriorityOrdered接口的BeanDefinitionRegistryPostProcessor却还没注册BeanDefinition，所以这在上一步获取不到</li>
</ul>
</li>
<li><p>没实现任何优先级接口(包含自定义的)的invokeBeanDefinitionRegistryPostProcessors</p>
</li>
<li><p>BeanDefinitionRegistryPostProcessor(包含自定义的)#invokeBeanFactoryPostProcessors(registryProcessors</p>
<ul>
<li><p>ConfigurationClassPostProcessor的invokeBeanFactoryPostProcessors</p>
<p>  //调用 BeanDefinitionRegistryPostProcessor.postProcessBeanFactory方法<br>  invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</p>
<ul>
<li><p>enhanceConfigurationClasses</p>
<ul>
<li>使用cglib对配置类进行代理，调用@Bean方法就不会重复创建实例</li>
</ul>
</li>
</ul>
</li>
<li><p>执行BeanDefinitionRegistryPostProcessor#postProcessBeanFactory</p>
</li>
</ul>
</li>
<li><p>通过getBeanFactoryPostProcessors添加进来的BeanFactoryPostProcessor#invokeBeanFactoryPostProcessors(regularPostProcessors</p>
<ul>
<li>getBeanFactoryPostProcessors添加进来的BeanPostProcessor，如springboot添加进来的ConfigFileApplicationListener$PropertySourceOrderingPostProcessor</li>
</ul>
</li>
<li><p>细节</p>
<ul>
<li>processedBeans会保存处理过的BeanDefinitionRegistryPostProcessor，执行只继承了BeanFactoryPostProcessor的类时，便不再执行带注册bean功能的工厂后置处理器</li>
</ul>
</li>
<li><p>实现了PriorityOrdered接口(包含自定义的)的BeanFactoryProcessor</p>
</li>
<li><p>实现了Ordered接口(包含自定义的)的BeanFactoryProcessor</p>
</li>
<li><p>没有实现任何优先级接口(包含自定义的)的BeanFactoryProcessor</p>
</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p>@Configuration加与不加的区别</p>
<ul>
<li><p>ConfigurationClassPostProceessor执行postProcessBeanFactory方法时会给配置类做cjlib动态代理，让@Bean的实例不会被重复new</p>
<ul>
<li>会判断实例是否是第一次创建（是否已经存在于IOC容器），如果说已经存在，那么spring应该直接去容器中拿这个beaninstance</li>
</ul>
</li>
<li><p>答案图片</p>
</li>
</ul>
</li>
<li><p>invokeBeanDefinitionRegistryPostProcessors(PriorityOrdered)</p>
<ul>
<li><p>解析配置类的时候会重新new 一个scanner(ClassPathBeanDefinitionScanner)和AnnotationConfigApplicationContext中的不是一个</p>
<ul>
<li>AnnotationConfigApplicationContext中的只是为了自己调用scan方法</li>
</ul>
</li>
</ul>
</li>
<li><p>创始类什么时候实例化</p>
<ul>
<li>getBean会实例化创始类</li>
</ul>
</li>
<li><p>@Component、@Import和@Bean区别</p>
<ul>
<li>@Component无法注入接口，只能注入类，@Bean可以自定义实现，可以控制bean的实例化过程，可以注入接口的实现类</li>
<li><p>@Import可以批量注入，可以导入不在扫描范围里的Bean，所以集成第三方框架一般都用@Import</p>
<ul>
<li><p>ImportSelector无法改变Bean的使用顺序，如Springboot中想要自定义某个默认的Bean(SqlSessionFactory)，就不能实现</p>
<ul>
<li>@ConditionalOnBean(SqlSessionFactory.class)配置了该bean，才注册</li>
<li>可以使用DeffredImportSelector，最后导入</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>invokeBeanFactoryPostProcessors</li>
<li>注册bean定义流程图</li>
</ul>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring源码(五)--AOP</title>
    <url>/alex-next/2022/07/16/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E4%BA%94)--AOP/</url>
    <content><![CDATA[<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul>
<li><p>JDK</p>
<ul>
<li>只有一个动态代理文件，不会重复增强</li>
<li>反射调用invoke</li>
</ul>
</li>
<li><p>CGLIB</p>
<ul>
<li>会有多个动态代理文件。有一个路由文件，根据索引去路由文件中找到对应方法</li>
<li>直接调用intercept</li>
<li>方法会重复增强，但是在spring中使用不会重复增强，因为springaop没有使用cglib的inctercept去执行方法，而是使用责任链直接调用方法本身</li>
</ul>
</li>
<li><p>参考</p>
</li>
</ul>
<h3 id="切面：类，被-AspectJ标注的类"><a href="#切面：类，被-AspectJ标注的类" class="headerlink" title="切面：类，被@AspectJ标注的类"></a>切面：类，被@AspectJ标注的类</h3><ul>
<li><p>advisor：某个具体的通知=advise+pointcut</p>
<ul>
<li>advise：通知类型(如前置通知)</li>
<li>pointcut：切点</li>
</ul>
</li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li><p>解析切面</p>
<ul>
<li><p>AbstractAutoProxyCreator#postProcessBeforeInstantiation</p>
<ul>
<li><p>解释</p>
<ul>
<li>在bean实例化之前调用</li>
<li>AspectJAwareAdvisorAutoProxyCreator类继承图</li>
</ul>
</li>
<li><p>Object cacheKey = getCacheKey(beanClass, beanName);</p>
<ul>
<li>构建缓存，尝试从缓存中取</li>
</ul>
</li>
<li><p>shouldSkip</p>
<ul>
<li><p>findCandidateAdvisors</p>
<ul>
<li>找到候选的Advisors(前置、后置、异常通知…)</li>
<li><p>buildAspectJAdvisors</p>
<ul>
<li><p>this.advisorFactory.isAspect(beanType)</p>
<ul>
<li>判断是不是切面</li>
</ul>
</li>
<li><p>this.advisorFactory.getAdvisors(factory);</p>
<ul>
<li>解析advisors</li>
<li><p>getAdvisor</p>
<ul>
<li>解析一个具体的advisor</li>
<li><p>getPointcut</p>
<ul>
<li>获取切点表达式</li>
</ul>
</li>
<li><p>InstantiationModelAwarePointcutAdvisorImpl将advisor封装到此对象中</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>this.advisorsCache.put(beanName, classAdvisors);</p>
<ul>
<li>添加到缓存中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>创建代理</p>
<ul>
<li><p>AbstractAutoProxyCreator#postProcessAfterInitialization</p>
<ul>
<li><p>解释</p>
<ul>
<li>在bean初始化完之后调用</li>
</ul>
</li>
<li><p>getCacheKey(bean.getClass(), beanName);</p>
<ul>
<li>尝试从缓存中取</li>
</ul>
</li>
<li><p>wrapIfNecessary</p>
<ul>
<li><p>getAdvicesAndAdvisorsForBean</p>
<ul>
<li>根据bean找到匹配的advisor</li>
<li><p>findEligibleAdvisors</p>
<ul>
<li><p>findCandidateAdvisors</p>
<ul>
<li>获取之前解析过的advisors</li>
</ul>
</li>
<li><p>findAdvisorsThatCanApply</p>
<ul>
<li>切点是否命中当前Bean(匹配方法)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>createProxy</p>
<ul>
<li><p>创建动态代理对象</p>
<ul>
<li>proxy-target-class=”true”强制创建cglib代理</li>
<li>有接口则创建jdk代理，否则cglib代理</li>
</ul>
</li>
<li><p>proxyFactory.getProxy</p>
<ul>
<li>createAopProxy().getProxy</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>调用代理</p>
<ul>
<li><p>解释</p>
<ul>
<li>责任链模式调用</li>
</ul>
</li>
<li><p>以jdk代理为例</p>
<ul>
<li><p>JdkDynamicAopProxy#invoke</p>
<ul>
<li><p>getInterceptorsAndDynamicInterceptionAdvice</p>
<ul>
<li>把aop的advisor 全部转化为拦截器</li>
</ul>
</li>
<li><p>new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</p>
<ul>
<li>创建调用对象</li>
</ul>
</li>
<li><p>invocation.proceed();</p>
<ul>
<li>基于责任链模式递归调用</li>
<li>通知advisor(前置、后置通知…)的拦截器都继承了MethodInterceptor</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><ul>
<li>aop源码</li>
</ul>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring源码(六)--事务</title>
    <url>/alex-next/2022/07/27/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E5%85%AD)--%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="事务源码"><a href="#事务源码" class="headerlink" title="事务源码"></a>事务源码</h2><h3 id="默认使用jdk"><a href="#默认使用jdk" class="headerlink" title="默认使用jdk?"></a>默认使用jdk?</h3><ul>
<li><p>JDK</p>
<ul>
<li>只有一个动态代理文件，不会重复增强</li>
<li>反射调用invoke</li>
</ul>
</li>
<li><p>CGLIB</p>
<ul>
<li>会有多个动态代理文件。有一个路由文件，根据索引去路由文件中找到对应方法</li>
<li>直接调用intercept</li>
<li>方法会重复增强，但是在spring中使用不会重复增强，因为springaop没有使用cglib的inctercept去执行方法，而是使用责任链直接调用方法本身</li>
</ul>
</li>
<li><p>嵌套事务正常调用，就算传播行为是REQUIRED_NEW也只会有一次代理，就算cglib代理也是一样(同一个类中事务方法调用)</p>
</li>
<li><p>分析解决</p>
<ul>
<li>不懂、忘了嵌套事务就看这个分析解决方案</li>
<li>注解开启 exposeProxy = true</li>
</ul>
</li>
</ul>
<h3 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h3><ul>
<li><p>REQUIRED（默认）</p>
<ul>
<li>开启新事务</li>
<li>适用于增删改查</li>
<li>融合到外部事务中</li>
</ul>
</li>
<li><p>SUPPORTS</p>
<ul>
<li>适用于查询</li>
</ul>
</li>
<li><p>REQUIRES_NEW</p>
<ul>
<li>开启新事务</li>
<li>适用于内部事务和外部事务不存在业务关联情况，如日志</li>
<li>内外部事务互相不影响</li>
<li>不用外部事务，创建新的事务</li>
</ul>
</li>
<li><p>NOT_SUPPORTED</p>
</li>
<li>NEVER </li>
<li>MANDATORY</li>
<li><p>NESTED</p>
<ul>
<li>开启新事务</li>
<li>外层影响内层， 内层不会影响外层，即可以局部回滚，外层提交内层才会提交</li>
</ul>
</li>
<li><p>参考</p>
</li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li><p>解析切面</p>
<ul>
<li>事务增强advisor的代码是内置的</li>
<li><p>@EnableTransactionManagement导入的两个类</p>
<ul>
<li><p>AutoProxyRegistrar</p>
<ul>
<li>导入InfrastructureAdvisorAutoProxyCreator</li>
</ul>
</li>
<li><p>ProxyTransactionManagementConfiguration</p>
<ul>
<li>定义了怎么增强事务方法调用，根据@Transactional(切点)去找对应的方法</li>
<li>事务内置的切面信息BeanFactoryTransactionAttributeSourceAdvisor</li>
<li>AnnotationTransactionAttributeSource();</li>
</ul>
</li>
</ul>
</li>
<li><p>AbstractAutoProxyCreator#postProcessBeforeInstantiation</p>
<ul>
<li><p>解释</p>
<ul>
<li>在bean实例化之前调用</li>
<li>AspectJAwareAdvisorAutoProxyCreator类继承图</li>
</ul>
</li>
<li><p>Object cacheKey = getCacheKey(beanClass, beanName);</p>
<ul>
<li>构建缓存，尝试从缓存中取</li>
</ul>
</li>
<li><p>shouldSkip</p>
<ul>
<li><p>findCandidateAdvisors</p>
<ul>
<li>找到候选的Advisors(前置、后置、异常通知…)</li>
<li><p>findAdvisorBeans</p>
<ul>
<li><p>beanNamesForTypeIncludingAncestors</p>
<ul>
<li><p>解释</p>
<ul>
<li>找出已注册的Advisor，事务在解析配置类的时候添加了一个事务相关的Advisor类</li>
</ul>
</li>
</ul>
</li>
<li><p>isEligibleBean(name)</p>
<ul>
<li>判断是不是InfrastructureAdvisorAutoProxyCreator</li>
</ul>
</li>
<li><p>advisors.add(this.beanFactory.getBean(name, Advisor.class));</p>
<ul>
<li>实例化advisor，并添加到advisors当中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>创建代理</p>
<ul>
<li><p>与AOP流程差不多，findAdvisorsThatCanApply-&gt;canApply使用PointCut匹配方法时，调用TransactionAttributeSourcePointcut#matches</p>
<ul>
<li><p>getTransactionAttributeSource</p>
<ul>
<li>获取我们@EnableTransactionManagement注解为我们容器中导入的ProxyTransactionManagementConfiguration配置类中的TransactionAttributeSource对象</li>
</ul>
</li>
<li><p>tas.getTransactionAttribute</p>
<ul>
<li><p>解释</p>
<ul>
<li>通过getTransactionAttribute看是否有@Transactional注解</li>
<li>TransactionAttribute封装了@Transactional的所有信息</li>
</ul>
</li>
<li><p>computeTransactionAttribute</p>
<ul>
<li><p>解释</p>
<ul>
<li>依次从实现类方法、实现类、实现接口方法、实现接口找@Transactional注解</li>
</ul>
</li>
<li><p>findTransactionAttribute</p>
<ul>
<li><p>SpringTransactionAnnotationParser#parseTransactionAnnotation</p>
<ul>
<li><p>AnnotatedElementUtils.findMergedAnnotationAttributes</p>
<ul>
<li>从element对象中获取@Transactional注解 然后把注解属性封装到了AnnotationAttributes</li>
<li>searchWithFindSemantics</li>
</ul>
</li>
<li><p>parseTransactionAnnotation(attributes)</p>
<ul>
<li>解析事务的各个属性封装到TransactionAttribute中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>setDescriptor(methodIdentification)</p>
<ul>
<li>把方法描述设置到事务属性上去</li>
</ul>
</li>
<li><p>this.attributeCache.put(cacheKey, txAttr);</p>
<ul>
<li>加入到缓存中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>调用代理</p>
<ul>
<li><p>JdkDynamicAopProxy#invoke</p>
<ul>
<li><p>getInterceptorsAndDynamicInterceptionAdvice</p>
<ul>
<li>把aop的advisor 全部转化为拦截器</li>
</ul>
</li>
<li><p>new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</p>
<ul>
<li>创建调用对象</li>
</ul>
</li>
<li><p>invocation.proceed();</p>
<ul>
<li><p>TransactionInterceptor#invoke</p>
<ul>
<li><p>invokeWithinTransaction</p>
<ul>
<li><p>getTransactionAttributeSource</p>
<ul>
<li>获得在ProxyTransactionManagementConfiguration添加的事务属源对象</li>
</ul>
</li>
<li><p>getTransactionAttribute</p>
<ul>
<li>获得解析的所有@Transactional的信息</li>
</ul>
</li>
<li><p>determineTransactionManager</p>
<ul>
<li>获得事务管理器</li>
</ul>
</li>
<li><p>methodIdentification</p>
<ul>
<li>获得匹配的方法(哪些需要事务)</li>
</ul>
</li>
<li><p>处理事务，分两种</p>
<ul>
<li><p>声明式事务</p>
<ul>
<li><p>createTransactionIfNecessary</p>
<ul>
<li><p>解释</p>
<ul>
<li>创建事务</li>
</ul>
</li>
<li><p>tm.getTransaction(txAttr);</p>
<ul>
<li><p>doGetTransaction</p>
<ul>
<li>尝试获取一个事务对象，从TransactionSynchronizationManager获取</li>
</ul>
</li>
<li><p>definition == null？</p>
<ul>
<li>判断从上一个方法传递进来的事务属性是不是为空，是空就创建一个默认的</li>
<li>if成立：definition = new DefaultTransactionDefinition();</li>
</ul>
</li>
<li><p>isExistingTransaction(transaction)？</p>
<ul>
<li>判断是否已经存在了事务(嵌套事务)</li>
<li><p>txObject.hasConnectionHolder() &amp;&amp; txObject.getConnectionHolder().isTransactionActive()</p>
<ul>
<li>若第一次进来开始事务，txObject.hasConnectionHolder() 返回的null 那么表示不存在事务</li>
</ul>
</li>
<li><p>if成立：return handleExistingTransaction(definition, transaction, debugEnabled);</p>
<ul>
<li><p>处理嵌套事务(分支)</p>
<ul>
<li>PROPAGATION_NEVER</li>
<li>PROPAGATION_NOT_SUPPORTED</li>
<li>PROPAGATION_REQUIRES_NEW</li>
<li>PROPAGATION_NESTED</li>
<li>默认(REQUIRED)</li>
<li>事务挂起</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>判断事务传播行为，能不能创建事务</p>
<ul>
<li><p>PROPAGATION_MANDATORY</p>
<ul>
<li>抛出异常</li>
</ul>
</li>
<li><p>PROPAGATION_REQUIRED</p>
</li>
<li>PROPAGATION_REQUIRES_NEW</li>
<li>PROPAGATION_NESTED</li>
</ul>
</li>
</ul>
</li>
<li><p>prepareTransactionInfo</p>
<ul>
<li>把事物状态和事物属性等信息封装成一个TransactionInfo对象，方便后续事务回滚提交</li>
<li>txInfo.newTransactionStatus(status);</li>
<li><p>txInfo.bindToThread();</p>
<ul>
<li>把事务信息对象绑定到当前线程变量中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>编程式事务</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="案例解析"><a href="#案例解析" class="headerlink" title="案例解析"></a>案例解析</h3><ul>
<li><p>1.普通方法调用事务方法，事务失效</p>
<ul>
<li>在调用代理时，getInterceptorsAndDynamicInterceptionAdvice会使用创建代理时TransactionAttributeSourcePointcut#matches(Method,class)方法匹配用户访问的方法是否有@Transactional注解；</li>
<li>若匹配成功会创建一个责任链，显而易见匹配会通不过，因此相当于直接调用方法，不使用事务</li>
</ul>
</li>
<li><p>AopContext.currentProxy()实质上就是重复调用了getInterceptorsAndDynamicInterceptionAdvice()和proceed()添加事务</p>
</li>
<li><p>2.事务方法A调用事务方法B，只有方法A起作用</p>
<ul>
<li>因为不使用AopContext.currentProxy()实质上就是简单的方法(调用的对象是普通的bean，是JDK代理方式在代理的时候反射生成的，CGLIB是子类直接调用父类的业务代码)调用了B，不会给方法B加上事务；而方法A是Spring使用动态代理去调用的，所以有事务</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring源码(八)--SpringMVC</title>
    <url>/alex-next/2022/08/07/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E5%85%AB)--SpringMVC/</url>
    <content><![CDATA[<h2 id="SpringMVC源码"><a href="#SpringMVC源码" class="headerlink" title="SpringMVC源码"></a>SpringMVC源码</h2><h3 id="参数注入"><a href="#参数注入" class="headerlink" title="参数注入"></a>参数注入</h3><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul>
<li><p>@Target</p>
<ul>
<li><p>指定作用的位置</p>
<ul>
<li><p>METHOD</p>
<ul>
<li>方法</li>
</ul>
</li>
<li><p>TYPE</p>
<ul>
<li>类、接口</li>
</ul>
</li>
<li><p>FIELD</p>
<ul>
<li>字段</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>@Retention</p>
<ul>
<li><p>指定保留策略</p>
<ul>
<li><p>RUNTIME</p>
<ul>
<li>运行时保留，可以通过反射拿到</li>
</ul>
</li>
<li><p>CLASS</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li><p>初始化</p>
<ul>
<li><p>DispatcherServlet#onRefresh</p>
<ul>
<li>initStrategies</li>
</ul>
</li>
</ul>
</li>
<li><p>调用</p>
<ul>
<li><p>DispatcherServlet#doService</p>
<ul>
<li><p>doDispatch(request, response);</p>
<ul>
<li><p>checkMultipart(request);</p>
<ul>
<li>检查是否有文件操作</li>
<li><p>resolveMultipart</p>
<ul>
<li>是的话处理文件</li>
</ul>
</li>
</ul>
</li>
<li><p>HandlerExecutionChain mappedHandler =getHandler(processedRequest);</p>
<ul>
<li><p>解释</p>
<ul>
<li>拿到执行链(HandlerInceptor*n+Handler)</li>
</ul>
</li>
<li><p>getHandlerInternal</p>
<ul>
<li>从缓存中找到对应的处理器</li>
</ul>
</li>
<li><p>obtainApplicationContext().getBean</p>
<ul>
<li>从容器中获得处理器实例</li>
</ul>
</li>
<li><p>getHandlerExecutionChain</p>
<ul>
<li>拿到所有的执行链(HandlerInceptor*n+Handler)</li>
</ul>
</li>
<li><p>getCorsHandlerExecutionChain</p>
<ul>
<li>处理CORS同源策略</li>
</ul>
</li>
</ul>
</li>
<li><p>HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler())</p>
<ul>
<li><p>解释</p>
<ul>
<li>拿到适配器，因为Controller可能有多种实现方式(注解、接口…)</li>
</ul>
</li>
<li><p>遍历this.handlerAdapters拿到对应的适配器</p>
</li>
</ul>
</li>
<li><p>mappedHandler.applyPreHandle</p>
<ul>
<li>遍历执行所有拦截器的preHandle方法</li>
</ul>
</li>
<li><p>ha.handle</p>
<ul>
<li><p>解释</p>
<ul>
<li>调用controller方法</li>
</ul>
</li>
<li><p>SimpleControllerHandlerAdapter#handle</p>
<ul>
<li>((Controller) handler).handleRequest(request, response);</li>
</ul>
</li>
</ul>
</li>
<li><p>mappedHandler.applyPostHandle</p>
<ul>
<li>遍历执行所有拦截器的postHandle方法</li>
</ul>
</li>
<li><p>processDispatchResult</p>
<ul>
<li><p>解释</p>
<ul>
<li>处理调用结果</li>
</ul>
</li>
<li><p>render(mv, request, response);</p>
<ul>
<li>视图解析</li>
<li><p>view = mv.getView();</p>
<ul>
<li>拿到视图</li>
</ul>
</li>
<li><p>view.render(mv.getModelInternal(), request, response);</p>
<ul>
<li>渲染视图</li>
<li><p>AbstractView#render</p>
<ul>
<li><p>AbstractJackson2View#renderMergedOutputModel</p>
<ul>
<li>对应的解析json数据</li>
</ul>
</li>
<li><p>InternalResourceView#renderMergedOutputModel</p>
<ul>
<li>前后端不分离时，解析返回的视图</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="spring与springmvc容器"><a href="#spring与springmvc容器" class="headerlink" title="spring与springmvc容器"></a>spring与springmvc容器</h3><ul>
<li>springmvc是子容器，spring是父容器，父容器拿不到子容器的bean，子容器可以拿到父容器的bean</li>
</ul>
<h3 id="手写springMVC代码"><a href="#手写springMVC代码" class="headerlink" title="手写springMVC代码"></a>手写springMVC代码</h3>]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring源码(四)--监听器</title>
    <url>/alex-next/2022/07/05/javaEE/spring%E6%BA%90%E7%A0%81/spring%E6%BA%90%E7%A0%81(%E5%9B%9B)--%E7%9B%91%E5%90%AC%E5%99%A8/</url>
    <content><![CDATA[<h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li><p>创建事件多播器</p>
<ul>
<li><p>initApplicationEventMulticaster</p>
<p>beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</p>
</li>
</ul>
</li>
<li><p>ApplicationListener接口的监听器解析</p>
<ul>
<li><p>两条路线</p>
<ul>
<li><p>registerListeners</p>
<ul>
<li><p>getApplicationEventMulticaster().addApplicationListener(listener);</p>
<ul>
<li>在onRefresh里面注册的监听器</li>
</ul>
</li>
<li><p>getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</p>
<ul>
<li>将bean的名字注册到多播器中</li>
</ul>
</li>
</ul>
</li>
<li><p>prepareBeanFactory</p>
<ul>
<li><p>beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));</p>
<ul>
<li><p>解释</p>
<ul>
<li>注册ApplicationListenerDetector</li>
</ul>
</li>
<li><p>在bean初始化结束后调用ApplicationListenerDetector#postProcessAfterInitialization</p>
<ul>
<li>this.applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么要注册两遍</p>
<ul>
<li>防止@Lazy懒加载的漏网之鱼</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>@EventListener注解解析过程</p>
<ul>
<li>1.在创始bean定义中注册了两个用于解析@EventListener</li>
<li><p>2.在bean初始完后调用smartSingleton.afterSingletonsInstantiated();</p>
<ul>
<li>EventListenerMethodProcessor实现了SmartInitializingSingleton</li>
</ul>
</li>
</ul>
</li>
<li><p>publishEvent：多播器发布事件</p>
<ul>
<li><p>SimpleApplicationEventMulticaster#multicastEvent</p>
<ul>
<li><p>接口</p>
<ul>
<li><p>listener.onApplicationEvent</p>
<ul>
<li>实现ApplicationListener之后直接调用</li>
</ul>
</li>
</ul>
</li>
<li><p>注解</p>
<ul>
<li><p>ApplicationListenerMethodAdapter</p>
<ul>
<li>反射实现</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p>bean创建完后扩展</p>
<ul>
<li>SmartInitializingSingleton</li>
<li>内置监听器</li>
</ul>
</li>
<li><p>使用了观察者模式</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/alex-next/2021/04/18/%E7%AE%97%E6%B3%95/dp/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="1-01背包问题"><a href="#1-01背包问题" class="headerlink" title="1.01背包问题"></a>1.01背包问题</h1><p>原题链接：<a href="https://www.acwing.com/problem/content/description/2/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/description/2/</a></p>
<p>详细解析：<a href="https://www.acwing.com/solution/content/1374/" target="_blank" rel="noopener">https://www.acwing.com/solution/content/1374/</a></p>
<p>关键：每件物品只能选一次，所以一维情况下，枚举背包容量时必须倒序，防止更新状态时前面的状态被污染</p>
<p>上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</span></span><br><span class="line"><span class="comment">第 i 件物品的体积是 vi，价值是 wi。</span></span><br><span class="line"><span class="comment">求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</span></span><br><span class="line"><span class="comment">输出最大价值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入格式</span></span><br><span class="line"><span class="comment">第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</span></span><br><span class="line"><span class="comment">接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出格式</span></span><br><span class="line"><span class="comment">输出一个整数，表示最大价值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">数据范围</span></span><br><span class="line"><span class="comment">0&lt;N,V≤1000</span></span><br><span class="line"><span class="comment">0&lt;vi,wi≤1000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,V;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;V;</span><br><span class="line">    <span class="keyword">int</span> v[N],w[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dp[V+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V+<span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N+<span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= v[i<span class="number">-1</span>]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] = max(dp[j],dp[j-v[i<span class="number">-1</span>]]+w[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[V]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// int dp[N+1][V+1];</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; N+1; i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     for (int j = 0; j &lt; V+1; j++)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         dp[i][j] = 0;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt; N+1; i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     for (int j = 1; j &lt; V+1; j++)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         if (v[i-1]&lt;=j)</span></span><br><span class="line">    <span class="comment">//         &#123;</span></span><br><span class="line">    <span class="comment">//             dp[i][j] = max(dp[i-1][j],dp[i-1][j-v[i-1]]+w[i-1]);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         else&#123;</span></span><br><span class="line">    <span class="comment">//             dp[i][j] = dp[i-1][j]; </span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;dp[N][V]&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2.完全背包问题"></a>2.完全背包问题</h1><p>原题链接：<a href="https://www.acwing.com/problem/content/3/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/3/</a></p>
<p>详细解析：<a href="https://www.acwing.com/solution/content/5345/" target="_blank" rel="noopener">https://www.acwing.com/solution/content/5345/</a></p>
<p>关键：与01背包不同的地方在于每个物品可以一直取，所以一维情况下，枚举背包容量时必须正序，这样更新状态时便可以使用到”污染”的状态(即一个物品可以被一直取)</p>
<p>上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,V;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;V;</span><br><span class="line">    <span class="keyword">int</span> v[N],w[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dp[V+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V+<span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N+<span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = v[i<span class="number">-1</span>]; j&lt;V+<span class="number">1</span>; j++)<span class="comment">//与0-1背包不同,j从小到大枚举,dp[j]的更新就是用到了"污染"的状态dp[j]</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] = max(dp[j],dp[j-v[i<span class="number">-1</span>]]+w[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[V]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int dp[N+1][V+1];</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; N+1; i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     for (int j = 0; j &lt; V+1; j++)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         dp[i][j] = 0;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt; N+1; i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     for (int j = 1; j &lt; V+1; j++)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         if(v[i-1]&gt;j)&#123;</span></span><br><span class="line">    <span class="comment">//             dp[i][j] = dp[i-1][j];</span></span><br><span class="line">    <span class="comment">//         &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//             dp[i][j] = max(dp[i-1][j],dp[i][j-v[i-1]]+w[i-1]);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;dp[N][V]&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-多重背包I"><a href="#3-多重背包I" class="headerlink" title="3.多重背包I"></a>3.多重背包I</h1><p>原题链接：<a href="https://www.acwing.com/problem/content/4/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/4/</a></p>
<p>详细解析：<a href="https://www.acwing.com/solution/content/17554/" target="_blank" rel="noopener">https://www.acwing.com/solution/content/17554/</a></p>
<p>背包I数据量最小，可以将多重背包拆成01背包然后当成01背包来做。</p>
<p>时间复杂度为$O(NVS)$</p>
<p>上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转换为0-1背包</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v,w,s;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= v; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= s &amp;&amp; k*v &lt;= j;k++)&#123;<span class="comment">//选1-s个，且选的物品总和不能把背包撑爆</span></span><br><span class="line">                dp[j] = max(dp[j],dp[j-v*k]+w*k);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-多重背包II"><a href="#4-多重背包II" class="headerlink" title="4.多重背包II"></a>4.多重背包II</h1><p>原题链接：<a href="https://www.acwing.com/problem/content/5/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/5/</a></p>
<p>详细解析：<a href="https://www.acwing.com/solution/content/5527/" target="_blank" rel="noopener">https://www.acwing.com/solution/content/5527/</a></p>
<p>此题数据量中等，可以考虑用二进制优化，即打包的思想，</p>
<p>核心思想：利用较少的几个数就能表示集合中所有的数。</p>
<p>时间复杂度为$O(NV\log S)$</p>
<p>上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">good</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> w,v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[N];</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;good&gt; goods;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v,w,s;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s; j*=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s-=j;</span><br><span class="line">            goods.push_back(&#123;j*w,j*v&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s&gt;<span class="number">0</span>)</span><br><span class="line">            goods.push_back(&#123;s*w,s*v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> g:goods)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= g.v; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j] = max(f[j],f[j-g.v]+g.w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-多重背包III"><a href="#5-多重背包III" class="headerlink" title="5.多重背包III"></a>5.多重背包III</h1><p>原题链接：<a href="https://www.acwing.com/problem/content/6/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/6/</a></p>
<p>详细解析：<a href="https://www.acwing.com/solution/content/6500/" target="_blank" rel="noopener">https://www.acwing.com/solution/content/6500/</a></p>
<p>​                <a href="https://www.bilibili.com/video/BV1354y1C7SF" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1354y1C7SF</a></p>
<p>由于此题数据量比前两个都多，二进制优化也不管用，所以引入单调队列优化解决此问题。</p>
<p>核心思想：按每种物品的体积v 将dp分成v个类，在每一类中就可以使用单调队列(窗口的大小就是物品的数量)。</p>
<p>时间复杂度为$O(NV)$</p>
<p>上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://www.bilibili.com/video/BV1354y1C7SF?from=search&amp;seid=6794272575550849440 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N], pre[N], q[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(pre, dp, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">int</span> v, w, s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v; ++j) &#123;<span class="comment">//拆分成v个类</span></span><br><span class="line">            <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt;= m; k += v) &#123;<span class="comment">//对每个类使用单调队列</span></span><br><span class="line">                <span class="comment">//q[hh]不在窗口[k-s*v,k-v]内,队头出队   </span></span><br><span class="line">                <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; k - q[hh] &gt;  s*v)</span><br><span class="line">                    ++hh;</span><br><span class="line">                <span class="comment">//当前值比对尾元素更有价值,队尾出队</span></span><br><span class="line">                <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; pre[k] &gt;= pre[q[tt]]+(k-q[tt])/v*w)</span><br><span class="line">                    --tt;</span><br><span class="line">                <span class="comment">//下标入队,便于队头出队 </span></span><br><span class="line">                q[++tt] = k;</span><br><span class="line">                <span class="comment">//使用队头最有价值元素更新dp</span></span><br><span class="line">                dp[k] = max(dp[k], pre[q[hh]] + (k - q[hh])/v * w);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度</title>
    <url>/alex-next/2021/05/09/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="1、高精度加法"><a href="#1、高精度加法" class="headerlink" title="1、高精度加法"></a>1、高精度加法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; add(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A.size() || i&lt;B.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;A.size())t+=A[i];</span><br><span class="line">        <span class="keyword">if</span>(i&lt;B.size())t+=B[i];</span><br><span class="line">        C.push_back(t%<span class="number">10</span>);</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t)C.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a,b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A,B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)A.push_back(a[i]-<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = b.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)B.push_back(b[i]-<span class="string">'0'</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C = add(A,B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="built_in">printf</span>(<span class="string">"%d"</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：如果有，记得在最后补上进位的1</p>
<h2 id="2、高精度减法"><a href="#2、高精度减法" class="headerlink" title="2、高精度减法"></a>2、高精度减法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.size()!=B.size())<span class="keyword">return</span> A.size()&gt;B.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = A.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(A[i]!=B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i]&gt;B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sub(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A.size();i++)&#123;</span><br><span class="line">        t = A[i]-t;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;B.size())t -= B[i];</span><br><span class="line">        C.push_back((t+<span class="number">10</span>)%<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(C.size()&gt;<span class="number">1</span> &amp;&amp; C.back()==<span class="number">0</span>)C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a,b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A,B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)A.push_back(a[i]-<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = b.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)B.push_back(b[i]-<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">if</span>(cmp(A,B))&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C = sub(A,B);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = C.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="built_in">printf</span>(<span class="string">"%d"</span>,C[i]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C = sub(B,A);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = C.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="built_in">printf</span>(<span class="string">"%d"</span>,C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：$(t+10)\%10$：无论$t<0$还是$t>=0$ ，最终都是正确的结果</0$还是$t></p>
<h2 id="3、高精度乘法"><a href="#3、高精度乘法" class="headerlink" title="3、高精度乘法"></a>3、高精度乘法</h2><p>高精度*低精度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mul(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A.size() || t;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;A.size())t += A[i]*b;</span><br><span class="line">        C.push_back(t%<span class="number">10</span>);</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(C.size()&gt;<span class="number">1</span> &amp;&amp; C.back()==<span class="number">0</span>)C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)A.push_back(a[i]-<span class="string">'0'</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C = mul(A,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="built_in">printf</span>(<span class="string">"%d"</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>高精度*高精度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mul(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C(A.size() + B.size(), <span class="number">0</span>); <span class="comment">// 初始化为 0，且999*99最多 5 位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.size(); j++)</span><br><span class="line">            C[i + j] += A[i] * B[j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C.size(); i++) &#123; <span class="comment">// i = C.size() - 1时 t 一定小于 10</span></span><br><span class="line">        t += C[i];</span><br><span class="line">        C[i] = t % <span class="number">10</span>;</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back(); <span class="comment">// 必须要去前导 0，因为最高位很可能是 0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b; <span class="comment">// a = "1222323", b = "2323423423"</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)A.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)B.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = mul(A, B);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; C[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、高精度除法"><a href="#4、高精度除法" class="headerlink" title="4、高精度除法"></a>4、高精度除法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; div(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;r)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = A.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        r = r*<span class="number">10</span>+A[i];</span><br><span class="line">        C.push_back(r/b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(C.begin(),C.end());</span><br><span class="line">    <span class="keyword">while</span>(C.size()&gt;<span class="number">1</span> &amp;&amp; C.back()==<span class="number">0</span>)C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)A.push_back(a[i]-<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C = div(A,b,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="built_in">printf</span>(<span class="string">"%d"</span>,C[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;r;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：开始是倒着来，结束时，再将结果倒置一下，为了和加减乘符合。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序与归并排序</title>
    <url>/alex-next/2021/05/08/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="1、快速排序"><a href="#1、快速排序" class="headerlink" title="1、快速排序"></a>1、快速排序</h2><p>① 基准元素取$x=p[l+r&gt;&gt;1]$</p>
<p>② 调整区间：根据基准元素将区间调整为左右两个小区间，左边的元素都小于等于$x$，右边的元素都大于等于$x$，<strong>但此时左右两个区间都是无序的</strong>。</p>
<p>③ 递归处理左右两个小区间。</p>
<p>注：边界问题，取$i=l-1和j=r+1$ ，防止边界元素遍历不到 (在<code>do-while</code>中先执行自加自减，再执行<code>while</code>)。</p>
<p>时间复杂度：每趟调整的时间复杂度为$O(n)$，递归处理栈深度最好为$O(logn)$，最差为$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> A[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = l<span class="number">-1</span>,j = r+<span class="number">1</span>,pivot = A[l+r&gt;&gt;<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">do</span> i++;<span class="keyword">while</span>(A[i]&lt;pivot);</span><br><span class="line">            <span class="keyword">do</span> j--;<span class="keyword">while</span>(A[j]&gt;pivot);</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)swap(A[i],A[j]);<span class="comment">//各取所需:A[i]&gt;pivot,A[j]&lt;pivot</span></span><br><span class="line">        &#125;</span><br><span class="line">        quick_sort(l,j);</span><br><span class="line">        quick_sort(j+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A[i]);</span><br><span class="line">    quick_sort(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)<span class="built_in">printf</span>(<span class="string">"%d "</span>,A[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例：第K个数"><a href="#例：第K个数" class="headerlink" title="例：第K个数"></a>例：第K个数</h2><p>题目描述：利用快速排序找出数组中第$k$小的数。</p>
<p>快速排序描述：</p>
<p>① 基准元素取$x=p[l+r&gt;&gt;1]$</p>
<p>② <strong>调整区间</strong>：根据基准元素将区间调整为左右两个小区间，左边的元素都小于等于$x$，右边的元素都大于等于$x$，<strong>但左右两个区间都没有顺序</strong>。</p>
<p>③ 递归处理左右两个小区间。</p>
<p>快速选择：</p>
<p>若找的元素的索引小于等于左区间的长度，则必定在右区间。</p>
<p><img alt="img" data-src="https://gitee.com/alexander1/pic/raw/master/acwing/20210508204944.png"></p>
<p>时间复杂度：第一层为$n$，第二层为$\frac{n}{2}$，第三层为$\frac{n}{4}$等等</p>
<p>加起来趋近于$2n$，所以时间复杂度为$O(n)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> A[l];</span><br><span class="line">    <span class="keyword">int</span> i = l<span class="number">-1</span>,j = r+<span class="number">1</span>,pivot = A[l+r&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++;<span class="keyword">while</span>(A[i]&lt;pivot);</span><br><span class="line">        <span class="keyword">do</span> j--;<span class="keyword">while</span>(A[j]&gt;pivot);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)swap(A[i],A[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sl = j-l+<span class="number">1</span>;<span class="comment">//小于等于pivot的区间长度</span></span><br><span class="line">    <span class="keyword">if</span>(k&lt;=sl) <span class="keyword">return</span> quick_sort(l,j,k);</span><br><span class="line">    <span class="keyword">return</span> quick_sort(j+<span class="number">1</span>,r,k-sl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;quick_sort(<span class="number">0</span>,n<span class="number">-1</span>,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、归并排序"><a href="#2、归并排序" class="headerlink" title="2、归并排序"></a>2、归并排序</h2><p>算法描述：</p>
<p>① 找出中间点mid</p>
<p>② 将区间$[l,r]$分为$[l,mid]和[mid+1,r]$两个区间，并进行递归排序。</p>
<p>③ <strong>合并区间</strong>：将区间$[l,mid]和[mid+1,r]$合并起来，需要开辟一个临时数组用来复制原数组的元素，<strong>此时的两个区间都是有序的 </strong>(在递归的最后一层每个区间只有1个元素，可以视为有序)，使用两个指针$i,j$分别指向两个区间，优先将小元素放入原数组中；最后，$i,j$不一定能到达两个区间末尾，所以还要分别进行一次$while$将元素放入原数组中。</p>
<p>时间复杂度：每趟合并为$O(n)$，栈深度为$O(log_2n)$，总时间复杂度为$O(nlog_2n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> p[N],tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        merge_sort(l,mid);</span><br><span class="line">        merge_sort(mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l;i&lt;=r;i++)</span><br><span class="line">            tmp[i] = p[i];</span><br><span class="line">        <span class="keyword">int</span> k = l,i = l,j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i]&lt;=tmp[j])p[k++] = tmp[i++];</span><br><span class="line">            <span class="keyword">else</span> p[k++] = tmp[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)p[k++] = tmp[i++];</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r)p[k++] = tmp[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i]);</span><br><span class="line">    merge_sort(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)<span class="built_in">printf</span>(<span class="string">"%d "</span>,p[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例：逆序对的数量"><a href="#例：逆序对的数量" class="headerlink" title="例：逆序对的数量"></a>例：逆序对的数量</h2><blockquote>
<p>给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。</p>
<p>逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i<j 且 a[i]>a[j]，则其为一个逆序对；否则不是。</j></p>
<p><strong>输入格式</strong></p>
<p>第一行包含整数 n，表示数列的长度。</p>
<p>第二行包含 n 个整数，表示整个数列。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示逆序对的个数。</p>
<p><strong>数据范围</strong></p>
<p>1≤n≤100000</p>
</blockquote>
<p><img alt="img" data-src="https://gitee.com/alexander1/pic/raw/master/acwing/20210508210441.png"></p>
<p>如图，若$tmp[i]&gt;tmp[j]$，则区间$[i,mid]$中的数均大于$tmp[j]$，因为两区间都是有序的</p>
<p>所以此次的逆序对个数就是$mid-i+1$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> p[N],tmp[N];</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        merge_sort(l,mid);</span><br><span class="line">        merge_sort(mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l;i&lt;=r;i++)</span><br><span class="line">            tmp[i] = p[i];</span><br><span class="line">        <span class="keyword">int</span> k = l,i = l,j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i]&lt;=tmp[j])p[k++] = tmp[i++];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p[k++] = tmp[j++];</span><br><span class="line">                res += mid-i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)p[k++] = tmp[i++];</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r)p[k++] = tmp[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i]);</span><br><span class="line">    merge_sort(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二分</title>
    <url>/alex-next/2021/05/09/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<h2 id="1、数的范围"><a href="#1、数的范围" class="headerlink" title="1、数的范围"></a>1、数的范围</h2><p>实现两个函数：</p>
<p>① 小于等于x的最大数</p>
<p>② 大于等于x的最小数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchL</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//小于等于x的最大数的下标</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>,r = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p[mid]&gt;x)r = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchR</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//大于等于x的最小数的下标</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>,r = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p[mid] &lt; x)l = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        <span class="keyword">int</span> l = searchL(m);</span><br><span class="line">        <span class="keyword">if</span>(p[l]!=m)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1 -1\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l1 = searchR(m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,l1,l);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>附：二分查找</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>,r = arr.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid]==x)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid]&gt;x)</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例：数的三次根方"><a href="#例：数的三次根方" class="headerlink" title="例：数的三次根方"></a>例：数的三次根方</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">-10000</span>,r = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">while</span>(r-l&lt;<span class="number">1e-8</span>)&#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid*mid*mid&gt;x)r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf"</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组模拟</title>
    <url>/alex-next/2021/05/29/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>为什么使用数组模拟单链表、双链表、栈、队列？</p>
<p>如果数据规模很大，一个一个new 速度太慢了，使用数组会大大加快速度。</p>
<h2 id="1-数组模拟单链表"><a href="#1-数组模拟单链表" class="headerlink" title="1.数组模拟单链表"></a>1.数组模拟单链表</h2><p><img alt="10048_8b47069add-数组表示单链表" data-src="https://gitee.com/alexander1/pic/raw/master/acwing/20210609111200.png"></p>
<p>在头部插入一个元素<code>x</code>：</p>
<p>先把值放到数据域中，让当前结点<code>next</code>指针指向<code>head</code>所指向的元素，让<code>head</code>指向当前元素，<code>idx</code>下移一位。<code>(idx</code>相当于元素的地址，<code>head</code>的值为第一个元素的地址<code>)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_head</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第<code>k</code>个输入的数后面插入一个元素<code>x</code>：</p>
<p>先把值放到数据域中，让当前结点<code>next</code>指针指向<code>k</code>的<code>next</code>域所指向的元素，让<code>k</code>的<code>next</code>指向当前元素，<code>idx</code>下移一位。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除第k个输入的数后面的数：</p>
<p>让<code>k</code>的<code>next</code>指向<code>k</code>的<code>next</code>的<code>next</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>C++代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> idx,head = <span class="number">-1</span>,e[N],ne[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示向链表头插入一个数x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_head</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示在第k个输入的数后面插入一个数x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示删除第k个输入的数后面的数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        <span class="keyword">int</span> k,x;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">'D'</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">            <span class="keyword">if</span>(!k)head = ne[head];</span><br><span class="line">            remove(k<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">'H'</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            add_head(x);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">'I'</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            add(k<span class="number">-1</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head;i!=<span class="number">-1</span>;i=ne[i])<span class="built_in">printf</span>(<span class="string">"%d "</span>,e[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-数组模拟双链表"><a href="#2-数组模拟双链表" class="headerlink" title="2.数组模拟双链表"></a>2.数组模拟双链表</h2><p>初始化左指针域和右指针域</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>,l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第<code>k</code>个结点右边插入一个元素：</p>
<p>与单链表类似，但要注意先让<code>k</code>的右节点的左指针指向<code>idx</code>，在让<code>k</code>的右指针指向<code>idx</code>。否则，<code>l[r[k]]</code>中的<code>r[k]</code>已经不是原来的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    l[r[k]] = idx;</span><br><span class="line">    r[k] = idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将第<code>k</code> 个插入的数删除<code>(</code>序号<code>1,2,...n)</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>C++代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> e[N],l[N],r[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>,l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第k个结点右边插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    l[r[k]] = idx;</span><br><span class="line">    r[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示将第 k 个插入的数删除(序号1,2,...n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="keyword">int</span> k,x;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">"L"</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            add(<span class="number">0</span>,x);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">"R"</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            add(l[<span class="number">1</span>],x);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">"D"</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">            remove(k+<span class="number">1</span>);    </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">"IL"</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            add(l[k+<span class="number">1</span>],x);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            add(k+<span class="number">1</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r[<span class="number">0</span>];i!=<span class="number">1</span>;i=r[i])<span class="built_in">printf</span>(<span class="string">"%d "</span>,e[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-数组模拟队列"><a href="#3-数组模拟队列" class="headerlink" title="3.数组模拟队列"></a>3.数组模拟队列</h2><p>当<code>tt&lt;hh</code>时，队列为空</p>
<p>队头为<code>q[hh]</code>，出队列<code>hh++</code></p>
<p><strong>c++代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N],hh,tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">"push"</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            q[++tt] = x;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">"pop"</span>)&#123;</span><br><span class="line">            hh++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">"empty"</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hh&lt;=tt)<span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;q[hh]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-数组模拟栈"><a href="#4-数组模拟栈" class="headerlink" title="4.数组模拟栈"></a>4.数组模拟栈</h2><p>当<code>tt=-1</code>时，栈为空</p>
<p>出栈<code>tt--</code></p>
<p><strong>c++代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[N],tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">"push"</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">            stk[++tt] = a;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"pop"</span>)&#123;</span><br><span class="line">            tt--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"query"</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,stk[tt]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"empty"</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;(tt==<span class="number">-1</span>?<span class="string">"YES"</span>:<span class="string">"NO"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂</title>
    <url>/alex-next/2021/05/01/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<h2 id="1-快速幂"><a href="#1-快速幂" class="headerlink" title="1.快速幂"></a>1.快速幂</h2><p>快速幂的方法其实可以借鉴多重背包的二进制化简法，异曲同工。</p>
<p>底数为$a$，幂指数为$k$，模数为$p$</p>
<p>例：若求$3^{13} \mod 2$ ，</p>
<p>解：幂指数$13=(1101)$，$3^{13}=3^8·3^4·3^1$   </p>
<p>每次遍历指数时，若二进制对应位为1，就把它与结果相乘再取余，让底数成自身，指数右移一位    ；</p>
<p>​                                若二进制对应位为0  ，让底数乘自身，指数右移一位    </p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        ll a,k,p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;a, &amp;k, &amp;p);</span><br><span class="line">        ll r = <span class="number">1</span>%p;</span><br><span class="line">        <span class="keyword">while</span>(k)&#123;<span class="comment">//指数不为0</span></span><br><span class="line">            <span class="keyword">if</span>(k&amp;<span class="number">1</span>)r=r*a%p;<span class="comment">//乘结果取余</span></span><br><span class="line">            k&gt;&gt;=<span class="number">1</span>;<span class="comment">//指数右移一位</span></span><br><span class="line">            a = a*a%p;<span class="comment">//底数乘自身</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-快速幂求逆元"><a href="#2-快速幂求逆元" class="headerlink" title="2.快速幂求逆元"></a>2.快速幂求逆元</h2><p>若p是质数,$\frac{a}{b}\equiv a·x(\mod p)$</p>
<p>两边同乘$b$得$a\equiv a·b·x(\mod p)$</p>
<p>即$1\equiv b·x(\mod p)$</p>
<p>由费马小定理可知，当n为质数时，</p>
<p>$b^{p-1} \equiv 1(\mod p)$</p>
<p>所以$x=b^{p-2},x称为b的模p乘法逆元$，其中$b$与$p$互质主要用来化除为乘</p>
<p>所以逆元就是$x\mod p$，即求$b^{p-2}\mod p$</p>
<p>注：当$b$是$p$的倍数时，$b$的逆元不存在，因为$b*x \mod p==0$  ，一定不等于1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> k,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)r = (ll)r*a%p;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a = (ll)a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,k,p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;p);</span><br><span class="line">        <span class="keyword">int</span> r = qmi(a,p<span class="number">-2</span>,p);</span><br><span class="line">        <span class="keyword">if</span>(a%p)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,r);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/P3390" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3390</a></p>
<p>矩阵快速幂=矩阵乘法+快速幂</p>
<p>理解：本质上都是对幂指数的优化求解。</p>
<p>c++版模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line">ll n,k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m[maxn][maxn], n;</span><br><span class="line">&#125;A,I;</span><br><span class="line"></span><br><span class="line">Mat <span class="keyword">operator</span>*(Mat b,Mat c)</span><br><span class="line">&#123;</span><br><span class="line">    Mat res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            ll x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                x += (ll)b.m[i][k] * c.m[k][j] % mod;</span><br><span class="line">            res.m[i][j] = x%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">qmi</span><span class="params">(Mat A,ll k)</span></span>&#123;</span><br><span class="line">    Mat I;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        I.m[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)I = I*A;</span><br><span class="line">        A = A*A;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> I;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;A.m[i][j];</span><br><span class="line">    I = qmi(A,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;I.m[i][j]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java版模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> k;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span>[][] mul(<span class="keyword">long</span>[][] a,<span class="keyword">long</span>[][] b)&#123;</span><br><span class="line">        <span class="keyword">long</span>[][] r = <span class="keyword">new</span> <span class="keyword">long</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">                    r[i][j] += a[i][k]*b[k][j]%mod;</span><br><span class="line">                    r[i][j] %= mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span>[][] qmi(<span class="keyword">long</span>[][] a,<span class="keyword">long</span> k)&#123;</span><br><span class="line">        <span class="keyword">long</span>[][] r = <span class="keyword">new</span> <span class="keyword">long</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            r[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((k&amp;<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">                r = mul(r,a);</span><br><span class="line">            k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            a = mul(a,a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String[] strs = in.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        n = Integer.parseInt(strs[<span class="number">0</span>]);</span><br><span class="line">        k = Long.parseLong(strs[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">long</span>[][] a = <span class="keyword">new</span> <span class="keyword">long</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            String[] s = in.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                a[i][j] = Integer.parseInt(s[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span>[][] r = qmi(a,k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                System.out.print(r[i][j]+<span class="string">" "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例：奇异的虫群"><a href="#例：奇异的虫群" class="headerlink" title="例：奇异的虫群"></a>例：奇异的虫群</h2><blockquote>
<p>在一个奇怪的星球上驻扎着两个虫群A和B，它们用奇怪的方式繁殖着，在t+1时刻A虫群的数量等于t时刻A虫群和B虫群数量之和，t+1时刻B虫群的数量等于t时刻A虫群的数量。由于星际空间的时间维度很广阔，所以t可能很大。OverMind 想知道在t时刻A虫群的数量对 p = 1,000,000,007.取余数的结果。当t=1时 A种群和B种群的数量均为1。<br>输入格式<br>　 测试数据包含一个整数t，代表繁殖的时间。<br>输出格式<br>　 输出一行，包含一个整数，表示对p取余数的结果<br>样例输入<br>　 10<br>样例输出<br>　 89<br>样例输入<br>　 65536<br>样例输出<br>　 462302286<br>　<br>数据规模和约定<br>　　对于50%的数据 t&lt;=10^9<br>　　对于70%的数据 t&lt;=10^15<br>　　对于100%的数据 t&lt;=10^18</p>
</blockquote>
<p>关系矩阵$R=\left[\matrix{1&amp;1\\1&amp;0}\right]$</p>
<p>初始矩阵$A = \left[\matrix{1&amp;1\\0&amp;0}\right]$</p>
<p>要求的就是$A·R^{k-1}$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mat</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;A,R;</span><br><span class="line"></span><br><span class="line">Mat <span class="keyword">operator</span> * (Mat a,Mat b)&#123;</span><br><span class="line">    Mat r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">            r.m[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;<span class="number">2</span>;k++)</span><br><span class="line">                r.m[i][j] = (r.m[i][j]+(ll)a.m[i][k]*b.m[k][j]%mod)%mod; </span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qmi</span><span class="params">(Mat &amp;A,ll k,Mat R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)A = A*R;</span><br><span class="line">        R = R*R;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">    A.m[<span class="number">0</span>][<span class="number">0</span>] = A.m[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    R.m[<span class="number">0</span>][<span class="number">0</span>] = R.m[<span class="number">0</span>][<span class="number">1</span>] = R.m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    qmi(A,k<span class="number">-1</span>,R);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;A.m[<span class="number">0</span>][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学知识</tag>
      </tags>
  </entry>
  <entry>
    <title>约数</title>
    <url>/alex-next/2021/04/26/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%BA%A6%E6%95%B0/</url>
    <content><![CDATA[<h2 id="1-试除法求约数"><a href="#1-试除法求约数" class="headerlink" title="1.试除法求约数"></a>1.试除法求约数</h2><p>先用<code>vector</code>把所有因数保存下来，再排序。</p>
<p>注意：判断下若两个因数相同，不要添加两次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=m/i;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m%i==<span class="number">0</span>)&#123;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">                <span class="keyword">if</span>(i!=m/i)res.push_back(m/i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(res.begin(),res.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:res)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-约数个数"><a href="#2-约数个数" class="headerlink" title="2.约数个数"></a>2.约数个数</h2><p>对于任意一个合数$N$，若$N=p_1^{\alpha_1}·p_2^{\alpha_2}···p_n^{\alpha_n},其中p_i为质数,\alpha_i$为每种质因数的个数，$n为N$的质因数种类数</p>
<p>约数个数$N_c=(\alpha_1+1)·(\alpha_2+1)···(\alpha_n+1)$</p>
<p>证明：对于合数$N$的任意一个因数$C$，可以表示为$C=p_1^{\beta_1}·p_2^{\beta_2}···p_n^{\beta_n},\beta_i\in[0,\alpha_i]$</p>
<p>由排列组合的知识，每种质因数有$\alpha_i+1$种情况，$+1$是因为不选择也是一种情况，满足乘法原理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; primes;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=m/i;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(m%i==<span class="number">0</span>)&#123;</span><br><span class="line">                m/=i;</span><br><span class="line">                primes[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m&gt;<span class="number">1</span>)primes[m]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p:primes)</span><br><span class="line">        res = res*(p.second+<span class="number">1</span>)%mod;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-约数之和"><a href="#3-约数之和" class="headerlink" title="3.约数之和"></a>3.约数之和</h2><p>对于任意一个合数$N$，若$N=p_1^{\alpha_1}·p_2^{\alpha_2}···p_n^{\alpha_n},其中p_i为质数,\alpha_i$为每种质因数的个数，$n为N$的质因数种类数</p>
<p>约数之和$S$可以表示为</p>
<p>$S=(p_1^0+p_1^1+p_1^2+····+p_1^{\alpha_1})·(p_2^0+p_2^1+p_2^2+····+p_2^{\alpha_2})····(p_n^0+p_n^1+p_n^2+····+p_n^{\alpha_n})$</p>
<p>证明：将$S$按项展开可表示为</p>
<p>$S=p_1^0·p_2^0··p_n^0+p_1^0·p_2^0··p_n^1+·····+p_1^{\beta_1}·p_2^{\beta_2}··p_n^{\beta_n}+·····+p_1^{\alpha_1}·p_2^{\alpha_2}··p_n^{\alpha_n}$</p>
<p>其中$\beta_1，\beta_2····\beta_n\in[0,\alpha_i]$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; primes;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=m/i;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(m%i==<span class="number">0</span>)&#123;</span><br><span class="line">                m/=i;</span><br><span class="line">                primes[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m&gt;<span class="number">1</span>)primes[m]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> prime:primes)&#123;</span><br><span class="line">        ll t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p = prime.first;</span><br><span class="line">        <span class="keyword">int</span> cnt = prime.second;</span><br><span class="line">       	<span class="keyword">while</span>(cnt--)t = (t*p+<span class="number">1</span>)%mod;</span><br><span class="line">        res = res*t%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>while(cnt--)t = (t*p+1)%mod;</code></p>
<p>初始化$t = 1$;</p>
<p>第一轮：$t = p+1$</p>
<p>第二轮：$t = p^2+p+1$</p>
<p>第n轮：$t = p^n+···+p^2+p+1$</p>
<h2 id="4-最大公约数"><a href="#4-最大公约数" class="headerlink" title="4.最大公约数"></a>4.最大公约数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n==<span class="number">0</span>?m:gcd(n,m%n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">int</span> r = gcd(a,b);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本原理：</p>
<p>若$x$能整除$a$且$x$能整除$b$，则$x$能整除$a·i+b·j$</p>
<p>$a\mod b=a-\lfloor{\frac{a}{b}}\rfloor·b$ ，即$a\mod b=a-c·b$  ，记 $c=\lfloor{\frac{a}{b}}\rfloor$</p>
<p>所以<code>gcd(a,b)=gcd(b,a mod b)</code></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学知识</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数</title>
    <url>/alex-next/2021/05/04/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%BB%84%E5%90%88%E6%95%B0/</url>
    <content><![CDATA[<h2 id="1-组合数I"><a href="#1-组合数I" class="headerlink" title="1.组合数I"></a>1.组合数I</h2><p>数据范围</p>
<p>$1≤n≤10000$,<br>$1≤b≤a≤2000$</p>
<p>分析：输入数据组数很多，但是每组数据比较小。考虑使用组合公式+打表。</p>
<p>根据高中的组合公式$C_a^b=C_{a-1}^b+C_{a-1}^{b-1}$，</p>
<p>直观解释，要从$a$个人中选出$b$个人，若不选甲，有$C_{a-1}^b$种方案；若选甲，有$C_{a-1}^{b-1}$种方案。</p>
<p>时间复杂度为$O(N^2)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>,mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> c[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">            <span class="keyword">if</span>(!j)c[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> c[i][j] = (c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,c[a][b]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-组合数II"><a href="#2-组合数II" class="headerlink" title="2.组合数II"></a>2.组合数II</h2><p>数据范围</p>
<p>$1≤n≤10000$,<br>$1≤b≤a≤10^5$</p>
<p>分析：输入数据比上组小，但每组数据比上组大。考虑使用定义式+逆元。</p>
<p>时间复杂度为$O(NlogN)$</p>
<p>注：$i!的逆元\equiv(i-1)!的逆元·i的逆元(mod\quad p)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>,mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> fact[N],infact[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> k,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)r = (ll)r*a%p;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a = (ll)a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        fact[i] = (ll)fact[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">        infact[i] = (ll)infact[i<span class="number">-1</span>]*qmi(i,mod<span class="number">-2</span>,mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(ll)fact[a]*infact[b]%mod*infact[a-b]%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-组合数III"><a href="#3-组合数III" class="headerlink" title="3.组合数III"></a>3.组合数III</h2><p>数据范围：</p>
<p>$1≤n≤20,$<br>$1≤b≤a≤10^{18},$<br>$1≤p≤10^5$</p>
<p>分析：输入数据量很少，但是每组的数据都要比前两题大很多。考虑定义式+逆元+lucas。主要是利用lucas定理将$a$和$b$化小。</p>
<p>$lucas定理：C_a^b=C_{a/p}^{b/p}·C_{a\%p}^{b\%p}(mod \quad p)$</p>
<p>时间复杂度为$O(log_pN·plogp)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)r = (ll)r*a%p;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a = (ll)a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b&gt;a)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,j = a;i&lt;=b;i++,j--)&#123;</span><br><span class="line">        r = (ll)r*j%p;</span><br><span class="line">        r = (ll)r*qmi(i,p<span class="number">-2</span>)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lucas</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; p &amp;&amp; b &lt; p)<span class="keyword">return</span> C(a,b);</span><br><span class="line">    <span class="keyword">return</span> (ll)C(a%p,b%p)*lucas(a/p,b/p)%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll a,b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;p;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;lucas(a,b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-组合数IV"><a href="#4-组合数IV" class="headerlink" title="4.组合数IV"></a>4.组合数IV</h2><p>数据范围</p>
<p>$1≤b≤a≤5000$</p>
<p>分析：本题与前三题的区别在于，这题要求出组合数的最后结果，而不是求余之后的结果。</p>
<p>考虑先将结果分解为质因数相乘，在利用高精度得出结果。</p>
<p>证明：$C_a^b=\frac{a!}{b!·(a-b)!}=p_1^{\alpha_1}·p_2^{\alpha_2}···p_n^{\alpha_n},其中p_i为质数,\alpha_i$为每种质因数的个数，$n为N$的质因数种类数</p>
<p>又每个质因数的次数$cnt(a!)=\lfloor\frac{a}{p}\rfloor+\lfloor\frac{a}{p^2}\rfloor+\lfloor\frac{a}{p^3}\rfloor+···$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"><span class="keyword">int</span> primes[N],cnt,sum[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//获取所有质数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;primes[j]&lt;=n/i;j++)&#123;</span><br><span class="line">            st[primes[j]*i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;<span class="comment">//求每个质数的次数</span></span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        r += n/p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mul(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a,<span class="keyword">int</span> b)&#123;<span class="comment">//高精度</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;a.size();i++)&#123;</span><br><span class="line">        t += a[i]*b;</span><br><span class="line">        c.push_back(t%<span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">        c.push_back(t%<span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    get_primes(a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = primes[i];</span><br><span class="line">        sum[i] = get(a,p)-get(b,p)-get(a-b,p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    res.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;sum[i];j++)</span><br><span class="line">            res = mul(res,primes[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = res.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,res[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-满足条件的01序列"><a href="#5-满足条件的01序列" class="headerlink" title="5. 满足条件的01序列"></a>5. 满足条件的01序列</h2><p>卡特兰数：$C_{2n}^n-C_{2n}^{n-1}=\frac{C_{2n}^n}{n+1}$</p>
<p><img alt="2020032210584895.png" data-src="https://cdn.acwing.com/media/article/image/2020/05/13/13653_c0dae9e295-2020032210584895.png"></p>
<p>举个栗子： $n=6$ 时，就可以画成上图，假设向右是0向上是1，则在红线以下的路径是合法的，<strong>可以看出每一条从$(0,0)$走到$(6,6)$的非法路径做关于红线的对称</strong>，都对应一条$(0,0)-(5,7)$的路径；反之，每一条从$(0,0)-(5,7)$的路径都对应一条从$(0,0)-(6,6)$的非法路径，那么就可以利用$(0,0)-(5,7)$的路径数间接求出$(0,0)-(6,6)$的非法路径数。</p>
<p>算法核心：每一条从$(0,0)$走到$(n，n)$的非法路径都对应一条从$(0,0)$走到$(n-1，n+1)$的非法路径，因此合法路径就是<br>因此从$(0,0)$走到$(n，n)$的不合法路径数就是$C_{2n}^{n-1}$ , 即合法的是 $C_{2n}^n-C_{2n}^{n-1} $，化简得 $\frac{C_{2n}^n}{n+1}$，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)r = (ll)r*a%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a = (ll)a*a%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>*n,b = n;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = b+<span class="number">1</span>;i&lt;=a;i++)r = (ll)r*i%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=b;i++)r = (ll)r*qmi(i,mod<span class="number">-2</span>)%mod;</span><br><span class="line">    r = (ll)r*qmi(b+<span class="number">1</span>,mod<span class="number">-2</span>)%mod;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;r;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>求组合数时，根据数据的范围以及具体的要求选择合适的方法。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学知识</tag>
      </tags>
  </entry>
  <entry>
    <title>质数</title>
    <url>/alex-next/2021/04/24/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<h2 id="1-试除法判断质数"><a href="#1-试除法判断质数" class="headerlink" title="1.试除法判断质数"></a>1.试除法判断质数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=x/i;i++)</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述for循环结束的条件是 <code>i &lt;= n/i</code>  只需要判断 $[2,\sqrt{n}]$ 内是否有n的因子, 因为$\sqrt{n}$ 之后的数如果是因子，必定已经被搜过了。</p>
<p>如 $2*6=12$ 若 6 是因子，必定在搜索 2 的时候，已经能判断 <code>n</code> 是合数。</p>
<h2 id="2-试除法分解质因数"><a href="#2-试除法分解质因数" class="headerlink" title="2.试除法分解质因数"></a>2.试除法分解质因数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=x/i;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line">                s++;</span><br><span class="line">                x/=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>)<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据算数基本定理，任意一个合数，可以用几个质数的幂的乘积来表示。</p>
<p>如:  </p>
<p>$12 = 2^2 * 3$</p>
<p>$20 = 2^2*5$ </p>
<h2 id="3-埃式筛质数"><a href="#3-埃式筛质数" class="headerlink" title="3.埃式筛质数"></a>3.埃式筛质数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> primes[N],cnt;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ai_seive</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//埃式筛----逐个将质因数倍数筛去</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=n/i;i++)&#123;<span class="comment">//一个合数的最小质因数一定小于根号n,所以从2遍历到根号n</span></span><br><span class="line">        <span class="keyword">if</span>(st[i]==<span class="number">0</span>)&#123;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> j = i*i;j&lt;=n;j+=i)<span class="comment">//从i*i开始筛，因为j*(2,3,...i-1)都被筛完了</span></span><br><span class="line">            	st[j] = <span class="number">1</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由 一个质数的倍数一定是合数，一次从2开始筛除它们的倍数。</p>
<h2 id="4-欧拉筛"><a href="#4-欧拉筛" class="headerlink" title="4.欧拉筛"></a>4.欧拉筛</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> primes[N],cnt;</span><br><span class="line"><span class="keyword">int</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ola</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i]==<span class="number">0</span>)primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;primes[j]&lt;=n/i;j++)&#123;<span class="comment">//如果primes[j]*i&gt;n,就没有意义了</span></span><br><span class="line">            st[primes[j]*i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1)    当<code>i%primes[j]!=0</code>时,说明此时遍历到的<code>primes[j]</code>不是<code>i</code>的质因子，由<code>primes[j]&lt;i</code>所以<code>primes[j]*i</code>的最小质因子就是<code>primes[j]</code>;</p>
<p>2)    当有<code>i%primes[j]==0</code>时,说明<code>i</code>的最小质因子是<code>primes[j]</code>,因此<code>primes[j]*i</code>的最小质因子也就应该是<code>prime[j]</code>，</p>
<p>之后接着用<code>st[primes[j+1]*i]=true</code>去筛合数时，就不是用最小质因子去更新了,因为<code>i</code>有最小质因子<code>primes[j]&lt;primes[j+1]</code>,</p>
<p>此时的<code>primes[j+1]</code>不是<code>primes[j+1]*i</code>的最小质因子，此时就应该退出循环，避免之后重复进行筛选。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学知识</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot笔记</title>
    <url>/alex-next/2020/08/05/javaEE/springboot/springboot/</url>
    <content><![CDATA[<p>项目gitee地址</p>
<blockquote>
<p><a href="https://gitee.com/alexander1/springboot_notes.git" target="_blank" rel="noopener">https://gitee.com/alexander1/springboot_notes.git</a></p>
</blockquote>
<h1 id="一、springboot入门-2-1-8"><a href="#一、springboot入门-2-1-8" class="headerlink" title="一、springboot入门(2.1.8)"></a>一、springboot入门(2.1.8)</h1><h2 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1.导入依赖"></a>1.导入依赖</h2><p><code>SpringBoot</code>的版本仲裁中心</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong><code>spring-boot-starter-web</code>:</strong></p>
<p>​    <code>spring-boot-starter:springboot</code>的场景启动器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-主程序入口-SpingBootApplication"><a href="#2-主程序入口-SpingBootApplication" class="headerlink" title="2.主程序入口@SpingBootApplication"></a>2.主程序入口@SpingBootApplication</h2><p><code>@SpringBootConfiguration:Springboot</code>的配置类;</p>
<p>​    标注在某个类上，表示这是一个<code>springboot</code>的配置类；</p>
<p>​    <code>@Configuration</code>：配置类上来标注这个注解；</p>
<p>​        配置类———配置文件；配置类也是容器中的一个组件;<code>@Component</code></p>
<p><code>@EnableAutoConfiguration</code>:开启自动配置功能</p>
<p>​    <code>@AutoConfigurationPackage</code>：自动配置包</p>
<p>​        <code>@Import(AutoConfigurationPackages.Registrar.class)</code></p>
<p>​        <code>Spring</code>的底层注解<code>@Import</code>,给容器中导入一个组件；</p>
<p>​        <strong>将主配置类(<code>@SpringBootApplication</code>标注的类)的所在包及下面所有组件扫描到<code>Spring</code>容器中；</strong></p>
<p>​    <code>@Import(AutoConfigurationImportSelector.class)</code></p>
<p>​        给容器导入组件</p>
<p>​        <code>AutoConfigurationImportSelector</code>：将所有需要导入的组件 以全类名的方式返回；这些组件就会被添加到容器中</p>
<p>​        会给容器中导入非常多的自动配置类(<code>xxxAutoConfiguration</code>)；就是给容器中导入这个场景需要的所有组件，并配置好这些组件;</p>
<p>​        有了自动配置类，免去了手动配置的任务</p>
<h2 id="3-项目结构"><a href="#3-项目结构" class="headerlink" title="3.项目结构"></a>3.项目结构</h2><p><code>resources</code>文件中目录结构：</p>
<ul>
<li><code>static</code>:保存所有的静态资源;<code>js css images;(WebContent)</code></li>
<li><code>templates</code>:保存所有的模板页面；(<code>spingboot</code>默认jar包使用嵌入式的Tomcat)</li>
<li><code>application.properties:Springboot</code>应用的配置文件</li>
</ul>
<h1 id="二、配置文件"><a href="#二、配置文件" class="headerlink" title="二、配置文件"></a>二、配置文件</h1><h2 id="1-YAML语法"><a href="#1-YAML语法" class="headerlink" title="1.YAML语法"></a>1.YAML语法</h2><p>K:V表示一对键值对(空格必须有)</p>
<p>以空格的缩进来控制层级关系；只要是左对齐的一列数据都是同一层级的</p>
<h2 id="2-值的写法"><a href="#2-值的写法" class="headerlink" title="2.值的写法"></a>2.值的写法</h2><h3 id="字面量：普通的值（数字，字符串，布尔）"><a href="#字面量：普通的值（数字，字符串，布尔）" class="headerlink" title="字面量：普通的值（数字，字符串，布尔）"></a>字面量：普通的值（数字，字符串，布尔）</h3><p>​    k:v：字面直接来写；</p>
<p>​            字符串默认不用加上单引号或者双引号</p>
<p>​            “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表达的意思</p>
<p>​            ‘’：单引号,会转移特殊字符，特殊字符最终只是一个普通的字符串数据</p>
<h3 id="对象、Map（属性和值）（键值对）"><a href="#对象、Map（属性和值）（键值对）" class="headerlink" title="对象、Map（属性和值）（键值对）"></a>对象、Map（属性和值）（键值对）</h3><p>​    k:v：</p>
<p>​            对象还是K:V的方式</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line">	<span class="attr">lastName:</span> <span class="string">zhangsan</span></span><br><span class="line">	<span class="attr">age:</span> <span class="number">13</span></span><br></pre></td></tr></table></figure>
<p>行内写法</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">friends: &#123;lastName: zhangsan,age: 18&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组（List、Set）"><a href="#数组（List、Set）" class="headerlink" title="数组（List、Set）"></a>数组（List、Set）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pets:</span><br><span class="line">	- cat</span><br><span class="line">	- dog</span><br><span class="line">	- pig</span><br></pre></td></tr></table></figure>
<p>行内写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pets: [cat,dog,pig]</span><br></pre></td></tr></table></figure>
<h2 id="3-配置文件注入"><a href="#3-配置文件注入" class="headerlink" title="3.配置文件注入"></a>3.配置文件注入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//必须注册为组件，才能够运用ConfigurationProperties</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    Integer id;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>导入<code>spring-boot-configuration-processor</code>，就有提示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>application.yml:</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">  id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">zhangsan</span></span><br></pre></td></tr></table></figure>
<p>build在idea中，IDEA maven项目默认不会把src下除<code>java</code>文件外的文件打包到<code>classes</code>文件夹下包含<code>**/*.xml,**/*.properties,**/*.yml</code>,所以要加上build语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        IDEA maven项目默认不会把src下除java文件外的文件打包到classes文件夹下</span></span><br><span class="line"><span class="comment">                包含**/*.xml,**/*.properties,**/*.yml</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用idea时，有些奇奇怪怪的错误，其实不是代码写错了，是idea有时候target下没有生成相应的编译文件</p>
<h2 id="4-Value获取值和-ConfigurationProperties的区别"><a href="#4-Value获取值和-ConfigurationProperties的区别" class="headerlink" title="4.@Value获取值和@ConfigurationProperties的区别"></a>4.@Value获取值和@ConfigurationProperties的区别</h2><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>@ConfigurationProperties</th>
<th>@Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>功能</td>
<td>批量注入配置文件中的属性</td>
<td>一个个指定</td>
</tr>
<tr>
<td>松散绑定(松散语法)</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>SpEL</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>JSR303数据校验</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>复杂类型封装</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
</div>
<p>配置文件yml和properties都能获取到值；</p>
<p>如果只需要配置文件中的某项值，使用@Value</p>
<p>如果专门编写了一个JavaBean来和配置文件进行映射时，就直接使用<code>@ConfigurationProperties</code></p>
<h2 id="5-PropertySource和-ImportResource"><a href="#5-PropertySource和-ImportResource" class="headerlink" title="5.@PropertySource和@ImportResource"></a>5.@PropertySource和@ImportResource</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.spring.pojo.Person;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: alex</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/8/6 16:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.spring"</span>)</span><br><span class="line"><span class="comment">//设置配置文件,必须配置在有@Component的类上</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:person.properties"</span>)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span><span class="comment">//首选</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="number">3</span>,<span class="string">"ls"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@ImportResource</code>:导入Spring的配置文件，让配置文件里面的内容生效。</p>
<p>SpringBoot里面没有Spring的配置文件，自己编写的配置文件，不能自动识别；想让Spring的配置文件键生效；<code>@ImportResource</code>标注在主配置类上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(locations = &#123;<span class="string">"classpath:beans.xml"</span>&#125;)</span><br><span class="line">导入Spring的配置文件</span><br></pre></td></tr></table></figure>
<p>SpringBoot推荐给容器添加组件的方式：</p>
<p>1.配置类==&gt;Spring配置文件</p>
<p>2.使用@Bean给容器添加组件</p>
<h2 id="6-Profile"><a href="#6-Profile" class="headerlink" title="6.Profile"></a>6.Profile</h2><h3 id="1-多Profile文件"><a href="#1-多Profile文件" class="headerlink" title="1.多Profile文件"></a>1.多Profile文件</h3><p>编写主配置文件时，文件名可以是 application-{profile}.properties/yml</p>
<p>默认使用<code>application.properties</code>的配置</p>
<h3 id="2-yml支持多文档块方式"><a href="#2-yml支持多文档块方式" class="headerlink" title="2.yml支持多文档块方式"></a>2.yml支持多文档块方式</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">  id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">张三$&#123;random.uuid&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">prod</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#---在hexo转换.md为.html文件时会报错，所以先注释掉，---在yaml中是分页符</span></span><br><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8082</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">prod</span></span><br></pre></td></tr></table></figure>
<h3 id="3-激活指定Profile"><a href="#3-激活指定Profile" class="headerlink" title="3.激活指定Profile"></a>3.激活指定Profile</h3><p>1.配置文件中指定<code>spring.profiles.active=dev</code></p>
<p>2.命令行：</p>
<p>​        <code>--spring.profiles.active=dev</code>，可以配置在程序参数</p>
<p>​        <code>java -jar springboot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev</code></p>
<p>​        可以直接在测试的时候，配置传入命令行参数</p>
<p>3.虚拟机参数：</p>
<p>​        <code>-Dspring.profiles.active=dev</code></p>
<h2 id="7-配置文件的加载位置"><a href="#7-配置文件的加载位置" class="headerlink" title="7.配置文件的加载位置"></a>7.配置文件的加载位置</h2><p>！！！idea没有图标，没有自动提示就删掉（包括resources），重新创建<code>application.properties</code></p>
<p><code>file:./config/</code></p>
<p><code>file:./</code></p>
<p><code>classpath:./config/</code></p>
<p><code>classpath:./</code></p>
<p>优先级由高到低，高优先级的配置会覆盖低优先级的配置；</p>
<p>SpringBoot会从这四个位置加载全部主配配置文件</p>
<p>注意：file:./指项目路径，如果在聚合项目中，file:./指的是父项目，而不是子项目</p>
<p>可以通过<code>spring.config.location</code>改变默认文件的位置</p>
<p><code>java -jar springboot-02-config-02-0.0.1-SNAPSHOT.jar --spring.config.location=D:/</code></p>
<h2 id="8-外部配置加载顺序"><a href="#8-外部配置加载顺序" class="headerlink" title="8.外部配置加载顺序"></a>8.外部配置加载顺序</h2><p><img alt="order" data-src="https://gitee.com/alexander1/pic/raw/master/springboot笔记/20210318153438.png"></p>
<p>参考官方文档</p>
<h2 id="9-自动配置原理"><a href="#9-自动配置原理" class="headerlink" title="9.自动配置原理"></a>9.自动配置原理</h2><h3 id="1-自动配置原理："><a href="#1-自动配置原理：" class="headerlink" title="1.自动配置原理："></a><strong>1.自动配置原理：</strong></h3><p>1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能@EnableAutoConfiguration</p>
<p>2）、<code>@EnableAutoConfiguration</code>作用</p>
<ul>
<li><p>利用<code>AutoConfigurationImportSelector</code>给容器中导入一些组件</p>
</li>
<li><p>可以查看<code>selectImports().getAutoConfigurationEntry()</code>方法的内容</p>
</li>
<li><p><code>List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)</code>;</p>
<ul>
<li><p><code>SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),getBeanClassLoader())</code>;<br>扫描所有jar包类路径下的 META-INF/spring.factories<br>把扫描到的这些文件的内容包装成properties对象<br>从properties中获取到<code>EnableAutoConfiguration.class</code>类对应的值，然后把它们添加在容器中</p>
<p>将类路径下<code>META-INF/spring.factories</code>里面配置的所有<code>EnableAutoConfiguration</code>的值添加到了容器中</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Auto Configure </span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br></pre></td></tr></table></figure>
<p>​         每一个这样的<code>xxxAutoConfiguration</code>类都是容器中的一个组件，都加入到容器中；用他们来做自动配置</p>
<p>3）、每一个自动配置类进行自动配置功能；</p>
<p>4）、以<strong><code>HttpEncodingAutoConfiguration</code></strong>为例解释自动配置原理；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//表示这是一个配置类，和配置文件一样，可以为容器中添加组件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HttpProperties.class)<span class="comment">//启动指定类的ConfigurationProperties功能，将配置文件中对应的值和HttpEncodingAutoConfiguration绑定起来；并把HttpProperties加入的IOC容器中</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>(type = ConditionalOnWebApplication.Type.SERVLET)<span class="comment">//Spring底层@Conditional注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；   判断当前应用是否是web应用，如果是，当前配置类生效</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(CharacterEncodingFilter.class)<span class="comment">//判断当前项目有没有这个类,CharacterEncodingFilter:SpringMVC进行乱码解决的过滤器；</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.http.encoding"</span>, value = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)<span class="comment">//判断配置文件中是否存在某个配置  spring.http.encoding.enabled;如果不存在，判断也是成立的，即使不配置spring.http.encoding.enabled,也是默认生效的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpProperties.Encoding properties;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpProperties properties)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.properties = properties.getEncoding();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">		filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">		filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.REQUEST));</span><br><span class="line">		filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.RESPONSE));</span><br><span class="line">		<span class="keyword">return</span> filter;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据当前不同的条件判断，决定这个配置类是否生效</p>
<p>一旦这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性从对应的properties类中获取，这些类的每一个属性是和主配置文件绑定的。</p>
<p>5）、所有在配置文件中能配置的属性都在xxxProperties中封装着</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.http"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Whether logging of (potentially sensitive) request details at DEBUG and TRACE level</span></span><br><span class="line"><span class="comment">	 * is allowed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> logRequestDetails;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * HTTP encoding properties.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Encoding encoding = <span class="keyword">new</span> Encoding();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>精髓：</p>
<p>​        1）、Springboot启动会加载大量的自动配置类</p>
<p>​        2）、先看需要的功能有没有Springboot默认写好的自动配置类；</p>
<p>​        3）、再看自动配置类中配置了哪些组件（只要有要用的组件，就不需要配置）</p>
<p>​        4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性，我们就可以在配置文件中指定这些属性的值；</p>
<p>xxxxAutoCOnfiguration:自动配置类；</p>
<p>给容器中自动添加组件</p>
<p>xxxxProperties：封装配置文件中相关属性；</p>
<h3 id="2-细节"><a href="#2-细节" class="headerlink" title="2.细节"></a>2.细节</h3><h4 id="1-Conditional派生注解-Spring注解版原生的-Conditional作用"><a href="#1-Conditional派生注解-Spring注解版原生的-Conditional作用" class="headerlink" title="1.@Conditional派生注解(Spring注解版原生的@Conditional作用)"></a>1.@Conditional派生注解(Spring注解版原生的@Conditional作用)</h4><p>作用：必须是<code>@Conditional</code>指定的条件成立，才给容器中添加组件，配置类里面的所有内容才生效；</p>
<p><strong>自动配置类必须在一定条件下才能生效；</strong></p>
<p>怎么才能知道那些配置类能够生效；</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">debug</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<p>在application.properties添加debug=true</p>
<h1 id="三、日志"><a href="#三、日志" class="headerlink" title="三、日志"></a>三、日志</h1><h2 id="1-日志框架"><a href="#1-日志框架" class="headerlink" title="1.日志框架"></a>1.日志框架</h2><p>市面上的日志框架；</p>
<p>JUL；<del>JCl(commons-logging)</del>；<del>Jboss-logging</del>；logback；log4j；slf4j；log4j2</p>
<p>高亮的是抽象层，其他是具体的实现</p>
<p>SpringBoot：底层是Spring框架，Spring框架默认是用JCL</p>
<p>​            SpringBoot选用的是slf4j和logback</p>
<h2 id="2-SLF4J使用"><a href="#2-SLF4J使用" class="headerlink" title="2.SLF4J使用"></a>2.SLF4J使用</h2><h3 id="1-如何在系统中使用SLF4J"><a href="#1-如何在系统中使用SLF4J" class="headerlink" title="1.如何在系统中使用SLF4J"></a>1.如何在系统中使用SLF4J</h3><p>开发的时候，不应该直接调用日志的实现类，而是调用日志抽象层的方法。</p>
<p>给系统导入slf4j的jar和logback的实现jar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Logger logger = LoggerFactory.getLogger(HelloWorld.class);</span><br><span class="line">        logger.info(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个日志的实现框架都有自己的配置文件。使用slf4j后，<strong>配置文件还是做成日志实现框架本身的配置文件；</strong></p>
<h3 id="2-遗留问题"><a href="#2-遗留问题" class="headerlink" title="2.遗留问题"></a>2.遗留问题</h3><p>统一日志记录，即使是别的框架统一一起使用slf4j</p>
<p>1.将系统中其它日志框架先排除出去；</p>
<p>2.用中间包来替换原有的日志框架；</p>
<p>3.导入slf4j其他的实现</p>
<h2 id="3-SpringBoot日志关系"><a href="#3-SpringBoot日志关系" class="headerlink" title="3.SpringBoot日志关系"></a>3.SpringBoot日志关系</h2><p>如果要引入其他框架，一定要把这个框架的默认日志依赖移除掉；</p>
<p>SpringBoot能自动配置所有的日志，底层使用的是slf4j+logback方式记录日志。</p>
<h2 id="4-日志使用"><a href="#4-日志使用" class="headerlink" title="4.日志使用"></a>4.日志使用</h2><h3 id="1-默认"><a href="#1-默认" class="headerlink" title="1.默认"></a>1.默认</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//        System.out.println();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志的级别：</span></span><br><span class="line">    <span class="comment">//由低到高 trace&lt;debug&lt;info&lt;warn&lt;error</span></span><br><span class="line">    <span class="comment">//调整输出的日志级别：日志就只会在这个级别以后的高级别生效</span></span><br><span class="line">    logger.trace(<span class="string">"这是trace日志..."</span>);</span><br><span class="line">    logger.debug(<span class="string">"这是debug信息..."</span>);</span><br><span class="line">    logger.info(<span class="string">"这是info日志..."</span>);</span><br><span class="line">    logger.warn(<span class="string">"这是warn日志..."</span>);</span><br><span class="line">    logger.error(<span class="string">"这是error日志..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置日志级别</span></span><br><span class="line"><span class="meta">logging.level.com.springboot</span>=<span class="string">trace</span></span><br><span class="line"><span class="comment">#在当前项目下生成日志</span></span><br><span class="line"><span class="meta">logging.file</span>=<span class="string">springboot.log</span></span><br><span class="line"><span class="comment">#在控制台输出的日志格式</span></span><br><span class="line"><span class="meta">logging.pattern.console</span>=<span class="string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span></span><br><span class="line"><span class="comment">#指定文件中输出日志格式</span></span><br><span class="line"><span class="meta">logging.pattern.file</span>=<span class="string">%d&#123;yyyy-MM-dd&#125; ==main== [%thread] %-5level %logger&#123;50&#125; - %msg%n</span></span><br></pre></td></tr></table></figure>
<h3 id="2-指定配置"><a href="#2-指定配置" class="headerlink" title="2.指定配置"></a>2.指定配置</h3><p>给类路径上放上每个日志框架自己的配置文件，就不使用SpringBoot的默认配置了；</p>
<p><code>logback.xml</code>：直接就会被日志框架识别了,所以需要改名</p>
<p><code>logback-spring.xm</code>l:日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以试用SpringBoot的高级Profile功能</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span>&gt;</span><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="5-切换日志框架"><a href="#5-切换日志框架" class="headerlink" title="5.切换日志框架"></a>5.切换日志框架</h2><h1 id="四、Web开发"><a href="#四、Web开发" class="headerlink" title="四、Web开发(*)"></a>四、Web开发(*)</h1><h2 id="1-SpringBoot对静态资源的配置规则"><a href="#1-SpringBoot对静态资源的配置规则" class="headerlink" title="1.SpringBoot对静态资源的配置规则"></a>1.SpringBoot对静态资源的配置规则</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Default resource handling disabled"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Duration cachePeriod = <span class="keyword">this</span>.resourceProperties.getCache().getPeriod();</span><br><span class="line">    CacheControl cacheControl = <span class="keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line">    <span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">        customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">                                             .addResourceLocations(<span class="string">"classpath:/META-INF/resources/webjars/"</span>)</span><br><span class="line">                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">    &#125;</span><br><span class="line">    String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">    <span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)</span><br><span class="line">                                             .addResourceLocations(getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations()))</span><br><span class="line">                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title">welcomePageHandlerMapping</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">			WelcomePageHandlerMapping welcomePageHandlerMapping = <span class="keyword">new</span> WelcomePageHandlerMapping(</span><br><span class="line">					<span class="keyword">new</span> TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(),</span><br><span class="line">					<span class="keyword">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">			welcomePageHandlerMapping.setInterceptors(getInterceptors());</span><br><span class="line">			<span class="keyword">return</span> welcomePageHandlerMapping;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>1）、所有/webjars/**，都去<code>classpath:/META-INF/resources/webjars/</code>找资源；</p>
<p>webjars：以jar包的方式引入静态资源</p>
<p>2）、”/**”访问静态资源的任何路径（静态资源的文件夹）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;classpath:/META-INF/resources/&quot;,</span><br><span class="line">&quot;classpath:/resources/&quot;,</span><br><span class="line">&quot;classpath:/static/&quot;,</span><br><span class="line">&quot;classpath:/public/&quot;,</span><br><span class="line">&quot;/&quot;:当前项目的根路径， release2.1.8没有发现根路径</span><br><span class="line">优先级：</span><br><span class="line">META-INF&gt;resources&gt;static&gt;public</span><br></pre></td></tr></table></figure>
<p><a href="http://localhost:8080/asserts/js/jquery-3.2.1.slim.min.js" target="_blank" rel="noopener">http://localhost:8080/asserts/js/jquery-3.2.1.slim.min.js</a></p>
<p>3）、欢迎页；静态资源文件夹下的所有index.html页面；被”/**”映射；</p>
<p>localhost:8080/  找index</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Resource <span class="title">getIndexHtml</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.resourceLoader.getResource(location + <span class="string">"index.html"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>templates下的index.html也可以找到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;classpath:/resources/index.html&quot;,</span><br><span class="line">&quot;classpath:/static/index.html&quot;,</span><br><span class="line">&quot;classpath:/public/index.html&quot;,</span><br><span class="line">&quot;classpath:/templates/index.html&quot;</span><br></pre></td></tr></table></figure>
<p>优先级从上到下，由高到低</p>
<p>4）、所有的**/favicon.ico都是在静态文件夹下找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">		<span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"spring.mvc.favicon.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FaviconConfiguration</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">private</span> <span class="keyword">final</span> ResourceProperties resourceProperties;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="title">FaviconConfiguration</span><span class="params">(ResourceProperties resourceProperties)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">this</span>.resourceProperties = resourceProperties;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Bean</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> SimpleUrlHandlerMapping <span class="title">faviconHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				SimpleUrlHandlerMapping mapping = <span class="keyword">new</span> SimpleUrlHandlerMapping();</span><br><span class="line">				mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + <span class="number">1</span>);</span><br><span class="line">				mapping.setUrlMap(Collections.singletonMap(<span class="string">"**/favicon.ico"</span>, faviconRequestHandler()));</span><br><span class="line">				<span class="keyword">return</span> mapping;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Bean</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> ResourceHttpRequestHandler <span class="title">faviconRequestHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				ResourceHttpRequestHandler requestHandler = <span class="keyword">new</span> ResourceHttpRequestHandler();</span><br><span class="line">				requestHandler.setLocations(resolveFaviconLocations());</span><br><span class="line">				<span class="keyword">return</span> requestHandler;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="keyword">private</span> List&lt;Resource&gt; <span class="title">resolveFaviconLocations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				String[] staticLocations = getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations());</span><br><span class="line">				List&lt;Resource&gt; locations = <span class="keyword">new</span> ArrayList&lt;&gt;(staticLocations.length + <span class="number">1</span>);</span><br><span class="line">				Arrays.stream(staticLocations).map(<span class="keyword">this</span>.resourceLoader::getResource).forEach(locations::add);</span><br><span class="line">				locations.add(<span class="keyword">new</span> ClassPathResource(<span class="string">"/"</span>));</span><br><span class="line">				<span class="keyword">return</span> Collections.unmodifiableList(locations);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>所有的**/favicon.ico都是在静态文件夹下找</p>
<p><strong>这个功能感觉有时候会不太好使</strong>，可以再试试关闭默认图标</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#关闭默认图标</span></span><br><span class="line"><span class="comment">#spring.mvc.favicon.enabled=false</span></span><br></pre></td></tr></table></figure>
<h2 id="2-模板引擎"><a href="#2-模板引擎" class="headerlink" title="2.模板引擎"></a>2.模板引擎</h2><p>JSP、Velocity、Freemarker、Thymeleaf </p>
<p>SpringBoot推荐的Thymeleaf ：</p>
<p>语法更简单、功能更强大</p>
<h3 id="1-引入Thymeleaf"><a href="#1-引入Thymeleaf" class="headerlink" title="1.引入Thymeleaf"></a>1.引入Thymeleaf</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>springboot2.x版本后默认使用Thymeleaf3</p>
<h3 id="2-thymeleaf使用"><a href="#2-thymeleaf使用" class="headerlink" title="2.thymeleaf使用"></a>2.thymeleaf使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.thymeleaf"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_ENCODING = StandardCharsets.UTF_8;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PREFIX = <span class="string">"classpath:/templates/"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SUFFIX = <span class="string">".html"</span>;</span><br><span class="line">    <span class="comment">//只要放在classpath:/templates/下，thymeleaf就能够渲染页面了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<p>1.导入thymeleaf的名称空间</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-语法规则"><a href="#3-语法规则" class="headerlink" title="3.语法规则"></a>3.语法规则</h2><p>1）、th:任意html，替换原生的属性</p>
<p>2）、表达式</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>语法</th>
<th>名称</th>
<th>描述</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>${…}</td>
<td>Variable Expressions</td>
<td>变量表达式</td>
<td>取出上下文变量的值</td>
</tr>
<tr>
<td>*{…}</td>
<td>Selection Variable Expressions</td>
<td>选择变量表达式</td>
<td>取出选择的对象的属性值</td>
</tr>
<tr>
<td>#{…}</td>
<td>Message Expressions</td>
<td>消息表达式</td>
<td>使文字消息国际化，I18N</td>
</tr>
<tr>
<td>@{…}</td>
<td>Link URL Expressions</td>
<td>链接表达式</td>
<td>用于表示各种超链接地址</td>
</tr>
<tr>
<td>~{…}</td>
<td>Fragment Expressions</td>
<td>片段表达式</td>
<td>引用一段公共的代码片段</td>
</tr>
</tbody>
</table>
</div>
<p>${…}: </p>
<p>1）、获取对象的属性、调用方法；</p>
<p>2）、使用内置的对象 </p>
<p>3）、使用内置的一些工具对象</p>
<p>*{…}:和${…}在功能上一致</p>
<h2 id="4-SpringMVC自动配置原理"><a href="#4-SpringMVC自动配置原理" class="headerlink" title="4.SpringMVC自动配置原理"></a>4.SpringMVC自动配置原理</h2><p>SpringBoot自动配置好了SpringMVC</p>
<p>以下是SpringBoot对SpringMVC的默认配置：</p>
<ul>
<li><p>自动配置了视图解析器ViewResolver(根据方法的返回值得到视图对象)</p>
<ul>
<li><p><code>ContentNegotiatingViewResolver</code>；组合了所有的视图解析器</p>
</li>
<li><p>如何定制：可以自己个容器中添加一个视图解析器，自动的将其组合进来</p>
</li>
</ul>
</li>
<li><p>自动注册了<code>Converter,GenericConverter，Formatter</code></p>
<p>自己添加的格式化器转换器，只需要放在容器中即可</p>
</li>
<li><p><code>HttpMessageConverter:SpringMVC</code>用来转换http请求和相应的;user—-json;</p>
<p>自己添加的HttpMessageConverter，只需要放在容器中即可</p>
</li>
<li><p><code>MessageCodesResolver</code>:定义错误代码生成规则</p>
</li>
<li><code>ConfigurableWebBindingInitializer</code>:初始化<code>WebDataBinder</code>,请求数据==&gt;JavaBean</li>
</ul>
<h2 id="5-如何修改SpringBoot的默认配置"><a href="#5-如何修改SpringBoot的默认配置" class="headerlink" title="5.如何修改SpringBoot的默认配置"></a>5.如何修改SpringBoot的默认配置</h2><p>模式：</p>
<p>​    1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（<code>@Bean</code>，<code>@Component</code>）；如果有就用用户配置的如果没有，才自动配置；如果有些组件可以有多个（<code>VIewResolver</code>）将用户配置的和自己默认的组合起来；</p>
<p>​    2）、扩展SpringMVC</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"><span class="comment">//alt+shift+p快速实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addViewController(<span class="string">"/add"</span>).setViewName(<span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容器中所有的<code>WebMvcConfigurer</code>都会起作用</p>
<p>3）、Springboot中有非常多的xxxConfigurer，用它进行额外配置</p>
<p>4）、Springboot中有非常多的xxxCustomizer，用它进行额外配置</p>
<h2 id="6-RESTFUL-crud"><a href="#6-RESTFUL-crud" class="headerlink" title="6.RESTFUL crud(*)"></a>6.RESTFUL crud(*)</h2><h3 id="1）、默认访问首页"><a href="#1）、默认访问首页" class="headerlink" title="1）、默认访问首页"></a>1）、默认访问首页</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"><span class="comment">//alt+shift+p快速实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addViewController(<span class="string">"/abc"</span>).setViewName(<span class="string">"success"</span>);</span><br><span class="line">        registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">webMvcConfigurer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">                registry.addViewController(<span class="string">"/login.html"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2）、国际化"><a href="#2）、国际化" class="headerlink" title="2）、国际化"></a>2）、国际化</h3><p>SpringMVC:</p>
<p>1）、编写国际化配置文件；</p>
<p>2）、使用<code>ResourceBundleMessageSource</code>管理国际化资源文件</p>
<p>3）、在页面使用fmt：message取出国际化内容</p>
<p>步骤：</p>
<p>1）、编写国际化配置文件，抽取页面需要显示的国际化消息</p>
<p>2）、Springboot自动配置好了管理国际化资源文件的组件；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = MessageSource.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="meta">@Conditional</span>(ResourceBundleCondition.class)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSourceAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.messages"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> MessageSourceProperties <span class="title">messageSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MessageSourceProperties();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）、去页面获取国际化的值；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-sm"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/login.html(l='zh_CN')&#125;"</span>&gt;</span>中文<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-sm"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/login.html(l='en_US')&#125;"</span>&gt;</span>English<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>4）、注册<code>LocaleResolver</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLocaleResolver</span> <span class="keyword">implements</span> <span class="title">LocaleResolver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Locale <span class="title">resolveLocale</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String l = request.getParameter(<span class="string">"l"</span>);</span><br><span class="line">        Locale locale = Locale.getDefault();</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(l))&#123;</span><br><span class="line">            String[] split = l.split(<span class="string">"_"</span>);</span><br><span class="line">            locale = <span class="keyword">new</span> Locale(split[<span class="number">0</span>],split[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> locale;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocaleResolver <span class="title">localeResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyLocaleResolver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3）、登录"><a href="#3）、登录" class="headerlink" title="3）、登录(*)"></a>3）、登录(*)</h3><p>开发期间要想页面修改后实时生效</p>
<p>1.禁用模板引擎的缓存</p>
<p>2.ctrl+F9,重新编译</p>
<p>登录错误消息的提示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:red"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;msg&#125;"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;not #strings.isEmpty(msg)&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>登陆成功跳转的时候应该用重定向</p>
<h4 id="重定向："><a href="#重定向：" class="headerlink" title="重定向："></a>重定向：</h4><p><img alt="重定向" data-src="https://gitee.com/alexander1/pic/raw/master/springboot笔记/20210318153405.png"></p>
<p>重定向时，正确的静态资源访问:</p>
<p><img alt data-src="https://gitee.com/alexander1/pic/raw/master/springboot笔记/20210318153413.png"></p>
<p>重定向可以跳转到相应的静态资源包下的html文件，但跳不到templates里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">项目中静态资源包:</span><br><span class="line">1.classpath:/resources/</span><br><span class="line">2.classpath:/static/</span><br><span class="line">3.classpath:/public/</span><br></pre></td></tr></table></figure>
<h4 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发:"></a>请求转发:</h4><p><img alt data-src="https://gitee.com/alexander1/pic/raw/master/springboot笔记/20210318153416.png"></p>
<p>请求转发时，错误的静态资源访问：</p>
<p><img alt data-src="https://gitee.com/alexander1/pic/raw/master/springboot笔记/20210318153419.png"></p>
<p>由于前面的请求是/user/login，所以不行</p>
<p>当只有一层时，</p>
<p><img alt data-src="https://gitee.com/alexander1/pic/raw/master/springboot笔记/20210318153421.png"></p>
<p><img alt data-src="https://gitee.com/alexander1/pic/raw/master/springboot笔记/20210318153423.png"></p>
<h4 id="总结-以此次项目为例"><a href="#总结-以此次项目为例" class="headerlink" title="总结(以此次项目为例)"></a>总结(以此次项目为例)</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>重定向</th>
<th>请求转发</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态资源访问路径</td>
<td>无论如何都是localhost:8080/crud/xxx.css(项目路径+访问资源的路径)</td>
<td>若原来的请求是/user/login,就是去掉一层目录后的目录,即localhost:8080/crud/user/xxx.css</td>
</tr>
<tr>
<td>地址栏</td>
<td>会变化</td>
<td>不会变化</td>
</tr>
<tr>
<td>哪里跳转</td>
<td>在客户端即浏览器跳转</td>
<td>在服务器内部跳转</td>
</tr>
<tr>
<td>请求域中的数据是否会丢失</td>
<td>会丢失</td>
<td>不会丢失</td>
</tr>
<tr>
<td>请求次数</td>
<td>2次</td>
<td>1次</td>
</tr>
</tbody>
</table>
</div>
<h3 id="4）、拦截器进行登录检查"><a href="#4）、拦截器进行登录检查" class="headerlink" title="4）、拦截器进行登录检查"></a>4）、拦截器进行登录检查</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">webMvcConfigurer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">            registry.addViewController(<span class="string">"/login.html"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//静态资源;</span></span><br><span class="line">            registry.addInterceptor(<span class="keyword">new</span> LoginHandlerInterceptor()).addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">                .excludePathPatterns(<span class="string">"/login.html"</span>,<span class="string">"/"</span>,<span class="string">"/user/login"</span>)</span><br><span class="line">                .excludePathPatterns(<span class="string">"/asserts/**"</span>,<span class="string">"/webjars/**"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一定要注意，springboot 1.5的不需要排除静态资源也可以访问，但是springboot2.x需要排除静态资源才能够访问</p>
<p>  <code>.excludePathPatterns(&quot;/asserts/**&quot;,&quot;/webjars/**&quot;);</code></p>
<h3 id="5）、CRUD-员工列表"><a href="#5）、CRUD-员工列表" class="headerlink" title="5）、CRUD-员工列表"></a>5）、CRUD-员工列表</h3><p>实验要求：</p>
<p>1）、RestfulCRUD：CRUD满足Rest风格：</p>
<p>URI：/资源名称/资源标识  HTTP请求方式区分对资源CRUD操作</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>普通CRUD（URI区分操作）</th>
<th>RestfulCRUD</th>
</tr>
</thead>
<tbody>
<tr>
<td>查询</td>
<td>getEmp</td>
<td>emp—-GET</td>
</tr>
<tr>
<td>添加</td>
<td>addEmp?xxx</td>
<td>emp—-POST</td>
</tr>
<tr>
<td>修改</td>
<td>updateEmp?id=xxx&amp;xxx</td>
<td>emp/{id}—-PUT</td>
</tr>
<tr>
<td>删除</td>
<td>deleteEmp?id=1</td>
<td>emp/{id}—-DELETE</td>
</tr>
</tbody>
</table>
</div>
<p>2）、实验的请求架构</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th>请求URI</th>
<th>请求方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>查询所有员工</td>
<td>emps</td>
<td>GET</td>
</tr>
<tr>
<td>查询某个员工</td>
<td>emp/{id}</td>
<td>GET</td>
</tr>
<tr>
<td>来到添加页面</td>
<td>emp</td>
<td>GET</td>
</tr>
<tr>
<td>添加员工</td>
<td>emp</td>
<td>POST</td>
</tr>
<tr>
<td>来到修改页面(查出员工进行信息会写)</td>
<td>emp/{id}</td>
<td>GET</td>
</tr>
<tr>
<td>修改员工</td>
<td>emp</td>
<td>PUT</td>
</tr>
<tr>
<td>删除员工</td>
<td>emp/{id}</td>
<td>DELETE</td>
</tr>
</tbody>
</table>
</div>
<p>thymeleaf公共页面抽取</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1.抽取公共片段</span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0"</span> <span class="attr">th:fragment</span>=<span class="string">"topbar"</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"></span><br><span class="line">2.使用公共片段</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">"~&#123;dashboard::topbar&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">3.默认效果</span><br><span class="line">th:insert的功能片段在div标签中</span><br><span class="line">如果使用th:insert等用法，可以不用写~&#123;&#125;</span><br><span class="line">[[~&#123;&#125;]] ; [(~&#123;&#125;)]</span><br></pre></td></tr></table></figure>
<p>三种引入功能片段的th属性：</p>
<p>th:insert：将公共片段插入到div标签中</p>
<p>th:replace：将声明引入的元素替换为公共片段</p>
<p>th:include：将被引入的片段的内容包含进这个标签中</p>
<p>引入片段的时候传入参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">"commons/bar::#sidebar(activeUri='main.html')"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="6）、CRUD-员工添加"><a href="#6）、CRUD-员工添加" class="headerlink" title="6）、CRUD-员工添加"></a>6）、CRUD-员工添加</h3><p>提交 数据格式不对：生日  日期</p>
<p>2017.12.12   2017-12-12   2017/12/12</p>
<p>日期的格式化：SpringMVC将页面提交的值需要转换为指定的类型</p>
<p>2017-12-12——-Date  类型转换，格式化；</p>
<p>默认日期是按照/的方式，</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.mvc.date-format</span>=<span class="string">yyyy-MM-dd</span></span><br><span class="line"><span class="attr">更改日期格式，但还是只能有一种方式</span></span><br></pre></td></tr></table></figure>
<h2 id="7、错误处理机制"><a href="#7、错误处理机制" class="headerlink" title="7、错误处理机制"></a>7、错误处理机制</h2><h3 id="1、SpringBoot默认的错误处理机制"><a href="#1、SpringBoot默认的错误处理机制" class="headerlink" title="1、SpringBoot默认的错误处理机制"></a>1、SpringBoot默认的错误处理机制</h3><p>原理：</p>
<p>​    可以参照<code>ErrorMvcAutoConfiguration</code>的错误处理自动配置；</p>
<p>​    给容器中添加了一下组件：</p>
<p>​    1、<code>DefaultErrorAttributes</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">帮我们在页面共享信息</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(ServerRequest request, <span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; errorAttributes = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    errorAttributes.put(<span class="string">"timestamp"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    errorAttributes.put(<span class="string">"path"</span>, request.path());</span><br><span class="line">    Throwable error = getError(request);</span><br><span class="line">    HttpStatus errorStatus = determineHttpStatus(error);</span><br><span class="line">    errorAttributes.put(<span class="string">"status"</span>, errorStatus.value());</span><br><span class="line">    errorAttributes.put(<span class="string">"error"</span>, errorStatus.getReasonPhrase());</span><br><span class="line">    errorAttributes.put(<span class="string">"message"</span>, determineMessage(error));</span><br><span class="line">    handleException(errorAttributes, determineException(error), includeStackTrace);</span><br><span class="line">    <span class="keyword">return</span> errorAttributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    2、<code>BasicErrorController</code>：处理默认/error请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicErrorController</span> <span class="keyword">extends</span> <span class="title">AbstractErrorController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(produces = MediaType.TEXT_HTML_VALUE)<span class="comment">//产生html数据,浏览器发出的请求来这个方法处理</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">errorHtml</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line">		Map&lt;String, Object&gt; model = Collections</span><br><span class="line">				.unmodifiableMap(getErrorAttributes(request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));</span><br><span class="line">		response.setStatus(status.value());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//去哪个页面作为错误页面；包含页面地址和页面内容</span></span><br><span class="line">		ModelAndView modelAndView = resolveErrorView(request, response, status, model);</span><br><span class="line">		<span class="keyword">return</span> (modelAndView != <span class="keyword">null</span>) ? modelAndView : <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>, model);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span><span class="comment">//产生json数据，其他客户端发出的请求来这个方法处理	</span></span><br><span class="line">	<span class="keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;</span><br><span class="line">		Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL));</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(body, status);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    3、<code>ErrorPageCustomizer</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;error.path:/error&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String path = <span class="string">"/error"</span>;<span class="comment">//系统出现错误以后来到error请求进行处理；(web.xml注册的错误页面规则)</span></span><br></pre></td></tr></table></figure>
<p>​    4、<code>DefaultErrorViewResolver</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveErrorView</span><span class="params">(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">		ModelAndView modelAndView = resolve(String.valueOf(status.value()), model);</span><br><span class="line">		<span class="keyword">if</span> (modelAndView == <span class="keyword">null</span> &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123;</span><br><span class="line">			modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> modelAndView;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> ModelAndView <span class="title">resolve</span><span class="params">(String viewName, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//默认SpringBoot可以去找到一个页面；error/404</span></span><br><span class="line">		String errorViewName = <span class="string">"error/"</span> + viewName;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//模板引擎可以解析这个页面地址就用模板引擎解析errorViewName指定的视图地址</span></span><br><span class="line">		TemplateAvailabilityProvider provider = <span class="keyword">this</span>.templateAvailabilityProviders.getProvider(errorViewName,</span><br><span class="line">				<span class="keyword">this</span>.applicationContext);</span><br><span class="line">		<span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//模板引擎可用的情况下返回到errorViewName指定的视图地址</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(errorViewName, model);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面     error/404.html</span></span><br><span class="line">		<span class="keyword">return</span> resolveResource(errorViewName, model);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​    步骤：</p>
<p>​            一旦系统出现了4xx或5xx之类的错误；<code>ErrorPageCustomizer</code>就会生效（定制错误的相应规则）;就会来到/error请求;就会来到<code>BasicErrorController</code>处理；</p>
<p>​        1）、显示页面；去哪个页面是由<strong><code>DefaultErrorViewResolver</code></strong>解析得到的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">resolveErrorView</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HttpStatus status,</span></span></span><br><span class="line"><span class="function"><span class="params">			Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有的ErrorViewResolver得到ModelAndView</span></span><br><span class="line">		<span class="keyword">for</span> (ErrorViewResolver resolver : <span class="keyword">this</span>.errorViewResolvers) &#123;</span><br><span class="line">			ModelAndView modelAndView = resolver.resolveErrorView(request, status, model);</span><br><span class="line">			<span class="keyword">if</span> (modelAndView != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> modelAndView;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2）、如果定制错误响应"><a href="#2）、如果定制错误响应" class="headerlink" title="2）、如果定制错误响应"></a>2）、如果定制错误响应</h3><h4 id="1）、如何定制错误的页面："><a href="#1）、如何定制错误的页面：" class="headerlink" title="1）、如何定制错误的页面："></a>1）、如何定制错误的页面：</h4><p>​    1）、<strong>有模板引擎的情况下</strong>；error/状态码；</p>
<p>将错误页面命名为  错误状态码.html放在模板引擎文件下的error文件夹下;</p>
<p>发生此错误码的错误就会来到对应的页面；</p>
<p>可以试用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）</p>
<p>也可以将error.html放在templates下</p>
<p>页面能获取的信息:</p>
<p>​                timestamp:时间戳</p>
<p>​                status：状态码</p>
<p>​                error：错误提示</p>
<p>​                exception：错误对象</p>
<p>​                message：异常消息</p>
<p>​                errors：JSR303数据校验的错误都在这里</p>
<p>​    2）、<strong>没有模板引擎（不用模板引擎）</strong>，静态资源文件加下找；</p>
<p>​    3）、<strong>以上都没有</strong>，就是默认来到SpringBoot的error页面；</p>
<h4 id="2）、定制错误的json数据；"><a href="#2）、定制错误的json数据；" class="headerlink" title="2）、定制错误的json数据；"></a>2）、定制错误的json数据；</h4><p>1）、自定义异常处理&amp;返回定制json数据；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//浏览器和客户端返回的都是json</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(UserNotExistException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">handleException</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"code"</span>,<span class="string">"user,not exist"</span>);</span><br><span class="line">        map.put(<span class="string">"message"</span>,e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有自适应效果</span></span><br></pre></td></tr></table></figure>
<p>2）、转发到/error进行自适应相应效果处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(UserNotExistException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleException</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"code"</span>,<span class="string">"user,not exist"</span>);</span><br><span class="line">    map.put(<span class="string">"message"</span>,e.getMessage());</span><br><span class="line">    <span class="comment">//转发到/error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"forward:/error"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）、定制额外的相应数据，参照P44</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(UserNotExistException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleException</span><span class="params">(Exception e, HttpServletRequest request)</span></span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//传入我们自己的错误状态码 4xx 5xx 否则就不会进入定制错误页面的解析流程</span></span><br><span class="line">    request.setAttribute(<span class="string">"javax.servlet.error.status_code"</span>,<span class="number">400</span>);</span><br><span class="line">    map.put(<span class="string">"code"</span>,<span class="string">"user,not exist"</span>);</span><br><span class="line">    map.put(<span class="string">"message"</span>,e.getMessage());</span><br><span class="line">    <span class="comment">//转发到/error</span></span><br><span class="line">    <span class="comment">//        return "forward:/error";</span></span><br><span class="line">    <span class="comment">//可以调到自定义的页面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以自定义页面跳转，也能够实现收到额外的相应数据</p>
<h2 id="8、配置嵌入式Servlet容器"><a href="#8、配置嵌入式Servlet容器" class="headerlink" title="8、配置嵌入式Servlet容器"></a>8、配置嵌入式Servlet容器</h2><p>SpringBoot默认是用的嵌入的Servlet容器（Tomcat）；</p>
<p>问题？</p>
<h3 id="1）、如何定制和修改Servlet容器的相关配置；"><a href="#1）、如何定制和修改Servlet容器的相关配置；" class="headerlink" title="1）、如何定制和修改Servlet容器的相关配置；"></a>1）、如何定制和修改Servlet容器的相关配置；</h3><p>​    1、修改和server有关的配置(ServerProperties[也是<code>EmbeddedServletContainerCustomizer</code>])</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.xxx</span>  <span class="string">#通用的Servlet容器设置</span></span><br><span class="line"><span class="meta">server.tomcat.xxx</span> <span class="string">#tomcat的设置</span></span><br></pre></td></tr></table></figure>
<p>​    2、编写一个<del><code>EmbeddedServletContainerCustomizer</code></del>，2.x后改为<code>WebServerFactoryCustomizer</code>，注入到IOC容器中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebServerFactoryCustomizer <span class="title">webServerFactoryCustomizer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt;() &#123;</span><br><span class="line">        <span class="comment">//定制嵌入式的Servlet容器的相关规则</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableWebServerFactory factory)</span> </span>&#123;</span><br><span class="line">            factory.setPort(<span class="number">8080</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2）、注册Servlet三大组件【Servlet、Filter、Listener】"><a href="#2）、注册Servlet三大组件【Servlet、Filter、Listener】" class="headerlink" title="2）、注册Servlet三大组件【Servlet、Filter、Listener】"></a>2）、注册Servlet三大组件【Servlet、Filter、Listener】</h3><p>由于Springboot默认是以jar包的方式启动嵌入式的Servlet容器来启动Springboot的web应用，没有web.xml文件。</p>
<p>注册三大组件用以下方式</p>
<p><code>ServletRegistrationBean</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">servletRegistrationBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServletRegistrationBean servletRegistrationBean = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> MyServlet(),<span class="string">"/myServlet"</span>);</span><br><span class="line">    <span class="keyword">return</span> servletRegistrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FilterRegistrationBean</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">filterRegistration</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FilterRegistrationBean register = <span class="keyword">new</span> FilterRegistrationBean(<span class="keyword">new</span> MyFilter());</span><br><span class="line">    <span class="comment">//        register.setFilter(new MyFilter());</span></span><br><span class="line">    register.setUrlPatterns(Arrays.asList(<span class="string">"/hello"</span>,<span class="string">"/myServlet"</span>));</span><br><span class="line">    <span class="keyword">return</span>  register;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ServletListenerRegistrationBean</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletListenerRegistrationBean <span class="title">mylistener</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServletListenerRegistrationBean servletListenerRegistrationBean = <span class="keyword">new</span> ServletListenerRegistrationBean(<span class="keyword">new</span> MyListener());</span><br><span class="line">    <span class="keyword">return</span> servletListenerRegistrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SpringBoot帮我们自动SpringMVC的时候，自动注册SpringMVC的前端控制器；DispatcherServlet</p>
<p>2）、SpringBoot能不能支持其他的Servlet容器；</p>
<h3 id="3）、替换为其他Servlet容器"><a href="#3）、替换为其他Servlet容器" class="headerlink" title="3）、替换为其他Servlet容器"></a>3）、替换为其他Servlet容器</h3><p>Tomcat（SpringBoot默认使用）</p>
<p>jetty</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>undertow</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4）、原理"><a href="#4）、原理" class="headerlink" title="4）、原理"></a>4）、原理</h3><p><a href="https://note.clboy.cn/#/backend/springboot/configservletcontainer?id=替换为其他嵌入式web服务器" target="_blank" rel="noopener">https://note.clboy.cn/#/backend/springboot/configservletcontainer?id=%e6%9b%bf%e6%8d%a2%e4%b8%ba%e5%85%b6%e4%bb%96%e5%b5%8c%e5%85%a5%e5%bc%8fweb%e6%9c%8d%e5%8a%a1%e5%99%a8</a></p>
<h2 id="9、使用外置的Servlet容器"><a href="#9、使用外置的Servlet容器" class="headerlink" title="9、使用外置的Servlet容器"></a>9、使用外置的Servlet容器</h2><p>嵌入式Servlet容器：应用打成可执行的jar</p>
<p>​                优点：简单、便携；</p>
<p>​                缺点：默认不支持JSP、优化定制比较复杂</p>
<p>外置的Servlet容器：外面安装Tomcat—应用war包的方式打包</p>
<h3 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h3><p>1）、必须创建一个war项目</p>
<p>2）、嵌入式的Tomcat指定为provided；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--打包的时候不会放入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3）、编写一个<code>SpringBootServletInitializer</code>，并调用configure方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletInitializer</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//传入SpringBoot应用的主程序</span></span><br><span class="line">        <span class="keyword">return</span> builder.sources(SpringbootWebJspApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>jar包：执行SpringBoot主类的main方法，启动IOC容器，创建嵌入式的Servlet容器；</p>
<p>war包：启动服务器，<strong>服务器启动Springboot应用</strong>【<code>SpringBootServletInitializer</code>】，启动IOC容器；</p>
<p>Servlet3.0新规范</p>
<p>规则：</p>
<p>​    1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面<code>ServletContainerInitializer</code>实例；</p>
<p>​    2）、<code>ServletContainerInitializer</code>的实现放在jar包的<code>META-INF/services</code>文件夹下，有一个名为<code>javax.servlet.ServletContainerInitializer</code>的文件，内容就是<code>ServletContainerInitializer</code>的实现类的全类名</p>
<p>​    3）、还可以使用<code>@HandlesTypes</code>，在应用启动的时候加载我们感兴趣的类</p>
<p>流程：</p>
<p>1）、启动Tomcat</p>
<p>2）、<code>org\springframework\spring-web\5.1.9.RELEASE\spring-web-5.1.9.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer：</code></p>
<p>Spring的Web模块里面有这个文件：<strong><code>org.springframework.web.SpringServletContainerInitializer</code></strong></p>
<p>3）、<code>SpringServletContainerInitializer</code>将<code>@HandlesTypes(WebApplicationInitializer.class)</code>必做主的所有这个类型的类传入到onStartup方法的<code>Set&lt;Class&lt;?&gt;&gt;</code>;为这些<code>WebApplicationInitializer</code>类型的类创建实例；</p>
<p>4）、每一个<code>WebApplicationInitializer</code>都调用自己的onStartup;【<code>SpringBootServletInitializer</code>】</p>
<p>5）、相当于<code>SpringBootServletInitializer</code>的类会被创建对象，并执行onStartup方法；</p>
<p>6）、<code>SpringBootServletInitializer</code>执行onStartup会<code>createRootApplicationContext</code>创建容器；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createRootApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建SpringApplicationBuilder</span></span><br><span class="line">    SpringApplicationBuilder builder = createSpringApplicationBuilder();</span><br><span class="line">    builder.main(getClass());</span><br><span class="line">    ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.info(<span class="string">"Root context already created (using as parent)."</span>);</span><br><span class="line">        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">null</span>);</span><br><span class="line">        builder.initializers(<span class="keyword">new</span> ParentContextApplicationContextInitializer(parent));</span><br><span class="line">    &#125;</span><br><span class="line">    builder.initializers(<span class="keyword">new</span> ServletContextApplicationContextInitializer(servletContext));</span><br><span class="line">    builder.contextClass(AnnotationConfigServletWebServerApplicationContext.class);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//2.调用configure,子类重写了这个方法,将SpringBoot的主程序类传了进来</span></span><br><span class="line">    builder = configure(builder);</span><br><span class="line">    builder.listeners(<span class="keyword">new</span> WebEnvironmentPropertySourceInitializer(servletContext));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.使用builder创建一个Spring应用</span></span><br><span class="line">    SpringApplication application = builder.build();</span><br><span class="line">    <span class="keyword">if</span> (application.getAllSources().isEmpty()</span><br><span class="line">        &amp;&amp; AnnotationUtils.findAnnotation(getClass(), Configuration.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        application.addPrimarySources(Collections.singleton(getClass()));</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.state(!application.getAllSources().isEmpty(),</span><br><span class="line">                 <span class="string">"No SpringApplication sources have been defined. Either override the "</span></span><br><span class="line">                 + <span class="string">"configure method or add an @Configuration annotation"</span>);</span><br><span class="line">    <span class="comment">// Ensure error pages are registered</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.registerErrorPageFilter) &#123;</span><br><span class="line">        application.addPrimarySources(Collections.singleton(ErrorPageFilterConfiguration.class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.启动SpringBootApplication</span></span><br><span class="line">    <span class="keyword">return</span> run(application);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7）、Spring的应用就启动了,并创建IOC容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">    listeners.starting();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">        configureIgnoreBeanInfo(environment);</span><br><span class="line">        Banner printedBanner = printBanner(environment);</span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">                                                         <span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">        prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">        refreshContext(context);</span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        listeners.started(context);</span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        listeners.running(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10、日期处理-后台数据返回前台（-）"><a href="#10、日期处理-后台数据返回前台（-）" class="headerlink" title="10、日期处理+后台数据返回前台（*）"></a>10、日期处理+后台数据返回前台（*）</h2><h3 id="1）、多写一个get方法"><a href="#1）、多写一个get方法" class="headerlink" title="1）、多写一个get方法"></a>1）、多写一个get方法</h3><p>person.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    Integer id;</span><br><span class="line">    String name;</span><br><span class="line">    Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", birth="</span> + birth +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer id, String name, Date birth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirth_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBirth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="keyword">this</span>.birth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirth</span><span class="params">(Timestamp birth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PersonController.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    PersonServiceImpl personService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getAllPersons"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getAllPersons</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> personService.getAllPersons();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回给浏览器的数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"name"</span>:<span class="string">"zs"</span>,<span class="attr">"birth"</span>:<span class="string">"2020-08-11 00:00:00"</span>,<span class="attr">"birth_test"</span>:<span class="number">1597075200000</span>&#125;,&#123;<span class="attr">"id"</span>:<span class="number">2</span>,<span class="attr">"name"</span>:<span class="string">"ls"</span>,<span class="attr">"birth"</span>:<span class="string">"2020-08-20 00:00:00"</span>,<span class="attr">"birth_test"</span>:<span class="number">1597852800000</span>&#125;,&#123;<span class="attr">"id"</span>:<span class="number">3</span>,<span class="attr">"name"</span>:<span class="string">"ww"</span>,<span class="attr">"birth"</span>:<span class="string">"2020-08-28 00:00:00"</span>,<span class="attr">"birth_test"</span>:<span class="number">1598544000000</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>可以发现，返回的数据名和pojo中的get方法有关,有几个get方法就有几个返回的属性</p>
<p>例：getBirth_test返回birth_test</p>
<h3 id="2）、现在可以直接在属性名上加上"><a href="#2）、现在可以直接在属性名上加上" class="headerlink" title="2）、现在可以直接在属性名上加上"></a>2）、现在可以直接在属性名上加上</h3><p>上面是以前的处理方法</p>
<p>现在的Person.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    Integer id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonFormat</span>(timezone = <span class="string">"GMT+8"</span>, pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">    Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", birth="</span> + birth +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer id, String name, Date birth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public String getBirth() &#123;</span></span><br><span class="line"><span class="comment">//        return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(this.birth);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirth</span><span class="params">(Timestamp birth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonFormat</span>(timezone = <span class="string">"GMT+8"</span>, pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br></pre></td></tr></table></figure>
<p>或者在配置文件中配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.jackson.date-format</span>=<span class="string">yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="meta">spring.jackson.time-zone</span>=<span class="string">GMT+8</span></span><br></pre></td></tr></table></figure>
<h3 id="3）、sql语句转换"><a href="#3）、sql语句转换" class="headerlink" title="3）、sql语句转换"></a>3）、sql语句转换</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>( b.book_start_time,<span class="string">'%Y-%m-%d %H:%i:%s'</span>) book_start_time</span><br></pre></td></tr></table></figure>
<h3 id="4）、前台转换"><a href="#4）、前台转换" class="headerlink" title="4）、前台转换"></a>4）、前台转换</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">templet: <span class="string">'&lt;div&gt;&#123;&#123; layui.laytpl.toDateString(d.createTime) &#125;&#125;&lt;/div&gt;'</span></span><br></pre></td></tr></table></figure>
<h3 id="5）、常用日期时间类"><a href="#5）、常用日期时间类" class="headerlink" title="5）、常用日期时间类"></a>5）、常用日期时间类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.sql.Date date1 = <span class="keyword">new</span> java.sql.Date(<span class="keyword">new</span> java.util.Date().getTime());</span><br><span class="line">LocalDate localDate = date1.toLocalDate();</span><br><span class="line">System.out.println(localDate);<span class="comment">//2020-08-12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Calendar日期类</span></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String format = dateFormat.format(calendar.getTimeInMillis());</span><br><span class="line">Timestamp timestamp = Timestamp.valueOf(format);</span><br><span class="line">System.out.println(timestamp);<span class="comment">//2020-08-12 13:35:57.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最新的日期类LocalDateTime、LocalDate、LocalTime</span></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">System.out.println(localDateTime);<span class="comment">//2020-08-12T13:35:57.127</span></span><br><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String format1 = dateTimeFormatter.format(localDateTime);</span><br><span class="line">System.out.println(format1);<span class="comment">//2020-08-12 13:35:57</span></span><br><span class="line">Timestamp timestamp1 = Timestamp.valueOf(format1);</span><br><span class="line">Timestamp timestamp2 = Timestamp.valueOf(localDateTime);</span><br><span class="line"></span><br><span class="line">System.out.println(timestamp1);<span class="comment">//2020-08-12 13:35:57.0</span></span><br><span class="line">System.out.println(timestamp2);<span class="comment">//2020-08-12 13:35:57.127</span></span><br></pre></td></tr></table></figure>
<h2 id="11、日期处理-前台的数据传给后台（-）"><a href="#11、日期处理-前台的数据传给后台（-）" class="headerlink" title="11、日期处理+前台的数据传给后台（*）"></a>11、日期处理+前台的数据传给后台（*）</h2><p><strong>前台传给后台日期的字符串，后台是无法用Date来映射的，要自己编写一个类型转换器，放入容器中</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.custhitachi.managerment.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.convert.converter.Converter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (source.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">			System.out.println(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">			Date date = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				date = simpleDateFormat.parse(source);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> date;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>或者入参的时候加上<code>@DateTimeFormat</code></strong></p>
<p>也可以直接加在属性上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DateTimeFormat</span>(pattern = <span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line"><span class="meta">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>,timezone=<span class="string">"GMT+8"</span>)</span><br><span class="line"><span class="keyword">private</span> Date symstarttime;</span><br></pre></td></tr></table></figure>
<h2 id="12、在tomcat运行war"><a href="#12、在tomcat运行war" class="headerlink" title="12、在tomcat运行war"></a>12、在tomcat运行war</h2><h3 id="1、带项目名（静态文件可能会不好使）"><a href="#1、带项目名（静态文件可能会不好使）" class="headerlink" title="1、带项目名（静态文件可能会不好使）"></a>1、带项目名（静态文件可能会不好使）</h3><p><img alt data-src="https://gitee.com/alexander1/pic/raw/master/springboot笔记/20210318150002.png"></p>
<p><img alt data-src="https://gitee.com/alexander1/pic/raw/master/springboot笔记/20210318150010.png"></p>
<h3 id="2、不带项目名"><a href="#2、不带项目名" class="headerlink" title="2、不带项目名"></a>2、不带项目名</h3><p><img alt data-src="https://gitee.com/alexander1/pic/raw/master/springboot笔记/20210318150014.png"></p>
<p><img alt data-src="https://gitee.com/alexander1/pic/raw/master/springboot笔记/20210318150017.png"></p>
<h1 id="五、Docker"><a href="#五、Docker" class="headerlink" title="五、Docker"></a>五、Docker</h1><p>见 <a href="https://alexander-wd.github.io/alex-next/2021/08/29/java%E5%90%8E%E7%AB%AF/Docker%E5%9F%BA%E7%A1%80%E7%AF%87/">docker基础篇</a></p>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
</search>
