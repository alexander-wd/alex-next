<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/alex-next/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/alex-next/images/favicon.ico?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/alex-next/images/favicon.ico?v=7.4.0">
  <link rel="mask-icon" href="/alex-next/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/alex-next/atom.xml" title="alex的博客 - github.com" type="application/atom+xml">

<link rel="stylesheet" href="/alex-next/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/alex-next/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/alex-next/',
    scheme: 'Pisces',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: true,
    pangu: true,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="python语法1.class12345678class Node:    def __init__(self,x=0,y=0):        self.x = x        self.y = y    # 相当于java的tostring    def __repr__(self):        return str(self.x)+&quot; &quot;+str(self.y) 2.排序 lambda">
<meta name="keywords" content="算法面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="算法面试题合集">
<meta property="og:url" content="https://alexander-wd.github.io/2023/01/31/面试题/算法面试题合集/index.html">
<meta property="og:site_name" content="alex的博客 - github.com">
<meta property="og:description" content="python语法1.class12345678class Node:    def __init__(self,x=0,y=0):        self.x = x        self.y = y    # 相当于java的tostring    def __repr__(self):        return str(self.x)+&quot; &quot;+str(self.y) 2.排序 lambda">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2023-02-13T10:48:08.256Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="算法面试题合集">
<meta name="twitter:description" content="python语法1.class12345678class Node:    def __init__(self,x=0,y=0):        self.x = x        self.y = y    # 相当于java的tostring    def __repr__(self):        return str(self.x)+&quot; &quot;+str(self.y) 2.排序 lambda">
  <link rel="canonical" href="https://alexander-wd.github.io/2023/01/31/面试题/算法面试题合集/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>算法面试题合集 | alex的博客 - github.com</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/alex-next/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">alex的博客 - github.com</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/alex-next/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/alex-next/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/alex-next/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/alex-next/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/alexander-wd" class="github-corner" title="alex GitHub" aria-label="alex GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://alexander-wd.github.io/alex-next/2023/01/31/面试题/算法面试题合集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="alex">
      <meta itemprop="description" content="时光静好,与君语;细水流年,与君同;繁华落尽,与君老.">
      <meta itemprop="image" content="/alex-next/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="alex的博客 - github.com">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">算法面试题合集

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2023-01-31 16:10:20" itemprop="dateCreated datePublished" datetime="2023-01-31T16:10:20+08:00">2023-01-31</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-31 16:10:20" itemprop="dateModified" datetime="2023-02-13T18:48:08+08:00">2023-01-31</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/alex-next/categories/面试题/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="python语法"><a href="#python语法" class="headerlink" title="python语法"></a>python语法</h2><h3 id="1-class"><a href="#1-class" class="headerlink" title="1.class"></a>1.class</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x=<span class="number">0</span>,y=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 相当于java的tostring</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.x)+<span class="string">" "</span>+str(self.y)</span><br></pre></td></tr></table></figure>
<h3 id="2-排序"><a href="#2-排序" class="headerlink" title="2.排序"></a>2.排序</h3><blockquote>
<p>lambda</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x=<span class="number">0</span>,y=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">x = [Node(<span class="number">1</span>,<span class="number">3</span>),Node(<span class="number">1</span>,<span class="number">2</span>),Node(<span class="number">2</span>,<span class="number">3</span>),Node(<span class="number">2</span>,<span class="number">1</span>)]</span><br><span class="line">x.sort(key=<span class="keyword">lambda</span> n:(n.x,n.y))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>attrgetter</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> attrgetter</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x=<span class="number">0</span>,y=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">x = [Node(<span class="number">1</span>,<span class="number">3</span>),Node(<span class="number">1</span>,<span class="number">2</span>),Node(<span class="number">2</span>,<span class="number">3</span>),Node(<span class="number">2</span>,<span class="number">1</span>)]</span><br><span class="line">x = sorted(x,key=attrgetter(<span class="string">'x'</span>,<span class="string">'y'</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Node类中自定义</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x = <span class="number">0</span>,y = <span class="number">0</span>)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.x)+<span class="string">" "</span>+str(self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.x == other.x:</span><br><span class="line">            <span class="keyword">return</span> self.y &lt; other.y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> self.x &lt; other.x <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">x = [Node(<span class="number">1</span>,<span class="number">3</span>),Node(<span class="number">1</span>,<span class="number">2</span>),Node(<span class="number">2</span>,<span class="number">3</span>),Node(<span class="number">2</span>,<span class="number">1</span>)]</span><br><span class="line">x = sorted(x)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>cmp_to_key</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br><span class="line"><span class="comment"># 注意一定要用要用返回正负,不能返回True和False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmp</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> a.x == b.x:</span><br><span class="line">        <span class="keyword">return</span> a.y - b.y</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> a.x - b.x</span><br><span class="line">x = [Node(<span class="number">1</span>,<span class="number">3</span>),Node(<span class="number">1</span>,<span class="number">2</span>),Node(<span class="number">2</span>,<span class="number">3</span>),Node(<span class="number">2</span>,<span class="number">1</span>)]</span><br><span class="line">x = sorted(x,key=cmp_to_key(cmp))</span><br><span class="line"><span class="comment"># x = sorted(x,key=cmp_to_key(lambda a,b:point[a].y-point[b].y))</span></span><br></pre></td></tr></table></figure>
<h3 id="3-优先队列-堆"><a href="#3-优先队列-堆" class="headerlink" title="3.优先队列(堆)"></a>3.优先队列(堆)</h3><blockquote>
<p>PriorityQueue简单用法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line">q = PriorityQueue()</span><br><span class="line">q.put((<span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line">q.put((<span class="number">-12</span>, <span class="number">-7</span>))</span><br><span class="line">q.put((<span class="number">7</span>, <span class="number">8</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">    print(q.get())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PriorityQueue与类的__lt__结合使用</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x = <span class="number">0</span>,y = <span class="number">0</span>)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.x)+<span class="string">" "</span>+str(self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.x == other.x:</span><br><span class="line">            <span class="keyword">return</span> self.y &lt; other.y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> self.x &lt; other.x <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">q1 = PriorityQueue()</span><br><span class="line">q1.put(Node(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">q1.put(Node(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">q1.put(Node(<span class="number">-1</span>,<span class="number">1</span>))</span><br><span class="line">q1.put(Node(<span class="number">4</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">print(q1.queue) <span class="comment"># 打印所有元素</span></span><br><span class="line">print(q1.queue[<span class="number">0</span>]) <span class="comment"># 打印第一个元素</span></span><br><span class="line">print(q1.queue[<span class="number">1</span>]) <span class="comment"># 打印第二个元素</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> q1.empty():</span><br><span class="line">    print(q1.get())</span><br></pre></td></tr></table></figure>
<h3 id="4-浅拷贝深拷贝"><a href="#4-浅拷贝深拷贝" class="headerlink" title="4.浅拷贝深拷贝"></a>4.浅拷贝深拷贝</h3><p>一维数组用浅拷贝即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph = [<span class="string">'.'</span>]*n</span><br><span class="line">graph.copy()</span><br></pre></td></tr></table></figure>
<p>二维数组得用深拷贝，否则只拷贝一层，即只拷贝了引用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">graph = [[<span class="string">'.'</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">copy.deepcopy(graph)</span><br></pre></td></tr></table></figure>
<h3 id="5-替换子字符串"><a href="#5-替换子字符串" class="headerlink" title="5.替换子字符串"></a>5.替换子字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'applepenapple'</span></span><br><span class="line">c = <span class="string">'apple'</span></span><br><span class="line">s = s.replace(c,<span class="string">""</span>)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<h3 id="6-初始化默认元素为list的map"><a href="#6-初始化默认元素为list的map" class="headerlink" title="6.初始化默认元素为list的map"></a>6.初始化默认元素为list的map</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">map = collections.defaultdict(list)</span><br><span class="line">map[<span class="number">1</span>].append(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="7-字符串"><a href="#7-字符串" class="headerlink" title="7.字符串"></a>7.字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 97 b</span></span><br><span class="line">print(ord(<span class="string">'a'</span>),chr(<span class="number">98</span>))</span><br></pre></td></tr></table></figure>
<h3 id="8-向上取整公式"><a href="#8-向上取整公式" class="headerlink" title="8.向上取整公式"></a>8.向上取整公式</h3><blockquote>
<p>UP(A/B)=(A+B-1)//B</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print((<span class="number">2</span>+<span class="number">3</span><span class="number">-1</span>)//<span class="number">3</span>)</span><br><span class="line">print(math.ceil(<span class="number">2</span>/<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="递归式的三种写法"><a href="#递归式的三种写法" class="headerlink" title="递归式的三种写法"></a>递归式的三种写法</h3><blockquote>
<p><a href="https://blog.csdn.net/sd4567855/article/details/98742129?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-98742129-blog-80921480.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3" target="_blank" rel="noopener">https://blog.csdn.net/sd4567855/article/details/98742129?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-98742129-blog-80921480.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p>
</blockquote>
<h3 id="NP完全理论"><a href="#NP完全理论" class="headerlink" title="NP完全理论"></a>NP完全理论</h3><p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/算法/20221005214438.png"></p>
<h2 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/80629756" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/80629756</a></p>
<p><a href="https://blog.csdn.net/m0_52935007/article/details/121637108" target="_blank" rel="noopener">https://blog.csdn.net/m0_52935007/article/details/121637108</a></p>
<h3 id="蒙特卡洛算法"><a href="#蒙特卡洛算法" class="headerlink" title="蒙特卡洛算法"></a>蒙特卡洛算法</h3><blockquote>
<p><strong>总是给出一个答案，但有时可能会产生一个不正确的答案</strong>。然而，<strong>通过在每次运行中使用独立的随机选择重复运行该算法，产生错误答案的概率可以变得任意小</strong>。</p>
<p>模式匹配、Testing String Equality、主元素问题</p>
</blockquote>
<h4 id="1-在长度-2N-的数组中找出重复-N-次的元素"><a href="#1-在长度-2N-的数组中找出重复-N-次的元素" class="headerlink" title="1.在长度 2N 的数组中找出重复 N 次的元素"></a>1.<a href="https://leetcode.cn/problems/n-repeated-element-in-size-2n-array/" target="_blank" rel="noopener">在长度 2N 的数组中找出重复 N 次的元素</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeatedNTimes</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x, y = random.randrange(n), random.randrange(n)</span><br><span class="line">        <span class="keyword">if</span> x != y <span class="keyword">and</span> nums[x] == nums[y]:</span><br><span class="line">            <span class="keyword">return</span> nums[x]</span><br></pre></td></tr></table></figure>
<h3 id="拉斯维加斯算法"><a href="#拉斯维加斯算法" class="headerlink" title="拉斯维加斯算法"></a>拉斯维加斯算法</h3><blockquote>
<p>它由那些总是<strong>给出正确答案或根本不给出答案</strong>的随机算法组成。</p>
<p>找第k小元素、Random Sampling问题、n皇后</p>
</blockquote>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h3><p><a href="https://leetcode.cn/problems/binary-search/" target="_blank" rel="noopener">题目链接</a></p>
<blockquote>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
</blockquote>
<h4 id="左闭右闭"><a href="#左闭右闭" class="headerlink" title="左闭右闭"></a>左闭右闭</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        i,j = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j: <span class="comment"># [i,j] i==j 在这个区间范围内</span></span><br><span class="line">            m = i+ ((j-i) &gt;&gt; <span class="number">1</span>) <span class="comment"># 等同于(i+j)&gt;&gt;1 防止 i+j溢出</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &gt; target:</span><br><span class="line">                j = m<span class="number">-1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[m] &lt; target:</span><br><span class="line">                i = m+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>一定要遵循<strong>循环不变量</strong>规则(坚持根据区间的定义来操作)</p>
</blockquote>
<h4 id="左闭右开"><a href="#左闭右开" class="headerlink" title="左闭右开"></a>左闭右开</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># [i,j)  j不能为len(nums)-1</span></span><br><span class="line">        i,j = <span class="number">0</span>,len(nums)</span><br><span class="line">        <span class="keyword">while</span> i &lt; j: <span class="comment"># [i,j)</span></span><br><span class="line">            m = i + ((j - i) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[m] &gt; target:</span><br><span class="line">                j = m</span><br><span class="line">            <span class="keyword">elif</span> nums[m] &lt; target:</span><br><span class="line">                i = m+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="2-移除元素"><a href="#2-移除元素" class="headerlink" title="2.移除元素"></a>2.移除元素</h3><p><a href="https://leetcode.cn/problems/remove-element/" target="_blank" rel="noopener">题目链接</a></p>
<blockquote>
<p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p>
</blockquote>
<h4 id="自己的思路实现"><a href="#自己的思路实现" class="headerlink" title="自己的思路实现"></a>自己的思路实现</h4><p>来两个指针i，j   i指向数组头部，j指向数组尾部；先遍历头部，遇到val，就遍历尾部，不是val，置换到i的位置，继续遍历i。直到i &gt; j。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span></span><br><span class="line">    i,j,cur = <span class="number">0</span>,len(nums) - <span class="number">1</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">        <span class="keyword">if</span> cur == i <span class="keyword">and</span> cur!=j:</span><br><span class="line">            <span class="keyword">if</span> nums[cur] != val:</span><br><span class="line">                i = i+<span class="number">1</span></span><br><span class="line">                cur = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = j</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[cur] != val:</span><br><span class="line">                nums[i] = nums[cur]</span><br><span class="line">                j = j<span class="number">-1</span></span><br><span class="line">                cur = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = j<span class="number">-1</span></span><br><span class="line">                cur = j</span><br><span class="line">    <span class="keyword">return</span> cur+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span></span><br><span class="line">    i,j = <span class="number">0</span>,len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">        <span class="keyword">while</span> i &lt;= j <span class="keyword">and</span> nums[i] != val:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j <span class="keyword">and</span> nums[j] == val:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; j:</span><br><span class="line">            nums[i] = nums[j]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="==快慢指针=="></a><strong>==快慢指针==</strong></h4><p>思路很简单，就是没想到</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新 新数组下标的位置</li>
</ul>
<p><img alt="27.移除元素-双指针法" data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntrds6r59g30du09mnpd.gif"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span></span><br><span class="line">    slow,fast = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> fast <span class="keyword">in</span> range(<span class="number">0</span>,len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[fast] != val:</span><br><span class="line">            nums[slow] = nums[fast]</span><br><span class="line">            slow = slow + <span class="number">1</span></span><br><span class="line">        fast = fast + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>
<h3 id="3-有序数组的平方"><a href="#3-有序数组的平方" class="headerlink" title="3.有序数组的平方"></a>3.有序数组的平方</h3><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">题目链接</a></p>
<blockquote>
<p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
<p>核心思想：两侧的绝对值大，一定在后面</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> nums <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    i,j,k = <span class="number">0</span>,n - <span class="number">1</span>,n - <span class="number">1</span></span><br><span class="line">    result = [<span class="number">-1</span>]*n</span><br><span class="line">    <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">        <span class="keyword">if</span> abs(nums[i]) &gt; abs(nums[j]):</span><br><span class="line">            result[k] = abs(nums[i]) ** <span class="number">2</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result[k] = abs(nums[j]) ** <span class="number">2</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="4-长度最小的子数组-2"><a href="#4-长度最小的子数组-2" class="headerlink" title="4.==长度最小的子数组(2)=="></a>4.==长度最小的子数组(2)==</h3><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">题目链接</a></p>
<blockquote>
<p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<p>滑动窗口 前缀和 双指针</p>
</blockquote>
<p><img alt="209.长度最小的子数组" data-src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, target: int, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    i,j,sum,result = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">100001</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> j &lt; n:</span><br><span class="line">        sum += nums[j]</span><br><span class="line">        <span class="keyword">while</span> sum &gt;= target:</span><br><span class="line">            result = min(result, j - i + <span class="number">1</span>)</span><br><span class="line">            sum -= nums[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> result == <span class="number">100001</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="5-螺旋矩阵II"><a href="#5-螺旋矩阵II" class="headerlink" title="5.螺旋矩阵II"></a>5.螺旋矩阵II</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/" target="_blank" rel="noopener">题目链接</a></p>
<blockquote>
<p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
<p>自己Kill的，nice!! </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span><span class="params">(self, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    array = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> j <span class="keyword">in</span> range(n)]</span><br><span class="line">    d = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">-1</span>],[<span class="number">-1</span>,<span class="number">0</span>]]</span><br><span class="line">    mod = <span class="number">0</span></span><br><span class="line">    i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    array[i][j] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,n ** <span class="number">2</span>):</span><br><span class="line">        ii = i + d[mod][<span class="number">0</span>]</span><br><span class="line">        jj = j + d[mod][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= ii &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= jj &lt; n <span class="keyword">and</span> array[ii][jj] == <span class="number">0</span>:</span><br><span class="line">            array[ii][jj] = k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mod = (mod + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">            ii = i + d[mod][<span class="number">0</span>]</span><br><span class="line">            jj = j + d[mod][<span class="number">1</span>]</span><br><span class="line">            array[ii][jj] = k + <span class="number">1</span></span><br><span class="line">        i = ii</span><br><span class="line">        j = jj</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>
<h3 id="6-在排序数组中查找元素的第一个和最后一个位置"><a href="#6-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="6.在排序数组中查找元素的第一个和最后一个位置"></a>6.<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">在排序数组中查找元素的第一个和最后一个位置</a></h3><blockquote>
<p><a href="https://blog.csdn.net/m0_48941999/article/details/123581107" target="_blank" rel="noopener">https://blog.csdn.net/m0_48941999/article/details/123581107</a></p>
<p>这个参考答案比leetcode要清晰</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getStart</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> n</span><br><span class="line">        i,j = <span class="number">0</span>,n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            m = i + ((j - i) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[m] &lt; target:</span><br><span class="line">                i = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[m] &gt; target:</span><br><span class="line">                j = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> m == <span class="number">0</span> <span class="keyword">or</span> nums[m - <span class="number">1</span>] != target:</span><br><span class="line">                    <span class="keyword">return</span> m</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j = m - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getEnd</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> n</span><br><span class="line">        i,j = <span class="number">0</span>,n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            m = i + ((j - i) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[m] &lt; target:</span><br><span class="line">                i = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[m] &gt; target:</span><br><span class="line">                j = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> m == n - <span class="number">1</span> <span class="keyword">or</span> nums[m + <span class="number">1</span>] != target:</span><br><span class="line">                    <span class="keyword">return</span> m</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i = m + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> [getStart(),getEnd()]</span><br></pre></td></tr></table></figure>
<h3 id="7-数的范围"><a href="#7-数的范围" class="headerlink" title="7.数的范围"></a>7.数的范围</h3><blockquote>
<p>参考题目 <a href="https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMax</span><span class="params">(x,nums)</span>:</span> <span class="comment"># 小于等于x最大值</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; nums[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    i,j = <span class="number">0</span>,len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        m = (i + j + <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[m] &lt;= x:</span><br><span class="line">            i = m</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = m - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums[i]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(x,nums)</span>:</span> <span class="comment"># 大于等于x最小值</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; nums[<span class="number">-1</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    i,j = <span class="number">0</span>,len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        m = (i + j) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[m] &gt;= x:</span><br><span class="line">            j = m</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i = m + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums[i]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMax</span><span class="params">(x,nums)</span>:</span> <span class="comment"># 小于x最大值</span></span><br><span class="line">    <span class="keyword">if</span> x &lt;= nums[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    i,j = <span class="number">0</span>,len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        m = (i + j + <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[m] &lt; x:  <span class="comment"># 小于x最大值</span></span><br><span class="line">            i = m</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = m - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums[i]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(x,nums)</span>:</span> <span class="comment"># 大于x最小值</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= nums[<span class="number">-1</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    i,j = <span class="number">0</span>,len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        m = (i + j) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[m] &gt; x: <span class="comment"># 大于x最小值</span></span><br><span class="line">            j = m</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i = m + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums[i]</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>快慢指针</p>
</blockquote>
<p><img alt="img" data-src="https://images.zsxq.com/FjOivUVvVuThME3dyxpVQu5Q2f8k?imageMogr2/auto-orient/quality/100!/ignore-error/1&amp;e=1667231999&amp;token=kIxbL07-8jAj8w1n4s9zv64FuZZNEATmlU_Vm6zD:eXUO1Ax6zJ1YHvHwweZhfWFQpbI="></p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="1-移除链表元素"><a href="#1-移除链表元素" class="headerlink" title="1.移除链表元素"></a>1.移除链表元素</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/" target="_blank" rel="noopener">题目链接</a></p>
<blockquote>
<p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<p>虚拟头结点很重要</p>
</blockquote>
<h4 id="直接使用原来的链表来进行删除操作"><a href="#直接使用原来的链表来进行删除操作" class="headerlink" title="直接使用原来的链表来进行删除操作"></a><strong>直接使用原来的链表来进行删除操作</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeElements</span><span class="params">(self, head: Optional[ListNode], val: int)</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> head.val == val:</span><br><span class="line">        head = head.next</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    cur = head</span><br><span class="line">    nxt = head.next</span><br><span class="line">    <span class="keyword">while</span> nxt <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> nxt.val == val:</span><br><span class="line">            cur.next = nxt.next</span><br><span class="line">            nxt = cur.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = nxt</span><br><span class="line">            nxt = nxt.next</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<h4 id="设置一个虚拟头结点在进行删除操作"><a href="#设置一个虚拟头结点在进行删除操作" class="headerlink" title="==设置一个虚拟头结点在进行删除操作=="></a>==<strong>设置一个虚拟头结点在进行删除操作</strong>==</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeElements</span><span class="params">(self, head: Optional[ListNode], val: int)</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">    hv = ListNode(next=head)</span><br><span class="line">    cur = hv</span><br><span class="line">    <span class="keyword">while</span> cur.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> cur.next.val == val:</span><br><span class="line">            cur.next = cur.next.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = cur.next</span><br><span class="line">    <span class="keyword">return</span> hv.next</span><br></pre></td></tr></table></figure>
<h3 id="2-设计链表"><a href="#2-设计链表" class="headerlink" title="2.设计链表"></a>2.设计链表</h3><p><a href="https://leetcode.cn/problems/design-linked-list/" target="_blank" rel="noopener">题目链接</a></p>
<blockquote>
<p>虚拟头结点很重要</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,val)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = Node(<span class="number">0</span>)</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, index: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> index &gt;= self.count <span class="keyword">or</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cnt &lt;= index:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cur.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNode</span><span class="params">(self, index: int)</span> -&gt; Node:</span></span><br><span class="line">        <span class="keyword">if</span> index &gt;= self.count:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cnt &lt;= index:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtHead</span><span class="params">(self, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        node = self.head.next</span><br><span class="line">        newNode = Node(val)</span><br><span class="line">        self.head.next = newNode</span><br><span class="line">        newNode.next = node</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtTail</span><span class="params">(self, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        tail = self.getNode(self.count - <span class="number">1</span>)</span><br><span class="line">        newNode = Node(val)</span><br><span class="line">        tail.next = newNode</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtIndex</span><span class="params">(self, index: int, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index == self.count:</span><br><span class="line">            self.addAtTail(val)</span><br><span class="line">        <span class="keyword">elif</span> index &gt; self.count:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            self.addAtHead(val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = self.getNode(index - <span class="number">1</span>)</span><br><span class="line">            newNode = Node(val)</span><br><span class="line">            nxt = node.next</span><br><span class="line">            node.next = newNode</span><br><span class="line">            newNode.next = nxt</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAtIndex</span><span class="params">(self, index: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index &gt;= self.count <span class="keyword">or</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">            pre = self.head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = self.getNode(index<span class="number">-1</span>)</span><br><span class="line">        pre.next = pre.next.next</span><br><span class="line">        self.count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cnt &lt;= self.count<span class="number">-1</span>:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            print(str(cur.val) + <span class="string">" "</span>)</span><br><span class="line">            cnt += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="3-反转链表"><a href="#3-反转链表" class="headerlink" title="3.反转链表"></a>3.反转链表</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/" target="_blank" rel="noopener">题目链接</a></p>
<blockquote>
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
</blockquote>
<h4 id="使用头插法"><a href="#使用头插法" class="headerlink" title="使用头插法"></a>使用头插法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: Optional[ListNode])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    hv = ListNode(next=head)</span><br><span class="line">    cur = hv.next.next</span><br><span class="line">    head.next = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        next = cur.next</span><br><span class="line"></span><br><span class="line">        hv.next = cur</span><br><span class="line">        cur.next = head</span><br><span class="line">        head = cur</span><br><span class="line">        cur = next</span><br><span class="line">    <span class="keyword">return</span> hv.next</span><br></pre></td></tr></table></figure>
<h4 id="逐个改变next"><a href="#逐个改变next" class="headerlink" title="逐个改变next"></a>逐个改变next</h4><p><img alt="img" data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnrf1oboupg30gy0c44qp.gif"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: Optional[ListNode])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">    pre = <span class="literal">None</span> <span class="comment"># pre = head ×</span></span><br><span class="line">    cur = head <span class="comment"># cur = head.next ×</span></span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        temp = cur.next  <span class="comment"># 暂存cur的下一个节点</span></span><br><span class="line">        cur.next = pre <span class="comment"># cur的next指向前一个结点</span></span><br><span class="line">        pre = cur <span class="comment"># 将下一轮的pre变为cur</span></span><br><span class="line">        cur = temp <span class="comment"># 将下一轮的cur变为cur.next</span></span><br><span class="line">    <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>
<h3 id="4-两两交换链表中的节点-2"><a href="#4-两两交换链表中的节点-2" class="headerlink" title="4.两两交换链表中的节点(2)"></a>4.<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">两两交换链表中的节点</a>(2)</h3><blockquote>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p>自己AK的</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: Optional[ListNode])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    pre = head</span><br><span class="line">    cur = head.next</span><br><span class="line"></span><br><span class="line">    temp = cur.next</span><br><span class="line">    cur.next = pre</span><br><span class="line"></span><br><span class="line">    pre.next = self.swapPairs(temp)</span><br><span class="line">    <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>
<blockquote>
<p>非递归版本</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: Optional[ListNode])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">    hv = ListNode(next=head)</span><br><span class="line">    temp = hv</span><br><span class="line">    <span class="keyword">while</span> temp.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> temp.next.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        pre = temp.next</span><br><span class="line">        cur = temp.next.next</span><br><span class="line"></span><br><span class="line">        temp.next = cur</span><br><span class="line">        pre.next = cur.next</span><br><span class="line">        cur.next = pre</span><br><span class="line">        temp = pre</span><br><span class="line">    <span class="keyword">return</span> hv.next</span><br></pre></td></tr></table></figure>
<h3 id="5-删除链表的倒数第-N-个结点"><a href="#5-删除链表的倒数第-N-个结点" class="headerlink" title="5.删除链表的倒数第 N 个结点"></a>5.<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">删除链表的倒数第 N 个结点</a></h3><h4 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h4><blockquote>
<p>应该没问题的吧   自测过</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head: Optional[ListNode], n: int)</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">    hv = ListNode(next=head)</span><br><span class="line">    cur = hv</span><br><span class="line">    self.remove(cur,cur.next,n)</span><br><span class="line">    <span class="keyword">return</span> hv.next</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self,pre: Optional[ListNode], cur: Optional[ListNode],n: int)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self.remove(cur,cur.next,n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> Solution.count == n:</span><br><span class="line">        pre.next = cur.next</span><br><span class="line">        Solution.count += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="快慢指针-1"><a href="#快慢指针-1" class="headerlink" title="快慢指针"></a>快慢指针</h4><blockquote>
<p>参考答案：快指针比慢指针先走n步</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head: Optional[ListNode], n: int)</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    hv = ListNode(next=head)</span><br><span class="line">    slow,fast = hv,hv</span><br><span class="line">    <span class="keyword">while</span> n != <span class="number">0</span>:</span><br><span class="line">        fast = fast.next</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> fast.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next</span><br><span class="line">    slow.next = slow.next.next</span><br><span class="line">    <span class="keyword">return</span> hv.next</span><br></pre></td></tr></table></figure>
<h3 id="6-链表相交"><a href="#6-链表相交" class="headerlink" title="6.链表相交"></a>6.<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/" target="_blank" rel="noopener">链表相交</a></h3><blockquote>
<p>自己答案：链表A和B的长度分别为lenA和lenB，假设 lenA &gt; lenB，先遍历A比B长的部分，即lenA-lenB的长度，之后遍历A和B依次比较结点是否相等(相交必有节点相等)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA: ListNode, headB: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">    lenA,lenB = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    curA,curB = headA,headB</span><br><span class="line">    <span class="keyword">while</span> curA <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        lenA += <span class="number">1</span></span><br><span class="line">        curA = curA.next</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> curB <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        lenB += <span class="number">1</span></span><br><span class="line">        curB = curB.next</span><br><span class="line"></span><br><span class="line">    curA, curB = headA, headB</span><br><span class="line">    <span class="keyword">if</span> lenA &gt; lenB:</span><br><span class="line">        cnt = lenA - lenB</span><br><span class="line">        <span class="keyword">while</span> cnt &gt; <span class="number">0</span>:</span><br><span class="line">            curA = curA.next</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cnt = lenB - lenA</span><br><span class="line">        <span class="keyword">while</span> cnt &gt; <span class="number">0</span>:</span><br><span class="line">            curB = curB.next</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> curA <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> curA == curB:</span><br><span class="line">            <span class="keyword">return</span> curA</span><br><span class="line">        curA = curA.next</span><br><span class="line">        curB = curB.next</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="7-环形链表-II-2"><a href="#7-环形链表-II-2" class="headerlink" title="7.环形链表 II(2)"></a>7.<a href="https://leetcode.cn/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">环形链表 II</a>(2)</h3><h4 id="使用set缓存"><a href="#使用set缓存" class="headerlink" title="使用set缓存"></a>使用set缓存</h4><blockquote>
<p>每次遍历把节点放入，如果发现此节点在set中存在的，说明是环形链表</p>
<p>空间复杂度o(n)，时间复杂度o(n)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    Set&lt;ListNode&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.contains(cur))&#123;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            visited.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用O-1-的空间"><a href="#使用O-1-的空间" class="headerlink" title="使用O(1)的空间"></a>使用O(1)的空间</h4><blockquote>
<p><strong>快慢指针</strong></p>
<p>几个问题：</p>
<p>1.如果存在环形链表快指针一定会追上慢指针  √   <strong>判断链表是否有环</strong></p>
<p>​    快指针每次都以一个节点的速度靠近慢指针</p>
<p>2.为什么遍历cur和slow，cur和slow会有相等的时候，明明步数都是1：</p>
<p>​    如果x &gt; z，用cur表示走x，用slow表示走z，那么slow可以多走几圈，最终cur与slow一定会相遇</p>
<p><img alt data-src="https://blog-wd.oss-cn-shanghai.aliyuncs.com/算法/20220905105844.png"></p>
<p>2.1 快指针追上慢指针的时候    慢指针一定没有走完一圈</p>
<p>​            假设环长度为n，若快指针在0.1n的位置，慢指针走一圈环(1步)，快指针(2步)一定已经绕一圈且追上了慢指针</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">    slow,fast = head,head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> fast.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        slow = slow.next</span><br><span class="line">        <span class="keyword">if</span> fast == slow:</span><br><span class="line">            cur = head</span><br><span class="line">            <span class="keyword">while</span> cur != slow:</span><br><span class="line">                cur = cur.next</span><br><span class="line">                slow = slow.next</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>虚拟头结点</p>
</blockquote>
<p><img alt="img" data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93.png"></p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="1-有效的字母异位词"><a href="#1-有效的字母异位词" class="headerlink" title="1.有效的字母异位词"></a>1.<a href="https://leetcode.cn/problems/valid-anagram/" target="_blank" rel="noopener">有效的字母异位词</a></h3><blockquote>
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>示例 1: 输入: s = “anagram”, t = “nagaram” 输出: true</p>
<p>示例 2: 输入: s = “rat”, t = “car” 输出: false</p>
<p><strong>说明:</strong> 你可以假设字符串只包含小写字母。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">    record = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        record[ord(s[i])-ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(t)):</span><br><span class="line">        record[ord(t[i])-ord(<span class="string">'a'</span>)] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">        <span class="keyword">if</span> record[i] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="2-两个数组的交集"><a href="#2-两个数组的交集" class="headerlink" title="2.两个数组的交集"></a>2.<a href="https://leetcode.cn/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">两个数组的交集</a></h3><blockquote>
<p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    t = [<span class="literal">False</span>]*<span class="number">1001</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">        t[i] = <span class="literal">True</span></span><br><span class="line">    r = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> set(nums2):</span><br><span class="line">        <span class="keyword">if</span> t[i] <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">            r.append(i)</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<h3 id="3-快乐数"><a href="#3-快乐数" class="headerlink" title="3.快乐数"></a>3.<a href="https://leetcode.cn/problems/happy-number/" target="_blank" rel="noopener">快乐数</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line">    s = set()</span><br><span class="line">    <span class="keyword">while</span> n != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        s.add(n)</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        t = n</span><br><span class="line">        <span class="keyword">while</span> t != <span class="number">0</span>:</span><br><span class="line">            add = t % <span class="number">10</span></span><br><span class="line">            sum += add ** <span class="number">2</span></span><br><span class="line">            t = t // <span class="number">10</span></span><br><span class="line">        n = sum</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="4-两数之和"><a href="#4-两数之和" class="headerlink" title="4.两数之和"></a>4.<a href="https://leetcode.cn/problems/two-sum/" target="_blank" rel="noopener">两数之和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">    dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> index,ele <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        <span class="keyword">if</span> target - ele <span class="keyword">in</span> dict:</span><br><span class="line">            <span class="keyword">return</span> [index,dict[target-ele]]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dict[ele] = index</span><br></pre></td></tr></table></figure>
<h3 id="5-四数相加-II-2"><a href="#5-四数相加-II-2" class="headerlink" title="5.四数相加 II(2)"></a>5.<a href="https://leetcode.cn/problems/4sum-ii/" target="_blank" rel="noopener">四数相加 II</a>(2)</h3><blockquote>
<p>map保存数组A和B的数之和的count</p>
<p>思想可以学学，有点组合的思想</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourSumCount</span><span class="params">(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int])</span> -&gt; int:</span></span><br><span class="line">    dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> i+j <span class="keyword">not</span> <span class="keyword">in</span> dict:</span><br><span class="line">                dict[i+j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dict[i+j] += <span class="number">1</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums3:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> nums4:</span><br><span class="line">            temp = <span class="number">0</span> - i - j</span><br><span class="line">            <span class="keyword">if</span> temp <span class="keyword">in</span> dict:</span><br><span class="line">                count += dict[temp]</span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h3 id="6-赎金信"><a href="#6-赎金信" class="headerlink" title="6.赎金信"></a>6.<a href="https://leetcode.cn/problems/ransom-note/" target="_blank" rel="noopener">赎金信</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canConstruct</span><span class="params">(self, ransomNote: str, magazine: str)</span> -&gt; bool:</span></span><br><span class="line">    dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> magazine:</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> dict:</span><br><span class="line">            dict[s] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dict[s] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> ransomNote:</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> dict <span class="keyword">or</span> dict[s] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dict[s] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="7-三数之和-2"><a href="#7-三数之和-2" class="headerlink" title="7.三数之和(2)"></a>7.<a href="https://leetcode.cn/problems/3sum/" target="_blank" rel="noopener">三数之和</a>(2)</h3><blockquote>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p><strong>注意：</strong> 答案中不可以包含重复的三元组。</p>
<p>for 循环遍历数组   用头尾双指针指向数组两个元素  </p>
<p>难点：注意i,left,right的去重</p>
<p>感觉更属于数组章节的算法：双指针</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    r = []</span><br><span class="line">    nums.sort()</span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">1</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        left = i + <span class="number">1</span></span><br><span class="line">        right = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            temp = nums[i] + nums[left] + nums[right]</span><br><span class="line">            <span class="keyword">if</span> temp &gt; <span class="number">0</span> :</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> temp &lt; <span class="number">0</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r.append([nums[i],nums[left],nums[right]])</span><br><span class="line">                <span class="comment"># 去重</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<h3 id="8-四数之和-2"><a href="#8-四数之和-2" class="headerlink" title="8.四数之和(2)"></a>8.<a href="https://leetcode.cn/problems/4sum/" target="_blank" rel="noopener">四数之和</a>(2)</h3><blockquote>
<p>题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p><strong>注意：</strong></p>
<p>答案中不可以包含重复的四元组。</p>
<p>示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</p>
<p>核心思想和三数之和差不多，只不过要两轮for循环遍历，然后再指定首尾双指针</p>
<p>要注意边界条件</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">if</span> nums <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> n &lt; <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    r = []</span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">1</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>,n - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = j + <span class="number">1</span></span><br><span class="line">            right = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                temp = nums[i] + nums[j] + nums[left] + nums[right]</span><br><span class="line">                <span class="keyword">if</span> temp &gt; target:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> temp &lt; target:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r.append([nums[i],nums[j],nums[left],nums[right]])</span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="1-反转字符串"><a href="#1-反转字符串" class="headerlink" title="1.反转字符串"></a>1.<a href="https://leetcode.cn/problems/reverse-string/" target="_blank" rel="noopener">反转字符串</a></h3><blockquote>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。<br>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>双指针   直接秒</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseString</span><span class="params">(self, s: List[str])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span> :</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    l,r = <span class="number">0</span>,n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        temp = s[l]</span><br><span class="line">        s[l] = s[r]</span><br><span class="line">        s[r] = temp</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line">        r -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="2-反转字符串-II"><a href="#2-反转字符串-II" class="headerlink" title="2.反转字符串 II"></a>2.<a href="https://leetcode.cn/problems/reverse-string-ii/" target="_blank" rel="noopener">反转字符串 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseStr</span><span class="params">(self, s: str, k: int)</span> -&gt; str:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    cnt = (n // (<span class="number">2</span> * k)) + <span class="number">1</span></span><br><span class="line">    re = list(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(cnt):</span><br><span class="line">        <span class="comment">#l,r = -1,-1</span></span><br><span class="line">        <span class="comment">#if i*2*k+k &lt;= n:</span></span><br><span class="line">        <span class="comment">#    l = i*2*k</span></span><br><span class="line">        <span class="comment">#    r = i*2*k+k-1</span></span><br><span class="line">        <span class="comment">#else:</span></span><br><span class="line">        <span class="comment">#    l = i * 2 * k</span></span><br><span class="line">        <span class="comment">#    r = n - 1</span></span><br><span class="line">        l, r = i * <span class="number">2</span> * k, min(i * <span class="number">2</span> * k + k - <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            re[l],re[r] = re[r],re[l]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(re)</span><br></pre></td></tr></table></figure>
<h3 id="3-替换空格"><a href="#3-替换空格" class="headerlink" title="3.替换空格"></a>3.<a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">替换空格</a></h3><blockquote>
<p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<p>不使用额外的辅助空间</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">    cnt = s.count(<span class="string">" "</span>)</span><br><span class="line">    res = list(s)</span><br><span class="line">    res.extend([<span class="string">' '</span>]*cnt*<span class="number">2</span>)</span><br><span class="line">    l,r = len(s) - <span class="number">1</span>,len(res) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> s[l] == <span class="string">" "</span>:</span><br><span class="line">            res[r<span class="number">-2</span>:r+<span class="number">1</span>] = <span class="string">"%20"</span></span><br><span class="line">            r -= <span class="number">3</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res[r] = res[l]</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        l -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join(res)</span><br></pre></td></tr></table></figure>
<h3 id="4-反转字符串中的单词-2"><a href="#4-反转字符串中的单词-2" class="headerlink" title="4.反转字符串中的单词(2)"></a>4.<a href="https://leetcode.cn/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">反转字符串中的单词</a>(2)</h3><h4 id="最直接的思路"><a href="#最直接的思路" class="headerlink" title="最直接的思路"></a>最直接的思路</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span>.join(s.strip().split()[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h4 id="不使用额外的空间"><a href="#不使用额外的空间" class="headerlink" title="不使用额外的空间"></a>不使用额外的空间</h4><blockquote>
<p>去除多余空格</p>
<p>翻转整个字符串</p>
<p>将每个单词翻转</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(temp,l,r)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            temp[l], temp[r] = temp[r], temp[l]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    l,r = <span class="number">0</span>,n - <span class="number">1</span></span><br><span class="line">    temp = []</span><br><span class="line">    <span class="keyword">while</span> l &lt;= r <span class="keyword">and</span> s[l] == <span class="string">' '</span>:</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= r <span class="keyword">and</span> s[r] == <span class="string">' '</span>:</span><br><span class="line">        r -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> s[l] != <span class="string">' '</span>:</span><br><span class="line">            temp.append(s[l])</span><br><span class="line">        <span class="keyword">elif</span> temp[<span class="number">-1</span>] != <span class="string">' '</span>:</span><br><span class="line">            temp.append(s[l])</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 翻转字符串</span></span><br><span class="line">    l,r = <span class="number">0</span>,len(temp) - <span class="number">1</span></span><br><span class="line">    reverse(temp,l,r)</span><br><span class="line">    <span class="comment"># 翻转每个单词</span></span><br><span class="line">    l,r = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    n = len(temp)</span><br><span class="line">    <span class="keyword">while</span> l &lt; n:</span><br><span class="line">        <span class="keyword">while</span> r &lt; n <span class="keyword">and</span> temp[r] != <span class="string">' '</span>:</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        reverse(temp,l,r - <span class="number">1</span>)</span><br><span class="line">        r += <span class="number">1</span></span><br><span class="line">        l = r</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(temp)</span><br></pre></td></tr></table></figure>
<h3 id="5-左旋转字符串"><a href="#5-左旋转字符串" class="headerlink" title="5.左旋转字符串"></a>5.<a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" target="_blank" rel="noopener">左旋转字符串</a></h3><h4 id="使用切片"><a href="#使用切片" class="headerlink" title="使用切片"></a>使用切片</h4><h4 id="不使用切片"><a href="#不使用切片" class="headerlink" title="不使用切片"></a>不使用切片</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseLeftWords</span><span class="params">(self, s: str, n: int)</span> -&gt; str:</span></span><br><span class="line">    s = list(s)</span><br><span class="line">    s[:n] = list(reversed(s[:n]))</span><br><span class="line">    s[n:] = list(reversed(s[n:]))</span><br><span class="line">    s.reverse()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(s)</span><br></pre></td></tr></table></figure>
<h3 id="6-实现-strStr-2"><a href="#6-实现-strStr-2" class="headerlink" title="6.实现 strStr()(2)"></a>6.<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/" target="_blank" rel="noopener">实现 strStr()</a>(2)</h3><blockquote>
<p>KMP</p>
<p>next[i]表示一个字符不匹配时，要看它前一个字符的next值，即next[i-1]，然后回溯到索引为next[i-1]的字符开始匹配</p>
<p>举例：             a a b a a f</p>
<p>前缀表next     0 1 0 1 2 0</p>
<p>前缀表之和模式串有关</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># 获取模式串的next数组(KMP的核心)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNext</span><span class="params">(next,s)</span>:</span></span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="comment"># j 指向前缀末尾位置， i 指向后缀末尾位置</span></span><br><span class="line">        <span class="comment"># 采用0 1 0 1 2 0</span></span><br><span class="line">        <span class="comment"># 每次回退取前一位的next值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> s[i] != s[j]:  <span class="comment"># 前缀和后缀不相等，回退</span></span><br><span class="line">                j = next[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j]:  <span class="comment"># 上面退出while可能是因为j == 0或者s[i] == s[j]，所以这里还要再判断一下</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            next[i] = j  <span class="comment"># next[i]的值就是j，前缀的长度</span></span><br><span class="line"></span><br><span class="line">    next = [<span class="number">-1</span>] * len(needle)</span><br><span class="line">    getNext(next,needle)</span><br><span class="line">    i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(haystack) <span class="keyword">and</span> j &lt; len(needle):</span><br><span class="line">        <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> haystack[i] != needle[j]:</span><br><span class="line">            j = next[j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> haystack[i] == needle[j]: <span class="comment"># 这里要么是中途能续上(如aab)，要么模式串从头开始</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> i - j <span class="keyword">if</span> j == len(needle) <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="7-重复的子字符串-2"><a href="#7-重复的子字符串-2" class="headerlink" title="7.重复的子字符串(2)"></a>7.<a href="https://leetcode.cn/problems/repeated-substring-pattern/" target="_blank" rel="noopener">重复的子字符串</a>(2)</h3><blockquote>
<p>给定一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成。</p>
<p>这道题绝对不止简单题的难度</p>
</blockquote>
<h4 id="移动匹配"><a href="#移动匹配" class="headerlink" title="移动匹配"></a>移动匹配</h4><blockquote>
<p>字符串:s+s(掐头去尾)</p>
<p>模式串:s</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeatedSubstringPattern</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNext</span><span class="params">(next,st)</span>:</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(st)):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> st[i] != st[j]:</span><br><span class="line">                j = next[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> st[i] == st[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            next[i] = j</span><br><span class="line">    next = [<span class="number">0</span>]*n</span><br><span class="line">    getNext(next,s)</span><br><span class="line">    i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="comment"># h:匹配串  s:模式串</span></span><br><span class="line">    <span class="comment"># 原字符串掐头去尾</span></span><br><span class="line">    h = (s+s)[<span class="number">1</span>:<span class="number">2</span>*len(s)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">while</span> i &lt; len(h) <span class="keyword">and</span> j &lt; len(s):</span><br><span class="line">        <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> s[j] != h[i]:</span><br><span class="line">            j = next[j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> s[j] == h[i]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> j == len(s)</span><br></pre></td></tr></table></figure>
<h4 id="最小重复字串"><a href="#最小重复字串" class="headerlink" title="最小重复字串"></a>最小重复字串</h4><blockquote>
<p>ababab  ab</p>
<p>ab  ababab</p>
<p>next: 0 0 1 2 3 4 5 6</p>
<p>若next[n-1]!=0 &amp;&amp; len(s)%(len(s)-next[n-1])==0，说明满足题设条件</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeatedSubstringPattern</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNext</span><span class="params">(next,st)</span>:</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(st)):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> st[i] != st[j]:</span><br><span class="line">                j = next[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> st[i] == st[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            next[i] = j</span><br><span class="line">    next = [<span class="number">0</span>]*n</span><br><span class="line">    getNext(next,s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> next[n - <span class="number">1</span>] != <span class="number">0</span> <span class="keyword">and</span> (n % (n - next[n - <span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="1-移除元素"><a href="#1-移除元素" class="headerlink" title="1.移除元素"></a>1.<a href="https://leetcode.cn/problems/remove-element/" target="_blank" rel="noopener">移除元素</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    slow,fast = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> fast <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> nums[fast] != val:</span><br><span class="line">            nums[slow] = nums[fast]</span><br><span class="line">            slow += <span class="number">1</span></span><br><span class="line">        fast += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>
<h3 id="2-反转字符串"><a href="#2-反转字符串" class="headerlink" title="2.反转字符串"></a>2.<a href="https://leetcode.cn/problems/reverse-string/" target="_blank" rel="noopener">反转字符串</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseString</span><span class="params">(self, s: List[str])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    i,j = <span class="number">0</span>,n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        s[i],s[j] = s[j],s[i]</span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="3-替换空格-1"><a href="#3-替换空格-1" class="headerlink" title="3.替换空格"></a>3.<a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">替换空格</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">    cnt = s.count(<span class="string">" "</span>)</span><br><span class="line">    res = list(s)</span><br><span class="line">    res.extend([<span class="string">" "</span>]*cnt*<span class="number">2</span>)</span><br><span class="line">    l,r = len(s) - <span class="number">1</span>,len(res) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> s[l] == <span class="string">" "</span>:</span><br><span class="line">            res[r<span class="number">-2</span>:r+<span class="number">1</span>] = <span class="string">"%20"</span></span><br><span class="line">            r -= <span class="number">3</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res[r] = res[l]</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        l -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join(res)</span><br></pre></td></tr></table></figure>
<h3 id="4-反转链表"><a href="#4-反转链表" class="headerlink" title="4.反转链表"></a>4.<a href="https://leetcode.cn/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: Optional[ListNode])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        temp = cur.next</span><br><span class="line">        cur.next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = temp</span><br><span class="line">    <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>
<h3 id="5-删除链表的倒数第-N-个结点-2"><a href="#5-删除链表的倒数第-N-个结点-2" class="headerlink" title="5.删除链表的倒数第 N 个结点(2)"></a>5.<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">删除链表的倒数第 N 个结点</a>(2)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head: Optional[ListNode], n: int)</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">    hv = ListNode(next=head)</span><br><span class="line">    slow,fast = hv,hv</span><br><span class="line">    <span class="keyword">while</span> n != <span class="number">0</span>:</span><br><span class="line">        fast = fast.next</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> fast.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        fast = fast.next</span><br><span class="line">        slow = slow.next</span><br><span class="line">    slow.next = slow.next.next</span><br><span class="line">    <span class="keyword">return</span> hv.next</span><br></pre></td></tr></table></figure>
<h3 id="6-链表相交-1"><a href="#6-链表相交-1" class="headerlink" title="6.链表相交"></a>6.<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/" target="_blank" rel="noopener">链表相交</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA: ListNode, headB: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">    lenA,lenB = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    curA,curB = headA,headB</span><br><span class="line">    <span class="comment"># 计算长度</span></span><br><span class="line">    <span class="keyword">while</span> curA <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        lenA += <span class="number">1</span></span><br><span class="line">        curA = curA.next</span><br><span class="line">    <span class="keyword">while</span> curB <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        lenB += <span class="number">1</span></span><br><span class="line">        curB = curB.next</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 长的比短的多走|lenA - lenB|步</span></span><br><span class="line">    curA, curB = headA, headB</span><br><span class="line">    <span class="keyword">if</span> lenA &gt; lenB:</span><br><span class="line">        cnt = lenA - lenB</span><br><span class="line">        <span class="keyword">while</span> cnt != <span class="number">0</span>:</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">            curA = curA.next</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cnt = lenB - lenA</span><br><span class="line">        <span class="keyword">while</span> cnt != <span class="number">0</span>:</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">            curB = curB.next</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> curA <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> curA == curB:</span><br><span class="line">            <span class="keyword">return</span> curA</span><br><span class="line">        curA = curA.next</span><br><span class="line">        curB = curB.next</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="7-环形链表-II-2-1"><a href="#7-环形链表-II-2-1" class="headerlink" title="7.环形链表 II(2)"></a>7.<a href="https://leetcode.cn/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">环形链表 II</a>(2)</h3><blockquote>
<p>详细解析见链表部分</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">    slow,fast = head,head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> fast.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        slow = slow.next</span><br><span class="line">        <span class="keyword">if</span> fast == slow:</span><br><span class="line">            cur = head</span><br><span class="line">            <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> cur == slow:</span><br><span class="line">                    <span class="keyword">return</span> cur</span><br><span class="line">                cur = cur.next</span><br><span class="line">                slow = slow.next</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="8-三数之和（2）"><a href="#8-三数之和（2）" class="headerlink" title="8.三数之和（2）"></a>8.<a href="https://leetcode.cn/problems/3sum/" target="_blank" rel="noopener">三数之和</a>（2）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    r = []</span><br><span class="line">    nums.sort()</span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">1</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        j,k = i + <span class="number">1</span>,n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; k:</span><br><span class="line">            temp = nums[i] + nums[j] + nums[k]</span><br><span class="line">            <span class="keyword">if</span> temp &gt; <span class="number">0</span>:</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> temp &lt; <span class="number">0</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r.append([nums[i],nums[j],nums[k]])</span><br><span class="line">                <span class="comment"># 去重</span></span><br><span class="line">                <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j + <span class="number">1</span>]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] == nums[k - <span class="number">1</span>]:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 本来不去重也要更新j,k</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<h3 id="9-四数之和-2"><a href="#9-四数之和-2" class="headerlink" title="9.四数之和(2)"></a>9.<a href="https://leetcode.cn/problems/4sum/" target="_blank" rel="noopener">四数之和</a>(2)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">if</span> nums <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> n &lt; <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    r = []</span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">1</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>,n - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left,right = j + <span class="number">1</span>,n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                temp = nums[i] + nums[j] + nums[left] + nums[right]</span><br><span class="line">                <span class="keyword">if</span> temp &gt; target:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> temp &lt; target:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r.append([nums[i],nums[j],nums[left],nums[right]])</span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="1-用栈实现队列"><a href="#1-用栈实现队列" class="headerlink" title="1.用栈实现队列"></a>1.<a href="https://leetcode.cn/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">用栈实现队列</a></h3><h3 id="2-用队列实现栈"><a href="#2-用队列实现栈" class="headerlink" title="2.用队列实现栈"></a>2.<a href="https://leetcode.cn/problems/implement-stack-using-queues/" target="_blank" rel="noopener">用队列实现栈</a></h3><h3 id="3-有效的括号"><a href="#3-有效的括号" class="headerlink" title="3.有效的括号"></a>3.<a href="https://leetcode.cn/problems/valid-parentheses/" target="_blank" rel="noopener">有效的括号</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="string">"["</span>:</span><br><span class="line">            stack.append(<span class="string">"]"</span>)</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="string">"&#123;"</span>:</span><br><span class="line">            stack.append(<span class="string">"&#125;"</span>)</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="string">"("</span>:</span><br><span class="line">            stack.append(<span class="string">")"</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[<span class="number">-1</span>] != i:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            stack.pop()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> stack <span class="comment"># 等价于len(stack) == 0 or stack is None</span></span><br></pre></td></tr></table></figure>
<h3 id="4-删除字符串中的所有相邻重复项"><a href="#4-删除字符串中的所有相邻重复项" class="headerlink" title="4.删除字符串中的所有相邻重复项"></a>4.<a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/" target="_blank" rel="noopener">删除字符串中的所有相邻重复项</a></h3><blockquote>
<p>so easy</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] == i:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(i)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(stack)</span><br></pre></td></tr></table></figure>
<h3 id="5-逆波兰表达式求值-2"><a href="#5-逆波兰表达式求值-2" class="headerlink" title="5.逆波兰表达式求值(2)"></a>5.<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">逆波兰表达式求值</a>(2)</h3><blockquote>
<p>so easy</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span><span class="params">(self, tokens: List[str])</span> -&gt; int:</span></span><br><span class="line">    stack = []</span><br><span class="line">    ch = &#123;</span><br><span class="line">        <span class="string">'+'</span>:<span class="keyword">lambda</span> a,b:a+b,</span><br><span class="line">        <span class="string">'-'</span>:<span class="keyword">lambda</span> a,b:a-b,</span><br><span class="line">        <span class="string">'*'</span>:<span class="keyword">lambda</span> a,b:a*b,</span><br><span class="line">        <span class="string">'/'</span>:<span class="keyword">lambda</span> a,b:int(a/b),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> tokens:</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> ch.keys():</span><br><span class="line">            stack.append(int(s))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b = stack.pop()</span><br><span class="line">            a = stack.pop()</span><br><span class="line">            r = ch[s](a,b)</span><br><span class="line">            stack.append(r)</span><br><span class="line">    <span class="keyword">return</span> stack.pop()</span><br></pre></td></tr></table></figure>
<h3 id="6-滑动窗口最大值-3"><a href="#6-滑动窗口最大值-3" class="headerlink" title="==6.滑动窗口最大值(3)=="></a>==6.<a href="https://leetcode.cn/problems/sliding-window-maximum/" target="_blank" rel="noopener">滑动窗口最大值</a>(3)==</h3><blockquote>
<p>单调队列核心思想:之前的元素比当前元素还小的话,可以提前移除之前的元素,不需要再维护无用的元素</p>
<p>注意清除已过期的元素</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="comment"># from collections import deque 导入</span></span><br><span class="line">    q = deque()</span><br><span class="line">    <span class="comment"># 将前k个元素入队</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt;= nums[q[<span class="number">-1</span>]]:</span><br><span class="line">            q.pop()</span><br><span class="line">        q.append(i)</span><br><span class="line">    res = [nums[q[<span class="number">0</span>]]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k,n):</span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt;= nums[q[<span class="number">-1</span>]]:</span><br><span class="line">            q.pop()</span><br><span class="line">        q.append(i)</span><br><span class="line">        <span class="keyword">if</span> i - q[<span class="number">0</span>] &gt;= k:</span><br><span class="line">            q.popleft()</span><br><span class="line">        res.append(nums[q[<span class="number">0</span>]])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>精简融合版</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="comment"># 队列中存的是元素下标</span></span><br><span class="line">    q = deque()</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="comment"># 队列不为空 且 当前元素大于队列中元素时,移除队列中的元素</span></span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt;= nums[q[<span class="number">-1</span>]]:</span><br><span class="line">            q.pop()</span><br><span class="line">        <span class="comment"># 添加到队列中</span></span><br><span class="line">        q.append(i)</span><br><span class="line">        <span class="comment"># 滑动窗口大小大于k,移除队头元素(一定要在下一步之前)</span></span><br><span class="line">        <span class="comment"># q[0]和q[1]都在队列中,q[0]一定比q[1]早过期,</span></span><br><span class="line">        <span class="comment"># 若q[1]比q[0]大,q[1]入队时,q[0]便会出队</span></span><br><span class="line">        <span class="comment"># 若q[1]比q[0]小,q[1]肯定是后入队的,否则q[0]会把q[1]排除掉</span></span><br><span class="line">        <span class="keyword">if</span> i - q[<span class="number">0</span>] &gt;= k:</span><br><span class="line">            q.popleft()</span><br><span class="line">        <span class="comment"># 滑动窗口大小为k时,添加结果</span></span><br><span class="line">        <span class="keyword">if</span> i + <span class="number">1</span> &gt;= k:</span><br><span class="line">            res.append(nums[q[<span class="number">0</span>]])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="7-前-K-个高频元素（2）"><a href="#7-前-K-个高频元素（2）" class="headerlink" title="7.前 K 个高频元素（2）"></a>7.<a href="https://leetcode.cn/problems/top-k-frequent-elements/" target="_blank" rel="noopener">前 K 个高频元素</a>（2）</h3><blockquote>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
</blockquote>
<p>最大堆:有n个元素，每次维护要logk的复杂度,所以总时间复杂度为nlogk，空间复杂度最差map要存储n个键值对，为O(n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">    mp = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        mp[n] = mp.get(n,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    q = []</span><br><span class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> mp.items():</span><br><span class="line">        heapq.heappush(q,(value,key))</span><br><span class="line">        <span class="keyword">if</span> len(q) &gt; k:</span><br><span class="line">            heapq.heappop(q)</span><br><span class="line">    res = [<span class="number">0</span>] * k</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k - <span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        res[i] = heapq.heappop(q)[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="==单调队列=="></a>==单调队列==</h3><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="==单调栈=="></a>==单调栈==</h3><blockquote>
<p>在一维数组中对每一个数找到第一个比自己小的元素。这类“在一维数组中找第一个满足某种条件的数”的场景就是典型的单调栈应用场景。The Next Greater问题</p>
</blockquote>
<h4 id="1-柱状图中最大的矩形-3"><a href="#1-柱状图中最大的矩形-3" class="headerlink" title="1.柱状图中最大的矩形(3)"></a>1.<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">柱状图中最大的矩形</a>(3)</h4><blockquote>
<p>基本思路：遍历每个矩阵，以这个矩阵为中心(即高度是此矩阵)向左右扩展，找比这个矩阵最近小的元素。</p>
<p>暴力法：O(n^2)，leetcode 测试案例87/98</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># 从左向右遍历：以每一根柱子为主心骨（当前轮最高的参照物），迭代直到找到左侧和右侧各第一个矮一级的柱子</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line">        left = i</span><br><span class="line">        right = i</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(left,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> heights[left] &lt; heights[i]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(right,len(heights)):</span><br><span class="line">            <span class="keyword">if</span> heights[right] &lt; heights[i]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        res = max(res,(right-left<span class="number">-1</span>) * heights[i])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<blockquote>
<p>动态规划</p>
<p>用两个dp数组保存左右两边最近比当前小的柱子的下标</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(heights)</span><br><span class="line">    <span class="comment"># 两个DP数列储存的均是下标index</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    lIndex = [<span class="number">0</span>] * n</span><br><span class="line">    rIndex = [<span class="number">0</span>] * n</span><br><span class="line">    lIndex[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        temp = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> temp &gt;= <span class="number">0</span> <span class="keyword">and</span> heights[temp] &gt;= heights[i]:</span><br><span class="line">            temp = lIndex[temp]</span><br><span class="line">        lIndex[i] = temp</span><br><span class="line">    rIndex[<span class="number">-1</span>] = n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        temp = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> temp &lt; n <span class="keyword">and</span> heights[temp] &gt;= heights[i]:</span><br><span class="line">            temp = rIndex[temp]</span><br><span class="line">        rIndex[i] = temp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        res = max(res,heights[i]*(rIndex[i]-lIndex[i]<span class="number">-1</span>))</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<blockquote>
<p>单调栈：在此题中递增，由于单调栈的性质，中心点向右扩展就是while循环进去的时机，向左扩展就是根据当前点到栈顶索引之差</p>
<p>注意：当前点的扩展，可能并不是在遍历此点的周期内，可能是在遍历其他点的时候，走while循环能够从栈中弹出的时候。</p>
<p>tips：为防止左右越界，我们可以在左右两侧虚拟两根无限低的柱子，记高度为 0。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">    q = []</span><br><span class="line">    heights.insert(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    heights.append(<span class="number">0</span>)</span><br><span class="line">    n = len(heights)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> heights[i] &lt; heights[q[<span class="number">-1</span>]]:</span><br><span class="line">            cur = q.pop()</span><br><span class="line">            left = q[<span class="number">-1</span>]</span><br><span class="line">            right = i - <span class="number">1</span></span><br><span class="line">            res = max(res,(right - left)*heights[cur])</span><br><span class="line">        q.append(i)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="2-每日温度-2"><a href="#2-每日温度-2" class="headerlink" title="2.每日温度(2)"></a>2.<a href="https://leetcode.cn/problems/daily-temperatures/" target="_blank" rel="noopener">每日温度</a>(2)</h4><blockquote>
<p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span><span class="params">(self, temperatures: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    q = []</span><br><span class="line">    n = len(temperatures)</span><br><span class="line">    res = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> temperatures[i] &gt; temperatures[q[<span class="number">-1</span>]]:</span><br><span class="line">            pp = q.pop()</span><br><span class="line">            res[pp] = i - pp</span><br><span class="line">        q.append(i)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="3-下一个更大元素-I"><a href="#3-下一个更大元素-I" class="headerlink" title="3.下一个更大元素 I"></a>3.<a href="https://leetcode.cn/problems/next-greater-element-i/" target="_blank" rel="noopener">下一个更大元素 I</a></h4><blockquote>
<p>典型的单调栈问题</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    mp = &#123;&#125;</span><br><span class="line">    q = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums2)):</span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> nums2[i] &gt; nums2[q[<span class="number">-1</span>]]:</span><br><span class="line">            index = q.pop()</span><br><span class="line">            mp[nums2[index]] = nums2[i]</span><br><span class="line">        q.append(i)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums1:</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> mp:</span><br><span class="line">           res.append(mp[num])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="4-下一个更大元素-II-2"><a href="#4-下一个更大元素-II-2" class="headerlink" title="4.下一个更大元素 II(2)"></a>4.<a href="https://leetcode.cn/problems/next-greater-element-ii/" target="_blank" rel="noopener">下一个更大元素 II</a>(2)</h4><blockquote>
<p>这题元素可以重复，所以往map里面放下标</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElements</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    mp = &#123;&#125;</span><br><span class="line">    q = []</span><br><span class="line">    temp = nums.copy()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> temp:</span><br><span class="line">        nums.append(t)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt; nums[q[<span class="number">-1</span>]]:</span><br><span class="line">            index = q.pop()</span><br><span class="line">            mp[index] = nums[i]</span><br><span class="line">        q.append(i)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(temp)):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> mp:</span><br><span class="line">            res.append(mp[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="5-接雨水-3"><a href="#5-接雨水-3" class="headerlink" title="5.接雨水(3)"></a>5.<a href="https://leetcode.cn/problems/trapping-rain-water/" target="_blank" rel="noopener">接雨水</a>(3)</h4><blockquote>
<p>双指针</p>
<p>思路：逐个计算每个位置的雨水量，找到该位置左边和右边最高的柱子，由于宽就是1，高是min(rHeight,lHeight)-height[i]，就能得出该位置的雨水量</p>
<p>时间复杂度为O(n^2)，leetcode通过测试案例 320/322</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(height)):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> i == len(height) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        lHeight,rHeight = height[i],height[i]</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(i<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> height[l] &gt; lHeight:</span><br><span class="line">                lHeight = height[l]</span><br><span class="line">        <span class="keyword">if</span> lHeight == height[i]: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(i+<span class="number">1</span>,len(height)):</span><br><span class="line">            <span class="keyword">if</span> height[r] &gt; rHeight:</span><br><span class="line">                rHeight = height[r]</span><br><span class="line">            <span class="keyword">if</span> rHeight &gt; lHeight:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        sum = sum + min(rHeight,lHeight) - height[i]</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>
<blockquote>
<p>动态规划</p>
<p>原来双指针找左右两边的最高柱子，有冗余过程，</p>
<p>我们事先用两个数组保存左右两边的最高柱子的高度。</p>
<p>时间复杂度为O(n)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(height)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    lHeight = [<span class="number">0</span>] * n</span><br><span class="line">    rHeight = [<span class="number">0</span>] * n</span><br><span class="line">    lHeight[<span class="number">0</span>] = height[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        lHeight[i] = max(height[i],lHeight[i<span class="number">-1</span>])</span><br><span class="line">    rHeight[<span class="number">-1</span>] = height[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        rHeight[i] = max(height[i],rHeight[i+<span class="number">1</span>])</span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        sum = sum + min(lHeight[i],rHeight[i]) - height[i]</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>
<blockquote>
<p>单调栈</p>
<p>计算雨水并不是像前两种方法一样———-逐个计算每个位置的雨水量</p>
<p>这里计算出</p>
<p>高度和前两种方法类似h = min(height[i],height[st[-1]]) - height[mid]，得出左右两边最高柱子的最小值再减去底部的大小</p>
<p>宽度当前柱子下标减去凹陷部位前一个柱子下标再减1</p>
<p>最后v = h*w</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">    st = [<span class="number">0</span>]</span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(height)):</span><br><span class="line">        <span class="keyword">while</span> st <span class="keyword">and</span> height[i] &gt; height[st[<span class="number">-1</span>]]:</span><br><span class="line">            mid = st.pop()</span><br><span class="line">            <span class="keyword">if</span> st:</span><br><span class="line">                h = min(height[i],height[st[<span class="number">-1</span>]]) - height[mid]</span><br><span class="line">                w = i - st[<span class="number">-1</span>] - <span class="number">1</span></span><br><span class="line">                sum += h*w</span><br><span class="line">        st.append(i)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>
<h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><h3 id="1-漂亮数组-2"><a href="#1-漂亮数组-2" class="headerlink" title="1.漂亮数组(2)"></a>1.<a href="https://leetcode.cn/problems/beautiful-array/" target="_blank" rel="noopener">漂亮数组</a>(2)</h3><blockquote>
<p>对于某些固定的 N，如果数组 A 是整数 1, 2, …, N 组成的排列，使得：</p>
<p>对于每个 i &lt; j，都不存在 k 满足 i &lt; k &lt; j 使得 A[k] * 2 = A[i] + A[j]。</p>
<p>那么数组 A 是漂亮数组。</p>
<p>重点：有两个很重要的推论</p>
<p><strong>1.数组A是漂亮数组，那么数组B=KA+b也是漂亮数组</strong></p>
<p>证明：</p>
<p>数组A是漂亮数组，那么不存在A[k] * 2 = A[i] + A[j], i &lt; k &lt; j，</p>
<p>两边同时乘K加2b ，A[k] <em> 2 </em> K + 2b = K <em> A[i] + b + K </em> A[j] + b 即 2B[K] = B[i] + B[j]</p>
<p>所以不存在2B[K] = B[i] + B[j], i &lt; k &lt; j</p>
<p><strong>2.数组A可以分为两部分，left和right且都为漂亮数组，其中left全为奇数，right全为偶数，那么数组A也是漂亮数组</strong></p>
<p>思路：可以采用分治法，left数组使用2n-1保证漂亮数组，right数组使用2n保证漂亮数组</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">beautifulArray</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">    memo = &#123;<span class="number">1</span>:[<span class="number">1</span>]&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(N)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> N <span class="keyword">not</span> <span class="keyword">in</span> memo:</span><br><span class="line">            odds = create((N + <span class="number">1</span>) // <span class="number">2</span>)</span><br><span class="line">            evens = create(N // <span class="number">2</span>)</span><br><span class="line">            memo[N] = [<span class="number">2</span>*x - <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> odds] + [<span class="number">2</span>*x <span class="keyword">for</span> x <span class="keyword">in</span> evens]</span><br><span class="line">        <span class="keyword">return</span> memo[N]</span><br><span class="line">    <span class="keyword">return</span> create(n)</span><br></pre></td></tr></table></figure>
<h3 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2.快速排序"></a>2.<a href="https://www.acwing.com/problem/content/787/" target="_blank" rel="noopener">快速排序</a></h3><p>推荐</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="comment">// 每次都是先i++,j--所以要i=l-1,j=r+1,这样才能指到真正的边界</span></span><br><span class="line">        <span class="comment">// 这样可以少写一次边界的swap语句</span></span><br><span class="line">        <span class="keyword">int</span> i = l<span class="number">-1</span>,j = r+<span class="number">1</span>,pivot = p[l+r&gt;&gt;<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="comment">// p[i],p[j]不能等于pivot,跳出while的条件就是i和j都到达pivot(pivot下标会变,但值不会变)</span></span><br><span class="line">            <span class="comment">// 若前半段一直小于基准,那么i会取到pivot的下标,然后i就可以继续走了</span></span><br><span class="line">            <span class="comment">// 如[2,5,1,6,10,7,8,9,11]</span></span><br><span class="line">            <span class="comment">// 一开始pivot是10,i一下就能走到pivot的位置</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 若i=l,j=r不用do-while也不行,如&#123;12,5,1,6,10,7,8,9,1&#125;有重复元素就会报错</span></span><br><span class="line">            <span class="keyword">while</span>(p[++i]&lt;pivot) ;</span><br><span class="line">            <span class="keyword">while</span>(p[--j]&gt;pivot) ;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)swap(p[i],p[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        quick_sort(l,j);</span><br><span class="line">        quick_sort(j+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python写法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(l: int,r: int)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> l &lt; r:</span><br><span class="line">        i,j = l - <span class="number">1</span>,r + <span class="number">1</span></span><br><span class="line">        pivot = n[l+r&gt;&gt; <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> n[i] &gt;= pivot:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> n[j] &lt;= pivot:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; j:</span><br><span class="line">                n[i],n[j] = n[j],n[i]</span><br><span class="line">        quick_sort(l,j)</span><br><span class="line">        quick_sort(j + <span class="number">1</span>,r)</span><br></pre></td></tr></table></figure>
<p>不推荐</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acwing测试只能通过10/13(会超时),而且按照定义pivot只能取A[l]</span></span><br><span class="line"><span class="comment">// https://blog.csdn.net/weixin_43586713/article/details/119820797</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = l,j = r,pivot = A[l];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; A[j]&gt;=pivot) j--;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; A[i]&lt;=pivot) i++;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)swap(A[i],A[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(A[l],A[i]);    </span><br><span class="line">        quick_sort(l,j<span class="number">-1</span>);</span><br><span class="line">        quick_sort(j+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第k个数"><a href="#第k个数" class="headerlink" title="第k个数"></a><a href="https://www.acwing.com/problem/content/788/" target="_blank" rel="noopener">第k个数</a></h4><blockquote>
<p>快速排序一次排完序后，数组分为两段：[l,j] [j+1,r]</p>
<p>若k &lt;= j-l+1说明在第一段，否则在第二段(在第二段递归时就相当于是第二段的第k-(j-l+1)个数)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> A[l];</span><br><span class="line">    <span class="keyword">int</span> i = l<span class="number">-1</span>,j = r+<span class="number">1</span>,pivot = A[l+r&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++;<span class="keyword">while</span>(A[i]&lt;pivot);</span><br><span class="line">        <span class="keyword">do</span> j--;<span class="keyword">while</span>(A[j]&gt;pivot);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)swap(A[i],A[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sl = j-l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=sl) <span class="keyword">return</span> quick_sort(l,j,k);</span><br><span class="line">    <span class="keyword">return</span> quick_sort(j+<span class="number">1</span>,r,k-sl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="3.归并排序"></a>3.<a href="https://www.acwing.com/problem/content/789/" target="_blank" rel="noopener">归并排序</a></h3><blockquote>
<p>合并的过程其实就是双指针i,j移动的过程，时间复杂度为O(n)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        merge_sort(l,mid);</span><br><span class="line">        merge_sort(mid+<span class="number">1</span>,r);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l;i&lt;=r;i++)</span><br><span class="line">            tmp[i] = p[i];</span><br><span class="line">        <span class="keyword">int</span> i = l,k = l,j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// i,j指向tmp数组</span></span><br><span class="line">        <span class="comment">// k指向p数组,有序的数存在p数组中</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i]&lt;=tmp[j]) p[k++] = tmp[i++];</span><br><span class="line">            <span class="keyword">else</span> p[k++] = tmp[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid) p[k++] = tmp[i++];</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r) p[k++] = tmp[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a><a href="https://www.acwing.com/problem/content/790/" target="_blank" rel="noopener">逆序对</a></h4><blockquote>
<p>两区间[l,mid] [mid+1,r]在归并排序中都是有序的</p>
<p>若i 属于[l,mid] ，j属于[mid+1,r]，tmp[i] &gt; tmp[j]  那么在区间[i,mid]的数也一定大于tmp[j] (因为是有序的) </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        merge_sort(l,mid);</span><br><span class="line">        merge_sort(mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l;i&lt;=r;i++)</span><br><span class="line">            tmp[i] = p[i];</span><br><span class="line">        <span class="keyword">int</span> k = l,i = l,j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i]&lt;=tmp[j])p[k++] = tmp[i++];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 此处统计数量即可</span></span><br><span class="line">                res += mid-i+<span class="number">1</span>;</span><br><span class="line">                p[k++] = tmp[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)p[k++] = tmp[i++];</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r)p[k++] = tmp[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-不无聊序列-2"><a href="#4-不无聊序列-2" class="headerlink" title="4.不无聊序列(2)"></a>4.<a href="https://www.luogu.com.cn/problem/UVA1608" target="_blank" rel="noopener">不无聊序列</a>(2)</h3><blockquote>
<p><a href="https://www.luogu.com.cn/problem/solution/UVA1608" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/solution/UVA1608</a></p>
<p><a href="https://blog.csdn.net/sinat_35678407/article/details/82868328" target="_blank" rel="noopener">https://blog.csdn.net/sinat_35678407/article/details/82868328</a></p>
<p>题目：如果一个序列的任意连续子序列都至少有一个元素唯一，则称这个序列“不无聊”，否则称这个序列“无聊”。给定T个序列，求是否“无聊”。</p>
<p>解题思路：</p>
<p>求独特数思路：使用map记录与当前元素值相同的上一个元素 and 下一个元素的位置</p>
<p>分支思路：对于区间[l,r]，若p位置为独特数a，那么就可以分治遍历[l,p-1]和[p-1,r]，因为在区间[l,r]内任意含独特数a的子序列一定是不无聊的。</p>
<p>步骤：</p>
<p>1.利用两个额外数组prepos[]、nextpos[]来记录每个元素与它相同的元素之前出现的位置，和之后紧接着出现的位置。</p>
<p>2.从两端进行搜索，寻找独特元素num[p]。</p>
<p>3.根据独特元素num[p]进行划分为左右子序列[l,p-1],[p+1,r]。</p>
<p>4.重复上面两个步骤，直到剩一个元素。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> prepos[len], nextpos[len], val[len];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; val_map;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> count)</span>  <span class="comment">// 初始化prepos、nextpos数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!val_map.count(val[i])) prepos[i] = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> prepos[i] = val_map[val[i]];</span><br><span class="line">		val_map[val[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	val_map.clear();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = count; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!val_map.count(val[i])) nextpos[i] = count + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> nextpos[i] = val_map[val[i]];</span><br><span class="line">		val_map[val[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">int</span> i = left, j = right;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (prepos[i] &lt; left &amp;&amp; nextpos[i] &gt; right) <span class="comment">// [left,right]内没有和val[i]一样的数，即val[i]就是独特数</span></span><br><span class="line">            <span class="keyword">return</span> solve(left, i - <span class="number">1</span>) &amp;&amp; solve(i + <span class="number">1</span>, right);</span><br><span class="line">		++i;</span><br><span class="line">        <span class="comment">// 其实可以不需要这部分，但是直接遍历找独特元素的时间复杂度为O(n^2)  (T(n)=T(n-1)+O(n))</span></span><br><span class="line">        <span class="comment">// 而双指针相遇方法的时间复杂度为O(nlogn)  (T(n)=2T(n/2)+O(n))</span></span><br><span class="line">		<span class="keyword">if</span> (prepos[j] &lt; left &amp;&amp; nextpos[j] &gt; right) <span class="keyword">return</span> solve(left, j - <span class="number">1</span>) &amp;&amp; solve(j + <span class="number">1</span>, right);</span><br><span class="line">		--j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;count);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, val+i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	init(count);</span><br><span class="line">	<span class="keyword">if</span> (solve(<span class="number">1</span>, count)) <span class="built_in">printf</span>(<span class="string">"non-boring sequence!"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"boring sequence!"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-最近点对-2维"><a href="#5-最近点对-2维" class="headerlink" title="5.最近点对(2维)"></a>5.最近点对(2维)</h3><blockquote>
<p>因为是python所以在洛谷不能AC，要用C++</p>
<p><a href="https://www.luogu.com.cn/problem/solution/P1429" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/solution/P1429</a></p>
<p>题解 <a href="https://www.jianshu.com/p/8bc681afbaff" target="_blank" rel="noopener">https://www.jianshu.com/p/8bc681afbaff</a></p>
<p>思路：</p>
<p>1.求区间[l,mid-1]和[mid,right]的最短距离为d1,d2</p>
<p>2.那么d = min(d1,d2)，筛选一个点在[l,mid-1]，一个点在[mid,right]的情况，这个点与中心点(point[mid])的距离必不能大于d</p>
<p>3.第2步缩小范围后，再遍历筛选出的所有点，求这些点的最短距离，不断更新d</p>
<p>返回d</p>
<p><img alt="img" data-src="https://cdn.luogu.com.cn/upload/pic/67233.png"></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x = <span class="number">0</span>,y = <span class="number">0</span>)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.x)+<span class="string">" "</span>+str(self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.x == other.x:</span><br><span class="line">            <span class="keyword">return</span> self.y &lt; other.y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> self.x &lt; other.x <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(left,right)</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dis</span><span class="params">(a:Node,b:Node)</span>-&gt;int:</span></span><br><span class="line">        <span class="keyword">return</span> math.sqrt(pow(a.x-b.x,<span class="number">2</span>)+pow(a.y-b.y,<span class="number">2</span>))</span><br><span class="line">    d = (<span class="number">1</span>&lt;&lt;<span class="number">31</span><span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> left == right:</span><br><span class="line">        <span class="keyword">return</span> d</span><br><span class="line">    <span class="keyword">if</span> left + <span class="number">1</span> == right:</span><br><span class="line">        <span class="keyword">return</span> dis(point[left],point[right])</span><br><span class="line">    mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">    d1 = run(left,mid<span class="number">-1</span>)</span><br><span class="line">    d2 = run(mid,right)</span><br><span class="line">    d = min(d1,d2)</span><br><span class="line">    mpt = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(left,right+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 统计带状区域中的点对</span></span><br><span class="line">        <span class="keyword">if</span> abs(point[mid].x-point[i].x) &lt;= d:</span><br><span class="line">            mpt.append(i)</span><br><span class="line">    mpt = sorted(mpt,key=cmp_to_key(<span class="keyword">lambda</span> a,b:point[a].y-point[b].y))</span><br><span class="line">    k = len(mpt)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,k):</span><br><span class="line">            distance = dis(point[mpt[i]],point[mpt[j]])</span><br><span class="line">            <span class="keyword">if</span> distance &lt;= d:</span><br><span class="line">                d = distance</span><br><span class="line">            <span class="comment"># 因为排了序，所以之后的都不满足条件了</span></span><br><span class="line">            <span class="keyword">if</span> point[mpt[j]].y - point[mpt[i]].y &gt; d:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n = int(input())</span><br><span class="line">    point = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        line = input().split(<span class="string">" "</span>)</span><br><span class="line">        point.append(Node(int(line[<span class="number">0</span>]),int(line[<span class="number">1</span>])))</span><br><span class="line">    point = sorted(point)</span><br><span class="line">    res = run(<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">    print(<span class="string">"%.4f"</span>%res)</span><br></pre></td></tr></table></figure>
<h3 id="6-众数问题"><a href="#6-众数问题" class="headerlink" title="6.众数问题"></a>6.众数问题</h3><blockquote>
<p>找出给定递增序列的众数，并求出众数在序列中出现的次数（重数）</p>
<p><a href="https://www.cnblogs.com/program-ai-cv-ml-se-fighting/p/11944099.html" target="_blank" rel="noopener">https://www.cnblogs.com/program-ai-cv-ml-se-fighting/p/11944099.html</a></p>
<p> AC代码</p>
<p>但无法AC <a href="https://www.acwing.com/problem/content/1330/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/1330/</a>  因为此方法无法给出最大的众数</p>
<p>[left,right]表示当前分治法遍历的数组区间</p>
<p>1.每次取mid = (left+right)/2，以nums[mid]为中心向左右扩展，找这个数在区间[left,right]中开始和结束位置l和r，计算nums[mid]的个数num与max比较并更新，显而易见那么[l,r]区间内都是nums[mid]。</p>
<p>2.此时再对区间[left,l)和(r,right]中的数做步骤1的操作，最后求出众数</p>
<p>最差时间复杂度O(nlogn)，最好时间复杂度O(n)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">max, ele = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMaxCnt</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> max, ele</span><br><span class="line">    mid = left + right &gt;&gt; <span class="number">1</span></span><br><span class="line">    l, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLR</span><span class="params">(left, right, mid)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> l, r</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(left, right + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[mid]:</span><br><span class="line">                l = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l + <span class="number">1</span>, right + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != nums[mid]:</span><br><span class="line">                r = i - <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = i</span><br><span class="line"></span><br><span class="line">    getLR(left, right, mid)</span><br><span class="line">    num = r - l + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> num &gt; max:</span><br><span class="line">        max = num</span><br><span class="line">        ele = nums[mid]</span><br><span class="line">    <span class="keyword">if</span> l - left &gt; max:</span><br><span class="line">        getMaxCnt(left, l - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> right - r - <span class="number">1</span> &gt; max:</span><br><span class="line">        getMaxCnt(r + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getMaxCnt(<span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">print(ele)</span><br><span class="line">print(max)</span><br></pre></td></tr></table></figure>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="深搜遍历"><a href="#深搜遍历" class="headerlink" title="深搜遍历"></a>深搜遍历</h3><h4 id="1-二叉树的前序遍历"><a href="#1-二叉树的前序遍历" class="headerlink" title="1.二叉树的前序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">1.二叉树的前序遍历</a></h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">return</span> self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)</span><br></pre></td></tr></table></figure>
<h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; List[int]:</span></span><br><span class="line">    res = []</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    stack.append(root)</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        res.append(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="2-二叉树的中序遍历"><a href="#2-二叉树的中序遍历" class="headerlink" title="2.二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">2.二叉树的中序遍历</a></h4><h5 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">return</span> self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)</span><br></pre></td></tr></table></figure>
<h5 id="迭代-注意"><a href="#迭代-注意" class="headerlink" title="迭代(注意)"></a>迭代(注意)</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; List[int]:</span></span><br><span class="line">    res = []</span><br><span class="line">    stack = []</span><br><span class="line">    cur = root</span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">or</span> stack :</span><br><span class="line">        <span class="keyword">if</span> cur:</span><br><span class="line">            stack.append(cur)</span><br><span class="line">            cur = cur.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            cur = cur.right</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="3-二叉树的后序遍历"><a href="#3-二叉树的后序遍历" class="headerlink" title="3.二叉树的后序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">3.二叉树的后序遍历</a></h4><h5 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">return</span> self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]</span><br></pre></td></tr></table></figure>
<h5 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; List[int]:</span></span><br><span class="line">    res = []</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    stack.append(root)</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        res.append(node.val)</span><br><span class="line">    <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="迭代遍历统一写法"><a href="#迭代遍历统一写法" class="headerlink" title="==迭代遍历统一写法=="></a>==迭代遍历统一写法==</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; List[int]:</span></span><br><span class="line">    res = []</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    stack.append(root)</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="comment"># 前序遍历</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right) <span class="comment"># 右</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left) <span class="comment"># 左</span></span><br><span class="line">            stack.append(node)  <span class="comment"># 中</span></span><br><span class="line">            stack.append(<span class="literal">None</span>)  <span class="comment"># 加入空节点作为处理标记</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 中序遍历</span></span><br><span class="line">            <span class="comment">#if node.right:</span></span><br><span class="line">            <span class="comment">#    stack.append(node.right) # 右</span></span><br><span class="line">            <span class="comment">#stack.append(node)  # 中</span></span><br><span class="line">            <span class="comment">#stack.append(None)  # 加入空节点作为处理标记</span></span><br><span class="line">            <span class="comment">#if node.left:</span></span><br><span class="line">            <span class="comment">#    stack.append(node.left) # 左</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 后序遍历</span></span><br><span class="line">            <span class="comment">#stack.append(node)  # 中</span></span><br><span class="line">            <span class="comment">#stack.append(None)  # 加入空节点作为处理标记</span></span><br><span class="line">            <span class="comment">#if node.right:</span></span><br><span class="line">            <span class="comment">#    stack.append(node.right) # 右</span></span><br><span class="line">            <span class="comment">#if node.left:</span></span><br><span class="line">            <span class="comment">#    stack.append(node.left) # 左</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="广搜遍历"><a href="#广搜遍历" class="headerlink" title="广搜遍历"></a>广搜遍历</h3><h4 id="4-二叉树的层序遍历-2"><a href="#4-二叉树的层序遍历-2" class="headerlink" title="4.二叉树的层序遍历(2)"></a>4.<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层序遍历</a>(2)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    q = deque()</span><br><span class="line">    r = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">    q.append(root)</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        t = []</span><br><span class="line">        cnt = len(q)</span><br><span class="line">        <span class="keyword">while</span> cnt != <span class="number">0</span>:</span><br><span class="line">            node = q.popleft()</span><br><span class="line">            t.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                q.append(node.right)</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">        r.append(t)</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<h4 id="5-二叉树的层序遍历-II-2"><a href="#5-二叉树的层序遍历-II-2" class="headerlink" title="5.二叉树的层序遍历 II(2)"></a>5.<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">二叉树的层序遍历 II</a>(2)</h4><blockquote>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    q = deque()</span><br><span class="line">    r = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">    q.append(root)</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        t = []</span><br><span class="line">        cnt = len(q)</span><br><span class="line">        <span class="keyword">while</span> cnt != <span class="number">0</span>:</span><br><span class="line">            node = q.popleft()</span><br><span class="line">            t.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                q.append(node.right)</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> t:</span><br><span class="line">            r.append(t)</span><br><span class="line">    <span class="keyword">return</span> r[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="6-二叉树的右视图-2"><a href="#6-二叉树的右视图-2" class="headerlink" title="6.二叉树的右视图(2)"></a>6.<a href="https://leetcode.cn/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">二叉树的右视图</a>(2)</h4><blockquote>
<p>while cnt != 0时，cnt==1加入结果集即可</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; List[int]:</span></span><br><span class="line">    q = deque()</span><br><span class="line">    r = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">    q.append(root)</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        cnt = len(q)</span><br><span class="line">        <span class="keyword">while</span> cnt != <span class="number">0</span>:</span><br><span class="line">            node = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="number">1</span>:</span><br><span class="line">                r.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                q.append(node.right)</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<h4 id="7-二叉树的层平均值"><a href="#7-二叉树的层平均值" class="headerlink" title="7.二叉树的层平均值"></a>7.<a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">二叉树的层平均值</a></h4><blockquote>
<p>给定一个非空二叉树的根节点 <code>root</code> , 以数组的形式返回每一层节点的平均值。与实际答案相差 <code>10-5</code> 以内的答案可以被接受。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averageOfLevels</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; List[float]:</span></span><br><span class="line">    q = deque()</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    q.append(root)</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        num,cnt = len(q),len(q)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cnt != <span class="number">0</span>:</span><br><span class="line">            node = q.popleft()</span><br><span class="line">            ans += node.val</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                q.append(node.right)</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">        res.append(ans/num)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="8-N-叉树的层序遍历-2"><a href="#8-N-叉树的层序遍历-2" class="headerlink" title="8.N 叉树的层序遍历(2)"></a>8.<a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">N 叉树的层序遍历</a>(2)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    res = []</span><br><span class="line">    q = deque()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    q.append(root)</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        t = []</span><br><span class="line">        l = len(q)</span><br><span class="line">        <span class="keyword">while</span> l != <span class="number">0</span>:</span><br><span class="line">            node = q.popleft()</span><br><span class="line">            t.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.children:</span><br><span class="line">                q.extend(node.children)</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">        res.append(t)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="1-对称二叉树"><a href="#1-对称二叉树" class="headerlink" title="1.对称二叉树"></a>1.<a href="https://leetcode.cn/problems/symmetric-tree/" target="_blank" rel="noopener">对称二叉树</a></h4><blockquote>
<p>迭代</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; bool:</span></span><br><span class="line">    q = deque()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    q.append(root.left)</span><br><span class="line">    q.append(root.right)</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        left = q.popleft()</span><br><span class="line">        right = q.popleft()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right <span class="keyword">or</span> (left.val != right.val):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        q.append(left.left)</span><br><span class="line">        q.append(right.right)</span><br><span class="line">        q.append(left.right)</span><br><span class="line">        q.append(right.left)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>递归</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; bool:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right: <span class="comment"># left,right都不为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right <span class="keyword">or</span> (left.val != right.val):<span class="comment"># left为空,right一定不为空,反之亦然,返回False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> compare(left.left,right.right) <span class="keyword">and</span> compare(left.right,right.left)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> compare(root.left,root.right)</span><br></pre></td></tr></table></figure>
<h4 id="2-二叉树的最大深度"><a href="#2-二叉树的最大深度" class="headerlink" title="2.二叉树的最大深度"></a>2.<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a></h4><blockquote>
<p>递归</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> max(self.maxDepth(root.left),self.maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>迭代</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; int:</span></span><br><span class="line">    q = deque()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    depth = <span class="number">0</span></span><br><span class="line">    q.append(root)</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        cnt = len(q)</span><br><span class="line">        depth += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> cnt != <span class="number">0</span>:</span><br><span class="line">            node = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                q.append(node.right)</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>
<h4 id="3-二叉树的最小深度"><a href="#3-二叉树的最小深度" class="headerlink" title="==3.二叉树的最小深度=="></a>==3.<a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最小深度</a>==</h4><blockquote>
<p>递归</p>
<p>要注意叶子结点的条件，左右子树都为None</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">   	<span class="comment"># 加这两句的原因是防止单独的None结点直接返回0,如[2,null,3,null,4,null,5,null,6]会输出1,正确结果是5</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root.left: </span><br><span class="line">        <span class="keyword">return</span> self.minDepth(root.right) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root.right:</span><br><span class="line">        <span class="keyword">return</span> self.minDepth(root.left) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> min(self.minDepth(root.right),self.minDepth(root.left)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>迭代</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; int:</span></span><br><span class="line">    q = deque()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    depth = <span class="number">0</span></span><br><span class="line">    q.append(root)</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        cnt = len(q)</span><br><span class="line">        depth += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> cnt != <span class="number">0</span>:</span><br><span class="line">            node = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="keyword">return</span> depth</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                q.append(node.right)</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>
<h4 id="4-完全二叉树的节点个数-2"><a href="#4-完全二叉树的节点个数-2" class="headerlink" title="==4.完全二叉树的节点个数(2)=="></a>==4.<a href="https://leetcode.cn/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">完全二叉树的节点个数</a>(2)==</h4><blockquote>
<p>递归：在完全二叉树中，如果递归向左遍历的深度不等于递归向右遍历的深度，则说明不是满二叉树</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countNodes</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    left = root.left</span><br><span class="line">    right = root.right</span><br><span class="line">    depthL,depthR = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> left:</span><br><span class="line">        left = left.left</span><br><span class="line">        depthL += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> right:</span><br><span class="line">        right = right.right</span><br><span class="line">        depthR += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> depthL == depthR:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; depthL) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self.countNodes(root.left) + self.countNodes(root.right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="5-平衡二叉树"><a href="#5-平衡二叉树" class="headerlink" title="==5.平衡二叉树=="></a>==5.<a href="https://leetcode.cn/problems/balanced-binary-tree/" target="_blank" rel="noopener">平衡二叉树</a>==</h4><blockquote>
<ul>
<li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。</li>
<li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。</li>
</ul>
<p><img alt="110.平衡二叉树2" data-src="https://img-blog.csdnimg.cn/20210203155515650.png"></p>
<p>后序遍历</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; bool:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHeight</span><span class="params">(root: Optional[TreeNode])</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftH,rightH = getHeight(root.left),getHeight(root.right)</span><br><span class="line">        <span class="keyword">if</span> leftH == <span class="number">-1</span> <span class="keyword">or</span> rightH == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> abs(leftH-rightH) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> max(leftH,rightH) + <span class="number">1</span></span><br><span class="line">    height = getHeight(root)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> height != <span class="number">-1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="6-二叉树的所有路径"><a href="#6-二叉树的所有路径" class="headerlink" title="6.二叉树的所有路径"></a>6.<a href="https://leetcode.cn/problems/binary-tree-paths/" target="_blank" rel="noopener">二叉树的所有路径</a></h4><blockquote>
<p>隐藏了回溯的过程</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; List[str]:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">path</span><span class="params">(root: Optional[TreeNode],st: str)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            res.append(st + str(root.val))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        path(root.left,st+str(root.val)+<span class="string">"-&gt;"</span>)</span><br><span class="line">        path(root.right,st+str(root.val)+<span class="string">"-&gt;"</span>)</span><br><span class="line">    path(root,<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="7-左叶子之和"><a href="#7-左叶子之和" class="headerlink" title="==7.左叶子之和=="></a>==7.<a href="https://leetcode.cn/problems/sum-of-left-leaves/" target="_blank" rel="noopener">左叶子之和</a>==</h4><blockquote>
<p>递归</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumOfLeftLeaves</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">left</span><span class="params">(node: Optional[TreeNode],flag:int)</span>-&gt;int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> <span class="keyword">not</span> node.left:</span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> node.val</span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> left(node.left,<span class="number">0</span>) + left(node.right,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> left(root.left,<span class="number">0</span>) + left(root.right,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumOfLeftLeaves</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:<span class="keyword">return</span> <span class="number">0</span> <span class="comment"># 要遍历到父节点时，判断左叶子才是要加的和</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.left.left <span class="keyword">and</span> <span class="keyword">not</span> root.left.right:</span><br><span class="line">        left = root.left.val</span><br><span class="line">    <span class="keyword">return</span> left + self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>迭代</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumOfLeftLeaves</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; int:</span></span><br><span class="line">    q = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    q.append(root)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        node = q.pop()</span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.left.left <span class="keyword">and</span> <span class="keyword">not</span> node.left.right:</span><br><span class="line">            res += node.left.val</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            q.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            q.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="8-找树左下角的值-2"><a href="#8-找树左下角的值-2" class="headerlink" title="8.找树左下角的值(2)"></a>8.<a href="https://leetcode.cn/problems/find-bottom-left-tree-value/" target="_blank" rel="noopener">找树左下角的值</a>(2)</h4><blockquote>
<p>迭代</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findBottomLeftValue</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; int:</span></span><br><span class="line">    q = deque()</span><br><span class="line">    q.append(root)</span><br><span class="line">    res = root.val</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        cnt = len(q)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(cnt):</span><br><span class="line">            node = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                res = node.val</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                q.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<blockquote>
<p>递归</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findBottomLeftValue</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; int:</span></span><br><span class="line">    maxDepth = <span class="number">1</span></span><br><span class="line">    val = root.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(root: Optional[TreeNode], depth: int)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> maxDepth,val</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">if</span> maxDepth &lt; depth:</span><br><span class="line">                val = root.val</span><br><span class="line">                maxDepth = depth</span><br><span class="line">        f(root.left, depth + <span class="number">1</span>)</span><br><span class="line">        f(root.right, depth + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    f(root, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> val</span><br></pre></td></tr></table></figure>
<h4 id="9-路径总和"><a href="#9-路径总和" class="headerlink" title="9.路径总和"></a>9.<a href="https://leetcode.cn/problems/path-sum/" target="_blank" rel="noopener">路径总和</a></h4><blockquote>
<p>递归</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: Optional[TreeNode], targetSum: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> targetSum == root.val:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> self.hasPathSum(root.left,targetSum-root.val) <span class="keyword">or</span> self.hasPathSum(root.right,targetSum-root.val)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>迭代</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: Optional[TreeNode], targetSum: int)</span> -&gt; bool:</span></span><br><span class="line">    q = []</span><br><span class="line">    val = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    q.append(root)</span><br><span class="line">    val.append(root.val)</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        node = q.pop()</span><br><span class="line">        va = val.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="keyword">if</span> va == targetSum:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            q.append(node.left)</span><br><span class="line">            val.append(node.left.val+va)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            q.append(node.right)</span><br><span class="line">            val.append(node.right.val+va)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="修改和构造"><a href="#修改和构造" class="headerlink" title="修改和构造"></a>修改和构造</h3><h4 id="1-翻转二叉树"><a href="#1-翻转二叉树" class="headerlink" title="1.翻转二叉树"></a>1.<a href="https://leetcode.cn/problems/invert-binary-tree/" target="_blank" rel="noopener">翻转二叉树</a></h4><blockquote>
<p> 递归法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; Optional[TreeNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    root.left, root.right = root.right, root.left</span><br><span class="line">    self.invertTree(root.left)</span><br><span class="line">    self.invertTree(root.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<blockquote>
<p>迭代法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; Optional[TreeNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    st = []</span><br><span class="line">    st.append(root)</span><br><span class="line">    <span class="keyword">while</span> st:</span><br><span class="line">        node = st.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        node.left,node.right = node.right,node.left</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            st.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            st.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h4 id="2-从前序与中序遍历序列构造二叉树-2"><a href="#2-从前序与中序遍历序列构造二叉树-2" class="headerlink" title="2.从前序与中序遍历序列构造二叉树(2)"></a>2.<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">从前序与中序遍历序列构造二叉树</a>(2)</h4><blockquote>
<p>复习*</p>
<p>前序： 3       9       20 15 7                 p1,p2…pk…..pn</p>
<p>中序： 9       3        15 20 7                 i1,i2,…ik…in</p>
<p>p1和ik相等，p2….pk 对应i1,i2,…,i(k-1)为左子树，p(k+1)….pn对应i(k+1)….in为右子树</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; Optional[TreeNode]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(preLeft,preRight,inLeft,inRight)</span>-&gt;TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> preLeft &gt; preRight:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(preorder[preLeft])</span><br><span class="line">        inRootIndex = mp[preorder[preLeft]]</span><br><span class="line">        inLeftSize = inRootIndex - inLeft</span><br><span class="line">        root.left = build(preLeft+<span class="number">1</span>,preLeft+inLeftSize,inLeft,inRootIndex<span class="number">-1</span>)</span><br><span class="line">        root.right = build(preLeft+inLeftSize+<span class="number">1</span>,preRight,inRootIndex+<span class="number">1</span>,inRight)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    n = len(inorder)</span><br><span class="line">    mp = &#123;element: i <span class="keyword">for</span> i, element <span class="keyword">in</span> enumerate(inorder)&#125;</span><br><span class="line">    <span class="keyword">return</span> build(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 根据下面一题的leetcode题解改编</p>
<p>一定要先构建左子树</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; Optional[TreeNode]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(inLeft,inRight)</span>-&gt;TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> inLeft &gt; inRight:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        rootVal = pre.pop()</span><br><span class="line">        root = TreeNode(rootVal)</span><br><span class="line">        inRootIndex = mp[rootVal]</span><br><span class="line">        root.left = build(inLeft, inRootIndex - <span class="number">1</span>)</span><br><span class="line">        root.right = build(inRootIndex + <span class="number">1</span>, inRight)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    pre = preorder[::<span class="number">-1</span>]</span><br><span class="line">    n = len(inorder)</span><br><span class="line">    mp = &#123;element: i <span class="keyword">for</span> i, element <span class="keyword">in</span> enumerate(inorder)&#125;</span><br><span class="line">    <span class="keyword">return</span> build(<span class="number">0</span>,n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="3-从中序与后序遍历序列构造二叉树-2"><a href="#3-从中序与后序遍历序列构造二叉树-2" class="headerlink" title="3.从中序与后序遍历序列构造二叉树(2)"></a>3.<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">从中序与后序遍历序列构造二叉树</a>(2)</h4><blockquote>
<p>方法和前一题差不多，一定一定要注意递归中的位置是相对的，一开始老是不过是因为用inLeftSize作为左边界(应该是postLeft+inLeftSize)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder: List[int], postorder: List[int])</span> -&gt; Optional[TreeNode]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(inLeft,inRight,postLeft,postRight)</span>-&gt;TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> inLeft &gt; inRight:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(postorder[postRight])</span><br><span class="line">        inRootIndex = mp[postorder[postRight]]</span><br><span class="line">        inLeftSize = inRootIndex - inLeft</span><br><span class="line">        root.left = build(inLeft,inRootIndex<span class="number">-1</span>,postLeft,postLeft+inLeftSize<span class="number">-1</span>)</span><br><span class="line">        root.right = build(inRootIndex+<span class="number">1</span>,inRight,postLeft+inLeftSize,postRight<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    n = len(inorder)</span><br><span class="line">    mp = &#123;ele:i <span class="keyword">for</span> i,ele <span class="keyword">in</span> enumerate(inorder)&#125;</span><br><span class="line">    <span class="keyword">return</span> build(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p> leetcode题解：一定要注意先构建右子树，因为每次会postorder.pop，若先构建左子树，pop的元素不对</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder: List[int], postorder: List[int])</span> -&gt; Optional[TreeNode]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(inLeft,inRight)</span>-&gt;TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> inLeft &gt; inRight:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        rootVal = postorder.pop()</span><br><span class="line">        root = TreeNode(rootVal)</span><br><span class="line">        inRootIndex = mp[rootVal]</span><br><span class="line">        root.right = build(inRootIndex+<span class="number">1</span>,inRight)</span><br><span class="line">        root.left = build(inLeft,inRootIndex<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    n = len(inorder)</span><br><span class="line">    mp = &#123;ele:i <span class="keyword">for</span> i,ele <span class="keyword">in</span> enumerate(inorder)&#125;</span><br><span class="line">    <span class="keyword">return</span> build(<span class="number">0</span>,n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="4-从前序与后序遍历序列构造二叉树"><a href="#4-从前序与后序遍历序列构造二叉树" class="headerlink" title="4.从前序与后序遍历序列构造二叉树"></a>4.从前序与后序遍历序列构造二叉树</h4><blockquote>
<p>前序和后序不能确定一棵二叉树</p>
<p><a href="https://blog.csdn.net/weixin_38853761/article/details/107491173" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38853761/article/details/107491173</a></p>
</blockquote>
<h4 id="5-最大二叉树-2"><a href="#5-最大二叉树-2" class="headerlink" title="5.==最大二叉树==(2)"></a>5.==<a href="https://leetcode.cn/problems/maximum-binary-tree/" target="_blank" rel="noopener">最大二叉树</a>==(2)</h4><blockquote>
<p>递归：O(n^2)，可能每次去最大值都在两边</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span><span class="params">(self, nums: List[int])</span> -&gt; Optional[TreeNode]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMax</span><span class="params">(left:int,right:int)</span>-&gt;int:</span></span><br><span class="line">        mx = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(left,right+<span class="number">1</span>):</span><br><span class="line">            mx = max(mx,nums[i])</span><br><span class="line">        <span class="keyword">return</span> mx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(left:int,right:int)</span>-&gt;Optional[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mx = findMax(left, right)</span><br><span class="line">        mx_index = mp[mx]</span><br><span class="line">        root = TreeNode(mx)</span><br><span class="line">        root.left = helper(left,mx_index<span class="number">-1</span>)</span><br><span class="line">        root.right = helper(mx_index+<span class="number">1</span>,right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    mp = &#123;ele:i <span class="keyword">for</span> i,ele <span class="keyword">in</span> enumerate(nums)&#125;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span><span class="params">(self, nums: List[int])</span> -&gt; Optional[TreeNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    mx = max(nums)</span><br><span class="line">    index = nums.index(mx)</span><br><span class="line">    root = TreeNode(mx)</span><br><span class="line">    left = nums[:index]</span><br><span class="line">    right = nums[index+<span class="number">1</span>:]</span><br><span class="line">    root.left = self.constructMaximumBinaryTree(left)</span><br><span class="line">    root.right = self.constructMaximumBinaryTree(right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<blockquote>
<p>单调栈：O(n)</p>
<p>单调栈降序排列，当前元素小于栈顶元素，不停更新左子树；之后，队列不为空，更新栈顶元素的右子树</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span><span class="params">(self, nums: List[int])</span> -&gt; Optional[TreeNode]:</span></span><br><span class="line">    q = []</span><br><span class="line">    n = len(nums)</span><br><span class="line">    tree = [<span class="literal">None</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        tree[i] = TreeNode(nums[i])</span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt; nums[q[<span class="number">-1</span>]]:</span><br><span class="line">            tree[i].left = tree[q[<span class="number">-1</span>]]</span><br><span class="line">            q.pop()</span><br><span class="line">        <span class="keyword">if</span> q:</span><br><span class="line">            tree[q[<span class="number">-1</span>]].right = tree[i]</span><br><span class="line">        q.append(i)</span><br><span class="line">    <span class="keyword">return</span> tree[q[<span class="number">0</span>]]</span><br></pre></td></tr></table></figure>
<h4 id="6-合并二叉树"><a href="#6-合并二叉树" class="headerlink" title="6.合并二叉树"></a>6.<a href="https://leetcode.cn/problems/merge-two-binary-trees/" target="_blank" rel="noopener">合并二叉树</a></h4><blockquote>
<p>递归</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span><span class="params">(self, root1: Optional[TreeNode], root2: Optional[TreeNode])</span> -&gt; Optional[TreeNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root1:</span><br><span class="line">        <span class="keyword">return</span> root2</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root2:</span><br><span class="line">        <span class="keyword">return</span> root1</span><br><span class="line">    merge = TreeNode(root1.val+root2.val)</span><br><span class="line">    merge.left = self.mergeTrees(root1.left,root2.left)</span><br><span class="line">    merge.right = self.mergeTrees(root1.right,root2.right)</span><br><span class="line">    <span class="keyword">return</span> merge</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><blockquote>
<p>性质：</p>
<p>1.中序遍历为递增</p>
</blockquote>
<h4 id="1-二叉搜索树中的搜索"><a href="#1-二叉搜索树中的搜索" class="headerlink" title="1.二叉搜索树中的搜索"></a>1.<a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树中的搜索</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchBST</span><span class="params">(self, root: Optional[TreeNode], val: int)</span> -&gt; Optional[TreeNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> root.val == val:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">elif</span> root.val &gt; val:</span><br><span class="line">        <span class="keyword">return</span> self.searchBST(root.left,val)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> self.searchBST(root.right,val)</span><br></pre></td></tr></table></figure>
<h4 id="2-验证二叉搜索树-2"><a href="#2-验证二叉搜索树-2" class="headerlink" title="==2.验证二叉搜索树(2)=="></a>==2.<a href="https://leetcode.cn/problems/validate-binary-search-tree/" target="_blank" rel="noopener">验证二叉搜索树</a>(2)==</h4><blockquote>
<p>先中序遍历获取路径，看看是不是递增的</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; bool:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root: Optional[TreeNode])</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        helper(root.left)</span><br><span class="line">        path.append(root.val)</span><br><span class="line">        helper(root.right)</span><br><span class="line">    </span><br><span class="line">    path = []</span><br><span class="line">    helper(root)</span><br><span class="line">    n = len(path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> path <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        <span class="keyword">if</span> path[i<span class="number">-1</span>] &gt;= path[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>每个节点的值都有上限和下限</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; bool:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">help</span><span class="params">(root,lower,upper)</span>-&gt;bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        val = root.val</span><br><span class="line">        <span class="keyword">if</span> val &lt;= lower <span class="keyword">or</span> val &gt;= upper:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> help(root.left,lower,val) <span class="keyword">and</span> help(root.right,val,upper)</span><br><span class="line">    <span class="keyword">return</span> help(root,float(<span class="string">"-inf"</span>),float(<span class="string">"inf"</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>自己想的，根据下面第三题的第三个方法改编而成</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; bool:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> pre</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        left = dfs(root.left)</span><br><span class="line">        <span class="keyword">if</span> pre &lt; root.val:</span><br><span class="line">            pre = root.val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        right = dfs(root.right)</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">and</span> right</span><br><span class="line">    pre = float(<span class="string">"-inf"</span>)</span><br><span class="line">    res = dfs(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="3-二叉搜索树的最小绝对差"><a href="#3-二叉搜索树的最小绝对差" class="headerlink" title="3.二叉搜索树的最小绝对差"></a>3.<a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">二叉搜索树的最小绝对差</a></h4><blockquote>
<p>分别找以root、root.left、root.right为中心的最小绝对差</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMinimumDifference</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mi</span><span class="params">(root: Optional[TreeNode])</span>-&gt;int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">while</span> root.left:</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">return</span> root.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mx</span><span class="params">(root: Optional[TreeNode])</span>-&gt;int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">while</span> root.right:</span><br><span class="line">            root = root.right</span><br><span class="line">        <span class="keyword">return</span> root.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> float(<span class="string">'inf'</span>)</span><br><span class="line">    min_left = abs(root.val - mx(root.left))</span><br><span class="line">    min_right = abs(mi(root.right) - root.val)</span><br><span class="line"></span><br><span class="line">    m_root = min(min_left,min_right)</span><br><span class="line">    m_left = self.getMinimumDifference(root.left)</span><br><span class="line">    m_right = self.getMinimumDifference(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min(m_root,m_left,m_right)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>根据二叉搜索树的性质，中序遍历递增有序，知道其他任意间隔距离大于等于 2 的下标对 (i,j) 的元素之差一定大于下标对 (i,i+1)的元素之差，故不需要再被考虑。</p>
<p>使用中序遍历求出二叉搜索树递增的路径，之后遍历找出结果（迭代写法）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMinimumDifference</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root: Optional[TreeNode])</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        helper(root.left)</span><br><span class="line">        path.append(root.val)</span><br><span class="line">        helper(root.right)</span><br><span class="line">    </span><br><span class="line">    path = []</span><br><span class="line">    helper(root)</span><br><span class="line">    n = len(path)</span><br><span class="line">    res = float(<span class="string">'inf'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        res = min(res,path[i]-path[i<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<blockquote>
<p>递归写法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMinimumDifference</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root: Optional[TreeNode])</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> pre,mi</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        helper(root.left)</span><br><span class="line">        <span class="keyword">if</span> pre == <span class="number">-1</span>:</span><br><span class="line">            pre = root.val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mi = min(mi,root.val-pre)</span><br><span class="line">            pre = root.val</span><br><span class="line">        helper(root.right)</span><br><span class="line"></span><br><span class="line">    mi = float(<span class="string">'inf'</span>)</span><br><span class="line">    pre = <span class="number">-1</span></span><br><span class="line">    helper(root)</span><br><span class="line">    <span class="keyword">return</span> mi</span><br></pre></td></tr></table></figure>
<h4 id="4-二叉搜索树中的众数"><a href="#4-二叉搜索树中的众数" class="headerlink" title="4.二叉搜索树中的众数"></a>4.<a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树中的众数</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMode</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root: Optional[TreeNode])</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">nonlocal</span> pre_cnt,m,m_cnt,pre</span><br><span class="line">        helper(root.left)</span><br><span class="line">        <span class="keyword">if</span> pre == root.val:</span><br><span class="line">            pre_cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre_cnt = <span class="number">1</span></span><br><span class="line">        pre = root.val</span><br><span class="line">        <span class="keyword">if</span> pre_cnt == m_cnt:</span><br><span class="line">            m.append(pre)</span><br><span class="line">        <span class="keyword">elif</span> pre_cnt &gt; m_cnt:</span><br><span class="line">            m = [pre]</span><br><span class="line">        m_cnt = max(m_cnt, pre_cnt)</span><br><span class="line">        helper(root.right)</span><br><span class="line"></span><br><span class="line">    m,m_cnt,pre,pre_cnt = [],<span class="number">0</span>,root.val,<span class="number">0</span></span><br><span class="line">    helper(root)</span><br><span class="line">    <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure>
<blockquote>
<p>中序遍历的方法很像上一题</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMode</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            dfs(root.left)</span><br><span class="line">            path.append(root.val)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        path = []</span><br><span class="line">        dfs(root)</span><br><span class="line">        n = len(path)</span><br><span class="line">        m_cnt,cnt,res = <span class="number">1</span>,<span class="number">1</span>,[path[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> path[i] == path[i<span class="number">-1</span>]:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt == m_cnt:</span><br><span class="line">                res.append(path[i])</span><br><span class="line">            <span class="keyword">elif</span> cnt &gt; m_cnt:</span><br><span class="line">                res = [path[i]]</span><br><span class="line">                m_cnt = cnt</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="5-二叉树的最近公共祖先-2"><a href="#5-二叉树的最近公共祖先-2" class="headerlink" title="==5.二叉树的最近公共祖先(2)=="></a>==5.<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">二叉树的最近公共祖先</a>(2)==</h4><blockquote>
<p>找到结果后，立即返回：</p>
<p><img alt="236.二叉树的最近公共祖先" data-src="https://img-blog.csdnimg.cn/2021020415105872.png"></p>
<p>左子树或右子树没有p或q，就返回None</p>
<p>左右子树都含有p或q，就返回root</p>
<p>左子树含有p和q，右子树一个没有，返回左子树；反之亦然</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">    <span class="keyword">if</span> root == q <span class="keyword">or</span> root == p <span class="keyword">or</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    left = self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">    right = self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> left:</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<h4 id="6-二叉搜索树的最近公共祖先-2"><a href="#6-二叉搜索树的最近公共祖先-2" class="headerlink" title="6.二叉搜索树的最近公共祖先(2)"></a>6.<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树的最近公共祖先</a>(2)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">        right = self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">        <span class="keyword">if</span> right:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">    <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">        left = self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">        <span class="keyword">return</span> self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">    <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">        <span class="keyword">return</span> self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<blockquote>
<p>迭代</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> p.val &gt; root.val <span class="keyword">and</span> q.val &gt; root.val:</span><br><span class="line">            root = root.right</span><br><span class="line">        <span class="keyword">elif</span> p.val &lt; root.val <span class="keyword">and</span> q.val &lt; root.val:</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h4 id="7-二叉搜索树中的插入操作-2"><a href="#7-二叉搜索树中的插入操作-2" class="headerlink" title="7.二叉搜索树中的插入操作(2)"></a>7.<a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树中的插入操作</a>(2)</h4><blockquote>
<p>按照二叉搜索树的方法遍历，找到Null的结点直接插入就行</p>
<p>算法时间复杂度是O(logn)，最坏的情况，二叉搜索树退化为链表，为O(n)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span><span class="params">(self, root: Optional[TreeNode], val: int)</span> -&gt; Optional[TreeNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">    res = root</span><br><span class="line">    <span class="keyword">while</span> root:</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left:</span><br><span class="line">                root.left = TreeNode(val)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = root.left</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                root.right = TreeNode(val)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = root.right</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<blockquote>
<p>递归</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span><span class="params">(self, root: Optional[TreeNode], val: int)</span> -&gt; Optional[TreeNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">    <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">        root.left = self.insertIntoBST(root.left,val)</span><br><span class="line">    <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">        root.right = self.insertIntoBST(root.right,val)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h4 id="8-删除二叉搜索树中的节点-2"><a href="#8-删除二叉搜索树中的节点-2" class="headerlink" title="8.删除二叉搜索树中的节点(2)"></a>8.<a href="https://leetcode.cn/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">删除二叉搜索树中的节点</a>(2)</h4><blockquote>
<p>中序遍历获取二叉搜索树所有元素，然后二分查找找到相应元素就删除，最后递归构造二叉搜索树</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, root: Optional[TreeNode], key: int)</span> -&gt; Optional[TreeNode]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(root: Optional[TreeNode])</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        trace(root.left)</span><br><span class="line">        li.append(root.val)</span><br><span class="line">        trace(root.right)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(l,r)</span>-&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> l &gt; r:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = l+r &gt;&gt; <span class="number">1</span></span><br><span class="line">        rt = TreeNode(li[mid])</span><br><span class="line">        rt.left = build(l,mid<span class="number">-1</span>)</span><br><span class="line">        rt.right = build(mid+<span class="number">1</span>,r)</span><br><span class="line">        <span class="keyword">return</span> rt</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(key: int,li)</span>-&gt;bool:</span></span><br><span class="line">        n = len(li)</span><br><span class="line">        l,r = <span class="number">0</span>,n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = l + r &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> li[mid] &gt; key:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> li[mid] &lt; key:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    li = []</span><br><span class="line">    trace(root)</span><br><span class="line">    <span class="keyword">if</span> find(key,li):</span><br><span class="line">        li.remove(key)</span><br><span class="line">    <span class="keyword">return</span> build(<span class="number">0</span>,len(li)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>递归</p>
<p>找到目标节点后，将目标节点的右子树最左边结点左子树设置为目标节点的左子树，然后将右子树(将目标节点设置为右子树)返回</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, root: Optional[TreeNode], key: int)</span> -&gt; Optional[TreeNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> root.val &lt; key:</span><br><span class="line">        root.right = self.deleteNode(root.right,key)</span><br><span class="line">    <span class="keyword">elif</span> root.val &gt; key:</span><br><span class="line">        root.left = self.deleteNode(root.left,key)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left: <span class="keyword">return</span> root.right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.right: <span class="keyword">return</span> root.left</span><br><span class="line">        node = root.right</span><br><span class="line">        <span class="keyword">while</span> node.left:</span><br><span class="line">            node = node.left</span><br><span class="line">        node.left = root.left</span><br><span class="line">        root = root.right</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h4 id="9-修剪二叉搜索树-2"><a href="#9-修剪二叉搜索树-2" class="headerlink" title="9.修剪二叉搜索树(2)"></a>9.<a href="https://leetcode.cn/problems/trim-a-binary-search-tree/" target="_blank" rel="noopener">修剪二叉搜索树</a>(2)</h4><blockquote>
<p>[L,R]总是偏向中间，两头的元素很可能不在区间内</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trimBST</span><span class="params">(self, root: Optional[TreeNode], low: int, high: int)</span> -&gt; Optional[TreeNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> root.val &lt; low:</span><br><span class="line">        <span class="keyword">return</span> self.trimBST(root.right,low,high)</span><br><span class="line">    <span class="keyword">elif</span> root.val &gt; high:</span><br><span class="line">        <span class="keyword">return</span> self.trimBST(root.left,low,high)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        root.left = self.trimBST(root.left,low,high)</span><br><span class="line">        root.right = self.trimBST(root.right,low,high)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<blockquote>
<p>迭代</p>
<p>处理二叉搜索树左子树&lt;L的情况：</p>
<p><img alt="669.修剪二叉搜索树1" data-src="https://img-blog.csdnimg.cn/20210204155327203.png"></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trimBST</span><span class="params">(self, root: Optional[TreeNode], low: int, high: int)</span> -&gt; Optional[TreeNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> root <span class="keyword">and</span> (root.val &gt; high <span class="keyword">or</span> root.val &lt; low):</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; high:</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root = root.right</span><br><span class="line">    cur = root</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="keyword">while</span> cur.left <span class="keyword">and</span> cur.left.val &lt; low:</span><br><span class="line">            cur.left = cur.left.right</span><br><span class="line">        cur = cur.left</span><br><span class="line"></span><br><span class="line">    cur = root</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="keyword">while</span> cur.right <span class="keyword">and</span> cur.right.val &gt; high:</span><br><span class="line">            cur.right = cur.right.left</span><br><span class="line">        cur = cur.right</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h4 id="10-将有序数组转换为二叉搜索树"><a href="#10-将有序数组转换为二叉搜索树" class="headerlink" title="10.将有序数组转换为二叉搜索树"></a>10.<a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">将有序数组转换为二叉搜索树</a></h4><blockquote>
<p>递归</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: List[int])</span> -&gt; Optional[TreeNode]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(l,r)</span>-&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> l &gt; r:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = l+r &gt;&gt; <span class="number">1</span></span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line">        root.left = helper(l,mid<span class="number">-1</span>)</span><br><span class="line">        root.right = helper(mid+<span class="number">1</span>,r)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="11-把二叉搜索树转换为累加树-2"><a href="#11-把二叉搜索树转换为累加树-2" class="headerlink" title="11.把二叉搜索树转换为累加树(2)"></a>11.<a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">把二叉搜索树转换为累加树</a>(2)</h4><blockquote>
<p>使用右中左的遍历顺序，正好符合本题题意</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convertBST</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; Optional[TreeNode]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(root: Optional[TreeNode])</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> sum</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        trace(root.right)</span><br><span class="line">        sum += root.val</span><br><span class="line">        root.val = sum</span><br><span class="line">        trace(root.left)</span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    trace(root)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img alt="img" data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211030125421.png"></p>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="1-组合-2"><a href="#1-组合-2" class="headerlink" title="1.组合(2)"></a>1.<a href="https://leetcode.cn/problems/combinations/" target="_blank" rel="noopener">组合</a>(2)</h3><blockquote>
<p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>
<ol>
<li>已经选择的元素个数：path.size();</li>
<li>所需需要的元素个数为: k - path.size();</li>
<li>列表中剩余元素（n-i） &gt;= 所需需要的元素个数（k - path.size()）</li>
<li>在集合n中至多要从该起始位置 : i &lt;= n - (k - path.size()) + 1，即i &lt; n - (k - path.size()) + 2开始遍历</li>
</ol>
<p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n: int, k: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(path:List[int],start:int)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(path) &gt;= k:</span><br><span class="line">            res.append(path.copy())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># for i in range(start,n+1):</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 剪枝,因为n=4,k=4,其实都不需要从2开始遍历了</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,n - (k - len(path)) + <span class="number">2</span>):</span><br><span class="line">                path.append(i)</span><br><span class="line">                dfs(path,i+<span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">    res = []</span><br><span class="line">    dfs(path=[],start=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="2-组合总和-III-2"><a href="#2-组合总和-III-2" class="headerlink" title="2.组合总和 III(2)"></a>2.<a href="https://leetcode.cn/problems/combination-sum-iii/" target="_blank" rel="noopener">组合总和 III</a>(2)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span><span class="params">(self, k: int, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(temp:List[int],k: int,n: int,pre: int)</span>:</span></span><br><span class="line">            <span class="comment"># 剪枝:到这个剪枝说明几个数都太小了,到了k的深度,总和还是不等于n(应该是小于n)</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">and</span> n != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">and</span> k == <span class="number">0</span>:</span><br><span class="line">                res.append(temp.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(pre,<span class="number">10</span>):</span><br><span class="line">                    temp.append(i)</span><br><span class="line">                    <span class="comment"># 剪枝:如果当前数i加入已经超过n了,那么之后的都不需要遍历了</span></span><br><span class="line">                    <span class="keyword">if</span> n - i &lt; <span class="number">0</span>:</span><br><span class="line">                        temp.pop()</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    dfs(temp,k - <span class="number">1</span>,n - i,i+<span class="number">1</span>)</span><br><span class="line">                    temp.pop()</span><br><span class="line"></span><br><span class="line">        dfs([],k,n,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="3-电话号码的字母组合-2"><a href="#3-电话号码的字母组合-2" class="headerlink" title="3.电话号码的字母组合(2)"></a>3.<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">电话号码的字母组合</a>(2)</h3><blockquote>
<p>多个集合取组合，各个集合之间相互不影响，那么就不用startIndex</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> digits == <span class="string">""</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        mp = &#123;&#125;</span><br><span class="line">        mp[<span class="number">2</span>] = <span class="string">"abc"</span></span><br><span class="line">        mp[<span class="number">3</span>] = <span class="string">"def"</span></span><br><span class="line">        mp[<span class="number">4</span>] = <span class="string">"ghi"</span></span><br><span class="line">        mp[<span class="number">5</span>] = <span class="string">"jkl"</span></span><br><span class="line">        mp[<span class="number">6</span>] = <span class="string">"mno"</span></span><br><span class="line">        mp[<span class="number">7</span>] = <span class="string">"pqrs"</span></span><br><span class="line">        mp[<span class="number">8</span>] = <span class="string">"tuv"</span></span><br><span class="line">        mp[<span class="number">9</span>] = <span class="string">"wxyz"</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(st:str,pos:int)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(st) == len(digits):</span><br><span class="line">                res.append(st)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> s <span class="keyword">in</span> mp[int(digits[pos])]:</span><br><span class="line">                    dfs(st+s,pos+<span class="number">1</span>)</span><br><span class="line">        dfs(<span class="string">""</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="4-组合总和-2"><a href="#4-组合总和-2" class="headerlink" title="4.组合总和(2)"></a>4.<a href="https://leetcode.cn/problems/combination-sum/" target="_blank" rel="noopener">组合总和</a>(2)</h3><blockquote>
<p>剪枝+设置下次递归的起点</p>
<p>和第2题相似，但有所不同，这里可以重复使用</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(arr:List[int],target,start:int)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> target == <span class="number">0</span>:</span><br><span class="line">            res.append(arr.copy())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,len(candidates)):</span><br><span class="line">                arr.append(candidates[i])</span><br><span class="line">                dfs(arr,target - candidates[i],i)</span><br><span class="line">                arr.pop()</span><br><span class="line">    dfs([],target,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="5-组合总和-II-2"><a href="#5-组合总和-II-2" class="headerlink" title="5.组合总和 II(2)"></a>5.<a href="https://leetcode.cn/problems/combination-sum-ii/" target="_blank" rel="noopener">组合总和 II</a>(2)</h3><blockquote>
<p>注意  使用used数组排除(剪枝)同一树层的元素</p>
<p>==同一树层不允许出现同一个数，但是同一深度上可以出现同一个数==</p>
<p>本题和组合总和II的区别就是candidates中的数会重复</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    res = []</span><br><span class="line">    candidates.sort()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(arr: List[int], tar, start: int,used:List[bool])</span>:</span></span><br><span class="line">        <span class="keyword">if</span> tar &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> tar == <span class="number">0</span>:</span><br><span class="line">            res.append(arr.copy())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(candidates)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> candidates[i] == candidates[i<span class="number">-1</span>] <span class="keyword">and</span> used[i<span class="number">-1</span>] <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                arr.append(candidates[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line">                dfs(arr, tar - candidates[i], i + <span class="number">1</span>,used)</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br><span class="line">                arr.pop()</span><br><span class="line">    used = [<span class="literal">False</span>]*len(candidates)</span><br><span class="line">    dfs([], target, <span class="number">0</span>,used)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用map</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(path,tar,start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> tar == <span class="number">0</span>:</span><br><span class="line">            res.append(path.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> tar &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mp = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,len(candidates)):</span><br><span class="line">                <span class="keyword">if</span> candidates[i] <span class="keyword">in</span> mp:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                mp[candidates[i]] = <span class="literal">True</span></span><br><span class="line">                path.append(candidates[i])</span><br><span class="line">                dfs(path,tar-candidates[i],i+<span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">    res = []</span><br><span class="line">    candidates.sort()</span><br><span class="line">    dfs([],target,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="6-分割回文串-2"><a href="#6-分割回文串-2" class="headerlink" title="6.分割回文串(2)"></a>6.<a href="https://leetcode.cn/problems/palindrome-partitioning/" target="_blank" rel="noopener">分割回文串</a>(2)</h3><blockquote>
<p>回溯+记忆化过程</p>
<p><img alt="131.分割回文串" data-src="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg"></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s: str)</span> -&gt; List[List[str]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(st:str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> st <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">return</span> memo[st]</span><br><span class="line">        l,r = <span class="number">0</span>,len(st) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            <span class="keyword">if</span> st[l] != st[r]:</span><br><span class="line">                memo[st] = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        memo[st] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(path:List[str],start:int)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt;= len(s):</span><br><span class="line">            res.append(path.copy())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,len(s)):</span><br><span class="line">                temp = s[start:i+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> helper(temp):</span><br><span class="line">                    path.append(temp)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dfs(path,i + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">    memo = &#123;&#125;</span><br><span class="line">    res = []</span><br><span class="line">    dfs([],<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="7-复原-IP-地址-2"><a href="#7-复原-IP-地址-2" class="headerlink" title="7.复原 IP 地址(2)"></a>7.<a href="https://leetcode.cn/problems/restore-ip-addresses/" target="_blank" rel="noopener">复原 IP 地址</a>(2)</h3><blockquote>
<p><img alt="93.复原IP地址" data-src="https://img-blog.csdnimg.cn/20201123203735933.png"></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(st:str,start:int,k:int)</span>:</span></span><br><span class="line">        l = n - start</span><br><span class="line">        <span class="comment"># k == 4 并且 st长度==s长度+4(因为有4个点)</span></span><br><span class="line">        <span class="keyword">if</span> k &gt;= <span class="number">4</span> <span class="keyword">and</span> len(st) == n + <span class="number">4</span>:</span><br><span class="line">            res.append(st[:<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 判断剩余的字符串能否组成IP地址</span></span><br><span class="line">        <span class="keyword">if</span> l &lt; (<span class="number">4</span> - k) <span class="keyword">or</span> l &gt; (<span class="number">4</span> - k) * <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start,len(s)):</span><br><span class="line">            temp = s[start:i+<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 剪枝：IP地址分串长度大于3  且  数值大小小于等于255</span></span><br><span class="line">            <span class="keyword">if</span> i - start + <span class="number">1</span> &gt; <span class="number">3</span> <span class="keyword">or</span> int(temp) &gt; <span class="number">255</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 判断首位不是'0'</span></span><br><span class="line">            <span class="keyword">if</span> len(temp) &gt; <span class="number">1</span> <span class="keyword">and</span> temp[<span class="number">0</span>] == <span class="string">'0'</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            dfs(st+temp+<span class="string">"."</span>,i+<span class="number">1</span>,k+<span class="number">1</span>)</span><br><span class="line">    res = []</span><br><span class="line">    n = len(s)</span><br><span class="line">    dfs(<span class="string">""</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="8-子集-2"><a href="#8-子集-2" class="headerlink" title="8.子集(2)"></a>8.<a href="https://leetcode.cn/problems/subsets/" target="_blank" rel="noopener">子集</a>(2)</h3><blockquote>
<p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<p>自己的解法：可以看做是一棵二叉树，选还是不选（0或1）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(r:List[int],k:int)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k &gt;= n:</span><br><span class="line">            res.append(r.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                dfs(r,k+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r.append(nums[k])</span><br><span class="line">                dfs(r,k+<span class="number">1</span>)</span><br><span class="line">                r.pop()</span><br><span class="line">    n = len(nums)</span><br><span class="line">    res = []</span><br><span class="line">    dfs([],<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<blockquote>
<p>题解</p>
<p><img alt="78.子集" data-src="https://img-blog.csdnimg.cn/202011232041348.png"></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start:int,r:List[int])</span>:</span></span><br><span class="line">        res.append(r.copy())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start,n):</span><br><span class="line">            r.append(nums[i])</span><br><span class="line">            dfs(i+<span class="number">1</span>,r)</span><br><span class="line">            r.pop()</span><br><span class="line">    res = []</span><br><span class="line">    n = len(nums)</span><br><span class="line">    dfs(<span class="number">0</span>,[])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="9-子集-II-2"><a href="#9-子集-II-2" class="headerlink" title="9.子集 II(2)"></a>9.<a href="https://leetcode.cn/problems/subsets-ii/" target="_blank" rel="noopener">子集 II</a>(2)</h3><blockquote>
<p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p>
<p>剪枝策略类比5.组合总和II</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(r:List[int],start:int,used:List[bool])</span>:</span></span><br><span class="line">        res.append(r.copy())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start,n):</span><br><span class="line">            <span class="comment"># used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span></span><br><span class="line">    		<span class="comment"># used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> used[i - <span class="number">1</span>] <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            r.append(nums[i])</span><br><span class="line">            dfs(r,i+<span class="number">1</span>,used)</span><br><span class="line">            r.pop()</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    res = []</span><br><span class="line">    n = len(nums)</span><br><span class="line">    used = [<span class="literal">False</span>]*n</span><br><span class="line">    dfs([],<span class="number">0</span>,used)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考第十题，可以发现本题的used只是第十题map的一种特例。</p>
<p>本质上都是要本树层不能有相同元素，但是同树根能有相同元素</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(r:List[int],start:int)</span>:</span></span><br><span class="line">        res.append(r.copy())</span><br><span class="line">        mp = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> mp:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            mp[nums[i]] = <span class="literal">True</span></span><br><span class="line">            r.append(nums[i])</span><br><span class="line">            dfs(r,i+<span class="number">1</span>)</span><br><span class="line">            r.pop()</span><br><span class="line">    nums.sort()</span><br><span class="line">    res = []</span><br><span class="line">    n = len(nums)</span><br><span class="line">    dfs([],<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="10-递增子序列-2"><a href="#10-递增子序列-2" class="headerlink" title="==10.递增子序列(2)=="></a>==10.<a href="https://leetcode.cn/problems/non-decreasing-subsequences/" target="_blank" rel="noopener">递增子序列</a>(2)==</h3><blockquote>
<p>使用map记录同一树层的元素</p>
<p><img alt="491. 递增子序列1" data-src="https://img-blog.csdnimg.cn/20201124200229824.png"></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSubsequences</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start:int,r:List[int],pre:int)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(r) &gt;= <span class="number">2</span>:</span><br><span class="line">            res.append(r.copy())</span><br><span class="line">        mp = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; pre:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> mp:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            mp[nums[i]] = <span class="literal">True</span></span><br><span class="line">            r.append(nums[i])</span><br><span class="line">            dfs(i+<span class="number">1</span>,r,nums[i])</span><br><span class="line">            r.pop()</span><br><span class="line">    n = len(nums)</span><br><span class="line">    res = []</span><br><span class="line">    dfs(<span class="number">0</span>,[],<span class="number">-200</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="11-全排列-2"><a href="#11-全排列-2" class="headerlink" title="11.全排列(2)"></a>11.<a href="https://leetcode.cn/problems/permutations/" target="_blank" rel="noopener">全排列</a>(2)</h3><blockquote>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p><img alt="46.全排列" data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png"></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(use,k:int,r:List[int])</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k &gt;= n:</span><br><span class="line">            res.append(r.copy())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">            <span class="keyword">if</span> used[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            r.append(nums[i])</span><br><span class="line">            use[i] = <span class="literal">True</span></span><br><span class="line">            dfs(use,k+<span class="number">1</span>,r)</span><br><span class="line">            use[i] = <span class="literal">False</span></span><br><span class="line">            r.pop()</span><br><span class="line"></span><br><span class="line">    res = []</span><br><span class="line">    n = len(nums)</span><br><span class="line">    used = [<span class="literal">False</span>]*n</span><br><span class="line">    dfs(used,<span class="number">0</span>,[])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="12-全排列-II-2"><a href="#12-全排列-II-2" class="headerlink" title="12.全排列 II(2)"></a>12.<a href="https://leetcode.cn/problems/permutations-ii/" target="_blank" rel="noopener">全排列 II</a>(2)</h3><blockquote>
<p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong><em>按任意顺序</em></strong> 返回所有不重复的全排列。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(k:int,use:List[bool],r:List[int])</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k &gt;= n:</span><br><span class="line">            res.append(r.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mp = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">            <span class="keyword">if</span> used[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> mp:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            mp[nums[i]] = <span class="literal">True</span></span><br><span class="line">            r.append(nums[i])</span><br><span class="line">            use[i] = <span class="literal">True</span></span><br><span class="line">            dfs(k + <span class="number">1</span>,use, r)</span><br><span class="line">            use[i] = <span class="literal">False</span></span><br><span class="line">            r.pop()</span><br><span class="line"></span><br><span class="line">    nums.sort()</span><br><span class="line">    n = len(nums)</span><br><span class="line">    used = [<span class="literal">False</span>]*n</span><br><span class="line">    res = []</span><br><span class="line">    dfs(<span class="number">0</span>,used,[])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="13-重新安排行程-3"><a href="#13-重新安排行程-3" class="headerlink" title="13.重新安排行程(3)"></a>13.<a href="https://leetcode.cn/problems/reconstruct-itinerary/" target="_blank" rel="noopener">重新安排行程</a>(3)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findItinerary</span><span class="params">(self, tickets: List[List[str]])</span> -&gt; List[str]:</span></span><br><span class="line">    tickets_map = defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> ticket <span class="keyword">in</span> tickets:</span><br><span class="line">        tickets_map[ticket[<span class="number">0</span>]].append(ticket[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(res) == len(tickets) + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">       	<span class="comment"># 排序：题目要求按字典序大小返回结果</span></span><br><span class="line">        tickets_map[start].sort()</span><br><span class="line">        <span class="comment"># 遍历tickets_map会随他自己本身的改变而改变</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> tickets_map[start]:</span><br><span class="line">            <span class="comment"># 防止出现死循环</span></span><br><span class="line">            end = tickets_map[start].pop(<span class="number">0</span>)</span><br><span class="line">            res.append(end)</span><br><span class="line">            <span class="keyword">if</span> dfs(end):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            res.pop()</span><br><span class="line">            <span class="comment"># 注意：再添加进来的话,就不是第一个元素了</span></span><br><span class="line">            tickets_map[start].append(end)</span><br><span class="line"></span><br><span class="line">    res = [<span class="string">"JFK"</span>]</span><br><span class="line">    dfs(<span class="string">"JFK"</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="14-N-皇后-3"><a href="#14-N-皇后-3" class="headerlink" title="14.N 皇后(3)"></a>14.<a href="https://leetcode.cn/problems/n-queens/" target="_blank" rel="noopener">N 皇后</a>(3)</h3><blockquote>
<p>以前的解法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n: int)</span> -&gt; List[List[str]]:</span></span><br><span class="line">    graph = [[<span class="string">'.'</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judge</span><span class="params">(x,y)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,x):</span><br><span class="line">            <span class="keyword">if</span> graph[i][y] == <span class="string">'Q'</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= y + x - i &lt; n:</span><br><span class="line">                <span class="keyword">if</span> graph[i][y + x - i] == <span class="string">'Q'</span>:<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= y - x + i &lt; n:</span><br><span class="line">                <span class="keyword">if</span> graph[i][y - x + i] == <span class="string">'Q'</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(k,x,y)</span>:</span></span><br><span class="line">        graph[x][y] = <span class="string">"Q"</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> k &lt; n:</span><br><span class="line">            <span class="keyword">if</span> judge(x+<span class="number">1</span>,i):</span><br><span class="line">                dfs(k+<span class="number">1</span>,x+<span class="number">1</span>,i)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k == n:</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> g <span class="keyword">in</span> graph:</span><br><span class="line">                str = <span class="string">""</span>.join(g)</span><br><span class="line">                temp.append(str)</span><br><span class="line">            res.append(temp)</span><br><span class="line">        graph[x][y] = <span class="string">"."</span></span><br><span class="line"></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        dfs(<span class="number">1</span>,<span class="number">0</span>,i)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考答案解法：思路更加清晰</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n: int)</span> -&gt; List[List[str]]:</span></span><br><span class="line">    graph = [[<span class="string">'.'</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judge</span><span class="params">(x,y)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,x):</span><br><span class="line">            <span class="keyword">if</span> graph[i][y] == <span class="string">'Q'</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= y + x - i &lt; n:</span><br><span class="line">                <span class="keyword">if</span> graph[i][y + x - i] == <span class="string">'Q'</span>:<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= y - x + i &lt; n:</span><br><span class="line">                <span class="keyword">if</span> graph[i][y - x + i] == <span class="string">'Q'</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(row)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> row == n:</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> g <span class="keyword">in</span> graph:</span><br><span class="line">                str = <span class="string">""</span>.join(g)</span><br><span class="line">                temp.append(str)</span><br><span class="line">            res.append(temp)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> judge(row,i):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            graph[row][i] = <span class="string">'Q'</span></span><br><span class="line">            dfs(row+<span class="number">1</span>)</span><br><span class="line">            graph[row][i] = <span class="string">'.'</span></span><br><span class="line">    res = []</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="15-解数独-3"><a href="#15-解数独-3" class="headerlink" title="15.解数独(3)"></a>15.<a href="https://leetcode.cn/problems/sudoku-solver/" target="_blank" rel="noopener">解数独</a>(3)</h3><blockquote>
<p>row,col,square分别存储行、列、方阵里是否有某个元素</p>
<p>tip：优化了初始化和剪枝dfs(si,sj)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># def dfs(i,j):</span></span><br><span class="line">    <span class="comment">#     while board[i][j]!='.':</span></span><br><span class="line">    <span class="comment">#         j += 1</span></span><br><span class="line">    <span class="comment">#         if j &gt;= 9:</span></span><br><span class="line">    <span class="comment">#             i += 1</span></span><br><span class="line">    <span class="comment">#             j = 0</span></span><br><span class="line">    <span class="comment">#         if i &gt;= 9:</span></span><br><span class="line">    <span class="comment">#             return True</span></span><br><span class="line">                </span><br><span class="line">    <span class="comment">#     for k in range(1,10):</span></span><br><span class="line">    <span class="comment">#         index = k - 1</span></span><br><span class="line">    <span class="comment">#         xx = (i//3)*3+j//3</span></span><br><span class="line">    <span class="comment">#         if row[i][index] or col[j][index] or square[xx][index]:</span></span><br><span class="line">    <span class="comment">#             continue</span></span><br><span class="line">    <span class="comment">#         row[i][index] = True</span></span><br><span class="line">    <span class="comment">#         col[j][index] = True</span></span><br><span class="line">    <span class="comment">#         square[xx][index] = True</span></span><br><span class="line">    <span class="comment">#         board[i][j] = str(k)</span></span><br><span class="line">    <span class="comment">#         if dfs(i,j):</span></span><br><span class="line">    <span class="comment">#             return True</span></span><br><span class="line">    <span class="comment">#         board[i][j] = '.'</span></span><br><span class="line">    <span class="comment">#         row[i][index] = False</span></span><br><span class="line">    <span class="comment">#         col[j][index] = False</span></span><br><span class="line">    <span class="comment">#         square[xx][index] = False</span></span><br><span class="line">    <span class="comment">#     return False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(si,sj)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(si,<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(sj,<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] != <span class="string">'.'</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">                    num_index = num - <span class="number">1</span></span><br><span class="line">                    xx = (i // <span class="number">3</span>) * <span class="number">3</span> + j // <span class="number">3</span></span><br><span class="line">                    <span class="keyword">if</span> row[i][num_index] <span class="keyword">or</span> col[j][num_index] <span class="keyword">or</span> square[xx][num_index]:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    row[i][num_index] = <span class="literal">True</span></span><br><span class="line">                    col[j][num_index] = <span class="literal">True</span></span><br><span class="line">                    square[xx][num_index] = <span class="literal">True</span></span><br><span class="line">                    board[i][j] = str(num)</span><br><span class="line">                    <span class="keyword">if</span> dfs(si,sj):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    board[i][j] = <span class="string">'.'</span></span><br><span class="line">                    row[i][num_index] = <span class="literal">False</span></span><br><span class="line">                    col[j][num_index] = <span class="literal">False</span></span><br><span class="line">                    square[xx][num_index] = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    row = [[<span class="literal">False</span>]*<span class="number">9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">    col = [[<span class="literal">False</span>] * <span class="number">9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">    square = [[<span class="literal">False</span>] * <span class="number">9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> board[i][j] != <span class="string">'.'</span>:</span><br><span class="line">                num = int(board[i][j]) - <span class="number">1</span></span><br><span class="line">                row[i][num] = <span class="literal">True</span></span><br><span class="line">                col[j][num] = <span class="literal">True</span></span><br><span class="line">                xx = (i // <span class="number">3</span>) * <span class="number">3</span> + j // <span class="number">3</span></span><br><span class="line">                <span class="comment"># yy = (i - i // 3) * 3 + j - j // 3</span></span><br><span class="line">                square[xx][num] = <span class="literal">True</span></span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="==总结=="></a>==总结==</h3><blockquote>
<p><strong>子集是收集树形结构中树的所有节点的结果</strong></p>
<p><strong>而组合问题、分割问题是收集树形结构中叶子节点的结果</strong></p>
<p>回溯算法能解决如下问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合                         C(n,n) </li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式                    A(n,n)   基本都需要used数组</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集                     结果集在各个节点上，不止在叶子结点</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<p>==tip<strong>:要对同一树层去重可以使用局部变量map</strong>。参考9,10,12==</p>
</blockquote>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h3><h4 id="1-斐波那契数"><a href="#1-斐波那契数" class="headerlink" title="1.斐波那契数"></a>1.<a href="https://leetcode.cn/problems/fibonacci-number/" target="_blank" rel="noopener">斐波那契数</a></h4><blockquote>
<p>步骤：</p>
<p>1.确定dp数组以及下标的含义</p>
<p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p>
<p>2.确定递推公式</p>
<p>为什么这是一道非常简单的入门题目呢？</p>
<p><strong>因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</strong></p>
<p>3.dp数组如何初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; dp[0] = 0;</span><br><span class="line">&gt; dp[1] = 1;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>4.确定遍历顺序</p>
<p>从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p>
<p>5.举例推导dp数组</p>
<p>序列为：0 1 1 2 3 5 8 13 21 34 55 ···</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    f = [<span class="number">-1</span>] * <span class="number">31</span></span><br><span class="line">    f[<span class="number">0</span>],f[<span class="number">1</span>] = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n + <span class="number">1</span>):</span><br><span class="line">        f[i] = f[i<span class="number">-1</span>] + f[i<span class="number">-2</span>]</span><br><span class="line">    <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure>
<h4 id="2-爬楼梯"><a href="#2-爬楼梯" class="headerlink" title="2.爬楼梯"></a>2.<a href="https://leetcode.cn/problems/climbing-stairs/" target="_blank" rel="noopener">爬楼梯</a></h4><blockquote>
<p>解法同斐波那契数列</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    f = [<span class="number">-1</span>] * <span class="number">45</span></span><br><span class="line">    f[<span class="number">0</span>],f[<span class="number">1</span>] = <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">        f[i] = f[i<span class="number">-1</span>] + f[i<span class="number">-2</span>]</span><br><span class="line">    <span class="keyword">return</span> f[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="3-使用最小花费爬楼梯"><a href="#3-使用最小花费爬楼梯" class="headerlink" title="3.使用最小花费爬楼梯"></a>3.<a href="https://leetcode.cn/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">使用最小花费爬楼梯</a></h4><blockquote>
<p>1.dp[i]表示到第i个台阶需要的花费</p>
<p>2.状态方程:dp[i]=min{dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]}</p>
<p>3.初始化条件:dp[0]=dp[1] = 0</p>
<p>4.从前往后遍历</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(cost) + <span class="number">1</span></span><br><span class="line">    dp = [<span class="number">0</span>]*n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">        dp[i] = min(dp[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然上述方法LeetCode能通过，但是对于输入样例[2]来说通过不了，因为题目中cost.length&gt;=2</p>
<p>这里我们将dp[i]认为是到第i个台阶的最小花费且算上第i个台阶的花费(因为总要花费)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(cost)</span><br><span class="line">    dp = [<span class="number">0</span>]*n</span><br><span class="line">    dp[<span class="number">0</span>],dp[<span class="number">1</span>] = cost[<span class="number">0</span>],cost[<span class="number">1</span>] </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">        dp[i] = min(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]) + cost[i]</span><br><span class="line">    <span class="keyword">return</span> min(dp[n<span class="number">-1</span>],dp[n<span class="number">-2</span>])</span><br></pre></td></tr></table></figure>
<h4 id="4-不同路径-2"><a href="#4-不同路径-2" class="headerlink" title="4.不同路径(2)"></a>4.<a href="https://leetcode.cn/problems/unique-paths/" target="_blank" rel="noopener">不同路径</a>(2)</h4><blockquote>
<p>1.dp[i] [j] 表示坐标i,j的方法数</p>
<p>2.机器人由于只能走右或下，所以dp[i] [j]=dp[i-1] [j] + dp[i] [j-1]</p>
<p>3.初始化条件为，当i=0或j=0时，dp[i] [j]=1</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">    dp = [[<span class="number">1</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="5-不同路径-II-2"><a href="#5-不同路径-II-2" class="headerlink" title="5.不同路径 II(2)"></a>5.<a href="https://leetcode.cn/problems/unique-paths-ii/" target="_blank" rel="noopener">不同路径 II</a>(2)</h4><blockquote>
<p>1.dp[i] [j] 表示坐标i,j的方法数</p>
<p>2.机器人由于只能走右或下，所以dp[i] [j]=dp[i-1] [j] + dp[i] [j-1]</p>
<p>3.初始化条件:</p>
<p>​    当i=0或j=0时，没遇到障碍之前dp[i] [j] = 1，遇到障碍后dp[i] [j] = 0</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    m = len(obstacleGrid)</span><br><span class="line">    n = len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">    dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][i] == <span class="number">0</span>:</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</span><br><span class="line">                dp[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="6-整数拆分-2"><a href="#6-整数拆分-2" class="headerlink" title="6.整数拆分(2)"></a>6.<a href="https://leetcode.cn/problems/integer-break/" target="_blank" rel="noopener">整数拆分</a>(2)</h4><blockquote>
<p>数学方法：尽量让乘数等于3，结果最大</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    sh = n // <span class="number">3</span></span><br><span class="line">    yu = n % <span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> yu == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> pow(<span class="number">3</span>,sh)</span><br><span class="line">    <span class="keyword">elif</span> yu == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> pow(<span class="number">3</span>,sh<span class="number">-1</span>) * <span class="number">4</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> pow(<span class="number">3</span>,sh) * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(n,step)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> step == <span class="number">1</span> <span class="keyword">and</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> step == <span class="number">1</span> <span class="keyword">and</span> n == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">return</span> dfs(n<span class="number">-3</span>,step+<span class="number">1</span>)*<span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> dfs(n,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1.dp[i]表示拆分i得到的最大值</p>
<p>2.拆分i时，从1开始遍历到i-2(不遍历到i-1是因为dp[1]没有意义)，</p>
<p>依次比较{dp[i],j <em> (i - j),j </em> dp[i - j]}的大小，j <em> (i - j)表示两数相乘，j </em> dp[i - j]表示j和i-j拆分最大值相乘</p>
<p>3.0,1没有意义，初始化为-1，初始化dp[2]=1</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    dp = [<span class="number">-1</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i<span class="number">-1</span>):</span><br><span class="line">            dp[i] = max(dp[i],j * (i - j),j * dp[i - j])</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h4 id="7-不同的二叉搜索树-2"><a href="#7-不同的二叉搜索树-2" class="headerlink" title="7.不同的二叉搜索树(2)"></a>7.<a href="https://leetcode.cn/problems/unique-binary-search-trees/" target="_blank" rel="noopener">不同的二叉搜索树</a>(2)</h4><blockquote>
<p>1.dp[i]表示1-i构成的二叉搜索树的个数</p>
<p>2.找规律发现dp[i] = dp[0]<em>dp[i-1]+dp[1]</em>dp[i-2]+…+dp[i-1]*dp[0]</p>
<p>3.初始化dp[0]=dp[1] = 1</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i):</span><br><span class="line">            dp[i] += dp[i - j - <span class="number">1</span>] * dp[j]</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分别以1,….,n为根节点，个数分别为dp[0]<em>dp[n-1],dp[1]</em>dp[n-2],dp[n-1]*dp[0]</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> memo[n] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> memo[n]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            res += dfs(i<span class="number">-1</span>) * dfs(n-i)</span><br><span class="line">        memo[n] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    memo = [<span class="number">0</span>] * <span class="number">20</span></span><br><span class="line">    memo[<span class="number">0</span>] = memo[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    dfs(n)</span><br><span class="line">    <span class="keyword">return</span> memo[n]</span><br></pre></td></tr></table></figure>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><blockquote>
<p>1.dp[i] [j] 表示从下标0-i的物品中取东西，放入容量为j的背包中，价值总和最大是多少。</p>
<p>2.推导公式：</p>
<p>​        对于第i件物品要么放：dp[i-1] [j-weight[i]] + value[i]   表示为了放进物品i，前i-1个物品的空间是j-weight[i]，前i-1个物品价值为dp[i-1] [j-weight[i]]</p>
<p>​        要么不放：dp[i-1] [j]  表示第i件物品不放，那么前i-1个物品就有j 的空间</p>
<p>​        dp[i] [j] = max(dp[i-1] [j],dp[i-1] [j-weight[i]] + value[i])</p>
<p>3.初始化：</p>
<p>​        i = 0，对于一个物品，那么只要空间大于等于weight[0]就放入</p>
<p>​        j = 0，空间为0，那么dp[i] [0]=0</p>
<p>注意：如果用二维dp，dp[i] [j]都是通过上一层即dp[i - 1] [j]计算而来，本层的dp[i] [j]并不会被覆盖！即依赖选不选上一个物品</p>
<p>​            如果用一维dp数组，不能将两层for循环倒序，因为本轮循环依赖上轮循环的结果，如果倒过来，背包里只会放一样物品</p>
<p>可以参考的总结：<a href="https://leetcode.cn/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/" target="_blank" rel="noopener">https://leetcode.cn/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/</a></p>
<p>组合问题、True/False问题、最大最小问题</p>
</blockquote>
<h5 id="1-分割等和子集-2"><a href="#1-分割等和子集-2" class="headerlink" title="1.分割等和子集(2)"></a>1.<a href="https://leetcode.cn/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">分割等和子集</a>(2)</h5><blockquote>
<p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>1.dp[i] [j] 表示对于nums[0-i]里面的数，能否组成数字j</p>
<p>2.对于第i个数，能否组成j，</p>
<p>​        取决于dp[i-1] [j]，此轮不用nums[i]，前i-1个数能组成j，那么前i个数一定能组成j</p>
<p>​        还取决于dp[i-1] [j-nums[i]]   此轮用nums[i]，对于前i-1个数，能否组成j-nums[i]</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPartition</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">    le = len(nums)</span><br><span class="line">    <span class="keyword">if</span> le &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(le):</span><br><span class="line">        sum += nums[i]</span><br><span class="line">    <span class="keyword">if</span> sum % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    n = sum // <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(le):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 以上：总和是奇数pass,单个数大于总和pass</span></span><br><span class="line">    </span><br><span class="line">    dp = [[<span class="literal">False</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(le)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(le):</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,le):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[i<span class="number">-1</span>][j] <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                dp[i][j] = <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 保证j-nums[i] &gt;= 0</span></span><br><span class="line">            <span class="keyword">if</span> j-nums[i] &gt;= <span class="number">0</span> <span class="keyword">and</span> dp[i<span class="number">-1</span>][j-nums[i]] <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                dp[i][j] = <span class="literal">True</span></span><br><span class="line">                <span class="comment"># 如果dp此时为True,且j==n正好是可以组成sum/2,可以直接返回True</span></span><br><span class="line">                <span class="keyword">if</span> j == n:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> dp[le<span class="number">-1</span>][n]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一维数组优化</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPartition</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        sum += num</span><br><span class="line">    half = sum // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> sum % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num &gt; half:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    le = len(nums)</span><br><span class="line">    dp = [<span class="literal">False</span>] * (half + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = dp[nums[<span class="number">0</span>]] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,le):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(half,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> j &gt;= nums[i]:</span><br><span class="line">                dp[j] = dp[j] <span class="keyword">or</span> dp[j-nums[i]]</span><br><span class="line">    <span class="keyword">return</span> dp[half]</span><br></pre></td></tr></table></figure>
<h5 id="2-最后一块石头的重量-II-2"><a href="#2-最后一块石头的重量-II-2" class="headerlink" title="2.最后一块石头的重量 II(2)"></a>2.<a href="https://leetcode.cn/problems/last-stone-weight-ii/" target="_blank" rel="noopener">最后一块石头的重量 II</a>(2)</h5><blockquote>
<p>思想和01背包差不多，可以直接套</p>
<p>但要注意：1.尽量将石头分为重量相同的两堆(sum//2)，即变成了01背包问题(使dp[sum//2]尽可能大)</p>
<p>​                    2.结果：一堆是sum-dp[sum//2]，另一堆是dp[sum//2]，它们之差是(sum-dp[sum//2])-dp[sum//2]</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lastStoneWeightII</span><span class="params">(self, stones: List[int])</span> -&gt; int:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> stones:</span><br><span class="line">        sum += s</span><br><span class="line">    n = sum // <span class="number">2</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    le = len(stones)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(le):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n,stones[i]<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            dp[j] = max(dp[j],dp[j-stones[i]]+stones[i])</span><br><span class="line">    <span class="keyword">return</span> sum - dp[n] - dp[n]</span><br></pre></td></tr></table></figure>
<h5 id="3-目标和-2"><a href="#3-目标和-2" class="headerlink" title="==3.目标和(2)=="></a>==3.<a href="https://leetcode.cn/problems/target-sum/" target="_blank" rel="noopener">目标和</a>(2)==</h5><blockquote>
<p>主要是推导过程</p>
<p>回溯法：会超时</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    n = len(nums)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(k,tar)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> sum</span><br><span class="line">        <span class="keyword">if</span> k == n:</span><br><span class="line">            <span class="keyword">if</span> tar == target:</span><br><span class="line">                sum += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                dfs(k + <span class="number">1</span>,tar - nums[k])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dfs(k + <span class="number">1</span>, tar + nums[k])</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>
<blockquote>
<p>动态规划</p>
<p>将nums=[a1,a2,a3···an]分为两部分，left和right</p>
<p>可以得出left + (-right) = target</p>
<p>​                left+right=sum</p>
<p>​                left-(sum-left) = target</p>
<p>所以        left = (sum + target) // 2</p>
<p>若abs(target) &gt; sum 或 (sum+target)是奇数 结果返回0</p>
<p>1.dp[i] [j]表示选取前i个数，组成j的个数</p>
<p>2.dp[i] [j] 至少有前i-1个数组成j的个数   即dp[i] [j] = dp[i-1] [j];</p>
<p>​    若j &gt;= num[i-1]  则还有可能有属于它自己的个数 即dp[i-1] [j-nums[i]]，总和为dp[i] [j] = dp[i-1] [j] + dp[i-1] [j-nums[i]]</p>
<p>3.开辟dp[n+1] [left+1]，初始化  dp[0] [0] =1 </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        sum += nums[i]</span><br><span class="line">    <span class="keyword">if</span> sum &lt; abs(target) <span class="keyword">or</span> (sum + target) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    left = (sum + target) // <span class="number">2</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (left+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,left + <span class="number">1</span>):</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j &gt;= nums[i<span class="number">-1</span>]:</span><br><span class="line">                dp[i][j] += dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]]</span><br><span class="line">    <span class="keyword">return</span> dp[n][left]</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 一维数组</span></span><br><span class="line">    <span class="comment"># dp = [0] * (left + 1)</span></span><br><span class="line">    <span class="comment"># dp[0] = 1</span></span><br><span class="line">    <span class="comment"># for i in range(n):</span></span><br><span class="line">    <span class="comment">#     for j in range(left,nums[i] - 1,-1):</span></span><br><span class="line">    <span class="comment">#         dp[j] += dp[j - nums[i]]</span></span><br><span class="line">    <span class="comment"># return dp[left]</span></span><br></pre></td></tr></table></figure>
<h5 id="4-一和零-2"><a href="#4-一和零-2" class="headerlink" title="4.一和零(2)"></a>4.<a href="https://leetcode.cn/problems/ones-and-zeroes/" target="_blank" rel="noopener">一和零</a>(2)</h5><blockquote>
<p>nice AC</p>
<p>首先统计出字符串含0,1 的个数，如[(1,1)(3,1)(2,4)(0,1)(1,0)]  一共5个物品</p>
<p>其中，物品的价值都是1；重量就是字符0,1的个数；m,n可以看做是两个背包的容量，分别用来装0,1</p>
<p>1.dp[i] [j] [k] 表示前i个物品，能装入容量分别为j，k，所得到的价值最大是多少</p>
<p>2.dp[i] [j] [k] = max(dp[i-1] [j] [k]，dp[i-1] [j-wj[i]] [k-wk[i]] + 1)</p>
<p>3.初始化 都是0</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span><span class="params">(self, strs: List[str], m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">    li = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(strs)):</span><br><span class="line">        zero = <span class="number">0</span></span><br><span class="line">        one = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> strs[i]:</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">'0'</span>:</span><br><span class="line">                zero += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                one += <span class="number">1</span></span><br><span class="line">        temp = []</span><br><span class="line">        temp.append(zero)</span><br><span class="line">        temp.append(one)</span><br><span class="line">        li.append(temp)</span><br><span class="line">    le = len(strs)</span><br><span class="line">    dp = [[[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(le+<span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># dp[0][0][0] = 0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,le+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">                dp[i][j][k] = dp[i<span class="number">-1</span>][j][k]</span><br><span class="line">                <span class="keyword">if</span> j &gt;= li[i<span class="number">-1</span>][<span class="number">0</span>] <span class="keyword">and</span> k &gt;= li[i<span class="number">-1</span>][<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j][k] = max(dp[i<span class="number">-1</span>][j][k],dp[i<span class="number">-1</span>][j-li[i<span class="number">-1</span>][<span class="number">0</span>]][k-li[i<span class="number">-1</span>][<span class="number">1</span>]]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> dp[le][m][n]</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 减少一维空间进行优化</span></span><br><span class="line">	<span class="comment"># dp = [[0] * (n+1) for _ in range(m+1)]</span></span><br><span class="line">    <span class="comment"># for i in range(1, le + 1):</span></span><br><span class="line">    <span class="comment">#     for j in range(m,li[i-1][0]-1,-1):</span></span><br><span class="line">    <span class="comment">#         for k in range(n,li[i-1][1]-1,-1):</span></span><br><span class="line">    <span class="comment">#             dp[j][k] = max(dp[j][k],dp[j-li[i-1][0]][k-li[i-1][1]]+1)</span></span><br><span class="line">    <span class="comment"># return dp[m][n]</span></span><br></pre></td></tr></table></figure>
<h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><blockquote>
<p>和01背包的区别就是物品可以无限取</p>
<p>1.dp[i] [j] 仍然表示前i个物品放入容量为j的最大价值</p>
<p>2.状态方程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; dp[i][j] = max(dp[i-1][j],dp[i][j-v[i]]+w[i]);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<pre><code> 因为可以无限取，所以如果选择当前物品i，dp[i] [j] = dp[i] [j-v[i]] + w[i]
</code></pre><p>3.初始化dp[N+1] [V+1]</p>
<p>tips：如果用一维数组，顺序是正序，因为完全背包更新的时候后面的根据前面的得到，而且此时是根据当前轮次的前面的状态进行更新</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line">&gt; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">&gt;     <span class="keyword">for</span>(<span class="keyword">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">&gt;         dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>tips：1.完全背包不管是一维数组还是二维数组构建，两个for循环顺序都可以互换，因为完全背包不像01背包，完全背包当前轮次更新不依赖上轮的结果</p>
<p>2.标准的完全背包顺序都无所谓，但是不一定所有用完全背包问题思想的顺序都能调换</p>
</blockquote>
<h5 id="1-零钱兑换-2"><a href="#1-零钱兑换-2" class="headerlink" title="1.零钱兑换(2)"></a>1.<a href="https://leetcode.cn/problems/coin-change/" target="_blank" rel="noopener">零钱兑换</a>(2)</h5><blockquote>
<p>贪心法不行：贪心法举例的时候不要带上1,2这些小数值</p>
<p>1.dp[i] [j] 表示前i种零钱 组成j的总金额，最少的硬币数</p>
<p>2.dp[i] [j] =min(dp[i-1] [j],dp[i] [j-coins[i]]+1)</p>
<p>3.<strong>初始化</strong>：总金额是0，直接返回0</p>
<p>​                初始化dp[0] [1] dp[0] [2] ··· dp[0] [j] 为inf(因为要比较最小值)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">    m,n = len(coins),amount</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line">    inf = <span class="number">11111</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][i] = inf</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j &gt;= coins[i<span class="number">-1</span>]:</span><br><span class="line">                dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i][j-coins[i<span class="number">-1</span>]]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> dp[m][n] == inf:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用一维数组</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">    m, n = len(coins), amount</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    inf = <span class="number">11111</span></span><br><span class="line">    dp = [inf] * (n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(coins[i], n + <span class="number">1</span>):</span><br><span class="line">            dp[j] = min(dp[j], dp[j - coins[i]] + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> dp[n] == inf:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h5 id="2-零钱兑换-II-2"><a href="#2-零钱兑换-II-2" class="headerlink" title="2.零钱兑换 II(2)"></a>2.<a href="https://leetcode.cn/problems/coin-change-ii/" target="_blank" rel="noopener">零钱兑换 II</a>(2)</h5><blockquote>
<p>1.dp[i] [j] 表示用前i个数，组成j的方案数</p>
<p>2.dp[i] [j] = dp[i-1] [j] + dp[i] [j-w[i]]</p>
<p>​    解释：如求[1,2,5]  组成5  方案数=[1,2,5] 组成3(5-2)    +    [1,2]组成5  = 使用5 + 不使用 5</p>
<p>​       0 1 2 3 4 5 </p>
<p>0    1 0 0 0 0 0</p>
<p>1    1 1 1 1 1 1</p>
<p>2    1 1 2 2 3 3 </p>
<p>5    1 1 2 2 3 4</p>
<p>3.初始化dp[0] [0] = 1</p>
<p>4.for循环次序  ：完全背包从左到右，要使用此轮左边的状态          <strong>两个for循环不能调转顺序</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(self, amount: int, coins: List[int])</span> -&gt; int:</span></span><br><span class="line">    m,n = len(coins),amount</span><br><span class="line">    dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(coins[i],n+<span class="number">1</span>):</span><br><span class="line">            dp[j] += dp[j-coins[i]]</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h5 id="3-组合总和-Ⅳ-2"><a href="#3-组合总和-Ⅳ-2" class="headerlink" title="==3.组合总和 Ⅳ(2)=="></a>==3.<a href="https://leetcode.cn/problems/combination-sum-iv/" target="_blank" rel="noopener">组合总和 Ⅳ</a>(2)==</h5><blockquote>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<p>这题只是求排列个数，<strong>如果本题要把排列都列出来的话，只能使用回溯算法爆搜</strong>。</p>
<p>和第二题一样</p>
<p>只不过第二题是组合问题，这题是排序问题，将两个for循环调换下顺序就行</p>
<p>1.dp[i] [j]表示前i个数组成j的总排列数</p>
<p>2.dp[i] [j] = dp[i-1] [j] + dp[i] [j-w[i]]</p>
<p>3.遍历顺序：先遍历背包容量，再遍历物品</p>
<p>解释一下调换次序为什么就是排列？因为nums 中的每个小于等于 i 的元素都可能作为元素之和等于 i 的排列的最后一个元素</p>
<p>举例（1,2,5）组成5的总个数</p>
<p>dp数组为</p>
<p>​      0 1 2 3 4 5</p>
<p>0    1 0 0 0 0 0</p>
<p>1    1 1 1 2 3 5</p>
<p>2    1 1 2 3 5 8 </p>
<p>5    1 1 2 3 5 9</p>
<p>如图，{1,2,5}组成5 以1结尾个数 = 5  (本质就是{1,2,5}组成4  后面+1就可以组成5，如1+1+2=4，1+1+2+1=5)，</p>
<p>​            {1,2,5}组成5 以2结尾个数 = 3  (本质就是{1,2,5}组成3  后面+2就可以组成5，如1+2=3，1+2+2=5) ，</p>
<p>​            {1,2,5}组成5 以5结尾个数 = 1  (本质就是{1,2,5}组成0  后面+5就可以组成5，如0=0，0+5=5) </p>
<p>dp[i] [j]本质是以当前数nums[i]为结尾+其他数为结尾(因为要其他所有数为结尾，所以要先遍历容量，后遍历物品)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">    m,n = len(nums),target</span><br><span class="line">    dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> j &gt;= nums[i]:</span><br><span class="line">                dp[j] += dp[j-nums[i]]</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h5 id="4-爬楼梯-进阶版"><a href="#4-爬楼梯-进阶版" class="headerlink" title="4.爬楼梯(进阶版)"></a>4.<a href="https://www.programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html#_70-%E7%88%AC%E6%A5%BC%E6%A2%AF" target="_blank" rel="noopener">爬楼梯(进阶版)</a></h5><blockquote>
<p>原本题目改为<strong>一步一个台阶，两个台阶，三个台阶，…….，直到 m个台阶。问有多少种不同的方法可以爬到楼顶呢？</strong></p>
<p>就是和题目3差不多的完全背包排列问题</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    dp = [<span class="number">0</span>]*(n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    m = <span class="number">2</span></span><br><span class="line">    <span class="comment"># 遍历背包</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j &gt;= step:</span><br><span class="line">                dp[j] += dp[j - step]</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h5 id="5-完全平方数-2"><a href="#5-完全平方数-2" class="headerlink" title="5.完全平方数(2)"></a>5.<a href="https://leetcode.cn/problems/perfect-squares/" target="_blank" rel="noopener">完全平方数</a>(2)</h5><blockquote>
<p>1.dp[i] [j] 表示(1-i)的数的平方和能组成j的最小个数</p>
<p>2.$dp[i][j]=min(dp[i-1][j],dp[i][j-i^2]+1)$，不取当前数i，总个数为dp[i-1] [j]，去当前数为 $dp[i][j-i^2]+1$</p>
<p>3.初始化dp[i] [j] = INF，除了dp[0] [0] = 0</p>
<p>本题是求最小数</p>
<p><strong>所以本题外层for遍历背包，内层for遍历物品，还是外层for遍历物品，内层for遍历背包，都是可以的！</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    m,n = int(math.sqrt(n)),n</span><br><span class="line">    dp = [n] * (n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">        p = pow(i,<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(p,n+<span class="number">1</span>):</span><br><span class="line">            dp[j] = min(dp[j],dp[j-p]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h5 id="6-单词拆分-2"><a href="#6-单词拆分-2" class="headerlink" title="6.单词拆分(2)"></a>6.<a href="https://leetcode.cn/problems/word-break/" target="_blank" rel="noopener">单词拆分</a>(2)</h5><blockquote>
<p>$dp[i][j] = dp[i-1][j]$ or $(dp[i][j-len(wordDict[i])]$ and $wordDict[i] == s[j-len(wordDict[i]):j])$</p>
<p>​    dp[i] [j]取决于前i-1个字符串能否组成s  ，即dp[i-1] [j]</p>
<p>​                还取决于去掉当前字符串wordDict[i]的情况能构成s-wordDict[i]，且wordDict[i] == s后面的字符串，</p>
<p>​                            即dp[i] [j]-&gt;$(dp[i][j-len(wordDict[i])]$ and $wordDict[i] == s[j-len(wordDict[i]):j])$</p>
<p>tips：此题是先遍历背包容量，再遍历物品的</p>
<p>​            因为此题的字符串读取是有先后关系的，不像数字。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s: str, wordDict: List[str])</span> -&gt; bool:</span></span><br><span class="line">    m, n = len(wordDict), len(s)</span><br><span class="line">    dp = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            dp[j] = dp[j] <span class="keyword">or</span> (dp[j-len(wordDict[i])] <span class="keyword">and</span> wordDict[i] == s[j-len(wordDict[i]):j])</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s: str, wordDict: List[str])</span> -&gt; bool:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    dp = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(wordDict)):</span><br><span class="line">            le = len(wordDict[i])</span><br><span class="line">            <span class="keyword">if</span> j &gt;= le <span class="keyword">and</span> wordDict[i] == s[j-le:j]:</span><br><span class="line">                dp[j] = dp[j] <span class="keyword">or</span> dp[j - le]</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h4 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h4><h5 id="1-解法I"><a href="#1-解法I" class="headerlink" title="1.解法I"></a>1.解法I</h5><blockquote>
<p>1.dp[i] [j] 表示前i个物品放入j容量的背包的最大价值</p>
<p>2.可以把这题看做是0-1背包，例如：物品a 重x，价值为y，个数为z，那么我们可以把这物品视作重量价值都相同的z个不同的物体。</p>
<p>​        状态方程dp[i] [j] = max(dp[i] [j] ,dp[i-1] [j-k<em>weight[i]] +k </em> value[i])  k表示物品个数</p>
<p>​        解释下为什么max第一项是dp[i] [j]，而不是dp[i-1] [j]，因为第二项当k=0时，就表示dp[i-1] [j]表示不选当前物品，已经包含在内，其次dp[i] [j] 随着k的for循环能够表示选k-1个物品z的最大价值。</p>
<p>​        即  $dp[i][j] = max(dp[i-1][j], dp[i-1][j-v] + w, dp[i-1][j-2<em>v] + 2</em>w,…, dp[i-1][j-k<em>v] + k</em>w)$</p>
<p>3.初始化dp[0] [0] = 0</p>
<p>时间复杂度为$O(N <em> V </em> S)$</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_packI</span><span class="params">(weight:List[int],value:List[int],nums:List[int],volume:int)</span> -&gt; int:</span></span><br><span class="line">    m,n = len(weight),volume</span><br><span class="line">    dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):s</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>,nums[i<span class="number">-1</span>]+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= k*weight[i<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][j-k*weight[i<span class="number">-1</span>]]+k*value[i<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>
<h5 id="2-解法II—二进制优化"><a href="#2-解法II—二进制优化" class="headerlink" title="2.解法II—二进制优化"></a>2.解法II—二进制优化</h5><blockquote>
<p>物品个数可以通过二进制优化成01背包</p>
<p>比如：物品a 重量为5，价值为3，个数为11，那么可以打包为1、2、4、4的4种新物品</p>
<p>时间复杂度为$O(N <em> V </em> logS)$</p>
<p>正常背包的思路下，我们要求出含这组商品的最优解，我们要枚举12次（枚举装0，1，2….12个）。</p>
<p>现在，如果我们把这11个商品分别打包成含商品个数为1个，2个，4个，4个（分别对应0001,0010,0100,0100）的四个”新的商品 “, 将问题转化为01背包问题，对于每个商品，我们都只枚举一次，那么我们只需要枚举四次 ，就可以找出这含组商品的最优解。 这样就大大减少了枚举次数。</p>
<p>这种优化对于大数尤其明显，例如有1024个商品，在正常情况下要枚举1025次 ， 二进制思想下转化成01背包只需要枚举10次。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_packII</span><span class="params">(weight:List[int],value:List[int],nums:List[int],volume:int)</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># m:原物品的种类数,n:背包容量</span></span><br><span class="line">    m_p,n = len(weight),volume</span><br><span class="line">    goods = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m_p):</span><br><span class="line">        k = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt;= nums[i]:</span><br><span class="line">            nums[i] -= k</span><br><span class="line">            goods.append([k * weight[i], k * value[i]])</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">            goods.append([nums[i]*weight[i],nums[i]*value[i]])</span><br><span class="line">    <span class="comment"># 二进制化后物品的数量</span></span><br><span class="line">    m = len(goods)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j &gt;= goods[i<span class="number">-1</span>][<span class="number">0</span>]:</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-goods[i<span class="number">-1</span>][<span class="number">0</span>]]+goods[i<span class="number">-1</span>][<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>
<h5 id="3-解法III—单调队列优化"><a href="#3-解法III—单调队列优化" class="headerlink" title="3.解法III—单调队列优化"></a>3.解法III—单调队列优化</h5><blockquote>
<p>1.针对每一类物品 i ，我们都更新一下 dp[0] —&gt; dp[m] 的值，最后 dp[m] 就是一个全局最优值</p>
<p>$dp[m] = max(dp[m], dp[m-v] + w, dp[m-2<em>v] + 2</em>w, dp[m-3<em>v] + 3</em>w, …)$</p>
<p>这是原来的方式，存在许多冗余，要用下面的方法进行优化</p>
<p>2.yxc思路：</p>
<p>朴素的解法动态转移方程如上，也就是$dp[j] = max(dp[j],dp[j-k<em>v]+k</em>w),0&lt;=j&lt;m(背包容量)$，对于单个物品来说</p>
<p>可以发现   ==<strong>dp[j] 只能从整数个v中转移过来，所以可以考虑将dp数组分为v个类</strong>==，因为考虑到背包容量分别使用单调队列找最大值</p>
<p>接下来，我们把 dp[0] —&gt; dp[m] 写成下面这种形式</p>
<p>$dp[0], dp[v],   dp[2<em>v],   dp[3</em>v],   … , dp[k<em>v]$<br>$dp[1], dp[v+1], dp[2</em>v+1], dp[3<em>v+1], … , dp[k</em>v+1]$<br>$dp[2], dp[v+2], dp[2<em>v+2], dp[3</em>v+2], … , dp[k<em>v+2]$<br>…<br>$dp[u], dp[v+u], dp[2</em>v+u], dp[3<em>v+u], … , dp[k</em>v+u]$</p>
<p>显而易见，m 一定等于 $k*v + u$，其中  $0 &lt;= u &lt; v$，</p>
<p>也就是说，$dp[k<em>v+j] $只依赖于 ${ dp[j], dp[v+j], dp[2</em>v+j], dp[3<em>v+j], … , dp[k</em>v+j] }$</p>
<p>虽然我本轮物品用不到dp[j-1]，但是我下个物品还是依赖dp[j-1]的，所以我每类dp都要更新的(dp[0],dp[1],..dp[j]都要更新)</p>
<p>例如：m=12，               v=3，   k=2</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>按容量余数遍历(0-v)</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>3</td>
<td>6</td>
<td>9</td>
<td>12</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>4</td>
<td>7</td>
<td>10</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>5</td>
<td>8</td>
<td>11</td>
</tr>
</tbody>
</table>
</div>
<p>其中12的情况，并不是说就装了这样4个物品，因为这个物品只有两个嘛，这表示</p>
<p>以余数0，构建单调队列举例：</p>
<p>$nums[i] * weight[i] = 6$</p>
<p>要求满足$k-q[0] &gt; nums[i] * weight[i]$(说明放满了当前物品，还有剩余空间装其他的)，其中k是此轮遍历的背包容量，q[0]表示队头的体积</p>
<p>[0] 3 6 9 12</p>
<p>[0 3] 6 9 12</p>
<p>[0 3 6] 9 12</p>
<p>0 [3 6 9] 12</p>
<p>0 3 [6 9 12]</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_packIII</span><span class="params">(weight:List[int],value:List[int],nums:List[int],volume:int)</span> -&gt; int:</span></span><br><span class="line">    m,n = len(weight),volume</span><br><span class="line">    dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="comment"># 之所以要拷贝前i-1个物品的dp数组，是因为在最优化过程中前面的状态可能会被覆盖掉并被再次使用。</span></span><br><span class="line">        pre = dp.copy()</span><br><span class="line">        q = deque()</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(weight[i]):  <span class="comment"># 拆分成v个类(按余数拆分)</span></span><br><span class="line">            k = j</span><br><span class="line">            <span class="comment"># 对每个类使用单调队列</span></span><br><span class="line">            <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">                <span class="comment"># q[0]表示对于物品i在j余数下在滑动窗口内造成价值最大的那种物品数目取法</span></span><br><span class="line">                <span class="comment"># q[0]不在窗口[k-s * v, k-v]内, 队头出队</span></span><br><span class="line">                <span class="comment"># q[0] &lt; k - nums[i] * weight[i]说明如果继续使用q[0]的这种取法，就已经会浪费空间了</span></span><br><span class="line">                <span class="comment"># 其实画个图就很好理解这个框是个什么位置</span></span><br><span class="line">                <span class="keyword">if</span> q <span class="keyword">and</span> k - q[<span class="number">0</span>] &gt; nums[i] * weight[i]:</span><br><span class="line">                    q.popleft()</span><br><span class="line">                <span class="comment"># ##################使用队尾的放法，还不如上一轮物品i的价值，那出队################</span></span><br><span class="line">                <span class="comment"># pre[k]用过前面i-1个物品在k的背包容量下的最大价值(这边k是当前遍历的轮次)</span></span><br><span class="line">                <span class="comment"># pre[q[-1]]用过前面i-1个物品在q[-1]的背包容量下的最大价值</span></span><br><span class="line">                <span class="comment"># k - q[-1]不一定能整除weight[i]</span></span><br><span class="line">                <span class="comment"># (k - q[-1]) // weight[i] * value[i]表示减去q[-1]的体积后尽可能放物品i的价值</span></span><br><span class="line">                <span class="keyword">while</span> q <span class="keyword">and</span> pre[k] &gt;= pre[q[<span class="number">-1</span>]] + (k - q[<span class="number">-1</span>]) // weight[i] * value[i]:</span><br><span class="line">                    q.pop()</span><br><span class="line">                q.append(k)</span><br><span class="line">                <span class="comment"># 使用队头最有价值元素更新dp</span></span><br><span class="line">                dp[k] = max(dp[k], pre[q[<span class="number">0</span>]] + (k - q[<span class="number">0</span>]) // weight[i] * value[i])</span><br><span class="line">                k += weight[i]</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h4 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a><a href="https://www.acwing.com/problem/content/7/" target="_blank" rel="noopener">混合背包</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mixed_pack</span><span class="params">(weight:List[int],value:List[int],nums:List[int],volume:int)</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># m:原物品的种类数,n:背包容量</span></span><br><span class="line">    m_p,n = len(weight),volume</span><br><span class="line">    goods = []</span><br><span class="line">    <span class="comment"># 混合背包转换为01背包和完全背包</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m_p):</span><br><span class="line">        <span class="keyword">if</span> nums[i] == <span class="number">-1</span>:</span><br><span class="line">            goods.append([<span class="number">-1</span>,weight[i],value[i]])</span><br><span class="line">        <span class="keyword">elif</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">            goods.append([<span class="number">0</span>,weight[i],value[i]])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> k &lt;= nums[i]:</span><br><span class="line">                nums[i] -= k</span><br><span class="line">                goods.append([<span class="number">-1</span>,k * weight[i], k * value[i]])</span><br><span class="line">                k &lt;&lt;= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                goods.append([<span class="number">-1</span>,nums[i]*weight[i],nums[i]*value[i]])</span><br><span class="line">    <span class="comment"># 转化后物品的数量</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> good <span class="keyword">in</span> goods:</span><br><span class="line">        <span class="keyword">if</span> good[<span class="number">0</span>] == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n,good[<span class="number">1</span>]<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                dp[j] = max(dp[j],dp[j-good[<span class="number">1</span>]]+good[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(good[<span class="number">1</span>],n+<span class="number">1</span>):</span><br><span class="line">                dp[j] = max(dp[j],dp[j-good[<span class="number">1</span>]]+good[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p><img alt="416.分割等和子集1" data-src="https://img-blog.csdnimg.cn/20210117171307407.png"></p>
<h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><h4 id="1-打家劫舍I-2"><a href="#1-打家劫舍I-2" class="headerlink" title="1.打家劫舍I(2)"></a>1.<a href="https://leetcode.cn/problems/house-robber/" target="_blank" rel="noopener">打家劫舍I</a>(2)</h4><blockquote>
<p>1.dp[i] 表示前i个房屋偷窃的最高金额</p>
<p>2.dp[i] = max(dp[i-1] , dp[i-2] + nums[i])</p>
<p>​        偷第i个房屋，就是dp[i-2] + nums[i]</p>
<p>​        不偷第i个房屋，就是前i-1个房屋(不一定要偷第i个房屋)的偷窃价值dp[i-1]</p>
<p>3.初始化dp[0] = nums[0] ,dp[1] = max(nums[0],nums[1])</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    ma = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> ma</span><br><span class="line">    dp = [<span class="number">0</span>] * n</span><br><span class="line">    dp[<span class="number">0</span>],dp[<span class="number">1</span>] = nums[<span class="number">0</span>],ma</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">        dp[i] = max(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>] + nums[i])</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="2-打家劫舍-II-2"><a href="#2-打家劫舍-II-2" class="headerlink" title="==2.打家劫舍 II(2)=="></a>==2.<a href="https://leetcode.cn/problems/house-robber-ii/" target="_blank" rel="noopener">打家劫舍 II</a>(2)==</h4><blockquote>
<p>同题目1</p>
<p>考虑到首尾相连，要分两种情况</p>
<p>1.去掉第1个房子</p>
<p>2.去掉最后一个房子</p>
<p>分别做dp，求其最大值</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">3</span> :</span><br><span class="line">        <span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>],nums[<span class="number">2</span>])</span><br><span class="line">    dp1 = [<span class="number">0</span>] * (n - <span class="number">1</span>)</span><br><span class="line">    dp1[<span class="number">0</span>], dp1[<span class="number">1</span>] = nums[<span class="number">0</span>], max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n<span class="number">-1</span>):</span><br><span class="line">        dp1[i] = max(dp1[i - <span class="number">1</span>], dp1[i - <span class="number">2</span>] + nums[i])</span><br><span class="line">    dp2 = [<span class="number">0</span>] * (n - <span class="number">1</span>)</span><br><span class="line">    dp2[<span class="number">0</span>], dp2[<span class="number">1</span>] = nums[<span class="number">1</span>], max(nums[<span class="number">2</span>], nums[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n - <span class="number">1</span>):</span><br><span class="line">        dp2[i] = max(dp2[i - <span class="number">1</span>], dp2[i - <span class="number">2</span>] + nums[i+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> max(dp1[n<span class="number">-2</span>],dp2[n<span class="number">-2</span>])</span><br></pre></td></tr></table></figure>
<h4 id="3-打家劫舍-III-2"><a href="#3-打家劫舍-III-2" class="headerlink" title="==3.打家劫舍 III(2)=="></a>==3.<a href="https://leetcode.cn/problems/house-robber-iii/" target="_blank" rel="noopener">打家劫舍 III</a>(2)==</h4><blockquote>
<p>记忆化+递归</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; int:</span></span><br><span class="line">    mp = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root: Optional[TreeNode])</span>-&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right: <span class="keyword">return</span> root.val</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">in</span> mp: <span class="keyword">return</span> mp[root]</span><br><span class="line">        <span class="comment"># 偷父节点</span></span><br><span class="line">        val1 = root.val</span><br><span class="line">        <span class="keyword">if</span> root.left: val1 += helper(root.left.left) + helper(root.left.right)</span><br><span class="line">        <span class="keyword">if</span> root.right: val1 += helper(root.right.left) + helper(root.right.right)</span><br><span class="line">        <span class="comment"># 不偷父节点</span></span><br><span class="line">        val2 = helper(root.left) + helper(root.right)</span><br><span class="line">        mp[root] = max(val1,val2)</span><br><span class="line">        <span class="keyword">return</span> mp[root]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(root)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>树形dp</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node: Optional[TreeNode])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        left = helper(node.left)</span><br><span class="line">        right = helper(node.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 不偷当前结点</span></span><br><span class="line">        val1 = max(left[<span class="number">0</span>],left[<span class="number">1</span>]) + max(right[<span class="number">0</span>],right[<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 偷当前结点</span></span><br><span class="line">        val2 = node.val + left[<span class="number">0</span>] + right[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> [val1,val2]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max(helper(root))</span><br></pre></td></tr></table></figure>
<h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><h4 id="1-买卖股票的最佳时机I-2"><a href="#1-买卖股票的最佳时机I-2" class="headerlink" title="1.买卖股票的最佳时机I(2)"></a>1.<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">买卖股票的最佳时机I</a>(2)</h4><blockquote>
<p>1.dp[i]表示前i天的最大收益</p>
<p>2.分为两种情况，第i天卖不卖。</p>
<p>​    第i天卖，收益为prices[i] - minn ，minn是前i-1天的最低买入价(每次迭代都要更新)</p>
<p>​    第i天不卖，就是前i-1天的最大收益，即dp[i-1]</p>
<p>3.初始化dp[0] = 0</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(prices)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [<span class="number">0</span>] * n</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    minn = min(prices[<span class="number">0</span>],prices[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        dp[i] = max(dp[i<span class="number">-1</span>],prices[i]-minn)</span><br><span class="line">        minn = min(minn,prices[i])</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="2-买卖股票的最佳时机-II-2"><a href="#2-买卖股票的最佳时机-II-2" class="headerlink" title="2.买卖股票的最佳时机 II(2)"></a>2.<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">买卖股票的最佳时机 II</a>(2)</h4><blockquote>
<p>1.dp[i] [0] 表示第i天持有股票的最大收益，dp[i] [1]表示第i天不持有股票的最大收益</p>
<p>2.$dp[i][0] = max(dp[i-1][0],dp[i-1][1]-prices[i])$ </p>
<p>​    第i天持有股票的最大收益 ：可能是第i-1天就持有股票，第i天什么都没做；也可能是第i-1天不持有股票，第i天购入的</p>
<p>​    $dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i])$</p>
<p>​    第i天不持有股票的最大收益：可能是第i-1天不持有股票，第i天什么都没做；也可能是第i-1天持有股票，第i天卖出的</p>
<p>3.初始化：dp[0] [0] = -prices[0]</p>
<p>和第一题的区别在于这里股票可以买卖多次</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(prices)                                                                                              ，</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]-prices[i])</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i])</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 使用O(1)空间优化</span></span><br><span class="line">    <span class="comment"># dp = [[0] * 2 for _ in range(2)]</span></span><br><span class="line">	<span class="comment"># dp[0][0] = -prices[0]</span></span><br><span class="line">	<span class="comment"># for i in range(1,n):</span></span><br><span class="line">	<span class="comment">#     dp[i%2][0] = max(dp[(i-1)%2][0],dp[(i-1)%2][1]-prices[i])</span></span><br><span class="line">	<span class="comment">#     dp[i%2][1] = max(dp[(i-1)%2][1],dp[(i-1)%2][0]+prices[i])</span></span><br><span class="line">	<span class="comment"># return dp[(n-1)%2][1]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>贪心，每次都将贡献大于0，放入结果</p>
</blockquote>
<h4 id="3-买卖股票的最佳时机-III-3"><a href="#3-买卖股票的最佳时机-III-3" class="headerlink" title="3.买卖股票的最佳时机 III(3)"></a>3.<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">买卖股票的最佳时机 III</a>(3)</h4><blockquote>
<p>1.第i天分别五种状态：不操作、第一次买入、第一次卖出、第二次买入、第二次卖出，可以用$dp[i][0],dp[i][1],dp[i][2],dp[i][3],dp[i][4]$表示</p>
<p>2.</p>
<p>   $dp[i][0] = dp[i-1][0]$<br>    $dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])$<br>    $dp[i][2] = max(dp[i-1][2],dp[i-1][1] + prices[i])$<br>    $dp[i][3] = max(dp[i-1][3],dp[i-1][2] - prices[i])$<br>   $ dp[i][4] = max(dp[i-1][4],dp[i-1][3] + prices[i])$</p>
<p>3.初始化$dp[i][1]=dp[i][3]=-prices[i]$</p>
<p>需要注意：dp[i] [1]，<strong>表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区</strong>。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(prices)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * <span class="number">5</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>],dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>],-prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">        dp[i][<span class="number">2</span>] = max(dp[i<span class="number">-1</span>][<span class="number">2</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">        dp[i][<span class="number">3</span>] = max(dp[i<span class="number">-1</span>][<span class="number">3</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>] - prices[i])</span><br><span class="line">        dp[i][<span class="number">4</span>] = max(dp[i<span class="number">-1</span>][<span class="number">4</span>],dp[i<span class="number">-1</span>][<span class="number">3</span>] + prices[i])</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h4 id="4-买卖股票的最佳时机-IV-3"><a href="#4-买卖股票的最佳时机-IV-3" class="headerlink" title="4.买卖股票的最佳时机 IV(3)"></a>4.<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">买卖股票的最佳时机 IV</a>(3)</h4><blockquote>
<p>需要注意：dp[i] [1]，<strong>表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区</strong>。</p>
<p>可以买卖k次</p>
<p>可以参考第三题的递推方程，可以得出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">&gt; <span class="keyword">for</span> j <span class="keyword">in</span> range(k):</span><br><span class="line">&gt;     dp[i][<span class="number">2</span>*(j+<span class="number">1</span>)<span class="number">-1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">2</span>*(j+<span class="number">1</span>)<span class="number">-1</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>*(j+<span class="number">1</span>)<span class="number">-2</span>]-prices[i])</span><br><span class="line">&gt;     dp[i][<span class="number">2</span>*(j+<span class="number">1</span>)] = max(dp[i<span class="number">-1</span>][<span class="number">2</span>*(j+<span class="number">1</span>)],dp[i<span class="number">-1</span>][<span class="number">2</span>*(j+<span class="number">1</span>)<span class="number">-1</span>]+prices[i])</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>初始化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">&gt;     dp[<span class="number">0</span>][<span class="number">2</span>*(i+<span class="number">1</span>)<span class="number">-1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k: int, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(prices)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (<span class="number">2</span>*k+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>*(i+<span class="number">1</span>)<span class="number">-1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(k):</span><br><span class="line">            dp[i][<span class="number">2</span>*(j+<span class="number">1</span>)<span class="number">-1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">2</span>*(j+<span class="number">1</span>)<span class="number">-1</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>*(j+<span class="number">1</span>)<span class="number">-2</span>]-prices[i])</span><br><span class="line">            dp[i][<span class="number">2</span>*(j+<span class="number">1</span>)] = max(dp[i<span class="number">-1</span>][<span class="number">2</span>*(j+<span class="number">1</span>)],dp[i<span class="number">-1</span>][<span class="number">2</span>*(j+<span class="number">1</span>)<span class="number">-1</span>]+prices[i])</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">2</span>*k]</span><br></pre></td></tr></table></figure>
<h4 id="5-最佳买卖股票时机含冷冻期-2"><a href="#5-最佳买卖股票时机含冷冻期-2" class="headerlink" title="5.最佳买卖股票时机含冷冻期(2)"></a>5.<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">最佳买卖股票时机含冷冻期</a>(2)</h4><blockquote>
<p>需要注意：dp[i] [1]，<strong>表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区</strong>。</p>
<p>1.$dp[i][0],dp[i][1],dp[i][2],dp[i][3]$分别表示第i天不操作、股票买入、股票卖出、冷冻期的状态。</p>
<p>2.</p>
<p>第i天不操作，可能是第i-1天是不操作、股票买入、股票卖出、冷冻期的状态</p>
<p>第i天股票买入，可能是第i-1天是买入的状态；也可能是第i-1天不操作或冷冻，然后第i天买入，状态转移方程为</p>
<p>$dp[i][1] = max(dp[i-1][1],dp[i-1][3]-prices[i],dp[i-1][0]-prices[i])$</p>
<p>第i天股票卖出，可能是第i-1天是卖出状态；也可能是第i-1天买入，第i天卖出，即$dp[i][2] = max(dp[i-1][2],dp[i-1][1]+prices[i])$</p>
<p>第i天冻结期，一定是第i-1天卖出状态，即$dp[i][3] = dp[i-1][2]$</p>
<p>3,初始化dp[0] [1] = -prices[0]</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(prices)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * <span class="number">4</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">3</span>]-prices[i],dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        dp[i][<span class="number">2</span>] = max(dp[i<span class="number">-1</span>][<span class="number">2</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line">        dp[i][<span class="number">3</span>] = dp[i<span class="number">-1</span>][<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h4 id="6-买卖股票的最佳时机含手续费-2"><a href="#6-买卖股票的最佳时机含手续费-2" class="headerlink" title="6.买卖股票的最佳时机含手续费(2)"></a>6.<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">买卖股票的最佳时机含手续费</a>(2)</h4><blockquote>
<p>和第二题差不多</p>
<p>1.dp[i] [0] 表示第i天持有股票的最大收益，dp[i] [1]表示第i天不持有股票的最大收益</p>
<p>2.$dp[i][0] = max(dp[i-1][0],dp[i-1][1]-prices[i])$ </p>
<p>​    第i天持有股票的最大收益 ：可能是第i-1天就持有股票，第i天什么都没做；也可能是第i-1天不持有股票，第i天购入的</p>
<p>​    $dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i]-fee)$</p>
<p>​    第i天不持有股票的最大收益：可能是第i-1天不持有股票，第i天什么都没做；也可能是第i-1天持有股票，第i天卖出的，要注意还要减去手续费</p>
<p>3.初始化：dp[0] [0] = -prices[0]</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int], fee: int)</span> -&gt; int:</span></span><br><span class="line">    n = len(prices)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [[-prices[<span class="number">0</span>],<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        dp[i%<span class="number">2</span>][<span class="number">0</span>] = max(dp[(i<span class="number">-1</span>)%<span class="number">2</span>][<span class="number">0</span>],dp[(i<span class="number">-1</span>)%<span class="number">2</span>][<span class="number">1</span>]-prices[i])</span><br><span class="line">        dp[i%<span class="number">2</span>][<span class="number">1</span>] = max(dp[(i<span class="number">-1</span>)%<span class="number">2</span>][<span class="number">1</span>],dp[(i<span class="number">-1</span>)%<span class="number">2</span>][<span class="number">0</span>]+prices[i]-fee)</span><br><span class="line">    <span class="keyword">return</span> dp[(n<span class="number">-1</span>)%<span class="number">2</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h3><h4 id="1-最长递增子序列-2"><a href="#1-最长递增子序列-2" class="headerlink" title="1.最长递增子序列(2)"></a>1.<a href="https://leetcode.cn/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长递增子序列</a>(2)</h4><blockquote>
<p>不连续</p>
<p>LIS：</p>
<p>示例：输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p>
<p>1.dp[i] 表示前i个数组成的最长递增子序列</p>
<p>2.nums[i]表示当前的数字，nums[j]表示遍历到前第j个数字(j&lt;i)</p>
<p>​    若nums[j] &lt; nums[i] 更新dp[i] = max(dp[i]，dp[j] + 1)</p>
<p>3.初始化dp为1</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    dp = [<span class="number">1</span>] * n</span><br><span class="line">    res = dp[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                dp[i] = max(dp[i],dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> res &lt; dp[i]:</span><br><span class="line">            res = dp[i]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<blockquote>
<p>贪心+二分</p>
<p>贪心策略：尽可能让上升的速度最慢</p>
<p>d数组并不代表最长子序列，只是表示当前情况下尽可能上升最慢的序列</p>
<p>以输入序列 [0,8,4,12,2] 为例：</p>
<p>第一步插入 0，d=[0]；</p>
<p>第二步插入 8，d=[0,8]；</p>
<p>第三步插入 4，d=[0,4]；</p>
<p>第四步插入 12，d=[0,4,12]；</p>
<p>第五步插入 2，d=[0,2,12]。</p>
<p>最终得到最大递增子序列长度为 3。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    d = []</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> d <span class="keyword">or</span> n &gt; d[<span class="number">-1</span>]:</span><br><span class="line">            d.append(n)</span><br><span class="line">        l,r = <span class="number">0</span>,len(d) - <span class="number">1</span></span><br><span class="line">        loc = r</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l+r) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> n &lt;= d[mid]:</span><br><span class="line">                loc = mid</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        d[loc] = n</span><br><span class="line">    <span class="keyword">return</span> len(d)</span><br></pre></td></tr></table></figure>
<h4 id="2-最长连续递增序列"><a href="#2-最长连续递增序列" class="headerlink" title="2.最长连续递增序列"></a>2.<a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">最长连续递增序列</a></h4><blockquote>
<p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p>
<p>使用temp替代了dp数组，temp表示以i结尾的子序列长度是多少</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLengthOfLCIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    temp = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; nums[i<span class="number">-1</span>]:</span><br><span class="line">            temp += <span class="number">1</span></span><br><span class="line">            res = max(res,temp)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="3-最长重复子数组-2"><a href="#3-最长重复子数组-2" class="headerlink" title="3.最长重复子数组(2)"></a>3.<a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">最长重复子数组</a>(2)</h4><blockquote>
<p>要连续</p>
<p>示例：nums1 = [3,2,1,4,7] ，nums2 = [1,2,3,2,1]，最长重复子数组为[3,2,1]</p>
<p>1.dp[i] [j] 表示以i-1和j-1结尾的最长重复子数组长度。</p>
<p>2.当nums1[i] == nums[j] 时，dp[i] [j] = dp[i-1] [j-1] + 1，其余时候都等于0(比如以7结尾的重复子数组长度为0)</p>
<p>3.初始化都为0</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLength</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; int:</span></span><br><span class="line">    n1 = len(nums1)</span><br><span class="line">    n2 = len(nums2)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (n2 + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n1+<span class="number">1</span>)]</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n1+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n2+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums1[i<span class="number">-1</span>] == nums2[j<span class="number">-1</span>]:</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">            res = max(res,dp[i][j])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="4-最长公共子序列-2"><a href="#4-最长公共子序列-2" class="headerlink" title="4.最长公共子序列(2)"></a>4.<a href="https://leetcode.cn/problems/longest-common-subsequence/" target="_blank" rel="noopener">最长公共子序列</a>(2)</h4><blockquote>
<p>LCS</p>
<p>不连续，所以当不相等时，可以依赖前面的状态</p>
<p>1、dp[i] [j] 表示以i和j结尾的最长公共子序列</p>
<p>2、 如果text1[i]等于text2[j]，  $dp[i][j] = dp[i-1][j-1]+1$<br>       否则，$dp[i][j] = max(dp[i-1][j],dp[i][j-1])$</p>
<p>3、初始化dp[i] [j] 等于0</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class="line">    l1 = len(text1)</span><br><span class="line">    l2 = len(text2)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (l2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(l1+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l1+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,l2+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>]:</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[l1][l2]</span><br></pre></td></tr></table></figure>
<h4 id="5-不相交的线-2"><a href="#5-不相交的线-2" class="headerlink" title="5.不相交的线(2)"></a>5.<a href="https://leetcode.cn/problems/uncrossed-lines/" target="_blank" rel="noopener">不相交的线</a>(2)</h4><blockquote>
<p>不连续</p>
<p>就是LCS</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxUncrossedLines</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; int:</span></span><br><span class="line">    l1 = len(nums1)</span><br><span class="line">    l2 = len(nums2)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (l2 + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(l1 + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, l1 + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, l2 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]:</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[l1][l2]</span><br></pre></td></tr></table></figure>
<h4 id="6-最大子数组和-2"><a href="#6-最大子数组和-2" class="headerlink" title="6.最大子数组和(2)"></a>6.<a href="https://leetcode.cn/problems/maximum-subarray/" target="_blank" rel="noopener">最大子数组和</a>(2)</h4><blockquote>
<p>temp 如果小于等于0那么前面的正数都没有了价值，直接重头开始</p>
<p>temp大于0时，才给res赋值</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    res,temp = nums[<span class="number">0</span>],<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="comment"># 防止[-2,-1,0]这样的无正数的输入</span></span><br><span class="line">        <span class="comment">#if res &lt;= 0 and num &lt;= 0:</span></span><br><span class="line">        <span class="comment">#    res = max(res,num)</span></span><br><span class="line">        <span class="comment">#    continue</span></span><br><span class="line">        <span class="comment">#temp += num</span></span><br><span class="line">        <span class="comment">#if temp &lt;= 0:</span></span><br><span class="line">        <span class="comment">#    temp = 0</span></span><br><span class="line">        <span class="comment">#else:</span></span><br><span class="line">        <span class="comment">#    res = max(res,temp)</span></span><br><span class="line">        <span class="keyword">if</span> temp &gt; <span class="number">0</span>:</span><br><span class="line">            temp += num</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp = num</span><br><span class="line">        <span class="keyword">if</span> temp &gt; res:</span><br><span class="line">            res = temp</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="7-判断子序列"><a href="#7-判断子序列" class="headerlink" title="7.判断子序列"></a>7.<a href="https://leetcode.cn/problems/is-subsequence/" target="_blank" rel="noopener">判断子序列</a></h4><blockquote>
<p>双指针只需要O(m+n)的时间复杂度</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">    i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    ns,nt = len(s),len(t)</span><br><span class="line">    <span class="keyword">if</span> ns == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; ns <span class="keyword">and</span> j &lt; nt:</span><br><span class="line">        <span class="keyword">if</span> s[i] == t[j]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == ns:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以用dp解决</p>
<p>1.dp[i] [j]表示s前i个字符和t前j个字符相同子序列的长度</p>
<p>2.若s[i] == t[j] ，dp[i] [j] = max(dp[i-1] [j-1] + 1) </p>
<p>否则，dp[i] [j] = dp[i] [j - 1] (因为是看t里面有没有s)</p>
<p>3.初始化dp为0</p>
<p>举例</p>
<p>​    ‘’  a h b g d c</p>
<p>‘’  0  0 0 0 0 0 0</p>
<p>a 0  1 1 1 1 1 1</p>
<p>d 0  0 0 0 0 2 2</p>
<p>c 0  0 0 0 0 0 3</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">    l1,l2 = len(s),len(t)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (l2 + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(l1 + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l1+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,l2+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>]:</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = dp[i][j<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[l1][l2]==l1</span><br></pre></td></tr></table></figure>
<h4 id="8-不同的子序列-3"><a href="#8-不同的子序列-3" class="headerlink" title="8.不同的子序列(3)"></a>8.<a href="https://leetcode.cn/problems/distinct-subsequences/" target="_blank" rel="noopener">不同的子序列</a>(3)</h4><blockquote>
<p>s=”babgbag”，t=”bag”</p>
<p>1.dp[i] [j]表示以i结尾的s子序列中出现以j结尾的t个数</p>
<p>2.当s[i]=t[j]时，有两种情况：</p>
<p>​    一是：用s[i]来匹配的，个数为dp[i-1] [j-1]</p>
<p>​    二是：不用s[i] 来匹配的，个数就是dp[i-1] [j]</p>
<p>​    一好理解，二的话，举个例子bagg，bag，不用s[i]匹配，就是bagg前三个字符就能匹配到bag</p>
<p>​    综上：dp[i] [j] = dp[i-1] [j-1] + dp[i-1] [j]</p>
<p>​    当s[i]不等于t[j]时，就一种情况，等于以i-1结尾的s子序列中出现以j结尾的t个数，即dp[i] [j] = dp[i-1] [j]</p>
<p>3.dp[i] [0] 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。那么就是1</p>
<p>​    dp[0] [j] ：无论如何空字符串s也不可能组成非空字符串t，所以dp[0] [j] = 0</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numDistinct</span><span class="params">(self, s: str, t: str)</span> -&gt; int:</span></span><br><span class="line">    m,n = len(s),len(t)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>]:</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]+dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="9-两个字符串的删除操作-2"><a href="#9-两个字符串的删除操作-2" class="headerlink" title="9.两个字符串的删除操作(2)"></a>9.<a href="https://leetcode.cn/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener">两个字符串的删除操作</a>(2)</h4><blockquote>
<p>本质上就是求LCS，然后用两字符串长度减去LCS长度</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">    l1,l2 = len(word1),len(word2)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (l2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(l1+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l1+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,l2+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]:</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> l1+l2<span class="number">-2</span>*dp[l1][l2]</span><br></pre></td></tr></table></figure>
<h4 id="10-编辑距离-3"><a href="#10-编辑距离-3" class="headerlink" title="==10.编辑距离(3)=="></a>==10.<a href="https://leetcode.cn/problems/edit-distance/" target="_blank" rel="noopener">编辑距离</a>(3)==</h4><blockquote>
<p>1.dp[i] [j] 表示对前i-1字符的word1和前j-1字符的word2编辑所需的最少操作数</p>
<p>2.<strong>对word1删除和对word2增加是相同的操作；同理，对word1增加和对word2删除是相同的操作</strong></p>
<p>​    本质上不同的有三种操作：</p>
<p>​    1.对word1删除</p>
<p>​    2.对word2删除</p>
<p>​    3.替换word1字符</p>
<p>当word1[i] = word2[j]时，</p>
<p>​    $dp[i][j] = dp[i-1][j-1]$    </p>
<p>当$word1[i]\neq word2[j]$时，有如上的三种操作：</p>
<p>​    1.对word1删除时，$dp[i][j]=dp[i-1][j]+1$</p>
<p>​    2.对word2删除时，$dp[i][j]=dp[i][j-1]+1$</p>
<p>​    3.替换word1字符时，$dp[i][j]=dp[i-1][j-1]+1$</p>
<p>​    $dp[i][j]=max(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1$</p>
<p>3.初始化：</p>
<p>​    dp[i] [0]初始化为i，表示对word1删除i次就能得到空字符串</p>
<p>​    dp[0] [j]初始化为j，表示对word1增加j次就能得到word2</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">    l1,l2 = len(word1),len(word2)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (l2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(l1+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l1+<span class="number">1</span>):</span><br><span class="line">        dp[i][<span class="number">0</span>] = i</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l2+<span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][i] = i</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l1+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,l2+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]:</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[l1][l2]</span><br></pre></td></tr></table></figure>
<h4 id="11-回文子串-2"><a href="#11-回文子串-2" class="headerlink" title="==11.回文子串(2)=="></a>==11.<a href="https://leetcode.cn/problems/palindromic-substrings/" target="_blank" rel="noopener">回文子串</a>(2)==</h4><blockquote>
<p>1.$dp[i][j]$表示区间[i,j]的子串是否是回文子串</p>
<p>2.若$s[i]\neq s[j]，dp[i][j]=False$</p>
<p>​    若$s[i]=s[j]$，分三种情况：</p>
<p>​    情况一：j==i，dp[i] [j] = True</p>
<p>​    情况二：j - i &lt;= 2，如’aa’和’aba’，因为已知条件是$s[i]=s[j]$，所以他们一定是回文子串</p>
<p>​    情况三：j - i &gt; 2，如’abba’，那么就看’bb’是不是回文子串了，即dp[i+1] [j-1]</p>
<p>3.遍历顺序：因为dp[i] [j] 依赖dp[i+1] [j-1]，所以i是逆序遍历，j是正序遍历；还要注意j从i遍历到n，不然会造成重复遍历</p>
<p>4.初始化：dp[i] [j]=False</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i,n):</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> (j - i &lt;= <span class="number">2</span> <span class="keyword">or</span> dp[i+<span class="number">1</span>][j<span class="number">-1</span>]):</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                dp[i][j] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="12-最长回文子序列-2"><a href="#12-最长回文子序列-2" class="headerlink" title="12.最长回文子序列(2)"></a>12.<a href="https://leetcode.cn/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">最长回文子序列</a>(2)</h4><blockquote>
<p>==不能直接套用第11题，因为11题是连续的，这里是不连续的==</p>
<p>1.dp[i] [j]表示区间[i,j]的最长回文子序列</p>
<p>2.当s[i]=s[j]时，dp[i] [j] = dp[i+1] [j-1] + 2，显而易见</p>
<p>​    当$s[i]\neq s[j]$，说明区间[i,j]不能增加长度，所以$dp[i][j] = max(dp[i+1][j],dp[i][j-1])$</p>
<p>3.遍历顺序同11题</p>
<p>4.初始化：防止dp[i+1] [j-1]越界，所以提前初始化dp[i] [i] = 1</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">        dp[i][i] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = max(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>子序列问题一定要记得构造dp[m] [n]数组，其他就是差不多的变化</p>
<p>子序列(不连续)：1,4,5</p>
<p>子序列(连续)：2,3,6</p>
<p>编辑距离：7-10</p>
<p>回文序列：11,12</p>
<p><img alt="img" data-src="https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%80%BB%E7%BB%93%E5%A4%A7%E7%BA%B21.jpg"></p>
<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="1-朋友圈-2"><a href="#1-朋友圈-2" class="headerlink" title="1.朋友圈(2)"></a>1.<a href="https://leetcode.cn/problems/number-of-provinces/" target="_blank" rel="noopener">朋友圈</a>(2)</h3><h4 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h4><blockquote>
<p>思路：从每一个城市出发，看能有几次机会从一个城市出发(因为有visited数组限制)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, isConnected: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i:int)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> visited,n</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> isConnected[i][j] == <span class="number">1</span> <span class="keyword">and</span> visited[j] <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                visited[j] = <span class="literal">True</span></span><br><span class="line">                dfs(j)</span><br><span class="line">    n = len(isConnected)</span><br><span class="line">    visited = [<span class="literal">False</span>] * n</span><br><span class="line">    province = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> visited[i] <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">            dfs(i)</span><br><span class="line">            province += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> province</span><br></pre></td></tr></table></figure>
<h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><blockquote>
<p>板子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x:int)</span>-&gt;int:</span> <span class="comment"># 逐层寻找父节点</span></span><br><span class="line">&gt;  	<span class="keyword">if</span> p[x] != x:</span><br><span class="line">&gt;      		<span class="comment"># 路径压缩，直接返根节点父节点</span></span><br><span class="line">&gt;         	<span class="comment"># find(p[x])虽然会去找根节点，但最后返回的还是父节点</span></span><br><span class="line">&gt;      		p[x] = find(p[x])</span><br><span class="line">&gt;  	<span class="keyword">return</span> p[x]</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(i,j)</span>:</span> <span class="comment"># 融合的话就默认让i的父节点接到j的父节点上</span></span><br><span class="line">&gt;  	p[find[i]] = find[j]</span><br><span class="line">&gt; </span><br><span class="line">&gt; p = [<span class="number">0</span>] * n</span><br><span class="line">&gt; <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">&gt;  	p[i] = i</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>路径压缩：只是尽量让树的层数更少，并不一定只有2层，像图中一样完美</p>
<p><img alt="image.png" data-src="https://pic.leetcode-cn.com/1609861184-fXdaCo-image.png"></p>
<p>1.父节点满足$p[i]==i$</p>
<p>2.查询每个连通块点的数量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 初始化:</span></span><br><span class="line">&gt; nums = [<span class="number">1</span>] * n</span><br><span class="line">&gt; <span class="comment">#赋值:</span></span><br><span class="line">&gt; t1 = find(i)</span><br><span class="line">&gt; t2 = find(j)</span><br><span class="line">&gt; <span class="comment"># 让节点数量都加到父节点上，最后查询的时候就在父节点上</span></span><br><span class="line">&gt; nums[t2] += nums[t1]</span><br><span class="line">&gt; <span class="comment"># 查询:直接查询该节点的父节点上的数量</span></span><br><span class="line">&gt; nums[find(a)]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>3.查询是否在一个连通块中：$find(a)==find(b)$</p>
<p>找结点个数：最后p[i]的值还满足p[i] == i说明这个是父节点</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, isConnected: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x:int)</span>-&gt;int:</span></span><br><span class="line">        <span class="keyword">if</span> p[x] != x:</span><br><span class="line">            p[x] = find(p[x])</span><br><span class="line">        <span class="keyword">return</span> p[x]</span><br><span class="line">    n = len(isConnected)</span><br><span class="line">    p = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        p[i] = i</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> isConnected[i][j] == <span class="number">1</span>:</span><br><span class="line">                p[find(i)] = find(j)</span><br><span class="line">    province = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> p[i] == i:</span><br><span class="line">            province += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> province</span><br></pre></td></tr></table></figure>
<h3 id="2-判断二分图-2"><a href="#2-判断二分图-2" class="headerlink" title="2.判断二分图(2)"></a>2.<a href="https://leetcode.cn/problems/is-graph-bipartite/" target="_blank" rel="noopener">判断二分图</a>(2)</h3><blockquote>
<p>并查集 二分图</p>
<p>用并查集解决问题时，发现当前结点在邻接结点的集合中时，说明当前的不是二分图</p>
<p>如果是二分图，那么图中每个顶点的所有邻接点都应该属于同一集合，且不与顶点处于同一集合</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span><span class="params">(self, graph: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x != p[x]:</span><br><span class="line">            p[x] = find(p[x])</span><br><span class="line">        <span class="keyword">return</span> p[x]</span><br><span class="line">    p = list(range(len(graph)))</span><br><span class="line">    <span class="keyword">for</span> u,g <span class="keyword">in</span> enumerate(graph):</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> g:</span><br><span class="line">            <span class="keyword">if</span> find(u) == find(v): <span class="comment"># 发现当前结点在邻接矩阵的集合中</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            p[find(v)] = find(g[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>着色法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span><span class="params">(self, graph: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i,c)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> valid,color</span><br><span class="line">        color[i] = c</span><br><span class="line">        cN = <span class="number">2</span> <span class="keyword">if</span> c == <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> nei <span class="keyword">in</span> graph[i]: <span class="comment"># i的所有邻接结点都染色为cN</span></span><br><span class="line">            <span class="keyword">if</span> color[nei] == <span class="number">0</span>: <span class="comment"># 未着色</span></span><br><span class="line">                dfs(nei,cN)</span><br><span class="line">                <span class="keyword">if</span> valid <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">elif</span> color[nei] != cN: <span class="comment"># 已经着色了,但和预期的不同</span></span><br><span class="line">                valid = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    n = len(graph)</span><br><span class="line">    color = [<span class="number">0</span>] * n</span><br><span class="line">    valid = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n): <span class="comment"># 可能不是连通图,要多次染色</span></span><br><span class="line">        <span class="keyword">if</span> valid <span class="keyword">is</span> <span class="literal">True</span> <span class="keyword">and</span> color[i] == <span class="number">0</span>:</span><br><span class="line">            dfs(i,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> valid</span><br></pre></td></tr></table></figure>
<h3 id="3-所有可能的路径-2"><a href="#3-所有可能的路径-2" class="headerlink" title="3.所有可能的路径(2)"></a>3.<a href="https://leetcode.cn/problems/all-paths-from-source-to-target/description/" target="_blank" rel="noopener">所有可能的路径</a>(2)</h3><blockquote>
<p>比较简单的一道dfs的题目</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allPathsSourceTarget</span><span class="params">(self, graph: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i,r)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> target</span><br><span class="line">        <span class="keyword">if</span> i == target:</span><br><span class="line">            res.append(r.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> graph[i]:</span><br><span class="line">            r.append(v)</span><br><span class="line">            dfs(v,r)</span><br><span class="line">            r.pop()</span><br><span class="line"></span><br><span class="line">    target = len(graph) - <span class="number">1</span></span><br><span class="line">    res = []</span><br><span class="line">    dfs(<span class="number">0</span>,[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="4-除法求值-2"><a href="#4-除法求值-2" class="headerlink" title="4.除法求值(2)"></a>4.<a href="https://leetcode.cn/problems/evaluate-division/" target="_blank" rel="noopener">除法求值</a>(2)</h3><blockquote>
<p>有点难度</p>
<p>注意这边不需要路径压缩，不然无法得到子节点之间的父子关系</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcEquation</span><span class="params">(self, equations: List[List[str]], values: List[float], queries: List[List[str]])</span> -&gt; List[float]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(x:str)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> p,v</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> p:</span><br><span class="line">            p[x] = x</span><br><span class="line">            v[x] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">root</span><span class="params">(x:str)</span>-&gt;str:</span> <span class="comment"># 直接返回根节点</span></span><br><span class="line">        <span class="keyword">nonlocal</span> p</span><br><span class="line">        <span class="keyword">while</span> p[x] != x:</span><br><span class="line">            x = p[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_value</span><span class="params">(x)</span>:</span><span class="comment"># 从叶子结点算到根节点的乘积,深度越深的结点,算出的值越大</span></span><br><span class="line">        value = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p[x] != x:</span><br><span class="line">            value *= v[x]</span><br><span class="line">            x = p[x]</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(parent:str,child:str,value:int)</span>:</span></span><br><span class="line">        init(parent)</span><br><span class="line">        init(child)</span><br><span class="line">        root1 = root(parent)</span><br><span class="line">        root2 = root(child)</span><br><span class="line">        <span class="keyword">if</span> root1 != root2:</span><br><span class="line">            <span class="comment"># p[root2] = root1</span></span><br><span class="line">            <span class="comment"># v[root2] = value * (get_value(parent)/get_value(child))</span></span><br><span class="line">            p[root1] = root2</span><br><span class="line">            v[root1] = value * (get_value(child) / get_value(parent))</span><br><span class="line">            <span class="comment"># 这边测试要使用2个集合(元素不少于2)合并才能看得出来</span></span><br><span class="line">            <span class="comment"># 测试用例:a/b=3.4    e/f=1.4     b/e=2.3</span></span><br><span class="line"></span><br><span class="line">    p = &#123;&#125;</span><br><span class="line">    v = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(equations)):</span><br><span class="line">        union(equations[i][<span class="number">0</span>],equations[i][<span class="number">1</span>],values[i])</span><br><span class="line">    res = [<span class="number">0</span>] * len(queries)</span><br><span class="line">    <span class="keyword">for</span> i,query <span class="keyword">in</span> enumerate(queries):</span><br><span class="line">        parent = query[<span class="number">0</span>]</span><br><span class="line">        child = query[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (parent <span class="keyword">in</span> p <span class="keyword">and</span> child <span class="keyword">in</span> p):</span><br><span class="line">            res[i] = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> parent == child:</span><br><span class="line">            res[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        root1 = root(parent)</span><br><span class="line">        root2 = root(child)</span><br><span class="line">        <span class="keyword">if</span> root1 != root2:</span><br><span class="line">            res[i] = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># res[i] = get_value(child)/get_value(parent)</span></span><br><span class="line">        res[i] = get_value(parent)/get_value(child)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="5-课程表-II-2"><a href="#5-课程表-II-2" class="headerlink" title="5.课程表 II(2)"></a>5.<a href="https://leetcode.cn/problems/course-schedule-ii/" target="_blank" rel="noopener">课程表 II</a>(2)</h3><blockquote>
<p>拓扑排序，dfs类似Q1,2</p>
<p>dfs：对每个valid且没访问过的结点进行dfs访问，</p>
<p>可以简单的类比并查集求二分图，不过这里是有向图，</p>
<p>每次遍历节点时，只有箭头方向的流向的结点才会被放入栈中，被视为一个“连通块”，其次，先放入栈中的是后学的课程(最后结果要倒序)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findOrder</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">    edges = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> pre <span class="keyword">in</span> prerequisites:</span><br><span class="line">        edges[pre[<span class="number">1</span>]].append(pre[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> valid</span><br><span class="line">        visited[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> edges[i]:</span><br><span class="line">            <span class="keyword">if</span> visited[u] == <span class="number">0</span>: <span class="comment"># 未搜索</span></span><br><span class="line">                dfs(u)</span><br><span class="line">                <span class="keyword">if</span> valid <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">elif</span> visited[u] == <span class="number">1</span>: <span class="comment"># 找到了在搜索中的，说明存在环</span></span><br><span class="line">                valid = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        visited[i] = <span class="number">2</span></span><br><span class="line">        res.append(i)</span><br><span class="line"></span><br><span class="line">    visited = [<span class="number">0</span>] * numCourses</span><br><span class="line">    valid = <span class="literal">True</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">0</span> <span class="keyword">and</span> valid:</span><br><span class="line">            dfs(i)</span><br><span class="line">    <span class="keyword">if</span> valid <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>bfs</p>
<p>这里不用deque队列也行</p>
<p>1.初始化统计每个节点的入度，存储边的信息(有向图)</p>
<p>2.每次从队列中取出入度为0的点，遍历有向边的，将边相连的另一个点的入度-1，若最后入度等于0，入队。</p>
<p>3.直到队列为空，返回</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findOrder</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">    edges = collections.defaultdict(list)</span><br><span class="line">    indeg = [<span class="number">0</span>] * numCourses</span><br><span class="line">    <span class="keyword">for</span> pre <span class="keyword">in</span> prerequisites:</span><br><span class="line">        edges[pre[<span class="number">1</span>]].append(pre[<span class="number">0</span>])</span><br><span class="line">        indeg[pre[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">    d = [u <span class="keyword">for</span> u <span class="keyword">in</span> range(numCourses) <span class="keyword">if</span> indeg[u] == <span class="number">0</span>]</span><br><span class="line">   	<span class="comment"># q = collections.deque([u for u in range(numCourses) if indeg[u] == 0])</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> d:</span><br><span class="line">        u = d.pop()</span><br><span class="line">        <span class="comment"># u = q.popleft()</span></span><br><span class="line">        res.append(u)</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> edges[u]:</span><br><span class="line">            indeg[e] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> indeg[e] == <span class="number">0</span>:</span><br><span class="line">                d.append(e)</span><br><span class="line">    <span class="keyword">if</span> len(res) != numCourses:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="6-钥匙和房间-2"><a href="#6-钥匙和房间-2" class="headerlink" title="6.钥匙和房间(2)"></a>6.<a href="https://leetcode.cn/problems/keys-and-rooms/" target="_blank" rel="noopener">钥匙和房间</a>(2)</h3><blockquote>
<p>这道题只能从0号房间出发</p>
<p>dfs</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canVisitAllRooms</span><span class="params">(self, rooms: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> visited</span><br><span class="line">        visited[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> rooms[i]:</span><br><span class="line">            <span class="keyword">if</span> visited[key] == <span class="number">0</span>:</span><br><span class="line">                dfs(key)</span><br><span class="line"></span><br><span class="line">    n = len(rooms)</span><br><span class="line">    visited = [<span class="number">0</span>] * n</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> vis <span class="keyword">in</span> visited:</span><br><span class="line">        <span class="keyword">if</span> vis == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>bfs</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canVisitAllRooms</span><span class="params">(self, rooms: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">    d = deque()</span><br><span class="line">    d.append(<span class="number">0</span>)</span><br><span class="line">    visited = [<span class="number">0</span>] * len(rooms)</span><br><span class="line">    visited[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> d:</span><br><span class="line">        room = d.popleft()</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> rooms[room]:</span><br><span class="line">            <span class="keyword">if</span> visited[key] == <span class="number">0</span>:</span><br><span class="line">                visited[key] = <span class="number">1</span></span><br><span class="line">                d.append(key)</span><br><span class="line">    <span class="keyword">for</span> vis <span class="keyword">in</span> visited:</span><br><span class="line">        <span class="keyword">if</span> vis == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="7-冗余连接-2"><a href="#7-冗余连接-2" class="headerlink" title="7.冗余连接(2)"></a>7.<a href="https://leetcode.cn/problems/redundant-connection/" target="_blank" rel="noopener">冗余连接</a>(2)</h3><blockquote>
<p>并查集 无向边</p>
<p>一开始每条边都在不同的集合里，逐条边遍历，查找根节点。如果根节点一样，说明当前边是冗余的；否则，合并。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findRedundantConnection</span><span class="params">(self, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> p[x] != x:</span><br><span class="line">            p[x] = find(p[x])</span><br><span class="line">        <span class="keyword">return</span> p[x]</span><br><span class="line"></span><br><span class="line">    n = len(edges)</span><br><span class="line">    p = list(range(n+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">        t1 = find(edge[<span class="number">0</span>])</span><br><span class="line">        t2 = find(edge[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> t1 == t2:</span><br><span class="line">            <span class="keyword">return</span> edge</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p[t1] = t2</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="8-冗余连接II-3"><a href="#8-冗余连接II-3" class="headerlink" title="8.冗余连接II(3)"></a>8.<a href="https://leetcode.cn/problems/redundant-connection-ii/description/" target="_blank" rel="noopener">冗余连接II</a>(3)</h3><blockquote>
<p>并查集 无向边</p>
<p>题意：给出的边，有一条是冗余的，去掉这条边就能将图转化为树</p>
<p>有两种情况：</p>
<p>1.存在入度为2的点</p>
<p><img alt="img" data-src="https://code-thinking.cdn.bcebos.com/pics/685.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II1.png"></p>
<p>那么一定是删掉入度为2 的点的其中一条边</p>
<p>2.不存在入度为2的点，但存在有向环</p>
<p><img alt="img" data-src="https://code-thinking.cdn.bcebos.com/pics/685.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II2.png"></p>
<p>那么就是删掉有向环中的一条边</p>
<p>整体做法：</p>
<p>1.首先统计所有点的入度</p>
<p>2.统计所有入度为2的点(注意这里要逆序统计，因为题目要求返回最后给出的边)</p>
<p>3.若存在入度为2的点，尝试删去其中一条边，若是树就返回这条边，不是的话，就返回另一条边</p>
<p>​    若不存在入度为2的点，存在有向环，那么就遍历结点，加入并查集，若存在两个根一样的结点对应的边，那么这条边就是冗余边(可以参考第7题)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findRedundantDirectedConnection</span><span class="params">(self, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x != p[x]:</span><br><span class="line">            p[x] = find(p[x])</span><br><span class="line">        <span class="keyword">return</span> p[x]</span><br><span class="line"></span><br><span class="line">    n = len(edges)</span><br><span class="line">    <span class="comment"># 统计入度</span></span><br><span class="line">    indeg = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        indeg[edges[i][<span class="number">1</span>]] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 统计入度为2的结点对应的2条边(记录边的索引)</span></span><br><span class="line">    two_edge = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> indeg[edges[i][<span class="number">1</span>]] == <span class="number">2</span>:</span><br><span class="line">            two_edge.append(i)</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 处理图中情况1 和 情况2</span></span><br><span class="line">    <span class="keyword">if</span> len(two_edge) &gt; <span class="number">0</span>: <span class="comment"># 如果有一个结点入度为2,看删除哪条边会变成树</span></span><br><span class="line">        p = list(range(n+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># 尝试删除two_edge[0]的边,所以忽略two_edge[0]这条边,不放入并查集中</span></span><br><span class="line">            <span class="comment"># 因为要返回数组的最后一条,所以倒序尝试从最后一条边开始删除</span></span><br><span class="line">            <span class="keyword">if</span> i == two_edge[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            t1 = find(edges[i][<span class="number">0</span>])</span><br><span class="line">            t2 = find(edges[i][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> t1 == t2: <span class="comment"># 构成环了,说明删除two_edge[0]的边,依然不能变成树,所以应该删除另一条边</span></span><br><span class="line">                <span class="keyword">return</span> edges[two_edge[<span class="number">1</span>]]</span><br><span class="line">            p[t2] = t1</span><br><span class="line">        <span class="keyword">return</span> edges[two_edge[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 没有入度为2的结点，就一定存在有向环</span></span><br><span class="line">    p = list(range(n+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        t1 = find(edges[i][<span class="number">0</span>])</span><br><span class="line">        t2 = find(edges[i][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> t1 == t2:</span><br><span class="line">            <span class="keyword">return</span> edges[i]</span><br><span class="line">        p[t2] = t1</span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<h3 id="9-单词接龙-3"><a href="#9-单词接龙-3" class="headerlink" title="9.单词接龙(3)"></a>9.<a href="https://leetcode.cn/problems/word-ladder/description/" target="_blank" rel="noopener">单词接龙</a>(3)</h3><blockquote>
<p>bfs</p>
<p>每次从队列中取出一个词，逐个字母替换26个字母，</p>
<p>每次遍历放入一个单词 距离要+1</p>
<p>细节：newWord如果在mapping中了，就不能再放入了，因为再放就不是最小值了</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; int:</span></span><br><span class="line">    wordSet = set(wordList)</span><br><span class="line">    <span class="keyword">if</span> len(wordSet)== <span class="number">0</span> <span class="keyword">or</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordSet:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    mapping = &#123;beginWord:<span class="number">1</span>&#125;</span><br><span class="line">    queue = deque([beginWord])</span><br><span class="line">    <span class="keyword">while</span> queue:<span class="comment"># 每次从队列中取出一个词，逐个字母替换</span></span><br><span class="line">        word = queue.popleft()</span><br><span class="line">        path = mapping[word]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">            word_list = list(word)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">                word_list[i] = chr(ord(<span class="string">'a'</span>)+j)</span><br><span class="line">                newWord = <span class="string">""</span>.join(word_list)</span><br><span class="line">                <span class="keyword">if</span> newWord == endWord: <span class="comment"># 找到了endWord</span></span><br><span class="line">                    <span class="keyword">return</span> path+<span class="number">1</span></span><br><span class="line">                <span class="comment"># newWord如果在mapping中了，就不能再放入了，因为再放就不是最小值了</span></span><br><span class="line">                <span class="keyword">if</span> newWord <span class="keyword">in</span> wordSet <span class="keyword">and</span> newWord <span class="keyword">not</span> <span class="keyword">in</span> mapping:</span><br><span class="line">                    mapping[newWord] = path+<span class="number">1</span></span><br><span class="line">                    queue.append(newWord)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer"><a href="#剑指-Offer" class="headerlink" title="剑指 Offer"></a><a href="https://github.com/doocs/leetcode/blob/main/lcof2/README.md" target="_blank" rel="noopener">剑指 Offer</a></h2><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><h4 id="001-整数除法-2"><a href="#001-整数除法-2" class="headerlink" title="001. 整数除法(2)"></a><a href="https://leetcode.cn/problems/xoh6Oh/description/" target="_blank" rel="noopener">001. 整数除法</a>(2)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, a: int, b: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># 处理特殊情况</span></span><br><span class="line">    MIN, MAX = -(<span class="number">1</span> &lt;&lt; <span class="number">31</span>), (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> a == MIN:</span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> MIN</span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> MAX</span><br><span class="line">    <span class="keyword">if</span> b == MIN:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> a == MIN <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	<span class="comment"># 判断符号，将所有负数变为整数</span></span><br><span class="line">    reverse = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">0</span>:</span><br><span class="line">        a = -a</span><br><span class="line">        reverse = <span class="keyword">not</span> reverse</span><br><span class="line">    <span class="keyword">if</span> b &lt; <span class="number">0</span>:</span><br><span class="line">        b = -b</span><br><span class="line">        reverse = <span class="keyword">not</span> reverse</span><br><span class="line">	<span class="comment"># 按照二进制的原理，统计a用b表示的个数</span></span><br><span class="line">    candidates = [b]</span><br><span class="line">    <span class="keyword">while</span> candidates[<span class="number">-1</span>] &lt;= a - candidates[<span class="number">-1</span>]:</span><br><span class="line">        candidates.append(candidates[<span class="number">-1</span>] &lt;&lt; <span class="number">1</span>)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 按照二进制的原理，统计a用b表示的个数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(candidates)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> a &gt;= candidates[i]:</span><br><span class="line">            res += (<span class="number">1</span>&lt;&lt;i)</span><br><span class="line">            a -= candidates[i]</span><br><span class="line">    <span class="keyword">return</span> res <span class="keyword">if</span> <span class="keyword">not</span> reverse <span class="keyword">else</span> -res</span><br></pre></td></tr></table></figure>
<h4 id="002-二进制加法"><a href="#002-二进制加法" class="headerlink" title="002. 二进制加法"></a><a href="https://leetcode.cn/problems/JFETK5/" target="_blank" rel="noopener">002. 二进制加法</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, a: str, b: str)</span> -&gt; str:</span></span><br><span class="line">    la,lb = len(a),len(b)</span><br><span class="line">    ma = max(lb,la)</span><br><span class="line">    a = a[::<span class="number">-1</span>]</span><br><span class="line">    b = b[::<span class="number">-1</span>]</span><br><span class="line">    res = []</span><br><span class="line">    jin = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(ma):</span><br><span class="line">        na,nb = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; la:</span><br><span class="line">            na = int(a[i])</span><br><span class="line">        <span class="keyword">if</span> i &lt; lb:</span><br><span class="line">            nb = int(b[i])</span><br><span class="line">        sum = na + nb + jin</span><br><span class="line">        jin = sum // <span class="number">2</span></span><br><span class="line">        r = sum % <span class="number">2</span></span><br><span class="line">        res.append(str(r))</span><br><span class="line">    <span class="keyword">if</span> jin == <span class="number">1</span>:</span><br><span class="line">        res.append(str(jin))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join(res[::<span class="number">-1</span>])</span><br><span class="line">	<span class="comment"># 高精度转换为十进制</span></span><br><span class="line">	<span class="comment"># return '&#123;0:b&#125;'.format(int(a, 2) + int(b, 2))</span></span><br></pre></td></tr></table></figure>
<h4 id="003-前-n-个数字二进制中-1-的个数"><a href="#003-前-n-个数字二进制中-1-的个数" class="headerlink" title="003. 前 n 个数字二进制中 1 的个数"></a><a href="https://leetcode.cn/problems/w3tCBm/" target="_blank" rel="noopener">003. 前 n 个数字二进制中 1 的个数</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">    bit = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        bit[i] = bit[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span></span><br><span class="line">        <span class="comment"># bit[i] = bit[i &gt;&gt; 1] + (i &amp; 1)</span></span><br><span class="line">    <span class="keyword">return</span> bit</span><br></pre></td></tr></table></figure>
<h4 id="004-只出现一次的数字-2"><a href="#004-只出现一次的数字-2" class="headerlink" title="004. 只出现一次的数字(2)"></a><a href="https://leetcode.cn/problems/WGki4K/" target="_blank" rel="noopener">004. 只出现一次的数字</a>(2)</h4><blockquote>
<p>哈希表</p>
<p>线性时间复杂度和线性空间复杂度</p>
<p>数字电路优化方法，看不懂</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    a,b = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        b = ~a &amp; (b ^ num)</span><br><span class="line">        a = ~b &amp; (a ^ num)</span><br><span class="line">    <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
<h3 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h3><h4 id="006-排序数组中两个数字之和"><a href="#006-排序数组中两个数字之和" class="headerlink" title="006. 排序数组中两个数字之和"></a><a href="https://leetcode.cn/problems/kLl5u1/" target="_blank" rel="noopener">006. 排序数组中两个数字之和</a></h4><blockquote>
<p>遍历每个数num[i]，去二分查找target-num[i]</p>
<p>时间复杂度为O(nlogn)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, numbers: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">    n = len(numbers)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        left,right = i + <span class="number">1</span>,n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + ((right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> numbers[mid] &gt; target-numbers[i]:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> numbers[mid] &lt; target-numbers[i]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [i,mid]</span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<blockquote>
<p>双指针</p>
<p>i,j指向首尾</p>
<p>若num[i]+num[j] &gt; target，j往前移一位(总和就更小)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, numbers: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">    n = len(numbers)</span><br><span class="line">    i,j = <span class="number">0</span>,n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        sum = numbers[i] + numbers[j]</span><br><span class="line">        <span class="keyword">if</span> sum &gt; target:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> sum &lt; target:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [i,j]</span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<h4 id="007-数组中和为-0-的三个数"><a href="#007-数组中和为-0-的三个数" class="headerlink" title="007. 数组中和为 0 的三个数"></a><a href="https://leetcode.cn/problems/1fGaJU/" target="_blank" rel="noopener">007. 数组中和为 0 的三个数</a></h4><blockquote>
<p>同 三数之和</p>
</blockquote>
<h4 id="008-和大于等于-target-的最短子数组"><a href="#008-和大于等于-target-的最短子数组" class="headerlink" title="==008. 和大于等于 target 的最短子数组=="></a><a href="https://leetcode.cn/problems/2VG8Kg/" target="_blank" rel="noopener">==008. 和大于等于 target 的最短子数组==</a></h4><blockquote>
<p>同长度最小的子数组</p>
</blockquote>
<h4 id="009-乘积小于-K-的子数组"><a href="#009-乘积小于-K-的子数组" class="headerlink" title="==009. 乘积小于 K 的子数组=="></a><a href="https://leetcode.cn/problems/ZVAVXX/" target="_blank" rel="noopener">==009. 乘积小于 K 的子数组==</a></h4><blockquote>
<p>思想：滑动窗口</p>
<p>在满足mul &lt; k的情况下，一直乘nums[j]，在第k个数时候，结果是j-i+1，意思就是结果集中要有第j个数，因为前j-1个数，在前面遍历的时候已经放进结果集了。</p>
<p>不满足mul &lt; k的情况下，更新i</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">    res, mul, i = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        mul *= num</span><br><span class="line">        <span class="keyword">while</span> i &lt;= j <span class="keyword">and</span> mul &gt;= k:</span><br><span class="line">            mul //= nums[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        res += j - i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="010-和为-k-的子数组-2"><a href="#010-和为-k-的子数组-2" class="headerlink" title="010. 和为 k 的子数组(2)"></a><a href="https://leetcode.cn/problems/QTMn0o/" target="_blank" rel="noopener">010. 和为 k 的子数组</a>(2)</h4><blockquote>
<p>使用前缀和的思想，统计前缀和的数量</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">    d = defaultdict(int,&#123;<span class="number">0</span>:<span class="number">1</span>&#125;)</span><br><span class="line">    res,sum = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        sum += num</span><br><span class="line">        res += d[sum - k]</span><br><span class="line">        d[sum] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="011-0-和-1-个数相同的子数组"><a href="#011-0-和-1-个数相同的子数组" class="headerlink" title="011. 0 和 1 个数相同的子数组"></a><a href="https://leetcode.cn/problems/A1NYOS/" target="_blank" rel="noopener">011. 0 和 1 个数相同的子数组</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMaxLength</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    res = sum = <span class="number">0</span></span><br><span class="line">    mp = &#123;<span class="number">0</span>:<span class="number">-1</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        sum += <span class="number">1</span> <span class="keyword">if</span> v == <span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> sum <span class="keyword">in</span> mp:</span><br><span class="line">            res = max(res,i - mp[sum])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mp[sum] = i</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="012-左右两边子数组的和相等"><a href="#012-左右两边子数组的和相等" class="headerlink" title="012. 左右两边子数组的和相等"></a><a href="https://leetcode.cn/problems/tvdfij/" target="_blank" rel="noopener">012. 左右两边子数组的和相等</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pivotIndex</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        sum += num</span><br><span class="line">    pre = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index,num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        <span class="keyword">if</span> pre == sum - num - pre:</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        pre += num</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h4 id="013-二维子矩阵的和"><a href="#013-二维子矩阵的和" class="headerlink" title="013. 二维子矩阵的和"></a><a href="https://leetcode.cn/problems/O4NDxx/" target="_blank" rel="noopener">013. 二维子矩阵的和</a></h4><h3 id="字符串-双指针"><a href="#字符串-双指针" class="headerlink" title="字符串/双指针"></a>字符串/双指针</h3><h4 id="014-字符串中的变位词"><a href="#014-字符串中的变位词" class="headerlink" title="014. 字符串中的变位词"></a><a href="https://leetcode.cn/problems/MPnaiL/" target="_blank" rel="noopener">014. 字符串中的变位词</a></h4><p>​    </p>
<h2 id="力扣周赛"><a href="#力扣周赛" class="headerlink" title="力扣周赛"></a>力扣周赛</h2><h3 id="320周"><a href="#320周" class="headerlink" title="320周"></a>320周</h3><h4 id="1-数组中不等三元组的数目"><a href="#1-数组中不等三元组的数目" class="headerlink" title="1.数组中不等三元组的数目"></a>1.<a href="https://leetcode.cn/problems/number-of-unequal-triplets-in-array/" target="_blank" rel="noopener">数组中不等三元组的数目</a></h4><blockquote>
<p>暴力法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unequalTriplets</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(j+<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> nums[i] != nums[j] <span class="keyword">and</span> nums[i] != nums[k] <span class="keyword">and</span> nums[k] != nums[j]:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将三元组分成三个区间 ：start…..i……len(nums)-1，只要区间里的数不重复就行</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unequalTriplets</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    start,res = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[i] != nums[i+<span class="number">1</span>]: <span class="comment"># 防止三元组有相等的</span></span><br><span class="line">            res += start*(i-start+<span class="number">1</span>)*(len(nums)<span class="number">-1</span>-i)</span><br><span class="line">            start = i + <span class="number">1</span> <span class="comment"># 跳过相等的数，防止重复</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="2-二叉搜索树最近节点查询"><a href="#2-二叉搜索树最近节点查询" class="headerlink" title="2.二叉搜索树最近节点查询"></a>2.<a href="https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树最近节点查询</a></h4><blockquote>
<p>相关：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">在排序数组中查找元素的第一个和最后一个位置</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closestNodes</span><span class="params">(self, root: Optional[TreeNode], queries: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    tree = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getVal</span><span class="params">(r)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> tree</span><br><span class="line">        <span class="keyword">if</span> r <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        getVal(r.left)</span><br><span class="line">        tree.append(r.val)</span><br><span class="line">        getVal(r.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMax</span><span class="params">(x,nums)</span>:</span> <span class="comment"># 小于等于x最大值</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; nums[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        i,j = <span class="number">0</span>,len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            m = (i + j + <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &lt;= x:</span><br><span class="line">                i = m</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = m - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(x,nums)</span>:</span> <span class="comment"># 大于等于x最小值</span></span><br><span class="line">        <span class="keyword">if</span> x &gt; nums[<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        i,j = <span class="number">0</span>,len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            m = (i + j) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &gt;= x:</span><br><span class="line">                j = m</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i = m + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[i]</span><br><span class="line"></span><br><span class="line">    getVal(root)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> query <span class="keyword">in</span> queries:</span><br><span class="line">        res.append([getMax(query,tree),getMin(query,tree)])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="3-到达首都的最少油耗"><a href="#3-到达首都的最少油耗" class="headerlink" title="3.到达首都的最少油耗"></a>3.<a href="https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/description/" target="_blank" rel="noopener">到达首都的最少油耗</a></h4><blockquote>
<p>依次遍历子节点，size表示当前结点及其子节点的个数，油耗就是UP(size/seats)上取整</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimumFuelCost</span><span class="params">(self, roads: List[List[int]], seats: int)</span> -&gt; int:</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(roads)+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> x,y <span class="keyword">in</span> roads:</span><br><span class="line">        g[x].append(y)</span><br><span class="line">        g[y].append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x:int,fa:int)</span>-&gt;int:</span></span><br><span class="line">        size = <span class="number">1</span> <span class="comment"># 表示当前结点及其子节点的个数</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> g[x]: <span class="comment"># 遍历子节点</span></span><br><span class="line">            <span class="keyword">if</span> y != fa:</span><br><span class="line">                size += dfs(y,x)</span><br><span class="line">        <span class="keyword">if</span> x != <span class="number">0</span>: <span class="comment"># 不是根节点</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            res += (size + seats - <span class="number">1</span>) // seats <span class="comment"># 上取整</span></span><br><span class="line">        <span class="keyword">return</span> size</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="HOT100"><a href="#HOT100" class="headerlink" title="HOT100"></a>HOT100</h2><h3 id="1-最长回文子串"><a href="#1-最长回文子串" class="headerlink" title="1.最长回文子串"></a>1.<a href="https://leetcode.cn/problems/longest-palindromic-substring/description/?favorite=2cktkvj" target="_blank" rel="noopener">最长回文子串</a></h3><blockquote>
<p>参考子序列问题的第11题</p>
<p>这边的回文子串同样要求是连续的</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    maxL,maxVal = <span class="number">1</span>,s[<span class="number">0</span>]</span><br><span class="line">    dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        dp[i][i] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>,n):</span><br><span class="line">            l = j - i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> (dp[i+<span class="number">1</span>][j<span class="number">-1</span>] <span class="keyword">or</span> j - i &lt;= <span class="number">2</span>):</span><br><span class="line">                dp[i][j] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> dp[i][j] <span class="keyword">and</span> maxL &lt; l:</span><br><span class="line">                maxVal = s[i:j+<span class="number">1</span>]</span><br><span class="line">                maxL = l</span><br><span class="line">    <span class="keyword">return</span> maxVal</span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/alex-next/tags/算法面试题/" rel="tag"># 算法面试题</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/alex-next/2023/01/13/面试题/Redis面试题/" rel="next" title="Redis面试题">
                  <i class="fa fa-chevron-left"></i> Redis面试题
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="gitalk-container"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#python语法"><span class="nav-number">1.</span> <span class="nav-text">python语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-class"><span class="nav-number">1.1.</span> <span class="nav-text">1.class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-排序"><span class="nav-number">1.2.</span> <span class="nav-text">2.排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-优先队列-堆"><span class="nav-number">1.3.</span> <span class="nav-text">3.优先队列(堆)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-浅拷贝深拷贝"><span class="nav-number">1.4.</span> <span class="nav-text">4.浅拷贝深拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-替换子字符串"><span class="nav-number">1.5.</span> <span class="nav-text">5.替换子字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-初始化默认元素为list的map"><span class="nav-number">1.6.</span> <span class="nav-text">6.初始化默认元素为list的map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-字符串"><span class="nav-number">1.7.</span> <span class="nav-text">7.字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-向上取整公式"><span class="nav-number">1.8.</span> <span class="nav-text">8.向上取整公式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时间复杂度"><span class="nav-number">2.</span> <span class="nav-text">时间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归式的三种写法"><span class="nav-number">2.1.</span> <span class="nav-text">递归式的三种写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NP完全理论"><span class="nav-number">2.2.</span> <span class="nav-text">NP完全理论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#随机算法"><span class="nav-number">3.</span> <span class="nav-text">随机算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#参考"><span class="nav-number">3.1.</span> <span class="nav-text">参考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#蒙特卡洛算法"><span class="nav-number">3.2.</span> <span class="nav-text">蒙特卡洛算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-在长度-2N-的数组中找出重复-N-次的元素"><span class="nav-number">3.2.1.</span> <span class="nav-text">1.在长度 2N 的数组中找出重复 N 次的元素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拉斯维加斯算法"><span class="nav-number">3.3.</span> <span class="nav-text">拉斯维加斯算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">4.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-二分查找"><span class="nav-number">4.1.</span> <span class="nav-text">1.二分查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#左闭右闭"><span class="nav-number">4.1.1.</span> <span class="nav-text">左闭右闭</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#左闭右开"><span class="nav-number">4.1.2.</span> <span class="nav-text">左闭右开</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-移除元素"><span class="nav-number">4.2.</span> <span class="nav-text">2.移除元素</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自己的思路实现"><span class="nav-number">4.2.1.</span> <span class="nav-text">自己的思路实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快慢指针"><span class="nav-number">4.2.2.</span> <span class="nav-text">==快慢指针==</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-有序数组的平方"><span class="nav-number">4.3.</span> <span class="nav-text">3.有序数组的平方</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-长度最小的子数组-2"><span class="nav-number">4.4.</span> <span class="nav-text">4.==长度最小的子数组(2)==</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-螺旋矩阵II"><span class="nav-number">4.5.</span> <span class="nav-text">5.螺旋矩阵II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-在排序数组中查找元素的第一个和最后一个位置"><span class="nav-number">4.6.</span> <span class="nav-text">6.在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-数的范围"><span class="nav-number">4.7.</span> <span class="nav-text">7.数的范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">4.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表"><span class="nav-number">5.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-移除链表元素"><span class="nav-number">5.1.</span> <span class="nav-text">1.移除链表元素</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#直接使用原来的链表来进行删除操作"><span class="nav-number">5.1.1.</span> <span class="nav-text">直接使用原来的链表来进行删除操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设置一个虚拟头结点在进行删除操作"><span class="nav-number">5.1.2.</span> <span class="nav-text">==设置一个虚拟头结点在进行删除操作==</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-设计链表"><span class="nav-number">5.2.</span> <span class="nav-text">2.设计链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-反转链表"><span class="nav-number">5.3.</span> <span class="nav-text">3.反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用头插法"><span class="nav-number">5.3.1.</span> <span class="nav-text">使用头插法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#逐个改变next"><span class="nav-number">5.3.2.</span> <span class="nav-text">逐个改变next</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-两两交换链表中的节点-2"><span class="nav-number">5.4.</span> <span class="nav-text">4.两两交换链表中的节点(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-删除链表的倒数第-N-个结点"><span class="nav-number">5.5.</span> <span class="nav-text">5.删除链表的倒数第 N 个结点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#递归写法"><span class="nav-number">5.5.1.</span> <span class="nav-text">递归写法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快慢指针-1"><span class="nav-number">5.5.2.</span> <span class="nav-text">快慢指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-链表相交"><span class="nav-number">5.6.</span> <span class="nav-text">6.链表相交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-环形链表-II-2"><span class="nav-number">5.7.</span> <span class="nav-text">7.环形链表 II(2)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用set缓存"><span class="nav-number">5.7.1.</span> <span class="nav-text">使用set缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用O-1-的空间"><span class="nav-number">5.7.2.</span> <span class="nav-text">使用O(1)的空间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">5.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希表"><span class="nav-number">6.</span> <span class="nav-text">哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-有效的字母异位词"><span class="nav-number">6.1.</span> <span class="nav-text">1.有效的字母异位词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-两个数组的交集"><span class="nav-number">6.2.</span> <span class="nav-text">2.两个数组的交集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-快乐数"><span class="nav-number">6.3.</span> <span class="nav-text">3.快乐数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-两数之和"><span class="nav-number">6.4.</span> <span class="nav-text">4.两数之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-四数相加-II-2"><span class="nav-number">6.5.</span> <span class="nav-text">5.四数相加 II(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-赎金信"><span class="nav-number">6.6.</span> <span class="nav-text">6.赎金信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-三数之和-2"><span class="nav-number">6.7.</span> <span class="nav-text">7.三数之和(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-四数之和-2"><span class="nav-number">6.8.</span> <span class="nav-text">8.四数之和(2)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串"><span class="nav-number">7.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-反转字符串"><span class="nav-number">7.1.</span> <span class="nav-text">1.反转字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-反转字符串-II"><span class="nav-number">7.2.</span> <span class="nav-text">2.反转字符串 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-替换空格"><span class="nav-number">7.3.</span> <span class="nav-text">3.替换空格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-反转字符串中的单词-2"><span class="nav-number">7.4.</span> <span class="nav-text">4.反转字符串中的单词(2)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最直接的思路"><span class="nav-number">7.4.1.</span> <span class="nav-text">最直接的思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不使用额外的空间"><span class="nav-number">7.4.2.</span> <span class="nav-text">不使用额外的空间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-左旋转字符串"><span class="nav-number">7.5.</span> <span class="nav-text">5.左旋转字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用切片"><span class="nav-number">7.5.1.</span> <span class="nav-text">使用切片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不使用切片"><span class="nav-number">7.5.2.</span> <span class="nav-text">不使用切片</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-实现-strStr-2"><span class="nav-number">7.6.</span> <span class="nav-text">6.实现 strStr()(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-重复的子字符串-2"><span class="nav-number">7.7.</span> <span class="nav-text">7.重复的子字符串(2)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#移动匹配"><span class="nav-number">7.7.1.</span> <span class="nav-text">移动匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最小重复字串"><span class="nav-number">7.7.2.</span> <span class="nav-text">最小重复字串</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双指针"><span class="nav-number">8.</span> <span class="nav-text">双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-移除元素"><span class="nav-number">8.1.</span> <span class="nav-text">1.移除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-反转字符串"><span class="nav-number">8.2.</span> <span class="nav-text">2.反转字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-替换空格-1"><span class="nav-number">8.3.</span> <span class="nav-text">3.替换空格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-反转链表"><span class="nav-number">8.4.</span> <span class="nav-text">4.反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-删除链表的倒数第-N-个结点-2"><span class="nav-number">8.5.</span> <span class="nav-text">5.删除链表的倒数第 N 个结点(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-链表相交-1"><span class="nav-number">8.6.</span> <span class="nav-text">6.链表相交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-环形链表-II-2-1"><span class="nav-number">8.7.</span> <span class="nav-text">7.环形链表 II(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-三数之和（2）"><span class="nav-number">8.8.</span> <span class="nav-text">8.三数之和（2）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-四数之和-2"><span class="nav-number">8.9.</span> <span class="nav-text">9.四数之和(2)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈与队列"><span class="nav-number">9.</span> <span class="nav-text">栈与队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-用栈实现队列"><span class="nav-number">9.1.</span> <span class="nav-text">1.用栈实现队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-用队列实现栈"><span class="nav-number">9.2.</span> <span class="nav-text">2.用队列实现栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-有效的括号"><span class="nav-number">9.3.</span> <span class="nav-text">3.有效的括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-删除字符串中的所有相邻重复项"><span class="nav-number">9.4.</span> <span class="nav-text">4.删除字符串中的所有相邻重复项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-逆波兰表达式求值-2"><span class="nav-number">9.5.</span> <span class="nav-text">5.逆波兰表达式求值(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-滑动窗口最大值-3"><span class="nav-number">9.6.</span> <span class="nav-text">==6.滑动窗口最大值(3)==</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-前-K-个高频元素（2）"><span class="nav-number">9.7.</span> <span class="nav-text">7.前 K 个高频元素（2）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单调队列"><span class="nav-number">9.8.</span> <span class="nav-text">==单调队列==</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单调栈"><span class="nav-number">9.9.</span> <span class="nav-text">==单调栈==</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-柱状图中最大的矩形-3"><span class="nav-number">9.9.1.</span> <span class="nav-text">1.柱状图中最大的矩形(3)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-每日温度-2"><span class="nav-number">9.9.2.</span> <span class="nav-text">2.每日温度(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-下一个更大元素-I"><span class="nav-number">9.9.3.</span> <span class="nav-text">3.下一个更大元素 I</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-下一个更大元素-II-2"><span class="nav-number">9.9.4.</span> <span class="nav-text">4.下一个更大元素 II(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-接雨水-3"><span class="nav-number">9.9.5.</span> <span class="nav-text">5.接雨水(3)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分治法"><span class="nav-number">10.</span> <span class="nav-text">分治法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-漂亮数组-2"><span class="nav-number">10.1.</span> <span class="nav-text">1.漂亮数组(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-快速排序"><span class="nav-number">10.2.</span> <span class="nav-text">2.快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第k个数"><span class="nav-number">10.2.1.</span> <span class="nav-text">第k个数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-归并排序"><span class="nav-number">10.3.</span> <span class="nav-text">3.归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#逆序对"><span class="nav-number">10.3.1.</span> <span class="nav-text">逆序对</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-不无聊序列-2"><span class="nav-number">10.4.</span> <span class="nav-text">4.不无聊序列(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-最近点对-2维"><span class="nav-number">10.5.</span> <span class="nav-text">5.最近点对(2维)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-众数问题"><span class="nav-number">10.6.</span> <span class="nav-text">6.众数问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树"><span class="nav-number">11.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#深搜遍历"><span class="nav-number">11.1.</span> <span class="nav-text">深搜遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-二叉树的前序遍历"><span class="nav-number">11.1.1.</span> <span class="nav-text">1.二叉树的前序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#递归"><span class="nav-number">11.1.1.1.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#迭代"><span class="nav-number">11.1.1.2.</span> <span class="nav-text">迭代</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-二叉树的中序遍历"><span class="nav-number">11.1.2.</span> <span class="nav-text">2.二叉树的中序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#递归-1"><span class="nav-number">11.1.2.1.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#迭代-注意"><span class="nav-number">11.1.2.2.</span> <span class="nav-text">迭代(注意)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-二叉树的后序遍历"><span class="nav-number">11.1.3.</span> <span class="nav-text">3.二叉树的后序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#递归-2"><span class="nav-number">11.1.3.1.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#迭代-1"><span class="nav-number">11.1.3.2.</span> <span class="nav-text">迭代</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代遍历统一写法"><span class="nav-number">11.1.4.</span> <span class="nav-text">==迭代遍历统一写法==</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#广搜遍历"><span class="nav-number">11.2.</span> <span class="nav-text">广搜遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-二叉树的层序遍历-2"><span class="nav-number">11.2.1.</span> <span class="nav-text">4.二叉树的层序遍历(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-二叉树的层序遍历-II-2"><span class="nav-number">11.2.2.</span> <span class="nav-text">5.二叉树的层序遍历 II(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-二叉树的右视图-2"><span class="nav-number">11.2.3.</span> <span class="nav-text">6.二叉树的右视图(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-二叉树的层平均值"><span class="nav-number">11.2.4.</span> <span class="nav-text">7.二叉树的层平均值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-N-叉树的层序遍历-2"><span class="nav-number">11.2.5.</span> <span class="nav-text">8.N 叉树的层序遍历(2)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性"><span class="nav-number">11.3.</span> <span class="nav-text">属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-对称二叉树"><span class="nav-number">11.3.1.</span> <span class="nav-text">1.对称二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-二叉树的最大深度"><span class="nav-number">11.3.2.</span> <span class="nav-text">2.二叉树的最大深度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-二叉树的最小深度"><span class="nav-number">11.3.3.</span> <span class="nav-text">==3.二叉树的最小深度==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-完全二叉树的节点个数-2"><span class="nav-number">11.3.4.</span> <span class="nav-text">==4.完全二叉树的节点个数(2)==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-平衡二叉树"><span class="nav-number">11.3.5.</span> <span class="nav-text">==5.平衡二叉树==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-二叉树的所有路径"><span class="nav-number">11.3.6.</span> <span class="nav-text">6.二叉树的所有路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-左叶子之和"><span class="nav-number">11.3.7.</span> <span class="nav-text">==7.左叶子之和==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-找树左下角的值-2"><span class="nav-number">11.3.8.</span> <span class="nav-text">8.找树左下角的值(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-路径总和"><span class="nav-number">11.3.9.</span> <span class="nav-text">9.路径总和</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改和构造"><span class="nav-number">11.4.</span> <span class="nav-text">修改和构造</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-翻转二叉树"><span class="nav-number">11.4.1.</span> <span class="nav-text">1.翻转二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-从前序与中序遍历序列构造二叉树-2"><span class="nav-number">11.4.2.</span> <span class="nav-text">2.从前序与中序遍历序列构造二叉树(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-从中序与后序遍历序列构造二叉树-2"><span class="nav-number">11.4.3.</span> <span class="nav-text">3.从中序与后序遍历序列构造二叉树(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-从前序与后序遍历序列构造二叉树"><span class="nav-number">11.4.4.</span> <span class="nav-text">4.从前序与后序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-最大二叉树-2"><span class="nav-number">11.4.5.</span> <span class="nav-text">5.==最大二叉树==(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-合并二叉树"><span class="nav-number">11.4.6.</span> <span class="nav-text">6.合并二叉树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉搜索树"><span class="nav-number">11.5.</span> <span class="nav-text">二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-二叉搜索树中的搜索"><span class="nav-number">11.5.1.</span> <span class="nav-text">1.二叉搜索树中的搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-验证二叉搜索树-2"><span class="nav-number">11.5.2.</span> <span class="nav-text">==2.验证二叉搜索树(2)==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-二叉搜索树的最小绝对差"><span class="nav-number">11.5.3.</span> <span class="nav-text">3.二叉搜索树的最小绝对差</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-二叉搜索树中的众数"><span class="nav-number">11.5.4.</span> <span class="nav-text">4.二叉搜索树中的众数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-二叉树的最近公共祖先-2"><span class="nav-number">11.5.5.</span> <span class="nav-text">==5.二叉树的最近公共祖先(2)==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-二叉搜索树的最近公共祖先-2"><span class="nav-number">11.5.6.</span> <span class="nav-text">6.二叉搜索树的最近公共祖先(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-二叉搜索树中的插入操作-2"><span class="nav-number">11.5.7.</span> <span class="nav-text">7.二叉搜索树中的插入操作(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-删除二叉搜索树中的节点-2"><span class="nav-number">11.5.8.</span> <span class="nav-text">8.删除二叉搜索树中的节点(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-修剪二叉搜索树-2"><span class="nav-number">11.5.9.</span> <span class="nav-text">9.修剪二叉搜索树(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-将有序数组转换为二叉搜索树"><span class="nav-number">11.5.10.</span> <span class="nav-text">10.将有序数组转换为二叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-把二叉搜索树转换为累加树-2"><span class="nav-number">11.5.11.</span> <span class="nav-text">11.把二叉搜索树转换为累加树(2)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-2"><span class="nav-number">11.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回溯"><span class="nav-number">12.</span> <span class="nav-text">回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-组合-2"><span class="nav-number">12.1.</span> <span class="nav-text">1.组合(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-组合总和-III-2"><span class="nav-number">12.2.</span> <span class="nav-text">2.组合总和 III(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-电话号码的字母组合-2"><span class="nav-number">12.3.</span> <span class="nav-text">3.电话号码的字母组合(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-组合总和-2"><span class="nav-number">12.4.</span> <span class="nav-text">4.组合总和(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-组合总和-II-2"><span class="nav-number">12.5.</span> <span class="nav-text">5.组合总和 II(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-分割回文串-2"><span class="nav-number">12.6.</span> <span class="nav-text">6.分割回文串(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-复原-IP-地址-2"><span class="nav-number">12.7.</span> <span class="nav-text">7.复原 IP 地址(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-子集-2"><span class="nav-number">12.8.</span> <span class="nav-text">8.子集(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-子集-II-2"><span class="nav-number">12.9.</span> <span class="nav-text">9.子集 II(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-递增子序列-2"><span class="nav-number">12.10.</span> <span class="nav-text">==10.递增子序列(2)==</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-全排列-2"><span class="nav-number">12.11.</span> <span class="nav-text">11.全排列(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-全排列-II-2"><span class="nav-number">12.12.</span> <span class="nav-text">12.全排列 II(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-重新安排行程-3"><span class="nav-number">12.13.</span> <span class="nav-text">13.重新安排行程(3)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-N-皇后-3"><span class="nav-number">12.14.</span> <span class="nav-text">14.N 皇后(3)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-解数独-3"><span class="nav-number">12.15.</span> <span class="nav-text">15.解数独(3)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-3"><span class="nav-number">12.16.</span> <span class="nav-text">==总结==</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划"><span class="nav-number">13.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础题"><span class="nav-number">13.1.</span> <span class="nav-text">基础题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-斐波那契数"><span class="nav-number">13.1.1.</span> <span class="nav-text">1.斐波那契数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-爬楼梯"><span class="nav-number">13.1.2.</span> <span class="nav-text">2.爬楼梯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-使用最小花费爬楼梯"><span class="nav-number">13.1.3.</span> <span class="nav-text">3.使用最小花费爬楼梯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-不同路径-2"><span class="nav-number">13.1.4.</span> <span class="nav-text">4.不同路径(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-不同路径-II-2"><span class="nav-number">13.1.5.</span> <span class="nav-text">5.不同路径 II(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-整数拆分-2"><span class="nav-number">13.1.6.</span> <span class="nav-text">6.整数拆分(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-不同的二叉搜索树-2"><span class="nav-number">13.1.7.</span> <span class="nav-text">7.不同的二叉搜索树(2)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#背包问题"><span class="nav-number">13.2.</span> <span class="nav-text">背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#01背包"><span class="nav-number">13.2.1.</span> <span class="nav-text">01背包</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-分割等和子集-2"><span class="nav-number">13.2.1.1.</span> <span class="nav-text">1.分割等和子集(2)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-最后一块石头的重量-II-2"><span class="nav-number">13.2.1.2.</span> <span class="nav-text">2.最后一块石头的重量 II(2)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-目标和-2"><span class="nav-number">13.2.1.3.</span> <span class="nav-text">==3.目标和(2)==</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-一和零-2"><span class="nav-number">13.2.1.4.</span> <span class="nav-text">4.一和零(2)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#完全背包"><span class="nav-number">13.2.2.</span> <span class="nav-text">完全背包</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-零钱兑换-2"><span class="nav-number">13.2.2.1.</span> <span class="nav-text">1.零钱兑换(2)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-零钱兑换-II-2"><span class="nav-number">13.2.2.2.</span> <span class="nav-text">2.零钱兑换 II(2)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-组合总和-Ⅳ-2"><span class="nav-number">13.2.2.3.</span> <span class="nav-text">==3.组合总和 Ⅳ(2)==</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-爬楼梯-进阶版"><span class="nav-number">13.2.2.4.</span> <span class="nav-text">4.爬楼梯(进阶版)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-完全平方数-2"><span class="nav-number">13.2.2.5.</span> <span class="nav-text">5.完全平方数(2)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-单词拆分-2"><span class="nav-number">13.2.2.6.</span> <span class="nav-text">6.单词拆分(2)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多重背包"><span class="nav-number">13.2.3.</span> <span class="nav-text">多重背包</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-解法I"><span class="nav-number">13.2.3.1.</span> <span class="nav-text">1.解法I</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-解法II—二进制优化"><span class="nav-number">13.2.3.2.</span> <span class="nav-text">2.解法II—二进制优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-解法III—单调队列优化"><span class="nav-number">13.2.3.3.</span> <span class="nav-text">3.解法III—单调队列优化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#混合背包"><span class="nav-number">13.2.4.</span> <span class="nav-text">混合背包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-4"><span class="nav-number">13.2.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#打家劫舍"><span class="nav-number">13.3.</span> <span class="nav-text">打家劫舍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-打家劫舍I-2"><span class="nav-number">13.3.1.</span> <span class="nav-text">1.打家劫舍I(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-打家劫舍-II-2"><span class="nav-number">13.3.2.</span> <span class="nav-text">==2.打家劫舍 II(2)==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-打家劫舍-III-2"><span class="nav-number">13.3.3.</span> <span class="nav-text">==3.打家劫舍 III(2)==</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#买卖股票的最佳时机"><span class="nav-number">13.4.</span> <span class="nav-text">买卖股票的最佳时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-买卖股票的最佳时机I-2"><span class="nav-number">13.4.1.</span> <span class="nav-text">1.买卖股票的最佳时机I(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-买卖股票的最佳时机-II-2"><span class="nav-number">13.4.2.</span> <span class="nav-text">2.买卖股票的最佳时机 II(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-买卖股票的最佳时机-III-3"><span class="nav-number">13.4.3.</span> <span class="nav-text">3.买卖股票的最佳时机 III(3)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-买卖股票的最佳时机-IV-3"><span class="nav-number">13.4.4.</span> <span class="nav-text">4.买卖股票的最佳时机 IV(3)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-最佳买卖股票时机含冷冻期-2"><span class="nav-number">13.4.5.</span> <span class="nav-text">5.最佳买卖股票时机含冷冻期(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-买卖股票的最佳时机含手续费-2"><span class="nav-number">13.4.6.</span> <span class="nav-text">6.买卖股票的最佳时机含手续费(2)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子序列问题"><span class="nav-number">13.5.</span> <span class="nav-text">子序列问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-最长递增子序列-2"><span class="nav-number">13.5.1.</span> <span class="nav-text">1.最长递增子序列(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-最长连续递增序列"><span class="nav-number">13.5.2.</span> <span class="nav-text">2.最长连续递增序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-最长重复子数组-2"><span class="nav-number">13.5.3.</span> <span class="nav-text">3.最长重复子数组(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-最长公共子序列-2"><span class="nav-number">13.5.4.</span> <span class="nav-text">4.最长公共子序列(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-不相交的线-2"><span class="nav-number">13.5.5.</span> <span class="nav-text">5.不相交的线(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-最大子数组和-2"><span class="nav-number">13.5.6.</span> <span class="nav-text">6.最大子数组和(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-判断子序列"><span class="nav-number">13.5.7.</span> <span class="nav-text">7.判断子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-不同的子序列-3"><span class="nav-number">13.5.8.</span> <span class="nav-text">8.不同的子序列(3)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-两个字符串的删除操作-2"><span class="nav-number">13.5.9.</span> <span class="nav-text">9.两个字符串的删除操作(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-编辑距离-3"><span class="nav-number">13.5.10.</span> <span class="nav-text">==10.编辑距离(3)==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-回文子串-2"><span class="nav-number">13.5.11.</span> <span class="nav-text">==11.回文子串(2)==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-最长回文子序列-2"><span class="nav-number">13.5.12.</span> <span class="nav-text">12.最长回文子序列(2)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-5"><span class="nav-number">13.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图论"><span class="nav-number">14.</span> <span class="nav-text">图论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-朋友圈-2"><span class="nav-number">14.1.</span> <span class="nav-text">1.朋友圈(2)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dfs"><span class="nav-number">14.1.1.</span> <span class="nav-text">dfs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并查集"><span class="nav-number">14.1.2.</span> <span class="nav-text">并查集</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-判断二分图-2"><span class="nav-number">14.2.</span> <span class="nav-text">2.判断二分图(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-所有可能的路径-2"><span class="nav-number">14.3.</span> <span class="nav-text">3.所有可能的路径(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-除法求值-2"><span class="nav-number">14.4.</span> <span class="nav-text">4.除法求值(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-课程表-II-2"><span class="nav-number">14.5.</span> <span class="nav-text">5.课程表 II(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-钥匙和房间-2"><span class="nav-number">14.6.</span> <span class="nav-text">6.钥匙和房间(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-冗余连接-2"><span class="nav-number">14.7.</span> <span class="nav-text">7.冗余连接(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-冗余连接II-3"><span class="nav-number">14.8.</span> <span class="nav-text">8.冗余连接II(3)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-单词接龙-3"><span class="nav-number">14.9.</span> <span class="nav-text">9.单词接龙(3)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指-Offer"><span class="nav-number">15.</span> <span class="nav-text">剑指 Offer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数学"><span class="nav-number">15.1.</span> <span class="nav-text">数学</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#001-整数除法-2"><span class="nav-number">15.1.1.</span> <span class="nav-text">001. 整数除法(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#002-二进制加法"><span class="nav-number">15.1.2.</span> <span class="nav-text">002. 二进制加法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#003-前-n-个数字二进制中-1-的个数"><span class="nav-number">15.1.3.</span> <span class="nav-text">003. 前 n 个数字二进制中 1 的个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#004-只出现一次的数字-2"><span class="nav-number">15.1.4.</span> <span class="nav-text">004. 只出现一次的数字(2)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组-1"><span class="nav-number">15.2.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#006-排序数组中两个数字之和"><span class="nav-number">15.2.1.</span> <span class="nav-text">006. 排序数组中两个数字之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#007-数组中和为-0-的三个数"><span class="nav-number">15.2.2.</span> <span class="nav-text">007. 数组中和为 0 的三个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#008-和大于等于-target-的最短子数组"><span class="nav-number">15.2.3.</span> <span class="nav-text">==008. 和大于等于 target 的最短子数组==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#009-乘积小于-K-的子数组"><span class="nav-number">15.2.4.</span> <span class="nav-text">==009. 乘积小于 K 的子数组==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#010-和为-k-的子数组-2"><span class="nav-number">15.2.5.</span> <span class="nav-text">010. 和为 k 的子数组(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#011-0-和-1-个数相同的子数组"><span class="nav-number">15.2.6.</span> <span class="nav-text">011. 0 和 1 个数相同的子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#012-左右两边子数组的和相等"><span class="nav-number">15.2.7.</span> <span class="nav-text">012. 左右两边子数组的和相等</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#013-二维子矩阵的和"><span class="nav-number">15.2.8.</span> <span class="nav-text">013. 二维子矩阵的和</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串-双指针"><span class="nav-number">15.3.</span> <span class="nav-text">字符串/双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#014-字符串中的变位词"><span class="nav-number">15.3.1.</span> <span class="nav-text">014. 字符串中的变位词</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#力扣周赛"><span class="nav-number">16.</span> <span class="nav-text">力扣周赛</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#320周"><span class="nav-number">16.1.</span> <span class="nav-text">320周</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-数组中不等三元组的数目"><span class="nav-number">16.1.1.</span> <span class="nav-text">1.数组中不等三元组的数目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-二叉搜索树最近节点查询"><span class="nav-number">16.1.2.</span> <span class="nav-text">2.二叉搜索树最近节点查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-到达首都的最少油耗"><span class="nav-number">16.1.3.</span> <span class="nav-text">3.到达首都的最少油耗</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HOT100"><span class="nav-number">17.</span> <span class="nav-text">HOT100</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-最长回文子串"><span class="nav-number">17.1.</span> <span class="nav-text">1.最长回文子串</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/alex-next/images/avatar.jpg"
      alt="alex">
  <p class="site-author-name" itemprop="name">alex</p>
  <div class="site-description" itemprop="description">时光静好,与君语;细水流年,与君同;繁华落尽,与君老.</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/alex-next/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/alex-next/categories/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/alex-next/tags/">
          
        
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/alex-next/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">alex</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/alex-next/lib/anime.min.js?v=3.1.0"></script>
  <script src="/alex-next/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/alex-next/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script src="/alex-next/lib/pjax/pjax.min.js?v=0.2.8"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
<script src="/alex-next/js/utils.js?v=7.4.0"></script><script src="/alex-next/js/motion.js?v=7.4.0"></script>
<script src="/alex-next/js/schemes/pisces.js?v=7.4.0"></script>
<script src="/alex-next/js/next-boot.js?v=7.4.0"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var id = element.id || '';
    var src = element.src || '';
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (id !=='') {
      script.id = element.id;
    }
    if (src !== '') {
      script.src = src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  








  <script src="/alex-next/js/local-search.js?v=7.4.0"></script>













    <div id="pjax">

  

  
    
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    
  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: '84888b5ba3be0f56b2ed',
      clientSecret: '1306406ecbdc02b679df3c95b94985753d302d6a',
      repo: 'alex-next',
      owner: 'alexander-wd',
      admin: ['alexander-wd'],
      id: '4a5da14b6ceb1a1efcddf3d55c07c441',
        language: 'zh-CN',
      
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script>

    </div>
</body>
</html>
